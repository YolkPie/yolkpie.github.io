<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Taro(三) | YolkPie</title><meta name="description" content="七、小程序运行时为了使 Taro 组件转换成小程序组件并运行在小程序环境下， Taro 主要做了两个方面的工作：编译以及运行时适配。编译过程会做很多工作，例如：将 JSX 转换成小程序 .wxml 模板，生成小程序的配置文件、页面及组件的代码等等。编译生成好的代码仍然不能直接运行在小程序环境里，那运行时又是如何与之协同工作的呢？… 7.1 注册程序、页面以及自定义组件在小程序中会区分程序、页面以及"><meta name="keywords" content="前端技术博客"><meta name="author" content="YolkPie"><meta name="copyright" content="YolkPie"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://yolkpie.github.io/2020/10/17/Taro(%E4%B8%89)/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Taro(三)"><meta property="og:url" content="https://yolkpie.github.io/2020/10/17/Taro(%E4%B8%89)/"><meta property="og:site_name" content="YolkPie"><meta property="og:description" content="七、小程序运行时为了使 Taro 组件转换成小程序组件并运行在小程序环境下， Taro 主要做了两个方面的工作：编译以及运行时适配。编译过程会做很多工作，例如：将 JSX 转换成小程序 .wxml 模板，生成小程序的配置文件、页面及组件的代码等等。编译生成好的代码仍然不能直接运行在小程序环境里，那运行时又是如何与之协同工作的呢？… 7.1 注册程序、页面以及自定义组件在小程序中会区分程序、页面以及"><meta property="og:image" content="https://m.360buyimg.com/img/jfs/t1/118880/20/18814/113416/5f6ded26Ec120c939/bd3281048222ce87.png"><meta property="article:published_time" content="2020-10-17T06:00:09.000Z"><meta property="article:modified_time" content="2020-12-09T07:34:49.941Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="微信小程序暗黑模式" href="https://yolkpie.github.io/2020/11/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F/"><link rel="next" title="Taro(二)" href="https://yolkpie.github.io/2020/10/17/Taro(%E4%BA%8C)/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://at.alicdn.com/t/font_1638514_cadwssqh3zv.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">45</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">45</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">20</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 相关链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#七、小程序运行时"><span class="toc-number">1.</span> <span class="toc-text">七、小程序运行时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-注册程序、页面以及自定义组件"><span class="toc-number">1.1.</span> <span class="toc-text">7.1 注册程序、页面以及自定义组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-组件-state-转换"><span class="toc-number">1.2.</span> <span class="toc-text">7.2 组件 state 转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-将组件的生命周期对应到小程序组件的生命周期"><span class="toc-number">1.3.</span> <span class="toc-text">7.3 将组件的生命周期对应到小程序组件的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-事件处理函数对应"><span class="toc-number">1.4.</span> <span class="toc-text">7.4 事件处理函数对应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-对-API-进行-Promise-化的处理"><span class="toc-number">1.5.</span> <span class="toc-text">7.5 对 API 进行 Promise 化的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、H5-运行时"><span class="toc-number">2.</span> <span class="toc-text">八、H5 运行时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-H5-运行时解析"><span class="toc-number">2.1.</span> <span class="toc-text">8.1 H5 运行时解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-组件实现"><span class="toc-number">2.2.</span> <span class="toc-text">8.1.1 组件实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-API-适配"><span class="toc-number">2.3.</span> <span class="toc-text">8.2 API 适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-路由"><span class="toc-number">2.4.</span> <span class="toc-text">8.3 路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-Redux-处理"><span class="toc-number">2.5.</span> <span class="toc-text">8.4 Redux 处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、更多参考"><span class="toc-number">3.</span> <span class="toc-text">九、更多参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、官方文档"><span class="toc-number">4.</span> <span class="toc-text">十、官方文档</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://m.360buyimg.com/img/jfs/t1/118880/20/18814/113416/5f6ded26Ec120c939/bd3281048222ce87.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">YolkPie</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 相关链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Taro(三)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-10-17 14:00:09"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-10-17</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-12-09 15:34:49"><i class="fas fa-history fa-fw"></i> 更新于 2020-12-09</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">5k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 17 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="far fa-comments fa-fw post-meta__icon"></i><span>评论数:</span><a href="/2020/10/17/Taro(%E4%B8%89)/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="七、小程序运行时"><a href="#七、小程序运行时" class="headerlink" title="七、小程序运行时"></a>七、小程序运行时</h2><p>为了使 Taro 组件转换成小程序组件并运行在小程序环境下， Taro 主要做了两个方面的工作：编译以及运行时适配。编译过程会做很多工作，例如：将 JSX 转换成小程序 .wxml 模板，生成小程序的配置文件、页面及组件的代码等等。编译生成好的代码仍然不能直接运行在小程序环境里，那运行时又是如何与之协同工作的呢？…</p>
<h3 id="7-1-注册程序、页面以及自定义组件"><a href="#7-1-注册程序、页面以及自定义组件" class="headerlink" title="7.1 注册程序、页面以及自定义组件"></a>7.1 注册程序、页面以及自定义组件</h3><p>在小程序中会区分程序、页面以及组件，通过调用对应的函数，并传入包含生命周期回调、事件处理函数等配置内容的 object 参数来进行注册：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>而在 Taro 里，它们都是一个组件类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; &#125;</span><br><span class="line">  handleClick () &#123; &#125;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<ul>
<li>那么 Taro 的组件类是如何转换成小程序的程序、页面或组件的呢？</li>
<li>例如，有一个组件：customComponent，编译过程会在组件底部添加一行这样的代码（此处代码作示例用，与实际项目生成的代码不尽相同）：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Component(createComponent(customComponent));</span><br></pre></td></tr></table></figure>

<ul>
<li>createComponent 方法是整个运行时的入口，在运行的时候，会根据传入的组件类，返回一个组件的配置对象<blockquote>
<p>在小程序里，程序的功能及配置与页面和组件差异较大，因此运行时提供了两个方法 createApp 和 createComponent 来分别创建程序和组件（页面）。createApp 的实现非常简单</p>
</blockquote>
</li>
</ul>
<p>createComponent 方法主要做了这样几件事情：</p>
<ul>
<li>将组件的 state 转换成小程序组件配置对象的 data</li>
<li>将组件的生命周期对应到小程序组件的生命周期</li>
<li>将组件的事件处理函数对应到小程序的事件处理函数</li>
</ul>
<h3 id="7-2-组件-state-转换"><a href="#7-2-组件-state-转换" class="headerlink" title="7.2 组件 state 转换"></a>7.2 组件 state 转换</h3><p>其实在 Taro（React） 组件里，除了组件的 state，JSX 里还可以访问 props 、render 函数里定义的值、以及任何作用域上的成员。而在小程序中，与模板绑定的数据均来自对应页面（或组件）的 data。因此 JSX 模板里访问到的数据都会对应到小程序组件的 data 上。接下来我们通过列表渲染的例子来说明 state 和 data 是如何对应的…</p>
<p>在 JSX 里访问 state</p>
<blockquote>
<p>在小程序的组件上使用 wx:for 绑定一个数组，就可以实现循环渲染。例如，在 Taro 里你可能会这么写：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.list.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>)&#125;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>编译后的小程序组件模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;view wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;list&#125;&#125;"</span> wx:<span class="keyword">for</span>-item=<span class="string">"item"</span>&gt;</span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/view&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>view&gt;</span><br></pre></td></tr></table></figure>

<p>其中 state.list 只需直接对应到小程序（页面）组件的 data.list 上即可…</p>
<p>在 render 里生成了新的变量</p>
<p>然而事情通常没有那么简单，在 Taro 里也可以这么用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.list.map(<span class="function"><span class="params">item</span> =&gt;</span> ++item).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>)&#125;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>编译后的小程序组件模板是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;view wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;$anonymousCallee_1&#125;&#125;"</span> wx:<span class="keyword">for</span>-item=<span class="string">"item"</span>&gt;&#123;&#123;item&#125;&#125;&lt;<span class="regexp">/view&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>view&gt;...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在编译时会给 Taro 组件创建一个 _createData 的方法，里面会生成 $anonymousCallee_1 这个变量， $anonymousCallee<strong>1 是由编译器生成的，对 this.state.list 进行相关操作后的变量。 $anonymousCallee</strong>1 最终会被放到组件的 data 中给模板调用：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $anonymousCallee_1 = <span class="keyword">this</span>.state.list.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++item;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>render 里 return 之前的所有定义变量或者对 props、state 计算产生新变量的操作，都会被编译到 _createData 方法里执行，这一点在前面 JSX 编译成小程序模板的相关文章中已经提到。每当 Taro 调用 this.setState API 来更新数据时，都会调用生成的 _createData 来获取最新数据…</p>
</blockquote>
<h3 id="7-3-将组件的生命周期对应到小程序组件的生命周期"><a href="#7-3-将组件的生命周期对应到小程序组件的生命周期" class="headerlink" title="7.3 将组件的生命周期对应到小程序组件的生命周期"></a>7.3 将组件的生命周期对应到小程序组件的生命周期</h3><blockquote>
<p>初始化过程里的生命周期对应很简单，在小程序的生命周期回调函数里调用 Taro 组件里对应的生命周期函数即可，例如：小程序组件 ready 的回调函数里会调用 Taro 组件的 componentDidMount 方法。它们的执行过程和对应关系如下图…</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/88595/18/7355/40049/5dfb4602E7f9b20b7/8a7e4b779f5c9422.jpg" alt=""></p>
<p>小程序页面的 componentWillMount 有一点特殊，会有两种初始化方式。由于小程序的页面需要等到 onLoad 之后才可以获取到页面的路由参数，因此如果是启动页面，会等到 onLoad 时才会触发。而对于小程序内部通过 navigateTo 等 API 跳转的页面，Taro 做了一个兼容，调用 navigateTo 时将页面参数存储在一个全局对象中，在页面 attached 的时候从全局对象里取到，这样就不用等到页面 onLoad 即可获取到路由参数，触发 componentWillMount 生命周期…</p>
<p>状态更新</p>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/106521/3/7426/31329/5dfb463bE58b19784/746931b709b55cfb.jpg" alt=""></p>
<ul>
<li>Taro 组件的 setState 行为最终会对应到小程序的 setData。Taro 引入了如 nextTick ，编译时识别模板中用到的数据，在 setData 前进行数据差异比较等方式来提高 setState 的性能。</li>
<li>如上图，组件调用 setState 方法之后，并不会立刻执行组件更新逻辑，而是会将最新的 state 暂存入一个数组中，等 nextTick 回调时才会计算最新的 state 进行组件更新。这样即使连续多次的调用 setState 并不会触发多次的视图更新。在小程序中 nextTick 是这么实现的…</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nextTick = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">  fn = <span class="keyword">typeof</span> fn === <span class="string">'function'</span> ? fn.bind(<span class="literal">null</span>, ...args) : fn</span><br><span class="line">  <span class="keyword">const</span> timerFunc = wx.nextTick ? wx.nextTick : setTimeout</span><br><span class="line">  timerFunc(fn)</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>除了计算出最新的组件 state ，在组件状态更新过程里还会调用前面提到过的 _createData 方法，得到最终小程序组件的 data，并调用小程序的 setData 方法来进行组件的更新</p>
<h3 id="7-4-事件处理函数对应"><a href="#7-4-事件处理函数对应" class="headerlink" title="7.4 事件处理函数对应"></a>7.4 事件处理函数对应</h3><p>在小程序的组件里，事件响应函数需要配置在 methods 字段里。而在 JSX 里，事件是这样绑定的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;View onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure>

<p>编译的过程会将 JSX 转换成小程序模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view bindclick=<span class="string">"handleClick"</span>&gt;&lt;<span class="regexp">/view&gt;...</span></span><br></pre></td></tr></table></figure>

<p>在 createComponent 方法里，会将事件响应函数 handleClick 添加到 methods 字段中，并且在响应函数里调用真正的 this.handleClick 方法。</p>
<p>在编译过程中，会提取模板中绑定过的方法，并存到组件的 $events 字段里，这样在运行时就可以只将用到的事件响应函数配置到小程序组件的 methods 字段中。</p>
<p>在运行时通过 processEvent 这个方法来处理事件的对应，省略掉处理过程，就是这样的…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processEvent</span>(<span class="params">eventHandlerName, obj</span>) </span>&#123;</span><br><span class="line">  obj[eventHandlerName] = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    scope[eventHandlerName].apply(callScope, realArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的核心作用就是解析出事件响应函数执行时真正的作用域 callScope 以及传入的参数。在 JSX 里，我们可以像下面这样通过 bind 传入参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;View onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>, arga, argb)&#125;&gt;&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure>

<p>小程序不支持通过 bind 的方式传入参数，但是小程序可以用 data 开头的方式，将数据传递到 event.currentTarget.dataset 中。编译过程会将 bind 方式传递的参数对应到 dataset 中，processEvent 函数会从 dataset 里取到传入的参数传给真正的事件响应函数。</p>
<p>至此，经过编译之后的 Taro 组件终于可以运行在小程序环境里了…</p>
<h3 id="7-5-对-API-进行-Promise-化的处理"><a href="#7-5-对-API-进行-Promise-化的处理" class="headerlink" title="7.5 对 API 进行 Promise 化的处理"></a>7.5 对 API 进行 Promise 化的处理</h3><blockquote>
<p>Taro 对小程序的所有 API 进行了一个分类整理，将其中的异步 API 做了一层 Promise 化的封装。例如，wx.getStorage 经过下面的处理对应到 Taro.getStorage(此处代码作示例用，与实际源代码不尽相同)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Taro[<span class="string">'getStorage'</span>] = <span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, options)</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	[<span class="string">'fail'</span>, <span class="string">'success'</span>, <span class="string">'complete'</span>].forEach(<span class="function">(<span class="params">k</span>) =&gt;</span> &#123;</span><br><span class="line">	  obj[k] = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	    options[k] &amp;&amp; options[k](res)</span><br><span class="line">	    <span class="keyword">if</span> (k === <span class="string">'success'</span>) &#123;</span><br><span class="line">		  resolve(res)</span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k === <span class="string">'fail'</span>) &#123;</span><br><span class="line">		  reject(res)</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	wx[<span class="string">'getStorage'</span>](obj)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>就可以这么调用了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小程序的调用方式</span></span><br><span class="line">Taro.getStorage(&#123;</span><br><span class="line">  key: <span class="string">'test'</span>,</span><br><span class="line">  success() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在 Taro 里也可以这样调用</span></span><br><span class="line">Taro.getStorage(&#123;</span><br><span class="line">  key: <span class="string">'test'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;)...</span><br></pre></td></tr></table></figure>

<h2 id="八、H5-运行时"><a href="#八、H5-运行时" class="headerlink" title="八、H5 运行时"></a>八、H5 运行时</h2><h3 id="8-1-H5-运行时解析"><a href="#8-1-H5-运行时解析" class="headerlink" title="8.1 H5 运行时解析"></a>8.1 H5 运行时解析</h3><blockquote>
<p>首先，我们选用 Nerv 作为 Web 端的运行时框架。你可能会有问题：同样是类 React 框架，为何我们不直接用 React，而是用 Nerv 呢？<br>为了更快更稳。开发过程中前端框架本身有可能会出现问题。如果是第三方框架，很有可能无法得到及时的修复，导致整个项目的进度受影响。Nerv 就不一样。作为团队自研的产品，出现任何问题我们都可以在团队内部快速得到解决。与此同时，Nerv 也具有与 React 相同的 API，同样使用 Virtual DOM 技术进行优化，正常使用与 React 并没有区别，完全可以满足我们的需要。</p>
</blockquote>
<p>使用 Taro 之后，我们书写的是类似于下图的代码…</p>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/85585/15/7357/213299/5dfb48dbE72b5b45a/30977175349dae04.png" alt=""></p>
<p>我们注意到，就算是转换过的代码，也依然存在着 view、button 等在 Web 开发中并不存在的组件。如何在 Web 端正常使用这些组件？这是我们碰到的第一个问题</p>
<h3 id="8-1-1-组件实现"><a href="#8-1-1-组件实现" class="headerlink" title="8.1.1 组件实现"></a>8.1.1 组件实现</h3><p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/94514/10/7444/106813/5dfb4900Ecaea3260/acbb909c42c72547.png" alt=""></p>
<p>作为开发者，你第一反应或许会尝试在编译阶段下功夫，尝试直接使用效果类似的 Web 组件替代：用 div 替代 view，用 img 替代 image，以此类推。</p>
<p>费劲心机搞定标签转换之后，上面这个差异似乎是解决了。但很快你就会碰到一些更加棘手的问题：hover-start-time、hover-stay-time 等等这些常规 Web 开发中并不存在的属性要如何处理？</p>
<p>回顾一下：在前面讲到多端转换的时候，我们说到了 babel。在 Taro 中，我们使用 babylon 生成 AST，babel-traverse 去修改和移动 AST 中的节点。但 babel 所做的工作远远不止这些。</p>
<p>我们不妨去 babel 的 playground 看一看代码在转译前后的对比：在使用了@babel/preset-env 的 BUILT-INS 之后，简单的一句源码 new Map()，在 babel 编译后却变成了好几行代码…</p>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/107508/31/1180/104356/5dfb4930Eca3a9a65/17016a525139f5d7.png" alt=""></p>
<p>注意看这几个文件：core-js/modules/web.dom.iterable，core-js/modules/es6.array.iterator，core-js/modules/es6.map。我们可以在 core-js 的 Git 仓库找到他们的真身。很明显，这几个模块就是对应的 es 特性运行时的实现。</p>
<p>从某种角度上讲，我们要做的事情和 babel 非常像。babel 把基于新版 ECMAScript 规范的代码转换为基于旧 ECMAScript 规范的代码，而 Taro 希望把基于 React 语法的代码转换为小程序的语法。我们从 babel 受到了启发：既然 babel 可以通过运行时框架来实现新特性，那我们也同样可以通过运行时代码，实现上面这些 Web 开发中不存在的功能。</p>
<p>举个例子。对于 view 组件，首先它是个普通的类 React 组件，它把它的子组件如实展示出来…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Nerv, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'nervjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来，我们需要对 hover-start-time 做处理。与 Taro 其他地方的命名规范一致，我们这个 View 组件接受的属性名将会是驼峰命名法：hoverStartTime。hoverStartTime 参数决定我们将在 View 组件触发 touch 事件多久后改变组件的样式…</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    hoverStartTime = <span class="number">50</span>,</span><br><span class="line">    onTouchStart</span><br><span class="line">  &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> _onTouchStart = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// @TODO 触发touch样式改变</span></span><br><span class="line">    &#125;, hoverStartTime);</span><br><span class="line">    onTouchStart &amp;&amp; onTouchStart(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div onTouchStart=&#123;_onTouchStart&#125;&gt;</span><br><span class="line">      &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;...</span></span><br></pre></td></tr></table></figure>

<p>再稍加修饰，我们就能得到一个功能完整的 Web 版 View 组件</p>
<p>view 可以说是小程序最简单的组件之一了。text 的实现甚至比上面的代码还要简单得多。但这并不说明组件的实现之路上就没有障碍。复杂如 swiper，scroll-view，tabbar，我们需要花费大量的精力分析小程序原生组件的 API，交互行为，极端值处理，接受的属性等等，再通过 Web 技术实现。…</p>
<h3 id="8-2-API-适配"><a href="#8-2-API-适配" class="headerlink" title="8.2 API 适配"></a>8.2 API 适配</h3><blockquote>
<p>除了组件，小程序下有一些 API 也是 Web 开发中所不具备的。比如小程序框架内置的 wx.request/wx.getStorage 等 API；但在 Web 开发中，我们使用的是 fetch/localStorage 等内置的函数或者对象</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/106825/8/7473/124175/5dfb4985E4d2133de/82548ed913b69f37.png" alt=""></p>
<p>小程序的 API 实现是个巨大的黑盒，我们仅仅知道如何使用它，使用它会得到什么结果，但对它内部的实现一无所知。</p>
<p>如何让 Web 端也能使用小程序框架中提供的这些功能？既然已经知道这个黑盒的入参出参情况，那我们自己打造一个黑盒就好了。</p>
<p>换句话说，我们依然通过运行时框架来实现这些 Web 端不存在的能力。</p>
<p>具体说来，我们同样需要分析小程序原生 API，最后通过 Web 技术实现。有兴趣可以在 Git 仓库中看到这些原生 API 的实现。下面以 wx.setStorage 为例进行简单解析。</p>
<p>wx.setStorage 是一个异步接口，可以把 key: value 数据存储在本地缓存。很容易联想到，在 Web 开发中也有类似的数据存储概念，这就是 localStorage。到这里，我们的目标已经十分明确：我们需要借助于 localStorage，实现一个与 wx.setStorage 相同的 API。…</p>
<blockquote>
<p>而在 Web 中，如果我们需要往本地存储写入数据，使用的 API 是 localStorage.setItem(key, value)。我们很容易就可以构思出这个函数的雏形</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setStorage</span>(<span class="params">&#123; key, value &#125;</span>) </span>&#123;</span><br><span class="line">  localStorage.setItem(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们顺手做点优化，把基于异步回调的 API 都给做了一层 Promise 包装，这可以让代码的流程处理更加方便。所以这段代码看起来会像下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setStorage</span>(<span class="params">&#123; key, value &#125;</span>) </span>&#123;</span><br><span class="line">  localStorage.setItem(key, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">errMsg</span>: <span class="string">'setStorage:ok'</span> &#125;);</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>看起来很完美，但开发的道路不会如此平坦。我们还需要处理其余的入参：success、fail 和 complete。success 回调会在操作成功完成时调用，fail 会在操作失败的时候执行，complete 则无论如何都会执行。setStorage 函数只会在 key 值是 String 类型时有正确的行为，所以我们为这个函数添加了一个简单的类型判断，并在异常情况下执行 fail 回调。经过这轮变动，这段代码看起来会像下面这样…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setStorage</span>(<span class="params">&#123; key, value, success, fail, complete &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123; <span class="attr">errMsg</span>: <span class="string">'setStorage:ok'</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'string'</span>) &#123;</span><br><span class="line">    localStorage.setItem(key, value);</span><br><span class="line">    success &amp;&amp; success(res);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fail &amp;&amp; fail(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(res);</span><br><span class="line">  &#125;</span><br><span class="line">  complete &amp;&amp; complete(res);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">errMsg</span>: <span class="string">'setStorage:ok'</span> &#125;);</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>把这个 API 实现挂载到 Taro 模块之后，我们就可以通过 Taro.setStorage 来调用这个 API 了。</p>
<p>当然，也有一些 API 是 Web 端无论如何无法实现的，比如 wx.login，又或者 wx.scanCode。我们维护了一个 API 实现情况的列表，在实际的多端项目开发中应该尽可能避免使用它们…</p>
<h3 id="8-3-路由"><a href="#8-3-路由" class="headerlink" title="8.3 路由"></a>8.3 路由</h3><blockquote>
<p>作为小程序的一大能力，小程序框架中以栈的形式维护了当前所有的页面，由框架统一管理。用户只需要调用 wx.navigateTo,wx.navigateBack,wx.redirectTo 等官方 API，就可以实现页面的跳转、回退、重定向，而不需要关心页面栈的细节。但是作为多端项目，当我们…</p>
</blockquote>
<p>小程序的路由比较轻量。使用时，我们先通过 app.json 为小程序配置页面列表:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"pages"</span>: [</span><br><span class="line">    <span class="string">"pages/index/index"</span>,</span><br><span class="line">    <span class="string">"pages/logs/logs"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在运行时，小程序内维护了一个页面栈，始终展示栈顶的页面（Page 对象）。当用户进行跳转、后退等操作时，相应的会使页面栈进行入栈、出栈等操作<br>同时，在页面栈发生路由变化时，还会触发相应页面的生命周期</p>
</blockquote>
<p>对于 Web 端单页应用路由，我们则以 react-router 为例进行说明</p>
<ul>
<li>首先，react-router 开始通过 history 工具监听页面路径的变化。</li>
<li>在页面路径发生变化时，react-router 会根据新的 location 对象，触发 UI 层的更新。</li>
<li>至于 UI 层如何更新，则是取决于我们在 Route 组件中对页面路径和组件的绑定，甚至可以实现嵌套路由。</li>
<li>可以说，react-router 的路由方案是组件级别的。</li>
<li>具体到 Taro，为了保持跟小程序的行为一致，我们不需要细致到组件级别的路由方案，但需要为每次路由保存完整的页面栈。</li>
<li>实现形式上，我们参考 react-router：监听页面路径变化，再触发 UI 更新。这是 React 的精髓之一，单向数据流…</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/85653/15/7454/12059/5dfb4a06Ed6a96cb0/9f223d0aecac549c.png" alt=""></p>
<blockquote>
<p>@tarojs/router 包中包含了一个轻量的 history 实现。history 中维护了一个栈，用来记录页面历史的变化。对历史记录的监听，依赖两个事件：hashchange 和 popstate。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例代码 */</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"hashchange"</span>, () =&gt; &#123;&#125;);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"popstate"</span>, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>对于使用 Hash 模式的页面路由，每次页面跳转都会依次触发 popstate 和 hashchange 事件。由于在 popstate 的回调中可以取到当前页面的 state，我们选择它作为主要跳转逻辑的容器。</li>
<li>作为 UI 层，@tarojs/router 包提供了一个 Router 组件，维护页面栈。与小程序类似，用户不需要手动调用 Router 组件，而是由 Taro 自动处理。</li>
<li>对于历史栈来说，无非就是三种操作：push, pop，还有 replace。在历史栈变动时触发 Router 的回调，就可以让 Router 也同步变化。这就是 Taro 中路由的基本原理…</li>
</ul>
<h3 id="8-4-Redux-处理"><a href="#8-4-Redux-处理" class="headerlink" title="8.4 Redux 处理"></a>8.4 Redux 处理</h3><ul>
<li>每当提到 React 的数据流，我们就不得不提到 Redux。通过合并 Reducer，Redux 可以让大型应用中的数据流更加规则、可预测。</li>
<li>我们在 Taro 中加入了 Redux 的支持，通过导入@tarojs/redux，即可在小程序端使用 Redux 的功能。</li>
<li>对于 Web 端，我们尝试直接使用 nerv-redux 包提供支持，但这会带来一些问题…</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Nerv <span class="keyword">from</span> <span class="string">'nervjs'</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'nerv-redux'</span></span><br><span class="line"></span><br><span class="line">@connect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Nerv</span>.<span class="title">Componnet</span> </span>&#123;</span><br><span class="line">  componentDidShow() &#123; <span class="built_in">console</span>.log(<span class="string">'didShow'</span>) &#125;</span><br><span class="line">  componentDidMount() &#123; <span class="built_in">console</span>.log(<span class="string">'didMount'</span>) &#125;</span><br><span class="line">  render() &#123; <span class="keyword">return</span> <span class="string">''</span> &#125;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<ul>
<li>回想一下前面讲的 componentDidShow 的实现：我们继承，并且改写 componentDidMount。</li>
<li>但是对于使用 Redux 的页面来说，我们继承的类，是经过@connect 修饰过的一个高阶组件。</li>
<li>问题就出在这里：这个高阶组件的签名里并没有 componentDidShow 这一个函数。所以我们的 componentDidMount 内，理所当然是取不到 componentDidShow 的。</li>
<li>为了解决这个问题，我们对 react-redux 代码进行了一些小改装，这就是@taro/redux-h5 的由来…</li>
</ul>
<h2 id="九、更多参考"><a href="#九、更多参考" class="headerlink" title="九、更多参考"></a>九、更多参考</h2><p>Taro 官方文档 <a href="https://taro.aotu.io/home/in.html" target="_blank" rel="noopener">https://taro.aotu.io/home/in.html</a></p>
<h2 id="十、官方文档"><a href="#十、官方文档" class="headerlink" title="十、官方文档"></a>十、官方文档</h2><p>Taro 小册子 <a href="https://git.jd.com/huangli47/taro-ebook/tree/master/ebook" target="_blank" rel="noopener">https://git.jd.com/huangli47/taro-ebook/tree/master/ebook</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YolkPie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yolkpie.github.io/2020/10/17/Taro(%E4%B8%89)/">https://yolkpie.github.io/2020/10/17/Taro(%E4%B8%89)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yolkpie.github.io" target="_blank">YolkPie</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://img12.360buyimg.com/imagetools/jfs/t1/139355/38/17398/8687/5fce3691E780c4ba3/de55e2d253898034.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F/"><img class="prev-cover" data-src="http://m.360buyimg.com/img/jfs/t1/134893/38/14546/9226/5f9e66e6E3ebfd8c2/ffde82fd4941cb0b.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">微信小程序暗黑模式</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/17/Taro(%E4%BA%8C)/"><img class="next-cover" data-src="https://m.360buyimg.com/img/jfs/t1/118880/20/18814/113416/5f6ded26Ec120c939/bd3281048222ce87.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Taro(二)</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '6e1bb19099a60d063402',
  clientSecret: '6fefeea17c4f73c838216b0aab539d37c7bbcdad',
  repo: 'yolkpie.github.io',
  owner: 'YolkPie',
  admin: ['yujihu'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: true,
  pagerDirection: 'last',
  createIssueManually: true,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By YolkPie</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><div style="display:none"><script type="text/javascript" src="https://s9.cnzz.com/z_stat.php?id=1279214088&web_id=1279214088"></script></div></body></html>