<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Vue3迁移指南 | YolkPie</title><meta name="description" content="虚拟DOM的核心之一就是它的Diff算法，其中最为核心的就是核心Diff算法，只有在新旧虚拟DOM的子节点都是多个的时候，核心Diff算法才会派上用场。"><meta name="keywords" content="vue"><meta name="author" content="YolkPie"><meta name="copyright" content="YolkPie"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yolkpie.net/2020/09/27/Vue3%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Vue3迁移指南"><meta property="og:url" content="https://yolkpie.net/2020/09/27/Vue3%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97/"><meta property="og:site_name" content="YolkPie"><meta property="og:description" content="虚拟DOM的核心之一就是它的Diff算法，其中最为核心的就是核心Diff算法，只有在新旧虚拟DOM的子节点都是多个的时候，核心Diff算法才会派上用场。"><meta property="og:image" content="https://img10.360buyimg.com/imagetools/jfs/t1/122074/8/13483/538833/5f70524dEdc179584/a381558342598384.png"><meta property="article:published_time" content="2020-09-27T08:47:09.000Z"><meta property="article:modified_time" content="2021-03-10T02:21:32.117Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="css行高line-height的一些理解" href="https://yolkpie.net/2020/09/29/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"><link rel="next" title="实时对话界面设计思考" href="https://yolkpie.net/2020/09/27/%E5%AE%9E%E6%97%B6%E5%AF%B9%E8%AF%9D%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%80%83/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">67</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">56</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">25</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%A4%A7%E6%94%B9%E5%8F%98"><span class="toc-number">2.</span> <span class="toc-text">重大改变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80API"><span class="toc-number">2.1.</span> <span class="toc-text">全局API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text">模版指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">渲染函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%94%B9%E5%8F%98"><span class="toc-number">2.5.</span> <span class="toc-text">其他改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4API"><span class="toc-number">2.6.</span> <span class="toc-text">移除API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80API%E2%80%94%E2%80%94createApp"><span class="toc-number">3.</span> <span class="toc-text">全局API——createApp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-API-Treeshaking"><span class="toc-number">4.</span> <span class="toc-text">全局 API Treeshaking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-model"><span class="toc-number">5.</span> <span class="toc-text">v-model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#key-attribute"><span class="toc-number">6.</span> <span class="toc-text">key attribute</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if-%E4%B8%8E-v-for-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%AF%B9%E6%AF%94"><span class="toc-number">7.</span> <span class="toc-text">v-if 与 v-for 的优先级对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-bind-%E5%90%88%E5%B9%B6%E8%A1%8C%E4%B8%BA"><span class="toc-number">8.</span> <span class="toc-text">v-bind 合并行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-for%E7%9A%84Ref%E6%95%B0%E7%BB%84"><span class="toc-number">9.</span> <span class="toc-text">v-for的Ref数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="toc-number">10.</span> <span class="toc-text">函数式组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6"><span class="toc-number">11.</span> <span class="toc-text">异步组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0-API"><span class="toc-number">12.</span> <span class="toc-text">渲染函数 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80-Slot"><span class="toc-number">13.</span> <span class="toc-text">统一 Slot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">14.</span> <span class="toc-text">自定义指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E7%9A%84-class-%E5%90%8D%E6%9B%B4%E6%94%B9"><span class="toc-number">15.</span> <span class="toc-text">过渡的 class 名更改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-prop-%E7%9A%84%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0%E4%B8%AD%E8%AE%BF%E9%97%AE-this"><span class="toc-number">16.</span> <span class="toc-text">在 prop 的默认函数中访问 this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-%E9%80%89%E9%A1%B9"><span class="toc-number">17.</span> <span class="toc-text">Data 选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-%E5%BC%BA%E5%88%B6%E8%A1%8C%E4%B8%BA"><span class="toc-number">18.</span> <span class="toc-text">attribute 强制行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">19.</span> <span class="toc-text">按键修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-API"><span class="toc-number">20.</span> <span class="toc-text">事件 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">21.</span> <span class="toc-text">过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF-Attribute"><span class="toc-number">22.</span> <span class="toc-text">内联模板 Attribute</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%87%E6%AE%B5"><span class="toc-number">23.</span> <span class="toc-text">片段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0"><span class="toc-number">24.</span> <span class="toc-text">自定义元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-number">25.</span> <span class="toc-text">参考文档</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://img10.360buyimg.com/imagetools/jfs/t1/133083/40/11052/11173/5f70524dE5f2bac4f/6ac0bf70c2099db1.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">YolkPie</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Vue3迁移指南</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-09-27 16:47:09"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-09-27</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-03-10 10:21:32"><i class="fas fa-history fa-fw"></i> 更新于 2021-03-10</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/vue/">vue</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Vue 3</code>已经正式发布，我们现有的项目基本都是基于<code>Vue 2</code>进行开发的，如何由<code>Vue 2.x</code>迁移到<code>Vue 3.x</code>，<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/migration/introduction.html#%E6%A6%82%E8%A7%88">官方文档</a>已经提供了迁移指南，本文是对官方迁移指南的总结。</p>
<h2 id="重大改变"><a href="#重大改变" class="headerlink" title="重大改变"></a>重大改变</h2><p><code>Vue 3</code>相较于<code>Vue 2</code>有许多<code>Break Change</code>的重大改变，是我们在迁移时需要重点关注的：</p>
<h3 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h3><ul>
<li>变更为使用应用程序实例</li>
<li>全局和内部API可以被<code>tree shaking</code></li>
</ul>
<h3 id="模版指令"><a href="#模版指令" class="headerlink" title="模版指令"></a>模版指令</h3><ul>
<li><code>v-model</code>用法的变更</li>
<li><code>v-for</code>节点上<code>key</code>用法的变更</li>
<li><code>v-if</code>和<code>v-for</code>优先级的变更</li>
<li><code>v-bind=&quot;object&quot;</code>合并策略的变更</li>
<li><code>v-for</code>中的<code>ref</code>不再注册为<code>ref</code>数组</li>
</ul>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul>
<li>只能使用普通函数创建功能组件</li>
<li><code>functional</code>属性及选项被遗弃</li>
<li>使用<code>defineAsyncComponent</code>创建异步组件</li>
</ul>
<h3 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h3><ul>
<li>渲染函数的API变更</li>
<li><code>$scopedSlots</code>property已删除，所有插槽都通过<code>$slots</code>作为函数暴露</li>
<li>自定义指令的API和组组件的生命周期保持一致</li>
<li>某些过渡<code>class</code>被重命名</li>
<li>组件的<code>watch</code>选项和实例的<code>$watch</code>方法不再支持点分隔字符串路径</li>
<li>应用程序容器的<code>innerHTML</code>将替换为根组件模版</li>
</ul>
<h3 id="其他改变"><a href="#其他改变" class="headerlink" title="其他改变"></a>其他改变</h3><ul>
<li><code>destroyed</code>生命周期被重命名为<code>unmounted</code>，<code>beforeDestroy</code>被重命名为<code>beforeUnmount</code></li>
<li>组件的默认属性不能访问<code>this</code></li>
<li><code>data</code>选项应使用声明为函数</li>
<li><code>mixin</code>的<code>data</code>与组件的<code>data</code>选项只进行简单的合并</li>
<li><code>attribute</code>强制行为的变更</li>
<li><code>&lt;template&gt;</code>在没有特殊的指令标记时，将被视为普通的元素，而不是渲染其内容</li>
</ul>
<h3 id="移除API"><a href="#移除API" class="headerlink" title="移除API"></a>移除API</h3><ul>
<li>按键修饰符</li>
<li>移除<code>$on</code>，<code>$off</code>和<code>$once</code>实例方法</li>
<li>移除过滤器，建议使用计算属性或方法</li>
<li>移除<code>inline-template</code>属性</li>
<li>移除<code>$destroy</code>实例方法</li>
</ul>
<h2 id="全局API——createApp"><a href="#全局API——createApp" class="headerlink" title="全局API——createApp"></a>全局API——<code>createApp</code></h2><p><code>Vue 2.x</code>有许多全局API和配置，这些API和配置可以全局改变<code>Vue</code>的行为。例如，要创建全局组件，可以使用<code>Vue.component</code>。</p>
<p>从技术上讲，<code>Vue 2</code>没有“app”的概念，我们定义的应用程序只是通过<code>new Vue()</code>创建的根<code>Vue</code>实例。从同一个<code>Vue</code>构造函数创建的每个根实例共享相同的全局配置，因此：</p>
<ul>
<li>全局配置使得在测试期间很容易意外地污染其他测试用例；</li>
<li>全局配置使得在同一页面上的多个“app”之间共享同一个 Vue 副本非常困难。</li>
</ul>
<p><code>Vue 3.x</code>中引入了一个新的全局API：<code>createApp</code>，调用<code>createApp</code>返回一个应用实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>任何全局改变 Vue 行为的 API 现在都会移动到应用实例上，以下是当前全局 API 及其相应实例 API 的表：</p>
<table>
<thead>
<tr>
<th>2.x 全局 API</th>
<th>3.x 实例 API (app)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config</td>
<td>app.config</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td>移除</td>
</tr>
<tr>
<td>Vue.config.ignoredElements</td>
<td>app.config.isCustomElement</td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
</tbody></table>
<p>使用<code>createApp(/* options */)</code>初始化后，应用实例<code>app</code>可用于挂载具有<code>app.mount(domTarget)</code>。</p>
<p>Vue 3 应用程序实例还可以提供可由应用程序内的任何组件注入的依赖项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在入口</span></span><br><span class="line">app.provide(<span class="string">&#x27;guide&#x27;</span>, <span class="string">&#x27;Vue 3 Guide&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    book: &#123;</span><br><span class="line">      <span class="keyword">from</span>: <span class="string">&#x27;guide&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; book &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在应用程序之间共享配置 (如组件或指令) 的一种方法是创建工厂功能，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">&#x27;./Foo.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">&#x27;./Bar.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createMyApp = <span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = createApp(options)</span><br><span class="line">  app.directive(<span class="string">&#x27;focus&#x27;</span> <span class="comment">/* ... */</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createMyApp(Foo).mount(<span class="string">&#x27;#foo&#x27;</span>)</span><br><span class="line">createMyApp(Bar).mount(<span class="string">&#x27;#bar&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="全局-API-Treeshaking"><a href="#全局-API-Treeshaking" class="headerlink" title="全局 API Treeshaking"></a>全局 API Treeshaking</h2><p>在<code>Vue 3</code>中，全局和内部<code>API</code>都经过了重构，并考虑到了<code>tree-shaking</code>的支持。因此，全局<code>API</code>现在只能作为<code>ES</code>模块构建的命名导出进行访问。例如，我们想要手动操作<code>DOM</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line">nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 一些和DOM有关的东西</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>受影响的<code>API</code>如下：</p>
<ul>
<li>Vue.nextTick</li>
<li>Vue.observable (用<code>Vue.reactive</code>替换)</li>
<li>Vue.version</li>
<li>Vue.compile</li>
<li>Vue.set</li>
<li>Vue.delete</li>
</ul>
<p>除了公共<code>API</code>，许多内部组件/帮助器现在也被导出为命名导出，只有当编译器的输出是这些特性时，才允许编译器导入这些特性，例如以下模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;div v-show=<span class="string">&quot;ok&quot;</span>&gt;hello&lt;/div&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>被编译为类似于以下的内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, Transition, withDirectives, vShow &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h(Transition, [withDirectives(h(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>), [[vShow, <span class="built_in">this</span>.ok]])])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这实际上意味着只有在应用程序实际使用了<code>Transition</code>组件时才会导入它。换句话说，如果应用程序没有任何 <code>Transition</code>组件，那么支持此功能的代码将不会出现在最终的捆绑包中。</p>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><ul>
<li><code>v-model</code>prop和事件默认名称已更改</li>
<li><code>v-bind</code>的<code>.sync</code>修饰符和组件的<code>model</code>选项已移除，可用<code>v-model</code>作为代替</li>
<li>可以在同一个组件上使用多个<code>v-model</code>进行双向绑定</li>
<li>可以自定义<code>v-model </code>修饰符</li>
</ul>
<p>在<code>Vue 2</code>中，开发者使用<code>v-model</code>指令必须使用名为<code>value</code>的<code>prop</code>。如果开发者出于不同的目的需要使用其他的<code>prop</code>，他们就不得不使用<code>v-bind.sync</code>。</p>
<p>在<code>Vue 3</code>中，双向数据绑定的<code>API</code>已经标准化，减少了开发者在使用<code>v-model</code>指令时的混淆并且在使用 <code>v-model</code>指令时可以更加灵活。</p>
<p>在<code>3.x</code>中，自定义组件上的<code>v-model</code>相当于传递了<code>modelValue prop</code>并接收抛出的 <code>update:modelValue</code>事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent v-model=<span class="string">&quot;pageTitle&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 简写: --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent</span><br><span class="line">  :modelValue=<span class="string">&quot;pageTitle&quot;</span></span><br><span class="line">  @update:modelValue=<span class="string">&quot;pageTitle = $event&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>若需要更改<code>model</code>名称，而可以将一个<code>argument</code>传递给<code>model</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent v-model:title=<span class="string">&quot;pageTitle&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 简写: --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent :title=<span class="string">&quot;pageTitle&quot;</span> @update:title=<span class="string">&quot;pageTitle = $event&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>这也可以作为<code>.sync</code>修饰符的替代，而且允许我们在自定义组件上使用多个<code>v-model</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent v-model:title=<span class="string">&quot;pageTitle&quot;</span> v-model:content=<span class="string">&quot;pageContent&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 简写： --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent</span><br><span class="line">  :title=<span class="string">&quot;pageTitle&quot;</span></span><br><span class="line">  @update:title=<span class="string">&quot;pageTitle = $event&quot;</span></span><br><span class="line">  :content=<span class="string">&quot;pageContent&quot;</span></span><br><span class="line">  @update:content=<span class="string">&quot;pageContent = $event&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="key-attribute"><a href="#key-attribute" class="headerlink" title="key attribute"></a>key attribute</h2><ul>
<li>对于<code>v-if</code>/<code>v-else</code>/<code>v-else-if</code>的各分支项<code>key</code>将不再是必须的，因为现在<code>Vue</code>会自动生成唯一的<code>key</code></li>
<li><code>&lt;template v-for&gt;</code>的<code>key</code>应该设置在<code>&lt;template&gt;</code>标签上 ，而不是设置在它的子节点上</li>
</ul>
<h2 id="v-if-与-v-for-的优先级对比"><a href="#v-if-与-v-for-的优先级对比" class="headerlink" title="v-if 与 v-for 的优先级对比"></a>v-if 与 v-for 的优先级对比</h2><p>两者作用于同一个元素上时<code>v-if</code>会拥有比<code>v-for</code>更高的优先级。由于语法上存在歧义，建议避免在同一元素上同时使用两者。比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。</p>
<h2 id="v-bind-合并行为"><a href="#v-bind-合并行为" class="headerlink" title="v-bind 合并行为"></a>v-bind 合并行为</h2><p><code>v-bind</code>的绑定顺序会影响渲染结果，如果一个元素同时定义了<code>v-bind=&quot;object&quot;</code>和一个相同的单独的<code>property</code>，那么声明绑定的顺序决定了它们如何合并。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-for的Ref数组"><a href="#v-for的Ref数组" class="headerlink" title="v-for的Ref数组"></a>v-for的Ref数组</h2><p>在<code>Vue 2</code>中，在<code>v-for</code>里使用的<code>ref attribute</code>会用<code>ref</code>数组填充相应的<code>$refs property</code>。在<code>Vue 3</code>中，这样的用法将不再在<code>$ref</code>中自动创建数组。要从单个绑定获取多个<code>ref</code>，需要将<code>ref</code>绑定到一个更灵活的函数上：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:ref</span>=<span class="string">&quot;setItemRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onBeforeUpdate, onUpdated &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> itemRefs = []</span><br><span class="line">    <span class="keyword">const</span> setItemRef = <span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">      itemRefs.push(el)</span><br><span class="line">    &#125;</span><br><span class="line">    onBeforeUpdate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      itemRefs = []</span><br><span class="line">    &#125;)</span><br><span class="line">    onUpdated(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(itemRefs)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      itemRefs,</span><br><span class="line">      setItemRef</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><ul>
<li>在<code>3.x</code>中，函数式组件的性能提升可以忽略不计，因此建议只使用有状态的组件</li>
<li>函数式组件只能使用接收<code>props</code>和<code>context</code>的普通函数创建</li>
<li><code>functional attribute</code>在单文件组件 (SFC) <code>&lt;template&gt;</code>已被移除</li>
<li><code>&#123; functional: true &#125;</code>选项在通过函数创建组件已被移除</li>
</ul>
<p>在<code>Vue 3</code>中，所有的函数式组件都是用普通函数创建的，换句话说，不需要定义<code>&#123; functional: true &#125;</code>组件选项。此外，现在不是在<code>render</code>函数中隐式提供<code>h</code>，而是全局导入<code>h</code>。</p>
<h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>在<code>Vue 2</code>中异步组件是通过将组件定义为返回<code>Promise</code>的函数来创建的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncPage = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./NextPage.vue&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>或者，对于带有选项的更高阶的组件语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncPage = &#123;</span><br><span class="line">  component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./NextPage.vue&#x27;</span>),</span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  timeout: <span class="number">3000</span>,</span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  loading: LoadingComponent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Vue 3</code>中，由于函数式组件被定义为纯函数，因此异步组件的定义需要通过将其包装在新的<code>defineAsyncComponent</code>助手方法中来显式地定义，同时<code>component</code>选项现在被重命名为<code>loader</code>，以便准确地传达不能直接提供组件定义的信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ErrorComponent <span class="keyword">from</span> <span class="string">&#x27;./components/ErrorComponent.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> LoadingComponent <span class="keyword">from</span> <span class="string">&#x27;./components/LoadingComponent.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带选项的异步组件</span></span><br><span class="line"><span class="keyword">const</span> asyncPage = defineAsyncComponent(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./NextPage.vue&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带选项的异步组件</span></span><br><span class="line"><span class="keyword">const</span> asyncPageWithOptions = defineAsyncComponent(&#123;</span><br><span class="line">  loader: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./NextPage.vue&#x27;</span>),</span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  timeout: <span class="number">3000</span>,</span><br><span class="line">  errorComponent: ErrorComponent,</span><br><span class="line">  loadingComponent: LoadingComponent</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="渲染函数-API"><a href="#渲染函数-API" class="headerlink" title="渲染函数 API"></a>渲染函数 API</h2><p>在<code>Vue 3.x</code>中，<code>h</code>是全局导入的，而不是作为参数自动传入渲染函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统一-Slot"><a href="#统一-Slot" class="headerlink" title="统一 Slot"></a>统一 Slot</h2><p>在<code>Vue 3.x</code>中，插槽被定义为当前节点的子对象，当你需要以编程方式引用作用域<code>slot</code>时，它们现在被统一到<code>$slots</code>选项中。</p>
<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>在<code>Vue 3</code>中，将自定义指令的API与组件的生命周期保持一致：</p>
<ul>
<li>bind → beforeMount，指令绑定到元素后发生，只发生一次。</li>
<li>inserted → mounted，元素插入父 DOM 后发生。</li>
<li>beforeUpdate，在元素本身更新之前调用。</li>
<li>移除<code>update</code>，改用<code>updated</code>。</li>
<li>componentUpdated → updated，组件和子级被更新，调用这个钩子。</li>
<li>beforeUnmount，在卸载元素之前调用。</li>
<li>unbind -&gt; unmounted，指令被移除，调用这个钩子。</li>
</ul>
<h2 id="过渡的-class-名更改"><a href="#过渡的-class-名更改" class="headerlink" title="过渡的 class 名更改"></a>过渡的 class 名更改</h2><p>过渡类名<code>v-enter</code>修改为<code>v-enter-from</code>、过渡类名<code>v-leave</code>修改为<code>v-leave-from</code>，变得更加明确易读。</p>
<h2 id="在-prop-的默认函数中访问-this"><a href="#在-prop-的默认函数中访问-this" class="headerlink" title="在 prop 的默认函数中访问 this"></a>在 prop 的默认函数中访问 this</h2><p>在属性的默认函数中无法访问<code>this</code>，替代方案为：</p>
<ul>
<li>把组件接收到的原始 <code>prop</code>作为参数传递给默认函数；</li>
<li>注入<code>API</code>可以在默认函数中使用：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    theme: &#123;</span><br><span class="line">      <span class="keyword">default</span> (props) &#123;</span><br><span class="line">        <span class="comment">// `props` 是传递给组件的原始值。</span></span><br><span class="line">        <span class="comment">// 在任何类型/默认强制转换之前</span></span><br><span class="line">        <span class="comment">// 也可以使用 `inject` 来访问注入的 property</span></span><br><span class="line">        <span class="keyword">return</span> inject(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;default-theme&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Data-选项"><a href="#Data-选项" class="headerlink" title="Data 选项"></a>Data 选项</h2><p><code>data</code>组件选项声明不再接收纯<code>JavaScript object</code>，只接受返回<code>object</code>的<code>function</code>。当合并来自<code>mixin</code>或<code>extend</code>的多个<code>data</code>返回值时，是浅层次合并的而不是深层次合并的(只合并根级属性)。</p>
<h2 id="attribute-强制行为"><a href="#attribute-强制行为" class="headerlink" title="attribute 强制行为"></a>attribute 强制行为</h2><p>删除枚举<code>attribute</code>的内部概念，并将这些<code>attribute</code>视为普通的非布尔<code>attribute</code>。</p>
<p>2.x 和 3.x 行为的比较</p>
<table>
<thead>
<tr>
<th>Attributes</th>
<th>v-bind value 2.x</th>
<th>v-bind value 3.x</th>
<th>HTML 输出</th>
</tr>
</thead>
<tbody><tr>
<td>2.x “枚举attribute” i.e. contenteditable, draggable and spellcheck.</td>
<td>undefined, false</td>
<td>undefined, null</td>
<td>移除</td>
</tr>
<tr>
<td>2.x “枚举attribute” i.e. contenteditable, draggable and spellcheck.</td>
<td>true, ‘true’, ‘’, 1, ‘foo’</td>
<td>true, ‘true’</td>
<td>“true”</td>
</tr>
<tr>
<td>2.x “枚举attribute” i.e. contenteditable, draggable and spellcheck.</td>
<td>null, ‘false’</td>
<td>false, ‘false’</td>
<td>“false”</td>
</tr>
<tr>
<td>其他非布尔attribute eg. aria-checked, tabindex, alt, etc.</td>
<td>undefined, null, false</td>
<td>undefined, null</td>
<td>移除</td>
</tr>
<tr>
<td>其他非布尔attribute eg. aria-checked, tabindex, alt, etc.</td>
<td>‘false’</td>
<td>false, ‘false’</td>
<td>“false”</td>
</tr>
</tbody></table>
<h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><ul>
<li>不再支持使用数字 (即键码) 作为<code>v-on</code>修饰符</li>
<li>不再支持<code>config.keyCodes</code></li>
</ul>
<p>建议对任何要用作修饰符的键使用 kebab-cased (短横线) 大小写名称：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 3 在 v-on 上使用 按键修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.delete</span>=<span class="string">&quot;confirmDelete&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="事件-API"><a href="#事件-API" class="headerlink" title="事件 API"></a>事件 API</h2><p><code>$on</code>，<code>$off</code>和<code>$once</code>实例方法已被移除，应用实例不再实现事件触发接口，<code>$emit</code>仍然是现有<code>API</code>的一部分，因为它用于触发由父组件以声明方式附加的事件处理程序。</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>在<code>Vue 3.x</code>中，<code>filters</code>已删除，不再受支持。建议用方法调用或计算属性替换它们。</p>
<h2 id="内联模板-Attribute"><a href="#内联模板-Attribute" class="headerlink" title="内联模板 Attribute"></a>内联模板 Attribute</h2><p>在<code>Vue 2.x</code>中，为子组件提供了<code>inline-template attribute</code>，以便将其内部内容用作模板，而不是将其作为分发内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>它们被编译为组件自己的模板<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>不是父级所包含的内容。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>Vue 3.x</code>中不再支持此功能，所有模板都直接写在<code>HTML</code>页面中。</p>
<ul>
<li><p>使用<code>&lt;script&gt;</code>标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/html&quot;</span> id=<span class="string">&quot;my-comp-template&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; hello &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComp = &#123;</span><br><span class="line">  template: <span class="string">&#x27;#my-comp-template&#x27;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认 Slot</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-comp</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; childState &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; parentMsg &#125;&#125; &#123;&#123; childState &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">my-comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  在子模板中，在传递时渲染默认slot</span></span><br><span class="line"><span class="comment">  在必要的private状态下。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:childState</span>=<span class="string">&quot;childState&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h2><p>在<code>Vue 3</code>中，组件正式支持多根节点组件，即片段。</p>
<h2 id="自定义元素"><a href="#自定义元素" class="headerlink" title="自定义元素"></a>自定义元素</h2><p>如果我们想添加在<code>Vue</code>外部定义的自定义元素 (例如使用<code>Web</code>组件<code>API</code>)，我们需要“指示”<code>Vue</code>将其视为自定义元素。以下面的模板为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plastic-button</span>&gt;</span><span class="tag">&lt;/<span class="name">plastic-button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>Vue 3.0</code>中，此检查在模板编译期间执行指示编译器将<code>&lt;plastic-button&gt;</code>视为自定义元素：</p>
<ul>
<li><p>如果使用生成步骤：将<code>isCustomElement</code>传递给<code>Vue</code>模板编译器，如果使用<code>vue-loader</code>，则应通过 <code>vue-loader</code>的<code>compilerOptions</code>选项传递：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack 中的配置</span></span><br><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">    use: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      compilerOptions: &#123;</span><br><span class="line">        isCustomElement: <span class="function"><span class="params">tag</span> =&gt;</span> tag === <span class="string">&#x27;plastic-button&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果使用动态模板编译，请通过<code>app.config.isCustomElement</code>传递：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line">app.config.isCustomElement = <span class="function"><span class="params">tag</span> =&gt;</span> tag === <span class="string">&#x27;plastic-button&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>自定义元素规范提供了一种将自定义元素用作自定义内置模板的方法，方法是向内置元素添加<code>is</code>属性。在<code>Vue 3.0</code>中，我们仅将<code>Vue</code>对<code>is</code>属性的特殊处理限制到<code>&lt;component&gt;</code>tag。</p>
<ul>
<li><p>在保留的<code>&lt;component&gt;</code>tag上使用时，它的行为将与<code>Vue 2.x</code>中完全相同；</p>
</li>
<li><p>在普通组件上使用时，它的行为将类似于普通 prop：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">is</span>=<span class="string">&quot;bar&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2.x 行为：渲染<code>bar</code>组件。</li>
<li>3.x 行为：通过<code>is</code>prop渲染<code>foo</code>组件。</li>
</ul>
</li>
<li><p>在普通元素上使用时，它将作为<code>is</code>选项传递给<code>createElement</code>调用，并作为原生<code>attribute</code>渲染，这支持使用自定义的内置元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">&quot;plastic-button&quot;</span>&gt;</span>点击我！<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2.x 行为：渲染 plastic-button 组件。</li>
<li>3.x 行为：通过回调渲染原生的 button。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>, &#123; <span class="attr">is</span>: <span class="string">&#x27;plastic-button&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>在<code>Vue 3.x</code>中引入了一个新的指令<code>v-is</code>，用于<code>DOM</code>内模板解析解决方案。<code>v-is</code>指令像一个动态的<code>2.x :is</code>绑定。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/migration/introduction.html#%E6%A6%82%E8%A7%88">https://v3.cn.vuejs.org/guide/migration/introduction.html#%E6%A6%82%E8%A7%88</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YolkPie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yolkpie.net/2020/09/27/Vue3%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97/">https://yolkpie.net/2020/09/27/Vue3%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yolkpie.net" target="_blank">YolkPie</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vue/">vue</a></div><div class="post_share"><div class="social-share" data-image="https://m.360buyimg.com/img/jfs/t1/168731/24/11527/11836/60482c1bE6bd47446/524c8b349cb6e7b3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/29/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"><img class="prev-cover" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/135283/19/11127/8821/5f73dde9E13365429/19b59ab164c39f68.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">css行高line-height的一些理解</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/27/%E5%AE%9E%E6%97%B6%E5%AF%B9%E8%AF%9D%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%80%83/"><img class="next-cover" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/115055/40/18966/2860947/5f703f85Ee882eb6b/482cfc741b348293.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">实时对话界面设计思考</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/02/04/NuxtJS/" title="nuxt.js"><img class="relatedPosts_cover" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/105460/30/11621/22495/5e38e372E0cfb98b4/ee15034e2da3e64e.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-04</div><div class="relatedPosts_title">nuxt.js</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/19/VueCLI3和TypeScript项目实践/" title="Vue CLI3和TypeScript项目实践"><img class="relatedPosts_cover" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/132074/32/2609/109500/5eec626dE785995ac/65e6c3a9122d6769.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-19</div><div class="relatedPosts_title">Vue CLI3和TypeScript项目实践</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/03/Vue服务器端渲染/" title="Vue服务器端渲染"><img class="relatedPosts_cover" data-src="https://cn.vuejs.org/images/logo.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-03</div><div class="relatedPosts_title">Vue服务器端渲染</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/19/diff/" title="核心Diff算法"><img class="relatedPosts_cover" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/145814/24/8751/761861/5f65d465Ec74e3d82/13384de14843dee4.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-19</div><div class="relatedPosts_title">核心Diff算法</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By YolkPie</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>