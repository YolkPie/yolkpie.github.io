<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Vue CLI3和TypeScript项目实践 | YolkPie</title><meta name="description" content="vue,TypeScript,Vue CLI3"><meta name="keywords" content="vue,TypeScript,Vue CLI3"><meta name="author" content="YolkPie"><meta name="copyright" content="YolkPie"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yolkpie.net/2020/06/19/VueCLI3%E5%92%8CTypeScript%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Vue CLI3和TypeScript项目实践"><meta property="og:url" content="https://yolkpie.net/2020/06/19/VueCLI3%E5%92%8CTypeScript%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"><meta property="og:site_name" content="YolkPie"><meta property="og:description" content="vue,TypeScript,Vue CLI3"><meta property="og:image" content="https://img13.360buyimg.com/imagetools/jfs/t1/132074/32/2609/109500/5eec626dE785995ac/65e6c3a9122d6769.png"><meta property="article:published_time" content="2020-06-19T06:45:44.000Z"><meta property="article:modified_time" content="2022-06-30T01:41:41.714Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="京东小程序上手" href="https://yolkpie.net/2020/06/19/%E4%BA%AC%E4%B8%9C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%89%8B/"><link rel="next" title="色彩理论与搭配" href="https://yolkpie.net/2020/05/21/%E8%89%B2%E5%BD%A9%E7%90%86%E8%AE%BA%E4%B8%8E%E6%90%AD%E9%85%8D/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">168</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">84</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">35</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#typescript%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">typescript入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">内置对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%80%BC"><span class="toc-number">1.3.</span> <span class="toc-text">任意值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA"><span class="toc-number">1.4.</span> <span class="toc-text">类型推论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type"><span class="toc-number">1.6.</span> <span class="toc-text">type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">接口（对象类型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.</span> <span class="toc-text">数组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-number">1.9.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.10.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.11.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.12.</span> <span class="toc-text">类与接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.13.</span> <span class="toc-text">泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-cli3-typescript"><span class="toc-number">2.</span> <span class="toc-text">vue-cli3 + typescript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85ts%E6%8F%92%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">安装ts插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.</span> <span class="toc-text">webpack配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-tsconfig-json"><span class="toc-number">2.3.</span> <span class="toc-text">添加 tsconfig.json</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-eslintrc-js%E9%85%8D%E7%BD%AE"><span class="toc-number">2.4.</span> <span class="toc-text">修改.eslintrc.js配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9main-js"><span class="toc-number">2.5.</span> <span class="toc-text">修改main.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9-ts-%E8%AF%86%E5%88%AB-vue"><span class="toc-number">2.6.</span> <span class="toc-text">让 ts 识别 .vue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91vue%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.7.</span> <span class="toc-text">开发vue项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85vue%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6"><span class="toc-number">2.7.1.</span> <span class="toc-text">安装vue相关插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-class-component"><span class="toc-number">2.7.2.</span> <span class="toc-text">vue-class-component</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-property-decorator"><span class="toc-number">2.7.3.</span> <span class="toc-text">vue-property-decorator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vuex-class"><span class="toc-number">2.7.4.</span> <span class="toc-text">vuex-class</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://img14.360buyimg.com/imagetools/jfs/t1/110991/20/10424/10025/5eec626dE6bbbdd8e/e4013df3a17fb8fc.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">YolkPie</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Vue CLI3和TypeScript项目实践</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-19 14:45:44"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-06-19</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-06-30 09:41:41"><i class="fas fa-history fa-fw"></i> 更新于 2022-06-30</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/typescript/">typescript</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="typescript入门"><a href="#typescript入门" class="headerlink" title="typescript入门"></a>typescript入门</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型包括：boolean、number、string、null、undefined 以及 ES6 中的新类型 Symbol。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 布尔值</span><br><span class="line">let isShow: boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数字</span><br><span class="line">let num: number &#x3D; 6</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">let name: string &#x3D; &quot;bob&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null 和 undefined</span><br><span class="line">let u: undefined &#x3D; undefined</span><br><span class="line">let n: null &#x3D; null</span><br><span class="line">&#x2F;&#x2F; undefined 和 null 是所有类型的子类型，可以赋值给其他类型</span><br><span class="line">let num: number &#x3D; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; void 可以用 void 表示没有任何返回值的函数</span><br><span class="line">function alertName(): void &#123;</span><br><span class="line">    alert(&#39;My name is Tom&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><ul>
<li>ECMAScript<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let b: Boolean &#x3D; new Boolean(1)</span><br><span class="line">let e: Error &#x3D; new Error(&#39;Error occurred&#39;)</span><br><span class="line">let d: Date &#x3D; new Date()</span><br><span class="line">let r: RegExp &#x3D; &#x2F;[a-z]&#x2F;</span><br></pre></td></tr></table></figure></li>
<li>DOM 和 BOM，有Document、HTMLElement、Event、NodeList 等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let body: HTMLElement &#x3D; document.body</span><br></pre></td></tr></table></figure>
<h3 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h3></li>
<li>any 类型的变量，允许被赋值为任意类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let anything: any &#x3D; &#39;seven&#39;</span><br><span class="line">anything &#x3D; 7</span><br></pre></td></tr></table></figure></li>
<li>变量如果在声明的时候，未指定其类型，没有赋值，会被推断成 any 类型，不做类型检查<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 被推断成 any 类型，不做类型检查</span><br><span class="line">let anything;</span><br><span class="line">anything &#x3D; &#39;seven&#39;</span><br><span class="line">anything &#x3D; 7</span><br></pre></td></tr></table></figure>
<h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3>若没有指定类型，ts会推断出一个类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let anything &#x3D; &#39;seven&#39; &#x2F;&#x2F; 推断为string类型</span><br><span class="line">anything &#x3D; 7 &#x2F;&#x2F; 会报错</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">let anything: string &#x3D; &#39;seven&#39; &#x2F;&#x2F; 推断为string类型</span><br><span class="line">anything &#x3D; 7 &#x2F;&#x2F; 会报错</span><br></pre></td></tr></table></figure>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3>使用 | 分隔每个类型。</li>
</ul>
<p>当不确定联合类型的变量哪个类型的时：</p>
<ul>
<li>只能访问该变量类型里共有的属性或方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    return something.length   &#x2F;&#x2F; 报错</span><br><span class="line">    return something.toString().length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以使用<strong>类型断言</strong>来手动指定一个值的类型，通过 &lt;类型&gt;值 或 值 as 类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if ((&lt;string&gt;something).length) &#123; &#x2F;&#x2F; 或 something as string</span><br><span class="line">        return (&lt;string&gt;something).length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
_注：类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的，比如<boolean>something会报错。</li>
<li>联合类型的变量在被赋值时，会根据类型推论推断出一个类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber &#x3D; &#39;seven&#39;;</span><br><span class="line">console.log(myFavoriteNumber.length); &#x2F;&#x2F; 5</span><br><span class="line">myFavoriteNumber &#x3D; 7;</span><br><span class="line">console.log(myFavoriteNumber.length); &#x2F;&#x2F; 编译时报错</span><br><span class="line">&#x2F;&#x2F; index.ts(5,30): error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.</span><br></pre></td></tr></table></figure>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3></li>
<li><strong>类型别名</strong>，用来给一个类型起个新名字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Something &#x3D; string | number</span><br><span class="line">let something: Something &#x3D; &#39;king&#39;</span><br></pre></td></tr></table></figure></li>
<li><strong>字符串字面量类型</strong>，用来约束取值只能是某几个字符串中的一个<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type EventNames &#x3D; &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;</span><br><span class="line">function handleEvent(ele: Element, event: EventNames) &#123; &#x2F;&#x2F; event只能取这三种字符串，否则报错</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口（对象类型）"><a href="#接口（对象类型）" class="headerlink" title="接口（对象类型）"></a>接口（对象类型）</h3>使用接口（Interfaces）来定义对象的类型，接口一般首字母大写<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义的属性必须严格匹配，不允许增加或减少</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 可选属性</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 定义任意属性，</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    [propName: string]: any; &#x2F;&#x2F; [propName: string] 定义了任意属性取 string 类型的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集。例如，若定义[propName: string]: string，则确定属性和可选属性都必须是string类型</p>
</blockquote>
</li>
</ul>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><ul>
<li>类型+方括号<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] &#x3D; [1, 2, 3]</span><br></pre></td></tr></table></figure></li>
<li>Array<elemType><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: Array&lt;number&gt; &#x3D; [1, 2, 3]</span><br></pre></td></tr></table></figure></li>
<li>用接口表示数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface NumberArray &#123;</span><br><span class="line">    [index: number]: number</span><br><span class="line">&#125;</span><br><span class="line">let fibonacci: NumberArray &#x3D; [1, 2, 3]</span><br></pre></td></tr></table></figure>
_注: 类数组，比如 arguments，其不是数组类型，不能用普通的数组的方式来描述，而应该用接口；类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3>数组合并了相同类型的对象，而元组合并了不同类型的对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let tom: [string, number] &#x3D; [&#39;Tom&#39;, 25]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以只赋值其中一项</span><br><span class="line">let tom: [string, number]</span><br><span class="line">tom[0] &#x3D; &#39;Tom&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当添加越界的元素时，其类型会被限制为元组中每个类型的联合类型：</span><br><span class="line">let tom: [string, number]</span><br><span class="line">tom &#x3D; [&#39;Tom&#39;, 25]</span><br><span class="line">tom.push(&#39;male&#39;)</span><br><span class="line">tom.push(true) &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3></li>
<li>函数声明<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum(x: number, y?: number): number &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数表达式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const mySum &#x3D; function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的代码虽然可以编译通过，但其并没有对左边的mySum进行了类型定义，只是通过赋值操作进行类型推论而推断出来的。正确的写法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const mySum: (x: number, y: number) &#x3D;&gt; number </span><br><span class="line">   &#x3D; </span><br><span class="line">  (x: number, y: number) &#x3D;&gt; &#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个 =&gt; 用来表示函数的定义，左边是输入类型(需要用括号括起来)，右边是输出类型；第二个=&gt;是箭头函数</p>
</blockquote>
</li>
<li>用接口或type定义函数的形状<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 接口</span><br><span class="line">interface SumFunc &#123;</span><br><span class="line">   (x: number, y: number): number</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 2. type，tslint更建议使用这种方式</span><br><span class="line">type SumFunc &#x3D; (x: number, y: number) &#x3D;&gt; number</span><br><span class="line">const mySum: SumFunc &#x3D; (x: number, y: number) &#x3D;&gt; &#123;</span><br><span class="line">   return x+y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3>TypeScript 有三种访问修饰符：</li>
<li>public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认是 public；</li>
<li>private 修饰的属性或方法是私有的，外部和子类都不能访问；当构造函数修饰为 private 时，该类不允许被继承或者实例化；</li>
<li>protected 修饰的属性或方法是受保护的，在子类中允许被访问；当构造函数修饰为 protected 时，该类只允许被继承，不允许被实例化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  protected name: string</span><br><span class="line">  private age: number</span><br><span class="line">  protected constructor (name, age) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.age &#x3D; age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  private food: string</span><br><span class="line">  constructor (name, age, food) &#123;</span><br><span class="line">    super(name, age)</span><br><span class="line">    this.food &#x3D; food</span><br><span class="line">  &#125;</span><br><span class="line">  public sayHi() &#123;</span><br><span class="line">    console.log(&#96;Meow, My name is $&#123;this.name&#125;&#96;)</span><br><span class="line">    &#x2F;&#x2F; console.log(&#96;Meow, My age is $&#123;this.age&#125;&#96;) &#x2F;&#x2F; 报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const animal &#x3D; new Animal(&#39;Jack&#39;, 2) &#x2F;&#x2F; 报错</span><br><span class="line">const cat &#x3D; new Cat(&#39;Jack&#39;, 2, &#39;fish&#39;)</span><br><span class="line">console.log(cat.sayHi())</span><br></pre></td></tr></table></figure>
<h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3>接口（Interfaces）可以用于对「对象的形状」进行描述。若是不同类之间有一些共有的特性，可以把特性提取成接口，用 <strong>implements</strong> 关键字来实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert(): void</span><br><span class="line">&#125;</span><br><span class="line">interface Light &#123;</span><br><span class="line">    lightOn(): void</span><br><span class="line">&#125;</span><br><span class="line">class Car implements Alarm, Light &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        console.log(&#39;Car alert&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    lightOn() &#123;</span><br><span class="line">        console.log(&#39;Car light on&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>接口继承接口：继承类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert(): void</span><br><span class="line">&#125;</span><br><span class="line">interface LightableAlarm extends Alarm &#123;</span><br><span class="line">    lightOn(): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>接口继承类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number;</span><br><span class="line">    constructor(x: number, y: number) &#123;</span><br><span class="line">        this.x &#x3D; x</span><br><span class="line">        this.y &#x3D; y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Point3d extends Point &#123;</span><br><span class="line">    z: number</span><br><span class="line">&#125;</span><br><span class="line">let point3d: Point3d &#x3D; &#123;x: 1, y: 2, z: 3&#125;</span><br><span class="line"></span><br><span class="line">interface PointInstanceType &#123;</span><br><span class="line">    x: number</span><br><span class="line">    y: number</span><br><span class="line">&#125;</span><br><span class="line">function printPoint(p: Point) &#123;</span><br><span class="line">    console.log(p.x, p.y);</span><br><span class="line">&#125;</span><br><span class="line">function printPoint(p: Point) &#123;</span><br><span class="line">    console.log(p.x, p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Point 当做一个类来用（使用 new Point 创建它的实例），也可以将 Point 当做一个类型来用。类型 PointInstanceType 和类型 Point 是等价的，只是缺少了构造函数、静态属性或静态方法</p>
</blockquote>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3>在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] &#x3D; []</span><br><span class="line">    for (let i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] &#x3D; value</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">createArray&lt;string&gt;(3, &#39;x&#39;)</span><br></pre></td></tr></table></figure></li>
<li>使用泛型接口定义函数形状<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface CreateArrayFunc &#123;</span><br><span class="line">    &lt;T&gt;(length: number, value: T): Array&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line">let createArray: CreateArrayFunc</span><br><span class="line">createArray &#x3D; function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] &#x3D; [];</span><br><span class="line">    for (let i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] &#x3D; value</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">createArray &lt;string&gt; (3, &#39;x&#39;); &#x2F;&#x2F; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</span><br></pre></td></tr></table></figure></li>
<li>泛型类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T</span><br><span class="line">    add: (x: T, y: T) &#x3D;&gt; T</span><br><span class="line">&#125;</span><br><span class="line">let myGenericNumber &#x3D; new GenericNumber&lt;number&gt;()</span><br><span class="line">myGenericNumber.zeroValue &#x3D; 0</span><br><span class="line">myGenericNumber.add &#x3D; function(x, y) &#123; return x + y; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="vue-cli3-typescript"><a href="#vue-cli3-typescript" class="headerlink" title="vue-cli3 + typescript"></a>vue-cli3 + typescript</h2><h3 id="安装ts插件"><a href="#安装ts插件" class="headerlink" title="安装ts插件"></a>安装ts插件</h3></li>
<li>ts-loader 让webpack识别 .ts .tsx文件</li>
<li>@typescript-eslint/parser ts文件解析器（不安装的话，eslint无法解析ts语法，会报Parsing error错误）</li>
<li>@typescript-eslint/eslint-plugin 版本号需要与@typescript-eslint/parser的版本一致，解析器相关的配置选项<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i ts-loader typescript @typescript-eslint&#x2F;parser @typescript-eslint&#x2F;eslint-plugin --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h3>找到./vue.config.js，配置如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">configureWebpack: config &#x3D;&gt; &#123;</span><br><span class="line">   &#x2F;&#x2F; 更改入口文件</span><br><span class="line">   config.entry.app &#x3D; &#39;.&#x2F;src&#x2F;main.ts&#39;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 加上.ts 后缀（引入.ts的时候不写后缀）</span><br><span class="line">   config.resolve.extensions.push(&#39;.ts&#39;)</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;  添加webpack对.ts的解析</span><br><span class="line">   config.module.rules.push(&#123;</span><br><span class="line">    test: &#x2F;\.ts$&#x2F;,</span><br><span class="line">    exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">    enforce: &#39;pre&#39;,</span><br><span class="line">    loader: &#39;tslint-loader&#39;</span><br><span class="line">   &#125;)</span><br><span class="line">   config.module.rules.push(&#123;</span><br><span class="line">    test: &#x2F;\.tsx?$&#x2F;,</span><br><span class="line">    loader: &#39;ts-loader&#39;,</span><br><span class="line">    exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">    options: &#123;</span><br><span class="line">        appendTsSuffixTo: [&#x2F;\.vue$&#x2F;],</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加-tsconfig-json"><a href="#添加-tsconfig-json" class="headerlink" title="添加 tsconfig.json"></a>添加 tsconfig.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;include&quot;: [</span><br><span class="line">    &quot;src&#x2F;**&#x2F;*&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;exclude&quot;: [</span><br><span class="line">    &quot;node_modules&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &#x2F;&#x2F; 用来指定允许从没有默认导出的模块中默认导入，即允许import React from &#39;react&#39;而不用只能import * as React from &#39;react&#39;</span><br><span class="line">    &quot;allowSyntheticDefaultImports&quot;: true,</span><br><span class="line">    &#x2F;&#x2F; 用于指定是否启用装饰器特性</span><br><span class="line">    &quot;experimentalDecorators&quot;: true,</span><br><span class="line">    &#x2F;&#x2F; 允许编译javascript文件</span><br><span class="line">    &quot;allowJs&quot;: true,</span><br><span class="line">    &quot;module&quot;: &quot;esnext&quot;,</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">    &#x2F;&#x2F; 如何处理模块</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class="line">    &#x2F;&#x2F; 将每个文件作为单独的模块</span><br><span class="line">    &quot;isolatedModules&quot;: true,</span><br><span class="line">    &quot;lib&quot;: [</span><br><span class="line">      &quot;dom&quot;,</span><br><span class="line">      &quot;es5&quot;,</span><br><span class="line">      &quot;es2015.promise&quot;</span><br><span class="line">    ],</span><br><span class="line">    &#x2F;&#x2F; 是否包含可以用于 debug 的 sourceMap</span><br><span class="line">    &quot;sourceMap&quot;: true,</span><br><span class="line">    &quot;pretty&quot;: true,</span><br><span class="line">    &#x2F;&#x2F; 基准目录</span><br><span class="line">    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;,</span><br><span class="line">    &#x2F;&#x2F; 指定特殊模块的路径</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">      &quot;*&quot;: [&quot;src&#x2F;types&#x2F;*&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改-eslintrc-js配置"><a href="#修改-eslintrc-js配置" class="headerlink" title="修改.eslintrc.js配置"></a>修改.eslintrc.js配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  root: true,</span><br><span class="line">  env: &#123;</span><br><span class="line">    node: true,</span><br><span class="line">    &#39;browser&#39;: true,</span><br><span class="line">    &#39;commonjs&#39;: true,</span><br><span class="line">    &#39;es6&#39;: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  parser: &#39;vue-eslint-parser&#39;,</span><br><span class="line">  extends: [</span><br><span class="line">    &#39;plugin:vue&#x2F;essential&#39;,</span><br><span class="line">    &#39;@vue&#x2F;standard&#39;,</span><br><span class="line">    &#x2F;&#x2F; 新增配置项</span><br><span class="line">    &quot;plugin:@typescript-eslint&#x2F;recommended&quot;</span><br><span class="line">  ],</span><br><span class="line">  &#x2F;&#x2F; 新增配置项</span><br><span class="line">  plugins: [&#39;@typescript-eslint&#39;],</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    &#x2F;&#x2F; 新增配置项</span><br><span class="line">    parser: &#39;@typescript-eslint&#x2F;parser&#39;,</span><br><span class="line">    ecmaFeatures: &#123;</span><br><span class="line">      &#39;legacyDecorators&#39;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    &#39;semi&#39;: [&#39;error&#39;, &#39;never&#39;],</span><br><span class="line">    &#39;no-extra-semi&#39;: 2,</span><br><span class="line">        &quot;space-before-function-paren&quot;: 0,</span><br><span class="line">    &#39;no-console&#39;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,</span><br><span class="line">    &#39;no-debugger&#39;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,</span><br><span class="line">    &#39;@typescript-eslint&#x2F;no-unused-vars&#39;: [0, &#123; args: &#39;none&#39; &#125;], &#x2F;&#x2F; 不限制定义的类型是否使用</span><br><span class="line">    &#39;@typescript-eslint&#x2F;explicit-function-return-type&#39;: 0, &#x2F;&#x2F; 不限制定义返回函数的类型</span><br><span class="line">    &#39;@typescript-eslint&#x2F;no-empty-function&#39;: 0, &#x2F;&#x2F; 不限制是空函数</span><br><span class="line">    &#39;@typescript-eslint&#x2F;no-explicit-any&#39;: 0, &#x2F;&#x2F; 不限制设置any类型</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="修改main-js"><a href="#修改main-js" class="headerlink" title="修改main.js"></a>修改main.js</h3><p>把项目主文件 main.js 修改成 main.ts ，里面的写法基本不变，但是有一点需要注意： 引入Vue文件的时候，需要加上 .vue 后缀，因为 TypeScript 默认只识别 *.ts 文件，不识别 *.vue 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br></pre></td></tr></table></figure>
<h3 id="让-ts-识别-vue"><a href="#让-ts-识别-vue" class="headerlink" title="让 ts 识别 .vue"></a>让 ts 识别 .vue</h3><p>由于 TypeScript 默认并不支持 *.vue 后缀的文件，在 vue 项目中引入的时候需要创建一个 vue-shim.d.ts 文件，例如 src/types/vue-shim.d.ts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare module &quot;*.vue&quot; &#123;</span><br><span class="line">  import Vue from &quot;vue&quot;;</span><br><span class="line">  export default Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="开发vue项目"><a href="#开发vue项目" class="headerlink" title="开发vue项目"></a>开发vue项目</h3><h4 id="安装vue相关插件"><a href="#安装vue相关插件" class="headerlink" title="安装vue相关插件"></a>安装vue相关插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-class-component vue-property-decorator vuex-class --save</span><br></pre></td></tr></table></figure>
<h4 id="vue-class-component"><a href="#vue-class-component" class="headerlink" title="vue-class-component"></a>vue-class-component</h4><p>让 TypeScript 正确推断 Vue 组件选项中的类型，有两种方案，一种是Vue.extend（vue api上的用法），一种是使用vue-class-component</p>
<p>1）Vue.extend，使用基础 Vue 构造器，创建一个“子类”，其用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">   ... &#x2F;&#x2F; 类型推断已启用</span><br><span class="line">&#125;)</span><br><span class="line">export default &#123;</span><br><span class="line">   &#x2F;&#x2F; 这里不会有类型推断，</span><br><span class="line">   &#x2F;&#x2F; 因为 TypeScript 不能确认这是 Vue 组件的选项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）vue-class-component的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Component from &#39;vue-class-component&#39;</span><br><span class="line">@Component(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    propMessage: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default class App extends Vue &#123;</span><br><span class="line">  &#x2F;&#x2F; initial data</span><br><span class="line">  msg &#x3D; 123</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; use prop values for initial data</span><br><span class="line">  helloMsg &#x3D; &#39;Hello, &#39; + this.propMessage</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; lifecycle hook</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    this.greet()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; computed</span><br><span class="line">  get computedMsg () &#123;</span><br><span class="line">    return &#39;computed &#39; + this.msg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; method</span><br><span class="line">  greet () &#123;</span><br><span class="line">    alert(&#39;greeting: &#39; + this.msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Prop</strong></p>
<p>当从父组件传递数据到子组件时，通过 Prop 来实现；为了确保 Prop 的类型安全，我们会给 Prop 添加指定类型验证，之前的做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    testProps: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      required: true,</span><br><span class="line">      default: () &#x3D;&gt; (&#123; message: &#39;test&#39; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述定义了一个 testProps，它的类型是 Object。只定义Object，并不能获取更多的信息，在 TypeScript 看来，这将会是一个 any 类型。可以通过 TypeScript 添加更多的类型说明：</p>
<ul>
<li>若是使用 Vue.extend() 或vue-class-component，给Prop添加类型注释时，需要以函数返回值的形式给 type 断言：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">interface User &#123;</span><br><span class="line">  name: string,</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    testProps: &#123;</span><br><span class="line">      type: Object as () &#x3D;&gt; User</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>若是使用 vue-propperty-decorator，给 prop 添加类型推荐时，就会变得简单：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Vue, Prop &#125; from &#39;vue-property-decorator&#39;</span><br><span class="line">interface User &#123;</span><br><span class="line">  name: string,</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line">@Component</span><br><span class="line">export default class Test extends Vue &#123;</span><br><span class="line">  @Prop(&#123; type: User &#125;)</span><br><span class="line">  private test: &#123; value: string &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h4>在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，简化书写，新增了这 7 个装饰器：</li>
<li>@Component (完全继承于vue-class-component)</li>
<li>@Emit</li>
<li>@Inject</li>
<li>@Provice</li>
<li>@Prop</li>
<li>@Watch</li>
<li>@Model<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Emit, Inject, Model, Prop, Provide, Vue, Watch &#125; from &#39;vue-property-decorator&#39;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">export class MyComponent extends Vue &#123;</span><br><span class="line">  @Prop(&#123; default: &#39;default value&#39; &#125;)</span><br><span class="line">  propA: string</span><br><span class="line"></span><br><span class="line">  @Prop([String, Boolean])</span><br><span class="line">  propB: string | boolean</span><br><span class="line"> </span><br><span class="line">  count &#x3D; 0</span><br><span class="line"></span><br><span class="line">  @Watch(&#39;child&#39;)</span><br><span class="line">  onChildChanged(val: string, oldVal: string) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  @Emit(&#39;reset&#39;)</span><br><span class="line">  emitTodo(n: number)&#123;</span><br><span class="line">    this.count +&#x3D; n</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 上面的代码等同于</span><br><span class="line">  methods: &#123;</span><br><span class="line">    emitTodo(n) &#123;</span><br><span class="line">      this.count +&#x3D; n</span><br><span class="line">      this.$emit(&#39;emitTodo&#39;, n)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Model(&#39;textInput&#39;, &#123; type: String &#125;) value</span><br><span class="line">  &#x2F;&#x2F; 上面的代码等同于</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &#39;value&#39;,</span><br><span class="line">    event: &#39;textInput&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: String</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 在上一层级父组件里声明的provide，下一层级子组件无论多少级都可以通过inject来访问到provide的数据</span><br><span class="line">  &#x2F;&#x2F; 父组件</span><br><span class="line">  @Provide()</span><br><span class="line">  name &#x3D; &#39;foo&#39;</span><br><span class="line">  &#x2F;&#x2F; 子组件</span><br><span class="line">  @Inject(&#39;name&#39;)</span><br><span class="line">  &#x2F;&#x2F; 上面的代码等同于</span><br><span class="line">  &#x2F;&#x2F; 父组件</span><br><span class="line">  provide: &#123;</span><br><span class="line">     name: &#39;foo&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 子组件</span><br><span class="line">  inject: [name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vuex-class"><a href="#vuex-class" class="headerlink" title="vuex-class"></a>vuex-class</h4>vuex-class 是基于 vue-class-component 对 Vuex 提供的装饰器。<br>目录结构：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">store  </span><br><span class="line">├── modules                  </span><br><span class="line">│   ├── home.ts    </span><br><span class="line">│   └── xxx.ts  </span><br><span class="line">├── index.ts  </span><br><span class="line">└── type.ts   </span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">index.ts</span><br></pre></td></tr></table></figure>
import Vue from ‘vue’<br>import Vuex from ‘vuex’<br>Vue.use(Vuex)<br>// 自动引入 modules 文件夹下的js文件，以文件名字作为对象的key<br>const modulesContext = require.context(‘./modules’, false, /.*.ts/)<br>const modules = modulesContext.keys().reduce((prev, cur) =&gt; {<br>const key = cur.match(/(\w+).ts/)[1]<br>prev[key] = modulesContext(cur).default<br>return prev<br>}, {})</li>
</ul>
<p>export default new Vuex.Store({<br>  modules<br>})</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_注：会报“Property &#39;context&#39; does not exist on type &#39;NodeRequire&#39;.”的错误，这里需要安装webpack类型声明：</span><br></pre></td></tr></table></figure>
<p>npm i @types/webpack-env –save-dev</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">home.ts </span><br></pre></td></tr></table></figure>
<p>import TYPES from ‘../types’<br>import {<br>  QueryParam,<br>  ResponseData<br>} from ‘@/types/index.d’<br>import * as Api from ‘@/utils/api.ts’</p>
<p>interface State {<br>  skuInfo: any,<br>  [propName: string]: any<br>}</p>
<p>const initState: State = {<br>  skuInfo: {}<br>}<br>export default {<br>  namespaced: true,<br>  state: initState,<br>  mutations: {<br>    [TYPES.SET_SKU_INFO] (state, skuInfo) {<br>      state.skuInfo = skuInfo<br>    }<br>  },<br>  actions: {<br>    getSkuInfo ({ dispatch, commit, getters, rootGetters }, { skuId }) {<br>      return new Promise((resolve, reject) =&gt; {<br>        Api.requestData({<br>          functionId: ‘getSkuInfo’,<br>          bodyParams: {<br>            skuId<br>          }<br>        }).then((resData: ResponseData) =&gt; {<br>          const { code, data } = resData<br>          if (code === ‘1’ &amp;&amp; data) {<br>            commit(TYPES.SET_SKU_INFO, data)<br>            resolve(data)<br>          } else {<br>            reject(resData)<br>          }<br>        }).catch(err =&gt; {<br>          console.log(err, ‘getSkuInfo err!’)<br>          reject(err)<br>        })<br>      })<br>    }<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在组件中使用 ‘home’ 模块中定义的 &#39;skuInfo&#39; State和 ‘getSkuInfo’ Action</span><br><span class="line">* 第一种方式：  </span><br></pre></td></tr></table></figure>
<p>import Vue from ‘vue’<br>import Component from ‘vue-class-component’<br>import { State, Action, namespace } from ‘vuex-class’<br>const homeModule = namespace(‘home’)</p>
<p>@Component<br>export class Home extends Vue {<br>  @homeModule.State(‘skuInfo’) skuInfo<br>  @homeModule.Action(‘getSkuInfo’) getSkuInfo: ({ skuId }) =&gt; Promise<any><br>  created () {<br>    this.getSkuInfo({ skuId: 64967590189 })<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 第二种方式：</span><br></pre></td></tr></table></figure>
<p>import Vue from ‘vue’<br>import Component from ‘vue-class-component’<br>import { State, Action } from ‘vuex-class’</p>
<p>@Component<br>export class Home extends Vue {<br>  @State(‘skuInfo’, { namespace: ‘home’ }) skuInfo: any<br>  @Action(‘getSkuInfo’, { namespace: ‘home’ }) getSkuInfo: ({ skuId }) =&gt; Promise<any><br>  created () {<br>    this.getSkuInfo({ skuId: 64967590189 })<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面的代码相当于：</span><br></pre></td></tr></table></figure>
<p>import Vue from ‘vue’<br>import { mapState, mapActions } from ‘vuex’<br>export default Vue.extend({<br>   computed: {<br>     …mapState(‘home’, [‘skuInfo’])<br>   },<br>   methods: {<br>     …mapActions(‘home’, [‘getSkuInfo’])<br>   }<br>})</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 书写声明文件</span><br><span class="line">#### 为本项目定义类型文件(可以重复引用)</span><br></pre></td></tr></table></figure>
<p>// 1. 全局类型声明，无需import<br>// 1.1<br>declare type QueryParam = string | string[]</p>
<p>declare interface ResponseData {<br>  code: number | string;<br>  data?: any;<br>  msg?: string;<br>}</p>
<p>// 1.2 定义一个命名空间，声明这个拥有多个子属性的全局变量<br>// 用法：homeData.QueryParam 或 homeData.ResponseData<br>declare namespace homeData {<br>  type QueryParam = string | string[]</p>
<p>  interface ResponseData {<br>    code: number | string;<br>    data?: any;<br>    msg?: string;<br>  }<br>}</p>
<p>// 2.1 模块类型声明，需import引入类型文件<br>export type QueryParam = string | string[]</p>
<p>export interface ResponseData {<br>  code: number | string;<br>  data?: any;<br>  msg?: string;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#### 为第三方库定义类型声明文件</span><br><span class="line"></span><br><span class="line">若是引用的第三方库已经定义好了类型声明文件，直接npm安装即可，例如webpack：</span><br></pre></td></tr></table></figure>
<p>npm i @types/webpack-env –save-dev</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">尝试使用npm install @type&#x2F;xxx 命令来安装声明文件，若是安装失败，则第三方库没有提供声明文件时，需要自己书写声明文件。</span><br><span class="line"></span><br><span class="line">**全局库**</span><br><span class="line"></span><br><span class="line">即通过 &lt;script&gt; 标签引入第三方库，能在全局命名空间下访问的（例如：不需要使用任何形式的import）。</span><br><span class="line">假设通过script标签引入jQuery，类型声明如下：</span><br><span class="line">创建一个 global.d.ts 文件，用来存放全局类型声明，例如 src&#x2F;types&#x2F;global.d.ts</span><br></pre></td></tr></table></figure>
<p>declare var jQuery: (selector: string) =&gt; any</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**模块化库**</span><br><span class="line"></span><br><span class="line">有两种写法，一种是全局类型声明，另一种则是模块导出声明。以为第三方工具类库@yolkpie&#x2F;utils定义类型声明文件为例：  </span><br><span class="line">* **全局类型声明**  </span><br><span class="line"></span><br><span class="line">创建一个 global.d.ts 文件，用来存放全局类型声明，例如 src&#x2F;types&#x2F;global.d.ts</span><br></pre></td></tr></table></figure>
<p>// 只需要对引用到的方法进行类型声明<br>declare module ‘@yolkpie/utils’ {<br>  export function isSupportWebp(): boolean<br>  export function rem(): void<br>  export function formatDate(date: Date|string|number, format?: string): string<br>}<br>declare module ‘vue-awesome-swiper’ {<br>  export const swiper: any<br>  export const swiperSlide: any<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* **模块导出声明**  </span><br><span class="line"></span><br><span class="line">创建一个 types 目录，专门用来管理自己写的声明文件，将 @yolkpie&#x2F;utils 的声明文件放到 types&#x2F;@yolkpie&#x2F;utils&#x2F;index.d.ts 中。这种方式需要配置下 tsconfig.json 中的 paths 和 baseUrl 字段。</span><br><span class="line">目录结构：</span><br></pre></td></tr></table></figure>
<p>src<br>└── types<br>    └── @yolkpie<br>        ├── utils<br>        │   └── index.d.ts<br>        ├── global.d.ts<br>        └── vue-shim.d.ts   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsconfig.json 内容：</span><br></pre></td></tr></table></figure>
<p>{<br>    “compilerOptions”: {<br>        “baseUrl”: “./“,<br>        “paths”: {<br>            “<em>“: [“src/types/</em>“]<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这样配置之后，通过 import 导入 @yolkpie&#x2F;utils  的时候，也会去 types 目录下寻找对应的模块的声明文件了。</span><br><span class="line">例如：src&#x2F;types&#x2F;@yolkpie&#x2F;utils&#x2F;index.d.ts</span><br></pre></td></tr></table></figure>
<p>// 1.直接export<br>export function isSupportWebp(): boolean<br>export function rem(): void<br>export function formatDate(date: Date|string|number, format?: string): string</p>
<p>// 2.export和declare混合<br>declare function isSupportWebp(): boolean<br>declare function rem(): void<br>declare function formatDate(date: Date|string|number, format?: string): string<br>declare namespace jQuery {<br>  function ajax(url: string, settings?: any): void;<br>}<br>export {<br>  rem,<br>  isSupportWebp,<br>  formatDate<br>}</p>
<pre><code>
</code></pre>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YolkPie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yolkpie.net/2020/06/19/VueCLI3%E5%92%8CTypeScript%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">https://yolkpie.net/2020/06/19/VueCLI3%E5%92%8CTypeScript%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yolkpie.net" target="_blank">YolkPie</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vue/">vue</a><a class="post-meta__tags" href="/tags/ts/">ts</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/19/%E4%BA%AC%E4%B8%9C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%89%8B/"><img class="prev-cover" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/144925/27/970/59191/5eec6d42Eee359811/8b7bbdb996007587.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">京东小程序上手</div></div></a></div><div class="next-post pull-right"><a href="/2020/05/21/%E8%89%B2%E5%BD%A9%E7%90%86%E8%AE%BA%E4%B8%8E%E6%90%AD%E9%85%8D/"><img class="next-cover" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/123300/4/2538/97455/5ec63661E0cdf0415/52fca025cb4f7250.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">色彩理论与搭配</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/02/04/NuxtJS/" title="nuxt.js"><img class="relatedPosts_cover" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/105460/30/11621/22495/5e38e372E0cfb98b4/ee15034e2da3e64e.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-04</div><div class="relatedPosts_title">nuxt.js</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/27/Vue3迁移指南/" title="Vue3迁移指南"><img class="relatedPosts_cover" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/122074/8/13483/538833/5f70524dEdc179584/a381558342598384.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-27</div><div class="relatedPosts_title">Vue3迁移指南</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/03/Vue服务器端渲染/" title="Vue服务器端渲染"><img class="relatedPosts_cover" data-src="https://cn.vuejs.org/images/logo.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-03</div><div class="relatedPosts_title">Vue服务器端渲染</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/19/diff/" title="核心Diff算法"><img class="relatedPosts_cover" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/145814/24/8751/761861/5f65d465Ec74e3d82/13384de14843dee4.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-19</div><div class="relatedPosts_title">核心Diff算法</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By YolkPie</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>