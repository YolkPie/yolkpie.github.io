<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>深入学习 React 合成事件 | YolkPie</title><meta name="description" content="提出问题我们借鉴一个比较典型的案例开始来分析React事件： 1234567891011121314151617181920212223242526272829export default class Dialog extends React.PureComponent &amp;#123;  state &#x3D; &amp;#123;    showBox: false  &amp;#125;;  componen"><meta name="keywords" content="前端技术博客"><meta name="author" content="YolkPie"><meta name="copyright" content="YolkPie"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yolkpie.net/2022/11/16/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0React%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="深入学习 React 合成事件"><meta property="og:url" content="https://yolkpie.net/2022/11/16/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0React%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6/"><meta property="og:site_name" content="YolkPie"><meta property="og:description" content="提出问题我们借鉴一个比较典型的案例开始来分析React事件： 1234567891011121314151617181920212223242526272829export default class Dialog extends React.PureComponent &amp;#123;  state &#x3D; &amp;#123;    showBox: false  &amp;#125;;  componen"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2022-11-16T11:00:00.000Z"><meta property="article:modified_time" content="2022-11-21T09:32:19.897Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="Webpack 的插件机制 - Tapable" href="https://yolkpie.net/2022/11/15/Webpack%20%E7%9A%84%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6-Tapable/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">181</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">85</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">35</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">提出问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">合成事件的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="toc-number">3.</span> <span class="toc-text">事件绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91"><span class="toc-number">4.</span> <span class="toc-text">事件触发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">5.</span> <span class="toc-text">合成事件的生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A3%E7%BB%91"><span class="toc-number">6.</span> <span class="toc-text">事件解绑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0"><span class="toc-number">7.</span> <span class="toc-text">批量更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React17-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%94%B9%E8%BF%9B"><span class="toc-number">8.</span> <span class="toc-text">React17 中的事件改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94"><span class="toc-number">9.</span> <span class="toc-text">问题解答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">YolkPie</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">深入学习 React 合成事件</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2022-11-16 19:00:00"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2022-11-16</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-11-21 17:32:19"><i class="fas fa-history fa-fw"></i> 更新于 2022-11-21</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>我们借鉴一个比较典型的案例开始来分析React事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">export default class Dialog extends React.PureComponent &#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    showBox: false</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    document.addEventListener(&quot;click&quot;, this.handleClickBody, false);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClickBody &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      showBox: false</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClickButton &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">    e.nativeEvent.stopPropagation();</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      showBox: true</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.handleClickButton&#125;&gt;点击我显示弹窗&lt;&#x2F;button&gt;</span><br><span class="line">        &#123;this.state.showBox &amp;&amp; (</span><br><span class="line">          &lt;div onClick&#x3D;&#123;(e) &#x3D;&gt; e.nativeEvent.stopPropagation()&#125;&gt;我是弹窗&lt;&#x2F;div&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码里我们不难看出我们想要做一个点击某一个按钮来展示一个模态框，并且在点击除了模态框区域以外的位置希望能够关闭这个模态框。 但是实际运行结果和我们所想的完全不一样，点击了 button 按钮并没有任何反应，这就需要从React的合成事件说起了，让我们分析完React的合成事件 后能够完全的来解答这个问题。</p>
<h2 id="合成事件的特性"><a href="#合成事件的特性" class="headerlink" title="合成事件的特性"></a>合成事件的特性</h2><p>React自行实现了一套事件系统，主要特性有以下:</p>
<ul>
<li><p>自行实现了一套事件捕获到事件冒泡的逻辑, 抹平各个浏览器之前的兼容性问题。</p>
</li>
<li><p>使用对象池来管理合成事件对象的创建和销毁，可以减少垃圾回收次数，防止内存抖动。</p>
</li>
<li><p>事件只在 document 上绑定，并且每种事件只绑定一次，减少内存开销。</p>
</li>
</ul>
<p>首先我们先抛开上面那个按钮，用下面这个十分简单的案例来了解React的事件使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  function handleButtonLog(e: React.MouseEvent&lt;HTMLButtonElement&gt;) &#123;</span><br><span class="line">    console.log(e.currentTarget);</span><br><span class="line">  &#125;</span><br><span class="line">  function handleDivLog(e: React.MouseEvent&lt;HTMLDivElement&gt;) &#123;</span><br><span class="line">    console.log(e.currentTarget);</span><br><span class="line">  &#125;</span><br><span class="line">  function handleH1Log(e: React.MouseEvent&lt;HTMLElement&gt;) &#123;</span><br><span class="line">    console.log(e.currentTarget);</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div onClick&#x3D;&#123;handleDivLog&#125;&gt;</span><br><span class="line">      &lt;h1 onClick&#x3D;&#123;handleH1Log&#125;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;handleButtonLog&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码运行后，会在控制台中分别打印出，button, h1, div三个 dom 节点，我们来研究一下他是如何工作的。</p>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>首先来确认事件是如何绑定到dom节点上的，我们知道App组件内的jsx代码会通过React.CreateElement函数返回jsx对象，其中我们的onClick事件是储存在每一个jsx对象的props属性内，通过一系列方法得知在React在reconciliation阶段中会把jsx对象转换为fiber对象，这里有一个方法叫做completeWork</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function completeWork(current, workInProgress, renderExpirationTime) &#123;</span><br><span class="line">    &#x2F;&#x2F; 只保留关键代码</span><br><span class="line">    case HostComponent:</span><br><span class="line">      &#123;</span><br><span class="line">        popHostContext(workInProgress);</span><br><span class="line">        var rootContainerInstance &#x3D; getRootHostContainer();</span><br><span class="line">        var type &#x3D; workInProgress.type;</span><br><span class="line">        if (current !&#x3D;&#x3D; null &amp;&amp; workInProgress.stateNode !&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; 更新</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 创建</span><br><span class="line">          if (_wasHydrated) &#123;</span><br><span class="line">            &#x2F;&#x2F; ssr情况</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            var instance &#x3D; createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 初始化DOM节点</span><br><span class="line">            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数内通过createInstance创建 dom 实例，并且调用finalizeInitialChildren函数，在finalizeInitialChildren函数中会把 props 设置到真实的 dom 节点上，这里如果遇到类似onClick，onChange的 props 时，会触发事件绑定的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 进行事件绑定</span><br><span class="line">ensureListeningTo(rootContainerElement, propKey);</span><br><span class="line"></span><br><span class="line">function ensureListeningTo(rootContainerElement, registrationName) &#123;</span><br><span class="line">  &#x2F;&#x2F; 忽略无关代码</span><br><span class="line">  var doc &#x3D; isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;</span><br><span class="line">  legacyListenToEvent(registrationName, doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ensureListeningTo函数中会通过实际触发事件的节点，去寻找到它的document节点，并且调用legacyListenToEvent函数来进行事件绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function legacyListenToEvent(registrationName, mountAt) &#123;</span><br><span class="line">  var listenerMap &#x3D; getListenerMapForElement(mountAt);</span><br><span class="line">  var dependencies &#x3D; registrationNameDependencies[registrationName];</span><br><span class="line"></span><br><span class="line">  for (var i &#x3D; 0; i &lt; dependencies.length; i++) &#123;</span><br><span class="line">    var dependency &#x3D; dependencies[i];</span><br><span class="line">    legacyListenToTopLevelEvent(dependency, mountAt, listenerMap);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Image 在 legacyListenToEvent 函数中首先通过获取 document 节点上监听的事件名称 Map 对象，然后去通过绑定在 jsx 上的事件名称，例如 onClick 来获取到真实的事件名称，例如 click，依次进行 legacyListenToTopLevelEvent 方法的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function legacyListenToTopLevelEvent(topLevelType, mountAt, listenerMap) &#123;</span><br><span class="line">  &#x2F;&#x2F; 只保留主逻辑</span><br><span class="line">  &#x2F;&#x2F; 相同的事件只绑定一次</span><br><span class="line">  if (!listenerMap.has(topLevelType)) &#123;</span><br><span class="line">    switch (topLevelType) &#123;</span><br><span class="line">      &#x2F;&#x2F; 根据事件类型进行捕获或者冒泡绑定</span><br><span class="line">      case TOP_SCROLL:</span><br><span class="line">        trapCapturedEvent(XX);</span><br><span class="line">      default:</span><br><span class="line">        trapBubbledEvent(topLevelType, mountAt)</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenerMap.set(topLevelType, null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 无论是trapBubbledEvent还是trapCapturedEvent都是调用trapEventForPluginEventSystem</span><br><span class="line">&#x2F;&#x2F; 区别就是第三个参数是ture还是false用来对应addEventListener中的第三个参数</span><br><span class="line">function trapBubbledEvent(topLevelType, element) &#123;</span><br><span class="line">  trapEventForPluginEventSystem(element, topLevelType, false);</span><br><span class="line">&#125;</span><br><span class="line">function trapCapturedEvent(topLevelType, element) &#123;</span><br><span class="line">  trapEventForPluginEventSystem(element, topLevelType, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>legacyListenToTopLevelEvent函数做了以下两件事</p>
<ul>
<li>是否在 document 上已经绑定过原始事件名，已经绑定过则直接退出，未绑定则绑定结束以后把事件名称设置到 Map 对象上，再下一次绑定相同的事件时直接跳过。</li>
<li>根据事件是否能冒泡来来进行捕获阶段的绑定或者冒泡阶段的绑定。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function trapEventForPluginEventSystem(container, topLevelType, capture) &#123;</span><br><span class="line">  var listener;</span><br><span class="line"></span><br><span class="line">  switch (getEventPriorityForPluginSystem(topLevelType)) &#123;</span><br><span class="line">    case DiscreteEvent:</span><br><span class="line">      listener &#x3D; dispatchDiscreteEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM, container);</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case UserBlockingEvent:</span><br><span class="line">      listener &#x3D; dispatchUserBlockingUpdate.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM, container);</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case ContinuousEvent:</span><br><span class="line">    default:</span><br><span class="line">      listener &#x3D; dispatchEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM, container);</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var rawEventName &#x3D; getRawEventName(topLevelType);</span><br><span class="line"></span><br><span class="line">  if (capture) &#123;</span><br><span class="line">    addEventCaptureListener(container, rawEventName, listener);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    addEventBubbleListener(container, rawEventName, listener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止我们已经拿到了真实的事件名称和绑定在事件的哪个阶段，剩下就还有一个监听事件本身了，这一步会在trapEventForPluginEventSystem函数内被获取到,他会通过事件的优先级来获取不同的监听事件，这部分会和调度方面有相关，我们只需要知道最终实际绑定的都是dispatchEvent这个监听事件，然后调用浏览器的addEventListener事件来绑定上dispatchEvent函数。</p>
<p>到此为止事件的绑定暂时告一段落了，从上面能得出几个结论。</p>
<ul>
<li><p>事件都是绑定在 document 上的。</p>
</li>
<li><p>jsx 中的事件名称会经过处理，处理后的事件名称才会被绑定，例如 onClick 会使用 click 这个名称来绑定。</p>
</li>
<li><p>不管用什么事件来绑定， 他们的监听事件并不是传入 jsx 的事件函数，而是会根据事件的优先级来绑定dispatchDiscreteEvent,dispatchUserBlockingUpdate或者dispatchEvent三个监听函数之一，但是最终在触发事件调用的还是dispatchEvent事件。</p>
</li>
</ul>
<h2 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h2><p>从事件绑定得知我们点击的 button 按钮的时候，触发的回调函数并不是实际的回调函数，而是dispatchEvent函数， 所以我们通常会有几个疑问</p>
<ul>
<li><p>它是怎么获取到用户事件的回调函数的？</p>
</li>
<li><p>为什么在合成事件对象不能被保存下来，而需要调用特殊的函数才能保留？</p>
</li>
<li><p>合成事件是怎么创建出来的？</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst) &#123;</span><br><span class="line">  var bookKeeping &#x3D; getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst, eventSystemFlags);</span><br><span class="line">  try &#123;</span><br><span class="line">    batchedEventUpdates(handleTopLevel, bookKeeping);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    releaseTopLevelCallbackBookKeeping(bookKeeping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的分析中我们就来解决这几个问题，首先看到dispatchEvent函数,忽略掉其他分支会发现实际调用的是dispatchEventForLegacyPluginEventSystem函数, 他首先通过callbackBookkeepingPool中获取一个bookKeeping对象，然后调用handleTopLevel函数，在调用结束的时候吧bookKeeping对象放回到callbackBookkeepingPool中，实现了内存复用。</p>
<p>bookKeeping 对象的结构如图:</p>
<p><img src= "/img/loading.gif" data-src="img01.webp"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 忽略分支代码，只保留主流程</span><br><span class="line">function handleTopLevel(bookKeeping) &#123;</span><br><span class="line">  var targetInst &#x3D; bookKeeping.targetInst;</span><br><span class="line">  var ancestor &#x3D; targetInst;</span><br><span class="line">  do &#123;</span><br><span class="line">    var tag &#x3D; ancestor.tag;</span><br><span class="line">    if (tag &#x3D;&#x3D;&#x3D; HostComponent || tag &#x3D;&#x3D;&#x3D; HostText) &#123;</span><br><span class="line">      bookKeeping.ancestors.push(ancestor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; while (ancestor);</span><br><span class="line"></span><br><span class="line">  for (var i &#x3D; 0; i &lt; bookKeeping.ancestors.length; i++) &#123;</span><br><span class="line">    targetInst &#x3D; bookKeeping.ancestors[i];</span><br><span class="line"></span><br><span class="line">    runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, eventTarget, eventSystemFlags);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在handleTopLevel函数内，通过首先把触发事件的节点如果是 dom 节点或者文字节点的话，那就把对应的 fiber 对象放入bookkeeping.ancestors的数组内，接下去依次获取bookKeeping.ancestors上的每一个 fiber 对象，通过runExtractedPluginEventsInBatch函数来创建合成事件对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) &#123;</span><br><span class="line">  var events &#x3D; extractPluginEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);</span><br><span class="line">  runEventsInBatch(events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在runExtractedPluginEventsInBatch中会通过调用extractPluginEvents函数，在这个函数内通过targetInst这个 fiber 对象，从这个对象一直往上寻找，寻找有一样的事件绑定的节点，并且把他们的回调事件组合到合成事件对象上，这里先讨论事件触发的流程，所以先简单带过合成事件是如何生成的以及是如何去寻找到需要被触发的事件, 后面会详细的讲解合成事件，最后在拿到合成事件以后调用runEventsInBatch函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function runEventsInBatch(events) &#123;</span><br><span class="line">  forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中processingEventQueue是多个事件列表，我们这只有一个事件队列，forEachAccumulated它的目的是为了按照队列的顺序去执行多个事件，在我们的例子中其实就相当于executeDispatchesAndReleaseTopLevel(processingEventQueue),接下来就是调用到executeDispatchesAndRelease，从名称就看出来他是首先执行事件，然后对事件对象进行释放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var executeDispatchesAndRelease &#x3D; function (event) &#123;</span><br><span class="line">  if (event) &#123;</span><br><span class="line">    executeDispatchesInOrder(event);</span><br><span class="line">    if (!event.isPersistent()) &#123;</span><br><span class="line">      event.constructor.release(event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码很少，首先调用executeDispatchesInOrder来传入合成事件，在里面按照顺序去执行合成事件对象上的回调函数，如果有多个回调函数，在执行每个回调函数的时候还会去判断event.isPropagationStopped()的状态，之前有函数调用了合成事件的 stopPropagation 函数的话，就停止执行后续的回调，但是要注意的时候这里的dispatchListeners[i]函数并不是用户传入的回调函数，而是经过包装的事件，这块会在合成事件的生成中介绍，在事件执行结束后 React 还会去根据用户是否调用了event.persist()函数来决定是否保留这次的事件对象是否要回归事件池，如果未被调用，该事件对象上的状态会被重置，至此事件触发已经完毕。</p>
<h2 id="合成事件的生成"><a href="#合成事件的生成" class="headerlink" title="合成事件的生成"></a>合成事件的生成</h2><p>从事件监听的流程中我们知道了合成事件是从extractPluginEvents创建出来的，那么看一下extractPluginEvents的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function extractPluginEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) &#123;</span><br><span class="line">  var events &#x3D; null;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; plugins.length; i++) &#123;</span><br><span class="line">    var possiblePlugin &#x3D; plugins[i];</span><br><span class="line">    if (possiblePlugin) &#123;</span><br><span class="line">      var extractedEvents &#x3D; possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);</span><br><span class="line">      if (extractedEvents) &#123;</span><br><span class="line">        events &#x3D; accumulateInto(events, extractedEvents);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来了解一下 plugins 是个什么东西，由于 React 会服务于不同的平台，所以每个平台的事件会用插件的形式来注入到 React 中，例如浏览器就是 ReactDOM 中进行注入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">injectEventPluginsByName(&#123;</span><br><span class="line">  SimpleEventPlugin: SimpleEventPlugin,</span><br><span class="line">  EnterLeaveEventPlugin: EnterLeaveEventPlugin,</span><br><span class="line">  ChangeEventPlugin: ChangeEventPlugin,</span><br><span class="line">  SelectEventPlugin: SelectEventPlugin,</span><br><span class="line">  BeforeInputEventPlugin: BeforeInputEventPlugin,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>injectEventPluginsByName函数会通过一些操作把事件插件注册到plugins对象上，数据结构如下:</p>
<p><img src= "/img/loading.gif" data-src="img02.webp"></p>
<p>所以会依次遍历plugin，调用plugin上的extractEvents函数来尝试是否能够生成出合成事件对象，在我们的例子中用的是 click 事件，那么它会进入到SimpleEventPlugin.extractEvents函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var SimpleEventPlugin &#x3D; &#123;</span><br><span class="line">  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) &#123;</span><br><span class="line">    var EventConstructor;</span><br><span class="line">    switch (topLevelType) &#123;</span><br><span class="line">      case TOP_KEY_DOWN:</span><br><span class="line">      case TOP_KEY_UP:</span><br><span class="line">        EventConstructor &#x3D; SyntheticKeyboardEvent;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      case TOP_BLUR:</span><br><span class="line">      case TOP_FOCUS:</span><br><span class="line">        EventConstructor &#x3D; SyntheticFocusEvent;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      default:</span><br><span class="line">        EventConstructor &#x3D; SyntheticEvent;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var event &#x3D; EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);</span><br><span class="line">    accumulateTwoPhaseDispatches(event);</span><br><span class="line">    return event;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个函数是通过topLevelType的类型来获取合成事件的构造函数，例如代码中的SyntheticKeyboardEvent，SyntheticFocusEvent等都是SyntheticEvent的子类，在基础上附加了自己事件的特殊属性，我们的 click 事件会使用到SyntheticEvent这个构造函数，然后通过getPooled函数来创建或者从事件池中取出一个合成事件对象实例。然后在accumulateTwoPhaseDispatchesSingle函数中，按照捕获到冒泡的顺序来获取所有的事件回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function accumulateTwoPhaseDispatchesSingle(event) &#123;</span><br><span class="line">  if (event &amp;&amp; event.dispatchConfig.phasedRegistrationNames) &#123;</span><br><span class="line">    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function traverseTwoPhase(inst, fn, arg) &#123;</span><br><span class="line">  var path &#x3D; [];</span><br><span class="line"></span><br><span class="line">  while (inst) &#123;</span><br><span class="line">    path.push(inst);</span><br><span class="line">    inst &#x3D; getParent(inst);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var i;</span><br><span class="line"></span><br><span class="line">  for (i &#x3D; path.length; i-- &gt; 0;) &#123;</span><br><span class="line">    fn(path[i], &#39;captured&#39;, arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (i &#x3D; 0; i &lt; path.length; i++) &#123;</span><br><span class="line">    fn(path[i], &#39;bubbled&#39;, arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>traverseTwoPhase函数会从当前的 fiber 节点通过 return 属性，找到所有的是原生 DOM 节点的 fiber 对象，然后推入到列表中，我们的例子中就是[ButtonFiber, H1Fiber, DivFiber], 首先执行捕获阶段的循环，从后往前执行，接着从前往后执行冒泡的循环，对应了浏览器原始的事件触发流程，最后会往accumulateDirectionalDispatches函数中传入当前执行的 fiber 和事件执行的阶段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function listenerAtPhase(inst, event, propagationPhase) &#123;</span><br><span class="line">  var registrationName &#x3D; event.dispatchConfig.phasedRegistrationNames[propagationPhase];</span><br><span class="line">  return getListener(inst, registrationName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function accumulateDirectionalDispatches(inst, phase, event) &#123;</span><br><span class="line">  var listener &#x3D; listenerAtPhase(inst, event, phase);</span><br><span class="line">  if (listener) &#123;</span><br><span class="line">    event._dispatchListeners &#x3D; accumulateInto(event._dispatchListeners, listener);</span><br><span class="line">    event._dispatchInstances &#x3D; accumulateInto(event._dispatchInstances, inst);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>listenerAtPhase中首先通过原生事件名和当前执行的阶段（捕获，还是冒泡）去再去获取对应的 props 事件名称（onClick，onClickCapture），然后通过 React 事件名称去 fiber 节点上获取到相应的事件回调函数，最后拼接在合成对象的_dispatchListeners数组内，当全部节点运行结束以后_dispatchListeners对象上就会有三个回调函数[handleButtonLog, handleH1Log, handleDivLog]，这里的回调函数就是我们在组件内定义的真实事件的回调函数。</p>
<p>到此合成事件构造就完成了，主要做了三件事:</p>
<ul>
<li><p>通过事件名称去选择合成事件的构造函数，</p>
</li>
<li><p>事件去获取到组件上事件绑定的回调函数设置到合成事件上的_dispatchListeners属性上，用于事件触发的时候去调用。</p>
</li>
<li><p>还有就是在初始化的时候去注入平台的事件插件。</p>
</li>
</ul>
<h2 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h2><p>通常我们写事件绑定的时候会在页面卸载的时候进行事件的解绑，但是在 React 中，框架本身由于只会在 document 上进行每种事件最多一次的绑定，所以并不会进行事件的解绑。</p>
<h2 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h2><p>当然如果我们使用 React 提供的事件，而不是使用我们自己绑定的原生事件除了会进行事件委托以外还有什么优势呢？ 再来看一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">export default class EventBatchUpdate extends React.PureComponent&lt;&gt; &#123;</span><br><span class="line">  button &#x3D; null;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">    this.button &#x3D; React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.button.current.addEventListener(</span><br><span class="line">      &quot;click&quot;,</span><br><span class="line">      this.handleNativeClickButton,</span><br><span class="line">      false</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  handleNativeClickButton &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState((preState) &#x3D;&gt; (&#123; count: preState.count + 1 &#125;));</span><br><span class="line">    this.setState((preState) &#x3D;&gt; (&#123; count: preState.count + 1 &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClickButton &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState((preState) &#x3D;&gt; (&#123; count: preState.count + 1 &#125;));</span><br><span class="line">    this.setState((preState) &#x3D;&gt; (&#123; count: preState.count + 1 &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&quot;update&quot;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;legacy event&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;button ref&#x3D;&#123;this.button&#125;&gt;native event add&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.handleClickButton&#125;&gt;React event add&lt;&#x2F;button&gt;</span><br><span class="line">        &#123;this.state.count&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如图</p>
<p><img src= "/img/loading.gif" data-src="img03.webp"></p>
<blockquote>
<p>首先点击第一个按钮，发现有两个 update 被打印出，意味着被 render 了两次。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="img04.webp"></p>
<blockquote>
<p>点击第二个按钮，只有一个 update 被打印出来。</p>
</blockquote>
<p>会发现通过 React 事件内多次调用setState，会自动合并多个setState，但是在原生事件绑定上默认并不会进行合并多个setState，那么有什么手段能解决这个问题呢？</p>
<ul>
<li>通过batchUpdate函数来手动声明运行上下文。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  handleNativeClickButton &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    ReactDOM.unstable_batchedUpdates(() &#x3D;&gt; &#123;</span><br><span class="line">      this.setState((preState) &#x3D;&gt; (&#123; count: preState.count + 1 &#125;));</span><br><span class="line">      this.setState((preState) &#x3D;&gt; (&#123; count: preState.count + 1 &#125;));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="img05.webp"></p>
<blockquote>
<p>首先点击第一个按钮，只有一个 update 被打印出来。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="img06.webp"></p>
<ul>
<li>启用concurrent mode的情况。（目前不推荐，未来的方案）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ReactDOM from &quot;React-dom&quot;;</span><br><span class="line"></span><br><span class="line">const root &#x3D; ReactDOM.unstable_createRoot(document.getElementById(&quot;root&quot;));</span><br><span class="line">root.render(&lt;App &#x2F;&gt;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>会发现不需要修改任何代码，只需要开启concurrent mode，就会自动进行setState的合并。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="img07.webp"></p>
<blockquote>
<p>首先点击第一个按钮，只有一个 update 被打印出来。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="img08.webp"></p>
<blockquote>
<p>点击第二个按钮，还是只有一个 update 被打印出来。 </p>
</blockquote>
<h2 id="React17-中的事件改进"><a href="#React17-中的事件改进" class="headerlink" title="React17 中的事件改进"></a>React17 中的事件改进</h2><p>在最近发布的React17版本中，对事件系统了一些改动，和 16 版本里面的实现有了一些区别，我们就来了解一下 17 中更新的点。</p>
<ul>
<li><p>更改事件委托</p>
<ul>
<li>首先第一个修改点就是更改了事件委托绑定节点，在 16 版本中，React 都会把事件绑定到页面的 document 元素上，这在多个 React 版本共存的情况下就会虽然某个节点上的函数调用了e.stopPropagation(),但还是会导致另外一个 React 版本上绑定的事件没有被阻止触发，所以在 17 版本中会把事件绑定到 render 函数的节点上。</li>
</ul>
</li>
<li><p>去除事件池</p>
<ul>
<li>17 版本中移除了event pooling，这是因为 React 在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为 null。在 React 16 及更早版本中，使用者必须调用 e.persist() 才能正确的使用该事件，或者正确读取需要的属性。</li>
</ul>
</li>
<li><p>对标浏览器</p>
<ul>
<li><p>onScroll 事件不再冒泡，以防止出现常见的混淆。</p>
</li>
<li><p>React 的 onFocus 和 onBlur 事件已在底层切换为原生的 focusin 和 focusout 事件。它们更接近 React 现有行为，有时还会提供额外的信息。</p>
</li>
<li><p>捕获事件（例如，onClickCapture）现在使用的是实际浏览器中的捕获监听器。</p>
</li>
</ul>
</li>
</ul>
<h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><p>现在让我们回到最开始的例子中，来看这个问题如何被修复</p>
<ul>
<li>16版本修复方法一</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  handleClickButton &#x3D; (e: React.MouseEvent) &#x3D;&gt; &#123;</span><br><span class="line">    e.nativeEvent.stopImmediatePropagation();</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>我们知道 React 事件绑定的时刻是在reconciliation阶段，会在原生事件的绑定前，那么可以通过调用e.nativeEvent.stopImmediatePropagation(); 来进行 document 后续事件的阻止。</p>
<ul>
<li>16版本修复方法二</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  window.addEventListener(&quot;click&quot;, this.handleClickBody, false);</span><br></pre></td></tr></table></figure>

<p>另外一个方法就是在 16 版本中事件会被绑定在 document 上，所以只要把原生事件绑定在 window 上，并且调用e.nativeEvent.stopPropagation();来阻止事件冒泡到 window 上即可修复。</p>
<ul>
<li>17版本修复方法</li>
</ul>
<p>在 17 版本中 React 事件并不会绑定在 document 上，所以并不需要修改任何代码，即可修复这个问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过一个经典的例子入手，自顶而下来分析 React 源码中事件的实现方式，了解事件的设计思想，最后给出多种的解决方案，能够在繁杂的业务中挑选最合适的技术方案来进行实践。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YolkPie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yolkpie.net/2022/11/16/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0React%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6/">https://yolkpie.net/2022/11/16/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0React%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yolkpie.net" target="_blank">YolkPie</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/11/15/Webpack%20%E7%9A%84%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6-Tapable/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Webpack 的插件机制 - Tapable</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By YolkPie</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>