<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>react-router原理解析 (一) | YolkPie</title><meta name="description" content="概要react-router 作为react项目最基本的的导航框架,  基本配置并不复杂, 但是它也提供了非常灵活的api, 和丰富的组件, 本文将从源码角度深入介绍react-router提供的导航组件, 以及其设计原理 react-router 对外提供3个包 12345678910react-router  &#x2F;&#x2F; react-router 导航的核心包react-rout"><meta name="keywords" content="react react-router"><meta name="author" content="YolkPie"><meta name="copyright" content="YolkPie"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yolkpie.net/2022/03/28/react-router%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E4%B8%80)/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="react-router原理解析 (一)"><meta property="og:url" content="https://yolkpie.net/2022/03/28/react-router%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E4%B8%80)/"><meta property="og:site_name" content="YolkPie"><meta property="og:description" content="概要react-router 作为react项目最基本的的导航框架,  基本配置并不复杂, 但是它也提供了非常灵活的api, 和丰富的组件, 本文将从源码角度深入介绍react-router提供的导航组件, 以及其设计原理 react-router 对外提供3个包 12345678910react-router  &#x2F;&#x2F; react-router 导航的核心包react-rout"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2022-03-28T08:01:13.000Z"><meta property="article:modified_time" content="2022-12-05T06:45:31.319Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="从头认识JavaScript的事件循环模型" href="https://yolkpie.net/2022/03/29/%E4%BB%8E%E5%A4%B4%E8%AE%A4%E8%AF%86JavaScript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8B/"><link rel="next" title="你不知道的TypeScript高级技巧" href="https://yolkpie.net/2022/03/26/TypeScript%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">181</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">85</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">35</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Router"><span class="toc-number">2.</span> <span class="toc-text">Router</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Route"><span class="toc-number">3.</span> <span class="toc-text">Route</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Switch"><span class="toc-number">4.</span> <span class="toc-text">Switch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WithRouter"><span class="toc-number">5.</span> <span class="toc-text">WithRouter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hooks-API"><span class="toc-number">6.</span> <span class="toc-text">Hooks API</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">YolkPie</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">react-router原理解析 (一)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2022-03-28 16:01:13"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2022-03-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-12-05 14:45:31"><i class="fas fa-history fa-fw"></i> 更新于 2022-12-05</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/react/">react</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>react-router 作为react项目最基本的的导航框架,  基本配置并不复杂, 但是它也提供了非常灵活的api, 和丰富的组件, 本文将从源码角度深入介绍react-router提供的导航组件, 以及其设计原理</p>
<p>react-router 对外提供3个包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">react-router  &#x2F;&#x2F; react-router 导航的核心包</span><br><span class="line">react-router-dom &#x2F;&#x2F; 对react-router进行了封装, 是react-router的拓展, 提供一些react组件</span><br><span class="line">react-router-native &#x2F;&#x2F; 同样是对react-router的封装, 区别是它是适用于react-native的库</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于react项目, 我们通常不会直接依赖react-router, 因为react-router-dom拥有其所有的功能, 并额外提供了BrowserRouter, HashRouter, Link等多个react组件 </span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">yarn add react-router-dom  </span><br></pre></td></tr></table></figure>

<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Router是react-router管理路由的核心组件,  是导航命令传递者，若没有引入Router，那么任何跳转都不会生效。  需要路由导航的页面都需要放在Router内被Router管理, Router的源码并不复杂,  因为其push, replace, back等导航功能的实现, 依赖另一个库 <code>history</code> 来实现, history库在React Router中扮演着导航执行者与监听者的重要角色。对于React Router，所有的“副作用”都由history库完成,   而Router源码中, 并没有直接持有history, history 需要从props从传入, 下面是Router的核心代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听history的变化</span></span><br><span class="line">props.history.listen(<span class="function"><span class="params">location</span> =&gt;</span> &#123;    </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>._isMounted) &#123;   </span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; location &#125;);   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;   </span><br><span class="line">      <span class="built_in">this</span>._pendingLocation = location;   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;);   </span><br></pre></td></tr></table></figure>


<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;RouterContext.Provider &gt;</span><br><span class="line">  &lt;HistoryContext.Provider</span><br><span class="line">    children=&#123;<span class="built_in">this</span>.props.children || <span class="literal">null</span>&#125;</span><br><span class="line">    value=&#123;<span class="built_in">this</span>.props.history&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/RouterContext.Provider&gt;</span><br></pre></td></tr></table></figure>


<p>可以看到 Router的工作就是监听history的变化, 通过创建的RouterContext. 将history的状态透传给子组件, 这也解释了为什么Router必须放在所有导航的组件的最外层, 因为只有这样子组件才能接受到context的变化.</p>
<p>通常情况下,  我么并不会直接使用Router组件, react-router-dom对Router进行了封装, 并提供了, BrowserHistory, HashHistory等组件,  其根据接收外部history对象的不同能提供不同的功能：如果接收browserHistory，则得到BrowserRouter，称为浏览器路由；如果接收hashHistory，则得到HashRouter，称为哈希路由；如果接收memoryHistory，则得到MemoryRouter，称为内存路由.</p>
<p>我们常用的BrowserRouter 就是 对 router 的封装, 不需要传入history 对象, 默认使用了  history 的 createBrrowserHistory  对象, BrowserRouter支持命名式路由跳转, 传递state等功能, 如果如果没有特殊的需求, 项目一般使用BrowserRouter, 作为路由管理对象</p>
<blockquote>
<p>需要注意的是, BrowserRouter需要服务端提供一些配置支持, 因为在用户强制刷新的场景, 如果当前路径为根路径, 如果仅给用户提供单纯的CDN静态文件，那么考虑当使用BrowserRouter后如导航到/foo/baz路径，这时用户强制刷新了页面，如果仅有单纯CDN静态文件的支持，由于找不到/foo/baz路径下的资源，页面就会返回“404无法找到”或者视具体情况产生其他错误.  解决这个问题的方式是在nginx的配置中, location字段添加 try_files $uri /index.html 这个配置</p>
</blockquote>
<p>其他常用router有HashRouter, StaticRouter等, 由于HashRouter不支持state持久化存储，其目的是支持在旧式浏览器上运行路由</p>
<p>StaticRouter一般称为静态路由。StaticRouter与其他类型Router的最大区别在于其不改变路径地址，且不记录历史栈，为无状态路由，大多在服务端渲染场景中使用, 其history并不由history第三方库提供，而是直接内化在其源码实现中。对于StaticRouter，可从react-router包中引入，无须传入history：主要用户服务端渲染</p>
<h2 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h2><p>Route组件的职责为接收路径信息并执行渲染。Route也称为路由端口，用于接收Router的命令,  当Route从Router接收到的location匹配的path参数时, Route就会渲染component参数中的组件, 同时Route也提供了render, children方式用于自定义渲染组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;RouterContext.Consumer&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">context</span> =&gt;</span> &#123;</span><br><span class="line">    invariant(context, <span class="string">&quot;You should not use &lt;Route&gt; outside a &lt;Router&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> location = <span class="built_in">this</span>.props.location || context.location;</span><br><span class="line">    <span class="keyword">const</span> match = <span class="built_in">this</span>.props.computedMatch</span><br><span class="line">      ? <span class="built_in">this</span>.props.computedMatch </span><br><span class="line">      : <span class="built_in">this</span>.props.path</span><br><span class="line">      ? matchPath(location.pathname, <span class="built_in">this</span>.props)</span><br><span class="line">      : context.match;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> props = &#123; ...context, location, match &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &#123; children, component, render &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children) &amp;&amp; children.length === <span class="number">0</span>) &#123;</span><br><span class="line">      children = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;RouterContext.Provider value=&#123;props&#125;&gt;</span><br><span class="line">        &#123;props.match</span><br><span class="line">          ? children</span><br><span class="line">            ? <span class="keyword">typeof</span> children === <span class="string">&quot;function&quot;</span></span><br><span class="line">              ? __DEV__</span><br><span class="line">                ? evalChildrenDev(children, props, <span class="built_in">this</span>.props.path)</span><br><span class="line">                : children(props)</span><br><span class="line">              : children</span><br><span class="line">            : component</span><br><span class="line">            ? React.createElement(component, props)</span><br><span class="line">            : render</span><br><span class="line">            ? render(props)</span><br><span class="line">            : <span class="literal">null</span></span><br><span class="line">          : <span class="keyword">typeof</span> children === <span class="string">&quot;function&quot;</span></span><br><span class="line">          ? __DEV__</span><br><span class="line">            ? evalChildrenDev(children, props, <span class="built_in">this</span>.props.path)</span><br><span class="line">            : children(props)</span><br><span class="line">          : <span class="literal">null</span>&#125;</span><br><span class="line">      &lt;/RouterContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&lt;/RouterContext.Consumer&gt;</span><br></pre></td></tr></table></figure>


<p>默认情况下, Route的匹配是模糊匹配  /cart  既会匹配 ‘/‘ 也会匹配 /cart  , 所以 / 路径会同时渲染两个页面, 解决的方式是使用exact参数, 只要加上 exact. 表示会精准匹配 /       </p>
<p>还有一种方式是将/放在最下面, 并包裹Switch组件, 因为switch是从上到下匹配的, /cart匹配到了/cart 下面的 /就不会被匹配到了, 后面会详细介绍Switch的原理</p>
<p>Route允许自行传入location进行匹配，而不是使用上下文中的location。传入的location的pathname可以与当前的pathname不相同，这可在某些场景中发挥作用，如路由动画等. </p>
<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>Switch拥有挑选Route的能力，会挑选并渲染第一个匹配路由路径的Route。当某Route匹配命中时，其余未匹配命中或者即便匹配路径的Route，都会返回null，Switch只渲染第一个匹配命中的Route</p>
<p>Switch的核心代码如下, 利用React.children.forEach遍历其子组件(也就是Route) , 然后, 匹配Route的path属性, 渲染出第一个匹配到的Route</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;RouterContext.Consumer&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">context</span> =&gt;</span> &#123;</span><br><span class="line">    invariant(context, <span class="string">&quot;You should not use &lt;Switch&gt; outside a &lt;Router&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> location = <span class="built_in">this</span>.props.location || context.location;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> element, match;</span><br><span class="line">    React.Children.forEach(<span class="built_in">this</span>.props.children, <span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (match == <span class="literal">null</span> &amp;&amp; React.isValidElement(child)) &#123;</span><br><span class="line">        element = child;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> path = child.props.path || child.props.from;</span><br><span class="line"></span><br><span class="line">        match = path</span><br><span class="line">          ? matchPath(location.pathname, &#123; ...child.props, path &#125;)</span><br><span class="line">          : context.match;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> match</span><br><span class="line">      ? React.cloneElement(element, &#123; location, <span class="attr">computedMatch</span>: match &#125;)</span><br><span class="line">      : <span class="literal">null</span>;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&lt;/RouterContext.Consumer&gt;</span><br></pre></td></tr></table></figure>


<p>为什么源码中不使用React的React.Children.toArray方法转换children，而直接使用forEach?这里要考虑同一个组件渲染在不同URL中的情况，如下所示：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/a&quot;</span> component=&#123;A&#125; /&gt;  </span><br><span class="line">  &lt;Route path=<span class="string">&quot;/b&quot;</span> component=&#123;A&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>


<p>在路径/a、/b同时渲染同一个A组件的情况下，若当前的路径为/a，并从该路径导航到/b路径，原先/a路径命中并渲染过A组件，且导航到/b路径也同样渲染A组件。由于对Switch的子组件来说，将同样渲染Route，Route也没有key的变化，Route的渲染也没有发生变化（都渲染A组件），因此A组件并不会触发componentWillUnmount，而是会进入A组件更新的生命周期。如果源码使用React.Children.toArray方法，由于该方法会为组件增加key标志，所以这时Route会因为key的不同，使旧key对应的Route被销毁，新key对应的Route被挂载。这样的销毁和挂载过程会导致同一个A组件也被销毁与重新挂载。</p>
<p>如果希望每次命中路由都能销毁旧组件，并重新渲染进而执行componentDidMount生命周期方法，则可以为渲染相同组件的各Route加入唯一的key值，如下所示：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当导航时，A组件会先销毁，再重新渲染并执行componentDidMount生命周期方法</span></span><br><span class="line">&lt;Switch&gt;  </span><br><span class="line">  &lt;Route path=<span class="string">&quot;/a&quot;</span> key=<span class="string">&quot;a&quot;</span> component=&#123;A&#125; /&gt;  </span><br><span class="line">  &lt;Route path=<span class="string">&quot;/b&quot;</span> key=<span class="string">&quot;b&quot;</span> component=&#123;A&#125; /&gt;</span><br><span class="line"> &lt;/Switch&gt;</span><br></pre></td></tr></table></figure>


<p>这时，由于key值不同，当导航从/a到/b时，key值为b对应的Route将得到渲染，但是由于原先的Route的key值为a，key值不一致，所以按照React的diff机制，key值为a对应的Route将会被销毁，key值为b对应的Route将会被挂载。对应的A组件也会执行相同的操作，即A组件会被销毁，并重新渲染，会执行componentDidMount生命周期方法。</p>
<h2 id="WithRouter"><a href="#WithRouter" class="headerlink" title="WithRouter"></a>WithRouter</h2><p>withRouter是React Router提供的高阶组件。在一些处于很深层级的组件中，如果希望获得props.history、props.location等对象，又不希望从上层逐级传入，则可使用withRouter高阶组件注入相关RouteComponentProps属性</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;RouterContext.Consumer&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">context</span> =&gt;</span> &#123;</span><br><span class="line">    invariant(</span><br><span class="line">      context,</span><br><span class="line">      <span class="string">`You should not use &lt;<span class="subst">$&#123;displayName&#125;</span> /&gt; outside a &lt;Router&gt;`</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Component</span><br><span class="line">        &#123;...remainingProps&#125;</span><br><span class="line">        &#123;...context&#125;</span><br><span class="line">        ref=&#123;wrappedComponentRef&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&lt;/RouterContext.Consumer&gt;</span><br></pre></td></tr></table></figure>


<p>从源码中可以看到, withRouter这个高阶组件, 所做的就是给子组件产地一个Router的Context, 是其获得路由状态和导航能力</p>
<h2 id="Hooks-API"><a href="#Hooks-API" class="headerlink" title="Hooks API"></a>Hooks API</h2><p>react-router提供了一些hook方法用于获取路由参数和history对象, 他们的原理也十分简单, 仅仅是对context做了一层封装</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useHistory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useContext(HistoryContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useLocation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useContext(Context).location;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> match = useContext(Context).match;</span><br><span class="line">  <span class="keyword">return</span> match ? match.params : &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useRouteMatch</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> location = useLocation();</span><br><span class="line">  <span class="keyword">const</span> match = useContext(Context).match;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> path ? matchPath(location.pathname, path) : match;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>由于location, match, history等对象, 在RouterContext中, 这些hook所做的仅仅就是返回对应的属性</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YolkPie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yolkpie.net/2022/03/28/react-router%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E4%B8%80)/">https://yolkpie.net/2022/03/28/react-router%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E4%B8%80)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yolkpie.net" target="_blank">YolkPie</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/react-react-router/">react react-router</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/29/%E4%BB%8E%E5%A4%B4%E8%AE%A4%E8%AF%86JavaScript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8B/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">从头认识JavaScript的事件循环模型</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/26/TypeScript%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">你不知道的TypeScript高级技巧</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By YolkPie</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>