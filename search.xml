<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AE伪3DUI 界面小教程</title>
    <url>/2021/03/29/AE%E4%BC%AA3DUI%20%E7%95%8C%E9%9D%A2%E5%B0%8F%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>本次给大家分享一个教程：使用Joysticks’n Sliders插件做一个3D-UI界面。</p>
<p>效果如下：</p>
<p><img src= "/img/loading.gif" data-src="https://storage.360buyimg.com/imgtools/3bbb5637f8-84af49c0-906c-11eb-9b88-f5ecb3f063c1.gif" alt="动效"></p>
<h3 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h3><p>本次3D-UI小动画主要用到的插件是：<strong>AE scripts Joystick‘n Sliders</strong>脚本：是一个二维动画绑定的插件，是通过创建控制杆或滑块来实现复杂的图形动画脚本。在图层上可以即时创建动画，只需在开始和结束位置设置关键帧，即可生成过渡动画，还可使用滑块来控制动画的任意位置，对于许多卡通角色制作，MG动画制作，等其他特殊动画制作，此脚本都可以提供高效的制作方案。</p>
<p><strong>Joysticks’n Sliders插件的安装：</strong></p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/164976/33/8158/71038/60619625E9dfdf55a/8f7fc83cd14cdfe7.png" alt="插件安装"></p>
<ol>
<li>复制Joysticks_n_Sliders.jsxbin文件到AE脚本目录：</li>
<li>Mac：应用程序\Adobe After Effects CC\Scripts\ScriptUI Panels\</li>
<li>打开AE软件设置，勾选上*允许脚本读写和访问网络</li>
</ol>
<p>附上 Joysticks’n Sliders的下载地址：<a href="https://www.lookae.com/joysticks-171/">https://www.lookae.com/joysticks-171/</a></p>
<h3 id="插件使用方法"><a href="#插件使用方法" class="headerlink" title="插件使用方法"></a>插件使用方法</h3><p>以下是插件中各个功能按钮的具体释义；</p>
<p>插件的Joysticks部分功能看似很多，但大部分情况只需要创建控制器按钮就足够了；</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/163017/16/15520/421132/60619626E60c41995/cd6d6f118dfbbd84.png" alt="插件翻译"></p>
<h3 id="3D-UI动画教程"><a href="#3D-UI动画教程" class="headerlink" title="3D-UI动画教程"></a>3D-UI动画教程</h3><h4 id="第一步：完成UI素材"><a href="#第一步：完成UI素材" class="headerlink" title="第一步：完成UI素材"></a>第一步：完成UI素材</h4><p>先在sketch里完成我们的UI设计稿；</p>
<p>新建一个800*600px的画布为背景层，然后设置大背景色值为：#EBF0F3；UI矩形大小为：374x450px，border-radius：50px；阴影参数分别如下：</p>
<p>阴影1：#D1D9E6    x and y：18px    模糊：30px    </p>
<p>阴影2：#FFFFFF    x and y：-18px    模糊：30px  </p>
<p>接下来就完成文字层、卡片层、按钮层的相关UI，最终效果如下；</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/164158/22/15319/311873/60619627Edac2a029/8090f8f3b7fbfdfc.png" alt="教程效果图-静态"></p>
<p>接下来做好命名和分组，分别导出背景层、文字层、卡片层、按钮层；或者我们直接将sketch文件通过插件导入到AE中；</p>
<p>再回忆一下将sketch文件导入到AE中的步骤：</p>
<ul>
<li>首先在Sketch中将所有需要运动的图层打组，然后在组命名前加上“#”，意味着该组属于一个图层不可编辑；</li>
<li>然后选中所有需要导出的组，在插件中找到“Sketch2AE”，然后执行生成导出切片命令，此时可以看到每个组下方都会出现一个名为“Slice To AE”的新图层；</li>
<li>然后再找到插件中的“Sketch2AE”，执行“导出画板命令”，然后在弹出的面板里设置合成时长和帧速率，并选择需要导出的画板，点击确定，同时给文件命名，然后选择导出的存放路径导出文件，此时在对应的路径下会自动生成一个.jsx的脚本文件和slice文件夹。</li>
<li>打开AE后，在菜单栏选择文件-脚本-运行脚本文件，选择刚才导出的.jsx文件，这就算导入成功了。</li>
</ul>
<h4 id="第二步：动效合成设置导入素材"><a href="#第二步：动效合成设置导入素材" class="headerlink" title="第二步：动效合成设置导入素材"></a>第二步：动效合成设置导入素材</h4><p>在AE中，我们需要新建合成，参数如下：</p>
<p>合成名称：3D-UI；宽高：800x600px；帧速率：30帧/秒；持续时间：3秒；</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/164735/1/15345/264393/60619627E159dd19b/017b51ee6d15db13.png" alt="新建合成"></p>
<p>接下来就是导入我们的设计素材，按照设计稿效果调整素材的位置；并新建一个纯色图层；</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/157049/36/16258/1251424/60619625Eac24044d/16a0c00f74b2730b.png" alt="步骤二：导入素材"></p>
<h4 id="第三步：调整属性，开启摄像机"><a href="#第三步：调整属性，开启摄像机" class="headerlink" title="第三步：调整属性，开启摄像机"></a>第三步：调整属性，开启摄像机</h4><p>选中四个图层，ctrl+D复制一层，此操作是需要副本，作为位置尺寸的参考；</p>
<p>选中复制出来的四个图层，并打开3D开关，按快捷键P，打开位置属性，分别对文字、卡片、按钮位置属性中的Z轴设置：-50、-30、-30的参数。因为近大远小的原因，元素的位置、缩放参数都会发生改变，这时候我们再选中之前复制出来的四个图层，按快捷键shift+S，调出素材的缩放属性，根据原有位置调整素材大小，然后删掉复制前的素材文件。</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/157122/24/16067/1356620/60619626E9ddf96f4/ae983892eaad9191.png" alt="第三步：调整属性"></p>
<h4 id="第四步：绑定插件"><a href="#第四步：绑定插件" class="headerlink" title="第四步：绑定插件"></a>第四步：绑定插件</h4><p>绑定插件之前，我们先需要新建一个摄像机图层，然后按快捷键：P，打开摄像机的位置属性，我们需要在第0帧打上关键帧参数不变；然后在第1帧打上关键帧：参数x=0，y=300；然后在第2帧打上关键帧：参数x=300，y=800；然后在第3帧打上关键帧：参数x=400，y=700；然后在第4帧打上关键帧：参数x=400，y=-100；</p>
<p><strong>需要注意的是：是第1帧（01f）、第2帧（02f）…而不是1s、2s</strong></p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/172884/3/989/1124777/60619627E4dc987bc/ae075132266387ce.png" alt="第四步-新建摄像机"></p>
<p>打好关键帧以后，我们选中摄像机图层，找到插件中的生成按钮，然后命名：3D-UI，点击按钮之后会自动生成一个控制器和控制区域，我们可以在效果控件中，将控制区域放大；然后拖动控制器，界面就产生了立体互动的效果；</p>
<p><img src= "/img/loading.gif" data-src="https://storage.360buyimg.com/imgtools/d53a57e753-c3265150-906f-11eb-9b88-f5ecb3f063c1.gif" alt="调整控制器"></p>
]]></content>
      <categories>
        <category>After Effects</category>
      </categories>
      <tags>
        <tag>After Effects</tag>
      </tags>
  </entry>
  <entry>
    <title>After Effects各功能基础认识</title>
    <url>/2021/03/22/After%20Effects%E5%90%84%E5%8A%9F%E8%83%BD%E5%9F%BA%E7%A1%80%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<h2 id="学习AE的必要性"><a href="#学习AE的必要性" class="headerlink" title="学习AE的必要性"></a>学习AE的必要性</h2><p>UI是基于静态页面来设计的，页面之间通过跳转切换。但是在设计过程中，设计师很重视单页的视觉效果，却经常忽略了对页面间跳转的处理。页面增加动效可以增强产品的趣味性和氛围。</p>
<p><strong>动效的重要性：</strong></p>
<p><strong>功能性：</strong>动效能够在一定层面上解决用户的需求，比如优化用户对界面的感知，引起用户注意，提供用户操作后的视觉反馈可以帮助用户为下一步操作做准备；</p>
<p><strong>物理性：</strong>让UI符合空间逻辑并根据物理定律制作动画，定义屏幕和UI设计元件之间的空间相对关系。当设计时考虑到重力、惯性、速度和刚性等因素，动效就会显得相对真实；</p>
<p><strong>趣味性：</strong>在页面中加入一些有趣的动画，能够让用户眼前一亮，印象深刻。</p>
<h2 id="认识After-Effects"><a href="#认识After-Effects" class="headerlink" title="认识After Effects"></a>认识After Effects</h2><p>大多数时候，当设计师在接触一款新的设计软件时，最重要的就是先了解软件的基础面板和常用的命令模块。AE面板界面主要包括菜单栏、顶部工具栏面板、项目面板、视图窗口区(动画展示区域)、图层编辑区、时间轴、视窗信息展示面板区、预览播放面板、效果面板。接下来我们就详细了解一下AE的各个面板。</p>
<p>熟悉各个面板和对应的命令模块，可以提高我们的操作效率，于此同时，大家可以根据自己的爱好和习惯自由安排面板布局，面板布局并没有具体限制和约束。</p>
<h2 id="AE基础面板介绍"><a href="#AE基础面板介绍" class="headerlink" title="AE基础面板介绍"></a>AE基础面板介绍</h2><h3 id="1-菜单栏"><a href="#1-菜单栏" class="headerlink" title="1.菜单栏"></a><strong>1.菜单栏</strong></h3><p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/157554/36/13735/57911/60571c8fE9b60f776/66a3d8461a00393a.png" alt="菜单栏"></p>
<p>菜单栏的功能命令贯通了整个AE动效的制作流程。从文件选项的新建项目、打开项目导入导出素材，然后再到编辑选项的粘贴、剪切、复制，再到合成选项的合成新建以及设置及预渲染的合成，到图层选项的图层新建设置以及蒙版和路径的一个绘制。再到效果选项的一个效果添加，再到动画选项的一个关键帧及曲线的一个调整都贯到整个AE的一个制作的流程。</p>
<p>窗口选项栏，它里面主要就是针对我们所能看到的这个AE界面的各个面板的调用，窗口选项栏打了勾的功能，就能在AE界面中显示该面板，而没有打勾的，是不存在的。如果我们要调用这些面板功能的话，就需要鼠标点击把它调出来，然后使用，如果把现存窗口选项栏里的勾点掉，那么相对的AE界面的面板也会去除。所勾选的窗口是可以浮动调整的，不需要浮动的话，我们也可以把窗口放回去。</p>
<h3 id="2-顶部工具栏面板"><a href="#2-顶部工具栏面板" class="headerlink" title="2.顶部工具栏面板"></a><strong>2.顶部工具栏面板</strong></h3><p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/139182/28/16735/141384/60571c90Eb776a59c/04b5a2a706c1d365.png" alt="顶部工具栏"></p>
<p>顶部工具栏面板具体功能如上图；做UI动效常用的工具有：选取工具、手型工具、缩放工具、旋转工具、锚点工具、矩形工具、钢笔工具、文本工具等；做MG动画会较多用到图钉工具；</p>
<h3 id="3-项目面板"><a href="#3-项目面板" class="headerlink" title="3.项目面板"></a><strong>3.项目面板</strong></h3><p>项目面板，主要是导入一些素材，以及合成的渲染输出，都是在这个项目面板里进行的。素材的格式包括：Mp3的音频、AI文件、psd文件、图片、Mp4、WMV等视频格式。导入素材可以在文件选项栏点击导入。也可以直接在项目面板双击来导入素材。</p>
<p><strong>PSD/AI文件导入到AE中的步骤：</strong></p>
<ul>
<li><p>双击项目面板或导入素材，选择想要导入的PSD源文件；</p>
</li>
<li><p>导入弹窗选择项：启用-选择所有可接受的文件或所有素材文件；导入为-选择合成保持图层大小；如下图：</p>
</li>
<li><p>点击打开，这样就完成了能显示图层的PSD源文件导入。步骤如下：</p>
<p>注：在PSD源文件中，一定要养成良好的命名习惯，尽可能把图层整理清晰后再保存，方便在AE中寻找图层；</p>
<p>​       在Illustrator中需要将设计中的<strong>每个元素放置到独立的图层中</strong>，然后保存文件；不然导入就是一个图层；   </p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/165822/15/15595/875816/60571c90Ef5308c60/68869ca868c87b94.png" alt="导入ps源文件"></p>
<p><strong>将Sketch文件导入到AE中的步骤：</strong></p>
<p>Sketch毫无疑问是如今UI设计行业使用频率最高的软件之一，其凭借轻量、高效的使用特点和拥有着专门的Toolbox插件体系的优势获得大家的认可。同时Sketch Toolbox中有不止百款插件供设计师们免费使用。不过Sketch并不是Adobe家族中的一员，所以从协同上来说，没有PS和AI便捷，但是借助一个插件“Sketch2AE”就可以促使Sketch导入到AE中。</p>
<ul>
<li>首先在Sketch中将所有需要运动的图层打组，然后在组命名前加上“#”，意味着该组属于一个图层不可编辑；</li>
<li>然后选中所有需要导出的组，在插件中找到“Sketch2AE”，然后执行生成导出切片命令，此时可以看到每个组下方都会出现一个名为“Slice To AE”的新图层；</li>
<li>然后再找到插件中的“Sketch2AE”，执行“导出画板命令”，然后在弹出的面板里设置合成时长和帧速率，并选择需要导出的画板，点击确定，同时给文件命名，然后选择导出的存放路径导出文件，此时在对应的路径下会自动生成一个.jsx的脚本文件和slice文件夹。</li>
<li>打开AE后，在菜单栏选择文件-脚本-运行脚本文件，选择刚才导出的.jsx文件，这就算导入成功了。</li>
</ul>
<h3 id="4-视图窗口"><a href="#4-视图窗口" class="headerlink" title="4.视图窗口"></a><strong>4.视图窗口</strong></h3><p>视图窗口（合成窗口）是视频的预览区域，能够直接的观察要处理的素材文件显示效果。该窗口不仅可以预览素材，在编辑素材的过程中也是不克或缺的。</p>
<p>下图是视图窗口各个功能点的解释：</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/168746/17/13953/316414/60571c90Eb37c8da5/6b4664de42b394dc.png" alt="视图窗口"></p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/167030/22/13944/28869/60571c90Ea36ad8da/ea1e9725804bb4c5.png" alt="红色提示条"></p>
<p>如果在动画设计中，视图窗口出现如上的红色提示条，不要惊慌～我们只需要按键盘上的“caps lock”就可以取消红色提示条了～</p>
<h3 id="5-素材图层编辑区"><a href="#5-素材图层编辑区" class="headerlink" title="5.素材图层编辑区"></a><strong>5.素材图层编辑区</strong></h3><p>图层编辑区域主要功能详细介绍如下：</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/169241/17/13935/164681/60571c90Ea9da764f/ab9c4ea82577a60e.png" alt="图层编辑区域"></p>
<h3 id="6-时间轴面板"><a href="#6-时间轴面板" class="headerlink" title="6.时间轴面板"></a>6.时间轴面板</h3><p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/165444/37/14120/228625/60571c90E48f350b0/4a28d656c2df364b.png" alt="时间轴区域"></p>
<p>时间轴窗口素材截取，全选全截，单选单截。调整左出点：alt+[   调整右出点：alt+]左右中括号是控制关键帧的出点和入点。</p>
<h3 id="7-预览面板和效果面板"><a href="#7-预览面板和效果面板" class="headerlink" title="7.预览面板和效果面板"></a>7.预览面板和效果面板</h3><p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/156178/40/17086/383546/60571c91E5e2f890d/7eff5ae439f40013.png" alt="预览面板和效果面板"></p>
<p>预览面板主要包括播放、逐帧播放、倒放、以及声音开关、调整帧速率等设置；</p>
<p>效果面板主要和一些“效果和预设”，所有的效果都收集在这里，我们可以选择或者搜索找到想要的效果并应用；</p>
<h2 id="After-Effects-CC工作流程"><a href="#After-Effects-CC工作流程" class="headerlink" title="After Effects CC工作流程"></a>After Effects CC工作流程</h2><p>启动一个项目包含两项任务：（1）基于最终输出格式设计项目（2）创建项目文件</p>
<h3 id="项目素材"><a href="#项目素材" class="headerlink" title="项目素材"></a>项目素材</h3><ul>
<li>文件路径：每次做项目之间，先建好文件夹，在文件夹内再建一个素材文件夹，用来存放图片、psd、ai或其他视频文件，避免再次打开源文件时，读取不到素材路径而画面缺失；</li>
<li>正确的命名习惯：尽可能用窗口兼容文件扩展名来命名素材和项目文件，例如，Quick Time电影的.mov和After Effects项目的.aep；</li>
<li>相同资源：确保所有资源在两个体系均可用，比如相同的字体、效果、编码器等；如果将一个项目渲染成一个或多个媒体格式，通常将合成的解析度设置和在输出中使用的最高解析度设置进行匹配，然后设置渲染队列窗口，来为项目的每一种格式渲染一个单独的版本。渲染输出时，经常输出的格式有：Quick Time、Microsoft Video For Windows、GIF、.swf格式等；</li>
</ul>
<h3 id="偏好设置"><a href="#偏好设置" class="headerlink" title="偏好设置"></a>偏好设置</h3><p>在开始一个合成之前，需要根据具体工作情况进行项目设置、渲染设置、输出模块设置以及偏好参数设置。</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/158607/40/14658/212375/60571c91E6f987982/db8073fb75ef8be0.png" alt="项目设置"></p>
<ul>
<li>视频渲染和效果：可设置使用范围；</li>
<li>时间显示样式：包括时基、帧数和胶片长度3种方式；</li>
<li>颜色设置：包括颜色深度和工作区颜色；</li>
<li>音频设置：为统一输出模式，同时节省时间，不必每一次渲染输出时都进行设置，可以根据成品需要设置渲染和输出的参数；</li>
</ul>
<h3 id="组织和管理素材"><a href="#组织和管理素材" class="headerlink" title="组织和管理素材"></a>组织和管理素材</h3><p>在我们导入素材时，AE不是将素材复制到项目中，而是在项目控制板中创建一个对应素材项目的路径链接，这就是为什么刚开始我们需要在项目文件中创建好素材文件的原因。如果中途文件丢失，就会用彩色占位符展示，此时我们可以双击彩色占位符，重新载入项目项目素材即可。</p>
<p>如果我们使用其他程序修改项目素材时，比如用AI或者PS修改文件样式保存后，再次打开项目时，AE中的素材样式也随之改动。</p>
<h3 id="输出设置"><a href="#输出设置" class="headerlink" title="输出设置"></a>输出设置</h3><p>当项目各种动效技巧完成时，接下来就是输出成品，为了加速渲染速度，可以先清理内存，执行 主菜单-编辑-清理-清理所有内存的命令；</p>
<ol>
<li>首先要激活输出的时间线窗口，选择 主菜单-合成-添加到渲染队列的命令，自动添加至渲染队列；</li>
<li>在渲染队列面板中单击渲染设置对应的选项，在弹出的渲染设置对话框中设置渲染文件的品质、分辨率、以及时间采样等选项，然后单击确定按钮关闭对话框；</li>
<li>在渲染队列面板中输出模式对应的选项，在弹出“输出模块设置”对话框中设置渲染文件的格式、视频输出、尺寸等选项，然后单击确定按钮关闭对话框；</li>
<li>在渲染队列面板中，单击“输出到”对应的选项，在弹出“将影片输出到”对话框中设置渲染文件的名称和路径，单击确定按钮关闭弹窗；</li>
<li>当设置完成后，就可以单击渲染按钮开始渲染，直至完成</li>
<li>高版本的AE CC 目前已经无法直接输出动态GIF文件了，我们需要借助Adobe Media Encoder ，在合成窗口中选择添加到Adobe Media Encoder 队列输出GIF；</li>
</ol>
]]></content>
      <categories>
        <category>After Effects</category>
      </categories>
      <tags>
        <tag>After Effects</tag>
      </tags>
  </entry>
  <entry>
    <title>After Effects表达式</title>
    <url>/2021/03/22/After-Effects%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="什么是表达式？"><a href="#什么是表达式？" class="headerlink" title="什么是表达式？"></a>什么是表达式？</h2><p>表达式是AE内部基于Javascript编程语言开发的编辑工具。使用表达式的最主要好处是自动化，简化和增强复杂性。<strong>交换表达式的关键帧会生成具有干净和准确结果的数据。</strong></p>
<h3 id="学习表达式之前需要了解这两点："><a href="#学习表达式之前需要了解这两点：" class="headerlink" title="学习表达式之前需要了解这两点："></a>学习表达式之前需要了解这两点：</h3><p><strong>1.所有的表达式只可以添加在AE里面的可编辑动画关建帧的属性上</strong>；</p>
<p>在AE里面表达式只可以输入在可编辑关键帧的属性上，比如位置，旋转，缩放等，所以我们使用表达式的目的是对一些动画属性进行控制，从而提高我们的工作效率或者制作出更棒的动画效果！</p>
<p><strong>2.并不是所有地方都需要表达式，我们要根据需求选择使用关键帧或者表达式；</strong></p>
<p>在AE里面并不是任何时候使用表达式都比关键帧要方便，有的时候关键帧的效果或者效率反而比表达式更好更快。所以要根据不同的效果选择打关键帧或者表达式，或者两者的结合。我们最终的目的还是完美的呈现动效效果。</p>
<h2 id="如何添加表达式？"><a href="#如何添加表达式？" class="headerlink" title="如何添加表达式？"></a>如何添加表达式？</h2><p>我们只需要按住键盘上的ALT键+鼠标左键点击关键帧前的小码表，就可以调出对应属性的表达式输入框。我们需要做的就是在输入框内输入表达式即可。</p>
<p><strong>表达式工具：</strong></p>
<p>1.表达式关闭开启工具  2.表达式图表工具   3.表达式关联器   4.表达式语言菜单</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/170573/2/14061/117135/60571ef3E85ea6d09/7a1b5283d880ae5f.png" alt="表达式开启"></p>
<p><strong>语言菜单：</strong>调用AE内置表达式函数命令</p>
<h2 id="表达式书写的一些规则："><a href="#表达式书写的一些规则：" class="headerlink" title="表达式书写的一些规则："></a>表达式书写的一些规则：</h2><p><strong>1.针对不同属性，表达式最终输出的是不同的数据类型</strong></p>
<p>在AE里面不同的属性的参数是不一样的,大致可以分为4种：<strong>单个数值</strong>、<strong>数组</strong>、<strong>布尔值</strong>、<strong>字符串；</strong></p>
<p><strong>数值和数组</strong></p>
<p>最常使用的就是单个数值和数组，那单个数值和数组有什么区别呢？锚点、位置、缩放这三个属性都是由两个数值组成的，所以这种类型叫数组；旋转和不透明这两个属性是由一个数值来调节的，所以这种数据叫单个数值；</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/171184/35/14021/366579/60571ef3E92ff38f8/841ee4498f13730b.png" alt="表达式数组和数值.png"></p>
<p><strong>布尔值和字符串</strong></p>
<p>布尔值主要是起开关作用的，<strong>它主要就是两个值：true和false，</strong>true代表“真”、false代表“假”。可以用数值0和1代表：<strong>0</strong>代表<strong>假、1</strong>代表<strong>真</strong>;</p>
<p>字符串不太常用，它主要是针对文本工具的：如“你好”（字符串需要用双引号“”括起来，双引号里面你可以填任何信息，中文、英文或者数字都可以，但它只是字符的意义）</p>
<p><strong>2.数组的书写格式</strong></p>
<p>数组是由多个数值组成的，所以数组的书写格式如：[10,10]，一维属性展示方式；</p>
<p>数组需要使用中括号[]括起来，中括号里面你可以填多个数值（要填几个数值取决于对应的属性），每一个数值之间用逗号隔开；二维属性展示方式；</p>
<p><strong>变量的使用：</strong></p>
<p>在AE表达式书写的时候，并不是我们书写的所有内容表达式都能识别。表达式一般能识别的就是表达式内部的一些函数命令，我们可以直接在“表达式语言菜单”中调用。除了内部的一些函数命令外，表达式还可以识别我们外部自定义的变量</p>
<p>什么是变量？</p>
<p>变量是我们用来存储数值用的，你可以把它当做一个容器；比如：a=100，我们就把100这个数值存储在a里面，则a这个时候就是一个变量，变量需要使用等于号“=”来进行赋值，你可以使用任何单词作为变量，字母a也好、字母b也好、单词也好、或者汉语拼音都可以，但是不能使用中文；</p>
<p><strong>表达式内置的函数命令：</strong></p>
<p>上面说道AE表达式只能够识别<strong>内置的函数命令</strong>和<strong>自定义的变量</strong>。</p>
<p>内置的函数命令就是我们最常使用的一些代码了，我们直接可以在AE表达式工具里面的“表达式语言菜单”里面进行调用。</p>
<h2 id="常用的表达式："><a href="#常用的表达式：" class="headerlink" title="常用的表达式："></a>常用的表达式：</h2><h4 id="1-时间time表达式"><a href="#1-时间time表达式" class="headerlink" title="1.时间time表达式"></a><strong>1.时间time表达式</strong></h4><p><strong>原理：</strong>time表示时间，以秒为单位，time<em>n =时间（秒数）</em>n （若应用于旋转属性，则n表示角度）</p>
<p><strong>举例：</strong>若在旋转属性上设置time表达式为time*60，则图层将通过1秒的时间旋转60度，2秒时旋转到120度以此类推（数值为正数时顺时针旋转，为负数时逆时针旋转）</p>
<p><strong>注意事项：</strong>time赋予旋转、不透明度属性时，表达式结果是一维展示，time<em>n。time赋予位置、缩放、锚点属性时：表达式结果必须是二维，[time</em>n,time*n]</p>
<p>以下是一维、二维属性添加time表达式的动画效果；</p>
<p><img src= "/img/loading.gif" data-src="https://storage.360buyimg.com/imgtools/f164c850b0-e9494d00-8a3f-11eb-a368-6d3780c2f1df.gif" alt="时间time表达式"></p>
<h4 id="2-抖动-摆动表达式："><a href="#2-抖动-摆动表达式：" class="headerlink" title="2.抖动/摆动表达式："></a>2.抖动/摆动表达式：</h4><p>wiggle(freq, amp, octaves = 1, amp_mult = 0.5, t = time)</p>
<p><strong>原理：</strong>freq=频率（设置每秒抖动的频率）；amp=振幅（每次抖动的幅度）；octaves=振幅幅度（在每次振幅的基础上还会进行一定的震幅幅度，很少用）；amp_mult=频率倍频（默认数值即可，数值越接近0，细节越少；越接近1，细节越多）；t=持续时间（抖动时间为合成时间，一般无需修改）；一般只写前两个数值即可</p>
<p><strong>举例：</strong>若在一维属性中，为位置属性添加wiggle(10,20)，则表示图层每秒抖动10次，每次随机波动的幅度为20；</p>
<p>若在二维属性中，为缩放添加n=wiggle(1,10);[n[0],n[0]]，则表示图层的缩放XY在每秒抖动10次，每次随机波动的幅度为20；若在二维属性中，想单独在单维度进行抖动，需要将属性设置为单独尺寸后添加wiggle(10,20)，表示图层的缩放X轴在每秒抖动10次，每次随机波动的幅度为20。</p>
<p><strong>注意事项：</strong>可直接在现有属性上运行，包括任何关键帧；<strong>单独尺寸的设置方式：选中属性-鼠标右击-选择单独尺寸</strong></p>
<p>以下左图是一维、二维属性添加wiggle表达式的动画效果；</p>
<p>跟抖动表达式相近效果的还有随机表达式：random(频率,振幅)，以下右图左边三个小飞机是wiggle表达式效果，右边是random表达式的展示效果；</p>
<p><strong>相比random函数，会发现，wiggle有两个明显的特点：</strong></p>
<p>1.有自适应性，同样是缩放，random需要填写两个参数，wiggle只需要一个，同时在旋转上表现了双倍的范围</p>
<p>2.wiggle的变化相比random产生的效果要平滑很多，你看看random，能看吗？能看吗？！</p>
<p><strong>需要再补充一点：wiggle的频率并非每秒钟变化的次数，当第一个参数的值是1时，一秒内仍然会产生多个数值。所以要想有好的结果，需要反复调试，就像开车打方向盘一样，找感觉吧～</strong></p>
<p><img src= "/img/loading.gif" data-src="https://storage.360buyimg.com/imgtools/bb22527414-5b6640a0-8a40-11eb-853a-6fded8704e77.gif" alt="wiggle表达式"></p>
<p><img src= "/img/loading.gif" data-src="https://storage.360buyimg.com/imgtools/4432fa7c42-2c403ec0-8a40-11eb-a368-6d3780c2f1df.gif" alt="random表达式"></p>
<h4 id="3-index表达式（索引表达式）："><a href="#3-index表达式（索引表达式）：" class="headerlink" title="3.index表达式（索引表达式）："></a>3.index表达式（索引表达式）：</h4><p><strong>原理：</strong>为每间隔多少数值来产生多少变化</p>
<p><strong>举例：</strong>若为图层1的旋转属性添加表达式index*5 ，则第一个图层会旋转5度，之后按Ctrl+D去复制多个图层时，第2个图层将旋转10度，以此类推；若想第一层图形不产生旋转保持正常形态，复制后的图形以5度递增，表达式可写为(index-1)*5</p>
<p><img src= "/img/loading.gif" data-src="/Users/lili896/Desktop/20210223AE%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%85%8D%E5%9B%BE/index%E7%B4%A2%E5%BC%95%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt="index索引表达式"></p>
<h4 id="4-value表达式"><a href="#4-value表达式" class="headerlink" title="4.value表达式"></a>4.value表达式</h4><p><strong>原理：</strong>在当前时间输出当前属性值</p>
<p><strong>举例：</strong>若对位置属性添加表达式为value+100，则位置会在关键帧数值的基础上对X轴向右偏移100（正数向右侧，负数像左侧）；若想控制Y轴的位置属性，则可对位置属性进行单独尺寸的分割，从而可单独控制Y轴（正数向下，负数向上）</p>
<p><strong>注意事项：</strong>更多的使用场景是结合其他表达式一起应用</p>
<h4 id="5-random表达式（随机表达式）"><a href="#5-random表达式（随机表达式）" class="headerlink" title="5.random表达式（随机表达式）"></a>5.random表达式（随机表达式）</h4><p><strong>原理：</strong>random(x,y)在数值x到y之间随机进行抽取，最小值为x，最大值为y</p>
<p><strong>举例：</strong>若为数字源文本添加表达式random(20)，则数据会随机改变，最大值不会超过20；</p>
<p>若为数字源文本添加表达式random(10,100)，则数据会在10&lt;数值&lt;100之间随机改变；</p>
<p>若为数字源文本添加表达式seedRandom(5, timeless = false)，random(50)，则数据会在50以内随机改变（前面的5是种子数，如一张画面中需要多个相同区间的数值做随机变化，就要为他们添加不同的种子数，防止两者随机变化雷同）；</p>
<p>若希望数字随机变化为整数则应添加表达式为Math.round(random(2,50))，表示在2和50之间随机改变无小数</p>
<p><strong>注意事项：</strong>随机表达式不仅局限于数据上的使用，其他属性也可以应用，若数值为整数Math的M要大写</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/158584/40/14488/2860938/605738aeEcb0c1c75/77920430d230ea39.gif" alt="数字随机表达式"></p>
<h4 id="6-循环表达式"><a href="#6-循环表达式" class="headerlink" title="6.循环表达式"></a>6.循环表达式</h4><p>AE中循环表达式主要有4中，分别是：loopOut loopIn loop</p>
<p>LoopOut（type=“循环方式”，numkeyframes=0）</p>
<p>LoopIn（type=“循环方式”，numkeyframes=0）</p>
<p><strong>原理：</strong>loopOut(type=”类型”,numkeyframes=0)对一组动作进行循环loopOut(type=”pingpong”,numkeyframes=0)是类似像乒乓球一样的来回循环；loopOut(type=”cycle”,numkeyframes=0)是周而复始的循环；</p>
<p>loopOut(type=”continue”)延续属性变化的最后速度，</p>
<p>loopOut(type=”offset”,numkeyframes=0)是重复指定的时间段进行循环；</p>
<p>numkeyframes=0是循环的次数，0为无限循环，1是最后两个关键帧无限循环，2是最后三个关键帧无限循环，以此类推</p>
<p>loopOut 和loopIn 这两个表达式都是表达循环类型的表达式；</p>
]]></content>
      <categories>
        <category>After Effects</category>
      </categories>
      <tags>
        <tag>After Effects</tag>
      </tags>
  </entry>
  <entry>
    <title>C4D基础知识点</title>
    <url>/2021/06/29/C4D%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="基础功能点"><a href="#基础功能点" class="headerlink" title="基础功能点"></a>基础功能点</h3><ol>
<li><strong>视图窗口中物体</strong>的旋转、缩放和位移</li>
</ol>
<p>物体旋转：Alt+鼠标左键</p>
<p>物体缩放：Alt+鼠标右键</p>
<p>物体推拉：Alt+鼠标滚轮（中键）</p>
<p>三维空间中的坐标系称为笛卡尔坐标系；</p>
<ol start="2">
<li>基础快捷键</li>
</ol>
<p>旋转：快捷键R、缩放：快捷键T、位移：快捷键E、快速找到当前物体：快捷键H&amp;S、物体复制：command+鼠标左键往下拖动、物体和世界切换：快捷键W、场景的四视图：鼠标中键、图层群组：alt+g（或者全选右击-群租对象）关闭当前预置：ctrl+F4</p>
<ol start="3">
<li>找到当前C4D文件：窗口右下角（可直接切换多个文件）</li>
</ol>
<p>关闭当前文件：窗口左上角文件–关闭（全部关闭）</p>
<p>合并两个文件：在其中一个文件下，点击左上角文件–合并–选择你想要合并的文件</p>
<ol start="4">
<li><p>等比旋转：先点击R调出旋转命令，把鼠标放在你想要旋转的轴上（此时你想旋转的轴将会点亮），右手按住鼠标左键不放，左手按住shift旋转。</p>
</li>
<li><p>物体的可编辑：快捷键C(物体转换为可编辑对象是不可逆的，物体转换为可编辑对象以后可以激活右键中的属性）</p>
</li>
<li><p>循环选择线：上方菜单栏–循环选择或用移动工具在循环线上双击</p>
</li>
<li><p>所有C4D中绿色的图标都是包含级关系（即需要把你所想要做效果的物体放在效果下边）</p>
</li>
<li><p>地面与平面的区别：地面不具备编辑属性，平面有限，地面无限</p>
</li>
<li><p>世界边缘的透明度调整：shift+V，视图窗口的调整</p>
</li>
<li><p>简单的一套渲染流程：给物体上材质–加上       天空（光照）–渲染效果设置–保存</p>
</li>
<li><p>在选择挤压命令时要记得勾选层级</p>
</li>
<li><p>在二维世界编辑点的时候，勾掉”仅选择可见元素”，编辑完点记得要勾上”仅选择可见元素</p>
</li>
<li><p>倒角的四种方法：C掉之前直接倒角，C掉以后右击倒角线，将物体细分曲面，将上方紫色的倒角放在需要倒角的物体下面（上下级关系，此处可以与绿色对比理解）</p>
</li>
<li><p>摄像机：默认摄像机默认打开，当你调整好角度后可以点击摄像机新建一个摄像机，这样当你移动后还可以点击创建的摄像机后面的十字准星回到原本设置好的角度</p>
</li>
<li><p>在正视图的情况下，选择模式-视图设置就能调整背景素材的透明度。</p>
</li>
<li><p>图形对称，需要先建立空白坐标系，然后将物体作为空白坐标系的子级，按住alt键，选择对称</p>
</li>
<li><p>建模方式：</p>
</li>
</ol>
<p>①Nurbs:曲面建模(Non-uniform Rational B Splines)</p>
<p>应用领域：工业产品表现(生活家电、汽车等) 、辅助视觉设计(抽象化曲线设计)、</p>
<p>电影特效(玻璃破碎等)</p>
<p>②多边形建模poly：应用领域：</p>
<p>特点：由点线面构成，操作简便，可控性高，自由度高，要求布线，对造型能力要求高；</p>
<ol start="18">
<li>C4Dnurbs主要特点：无点线面、主要依靠样条、操作简便</li>
</ol>
<p>​      其他软件nurbs的主要特点：少数点控制多数点、命令复杂</p>
<ol start="19">
<li>挤压模式下：可以勾选层级，挤压就对子级的所有层级起作用<strong>。</strong></li>
</ol>
<h3 id="操作栏知识点"><a href="#操作栏知识点" class="headerlink" title="操作栏知识点"></a>操作栏知识点</h3><p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/181588/20/11690/1223977/60dae859Ed698a00c/7c990f8fa2b1378f.jpg" alt="工具栏功能"></p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/193551/9/9943/1223977/60dae859Eb7ef2b6c/acd60ff7c879338f.jpg" alt="工具栏功能3"></p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/174501/33/17242/56259/60dae85aE554639f8/f47fbee325ba7044.jpg" alt="绿色功能"></p>
<p>绿色功能通常作为父级使用，物体为子级产生作用。</p>
<p>放样：两个样条点和线必须相同才能用放样，两条同样的竖线放样后形成矩形面</p>
<p>扫描：适合做管状的物体，线画一个曲线的线条，然后再画圆环，再将两个层作为扫描的子级，就形成管状。</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/178074/32/11820/159468/60dae85bEb713e879/3351f5ab6b7375da.jpg" alt="紫色功能"></p>
<p>紫色功能通常作为子级使用，物体为父级产生作用。</p>
<h3 id="关于材质"><a href="#关于材质" class="headerlink" title="关于材质"></a>关于材质</h3><ol>
<li>漫射通道：物体本身的颜色。</li>
<li>发光通道：萤火虫的尾巴，自发光模式；</li>
<li>透明通道：透明亮度：数值越大，物体越透明；</li>
</ol>
<p>各种物体的折射率：真空:1.0、空气:1.0003、冰:1.309、水:1.3333、酒精:1.3600、玻璃:1.5000</p>
<p>菲涅尔反射：菲涅尔反射率数值越大，中心反射越小，外部反射越大；</p>
<p>吸收颜色：物体暗部反射环境的颜色；</p>
<p>模糊：制作毛玻璃的时候会使用模糊；</p>
<ol start="4">
<li><p>反射通道：物体对周围环境的反射；</p>
</li>
<li><p>环境通道：假反射；</p>
</li>
<li><p>烟雾通道：物体表面雾蒙蒙；</p>
</li>
<li><p>凹凸通道：噪波，物体表面假凹凸不平；</p>
</li>
<li><p>Alpha：理解为镂空，直接透明的算法，不会在中间计算折射，某些地方显示，某些地方不显示；</p>
</li>
<li><p>高光：对光源点的反射；</p>
<p>参数：宽度-高光范围的大小，范围越大表面越粗糙，参数越小表面越平滑；</p>
<p>高度：可以理解为高光的强度；</p>
<p>衰减：指的是中心到四周的衰减大小；</p>
<p>模式：塑料、金属、固有色；</p>
</li>
<li><p>辉光：理解为外发光；</p>
</li>
<li><p>置换通道：把模型表面发生真变化；</p>
</li>
<li><p>建筑材质球和默认材质球的区别：没有贴图功能；</p>
</li>
</ol>
<h3 id="关于输出"><a href="#关于输出" class="headerlink" title="关于输出"></a>关于输出</h3><p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/191530/37/10855/173922/60dae85aE592817ed/01e684cf67b7a1c9.jpg" alt="渲染设置"></p>
<ol>
<li>物体的渲染和输出</li>
</ol>
<p>Ctrl+R:在做好之前预览窗口渲染，即可以快速查看当前窗口渲染效果；Shift+R：输出渲染；Alt+R：预览跟窗口预览相似，但是它能一直停留；</p>
<ol start="2">
<li><p>渲染设置中提高精度值：抗锯齿选项开到最优；环境吸收选项取样值拉大；</p>
</li>
<li><p>灯光和阴影：灯光具有叠加属性，无上限，有下限；软阴影：计算机模拟贴图制作的假阴影（渲染速度块）；硬阴影：模拟边缘锐利的阴影；区域：通过给的灯光大小来模拟真实阴影；</p>
</li>
<li><p>如何判断灯光的好坏:有高光，有阴影，有过度；</p>
</li>
<li><p>摄像机的固定：摄像机右击第一个选项里面的保护；</p>
</li>
<li><p>保存带有通道：在渲染设置里面勾选Alpha通道、保存png图片；</p>
</li>
<li><p>渲染输出一般尺寸选择：1280*720，预置：HDV高清；</p>
</li>
<li><p>渲染输出的帧频一定要和工程里边的帧频数保持一致；</p>
</li>
<li><p>输出为视频格式：quitetime影片；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>色彩</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS文本溢出解决方案</title>
    <url>/2021/09/14/CSS%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>CSS的学习，就我个人看来，是有别于JavaScript这张传统程序语言的学习的。本身属性就多，值也多，不同属性在一起表现也不一样，不同属性和不同类型的HTML标签在一起又不一样，再加上兼容性差异和未定义行为。就像是很多个不确定因素，有着无穷多的组合和可能性。掌握这些不确定性，看书是绝对不够的，一定是要多多实践，多多思考，多多积累。对于底层机理的理解，也是需要一定的天赋的。</p>
<p>因此，就是自己很多年一直与CSS密切打交道，学习它，也有很多不知道的，理解不透彻，或者说因为要学习和思考的东西太多，还来不及估计到一些属性或者声明。</p>
<p>比方说本文要介绍的word-break:break-all和word-wrap:break-word, 虽然都有使用，都照过面，实际上，却一直没有机会能够好好看看这两个到底有什么区别，各个浏览器的兼容性如何，等等。换句话说，就是深入理解。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>做移动端项目时，在详情页富文本传过来一段很长的空格；页面展示的时候由于空格没有及时换行；导致空格后文字超出屏幕；页面展示缺少文字。当然，这个情况有兼容性，就是大部分的安卓手机；同样的在PC端（小屏幕）展示同样有问题；我的14.7寸的展示就有问题；</p>
<h3 id="word-break属性"><a href="#word-break属性" class="headerlink" title="word-break属性"></a>word-break属性</h3><ul>
<li>属性值：</li>
</ul>
<p>normal;<br>使用默认的换行规则。(即单词中间不换行，会提前折行)；（会溢出）<br><img src= "/img/loading.gif" data-src="1-nor.jpg" alt="示例"></p>
<p>break-all;<br>允许任意非CJK(Chinese/Japanese/Korean)文本间的单词断行。<br>一个长长的单词不会新起一行展示，而是直接在本行剩余空间展示，展示不全时折断展示；（万恶原则）<br>兼容性：所有浏览器都支持；<br><img src= "/img/loading.gif" data-src="1-all.jpg" alt="示例"></p>
<p>keep-all;<br>不允许CJK(Chinese/Japanese/Korean)文本中的单词换行，只能在半角空格或连字符处换行。非CJK文本的行为实际上和normal一致。（会溢出）<br><img src= "/img/loading.gif" data-src="3-keep.jpg" alt="示例"></p>
<p>break-word;<br>一个长长的单词会新起一行展示，新的一行展示不全时折断展示；（新人榨干原则）<br><img src= "/img/loading.gif" data-src="4-word.jpg" alt="示例"></p>
<ul>
<li><p>万恶原则：不会新起一行，而是在本行剩余空间继续展示，不够则打断折行。能利用每一行的剩余空间，不浪费一点点空间；我这里将这样的‘不留余地’称作万恶的压榨原则；</p>
</li>
<li><p>新人榨干原则：本行不够展示的时候，会另起新的一行展示，如果在新的一行上仍然不够的话，会打断折行展示；这种新起一行，不利用上一行的剩余空间原则；我称之为新人榨干原则；</p>
</li>
<li><p>兼容性：<br><img src= "/img/loading.gif" data-src="1-jian.jpg" alt="示例"></p>
</li>
</ul>
<h3 id="word-wrap-属性"><a href="#word-wrap-属性" class="headerlink" title="word-wrap 属性"></a>word-wrap 属性</h3><p>normal;<br>正常的换行规则（长单词新起一行且不折断）（会溢出）</p>
<p>bredak-word;<br>一个长长的单词会新起一行展示，且在新的一行展示不全时折断展示；（新人榨干原则）</p>
<p><strong>word-wrap</strong>属性其实也是很有故事的，之前由于和word-break长得太像，难免会让人记不住搞混淆，晕头转向，于是在CSS3规范里，把这个属性的名称给改了，叫做：<strong>overflow-wrap</strong> 这个新属性名称显然语义更准确，也更容易区别和记忆。<br>但是呢，也就Chrome/Safari等WebKit/Blink浏览器支持。<br>所以，虽然换了个好看好用的新名字，为了兼容使用，目前，还是乖乖使用word-wrap吧。兼容性见下表（黄绿色的表示不支持overflow-wrap新的标准属性的）：</p>
<h3 id="overflow-wrap属性-word-wrap的别名"><a href="#overflow-wrap属性-word-wrap的别名" class="headerlink" title="overflow-wrap属性 (word-wrap的别名)"></a>overflow-wrap属性 (word-wrap的别名)</h3><ol>
<li>是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。</li>
<li>与word-break相比，overflow-wrap仅在无法实现-将整个单词放在自己的行而不溢出的情况下，才会产生中断。</li>
</ol>
<ul>
<li>属性值：<br>normal;<br>行只能在正常的单词断点处中断。（会溢出）。<br><img src= "/img/loading.gif" data-src="f-nor.jpg" alt="示例"></li>
</ul>
<p>anywhere;<br>允许任意非CJK(Chinese/Japanese/Korean)文本间的单词断行。（一个单词一行；长单词截断）<br>兼容性：所有浏览器都支持<br><img src= "/img/loading.gif" data-src="f-any.jpg" alt="示例"></p>
<p>break-word;<br>表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行（新人榨干原则）。<br><img src= "/img/loading.gif" data-src="f-break.jpg" alt="示例"></p>
<ul>
<li>兼容性：<br><img src= "/img/loading.gif" data-src="space-jian.jpg" alt="示例"></li>
</ul>
<h3 id="white-space属性"><a href="#white-space属性" class="headerlink" title="white-space属性"></a>white-space属性</h3><ul>
<li>属性值：<br>white-space CSS 属性是用来设置如何处理元素中的空白；</li>
</ul>
<p>normal<br>连续的空白符会被合并，换行符会被当作空白符来处理。换行在填充「行框盒子(line boxes)」时是必要。</p>
<p>nowrap<br>和 normal 一样，连续的空白符会被合并。但文本内的换行无效</p>
<p>pre<br>连续的空白符会被保留。在遇到换行符或者<br>元素时才会换行。</p>
<p>pre-wrap<br>连续的空白符会被保留。在遇到换行符或者<br>元素，或者需要为了填充「行框盒子(line boxes)」时才会换行。</p>
<p>pre-line<br>连续的空白符会被合并。在遇到换行符或者<br>元素，或者需要为了填充「行框盒子(line boxes)」时会换行。</p>
<p><strong>break-spaces</strong><br>与 pre-wrap的行为相同，除了：</p>
<ul>
<li><p>任何保留的空白序列总是占用空间，包括在行尾。</p>
</li>
<li><p>每个保留的空格字符后都存在换行机会，包括空格字符之间。</p>
</li>
<li><p>这样保留的空间占用空间而不会挂起，从而影响盒子的固有尺寸（最小内容大小和最大内容大小）。</p>
</li>
<li><p>兼容性：<br><img src= "/img/loading.gif" data-src="space-jian.jpg" alt="示例"></p>
</li>
</ul>
<h3 id="line-break属性"><a href="#line-break属性" class="headerlink" title="line-break属性"></a>line-break属性</h3><ul>
<li>属性值：<br>用来处理如何断开（break lines）带有标点符号的中文、日文或韩文（CJK）文本的行。</li>
</ul>
<p>auto<br>使用默认的断行规则分解文本。</p>
<p>loose<br>使用尽可能松散（least restrictive）的断行规则分解文本。一般用于短行的情况，如报纸。</p>
<p>normal<br>使用最一般（common）的断行规则分解文本。</p>
<p>strict<br>使用最严格（stringent）的断行原则分解文本。</p>
<p>anywhere<br>在每个印刷字符单元（typographic character unit）的周围，都有一个自动换行（soft wrap）的机会，包括任何标点符号（punctuation character）或是保留的空白字符（preserved white spaces），或是单词之间。但忽略任何用于阻止换行的字符，即使是来自 GL、WJ 或 ZWJ 字符集的字符，或是由 word-break 属性强制的字符。不同的换行机会拥有相同的优先级。也不应用断字符（hyphenation，可能是 “-“）。</p>
<ul>
<li>兼容性：<br>火狐浏览器不支持此属性；其余浏览器均支持</li>
</ul>
<h3 id="我遇到的棘手问题"><a href="#我遇到的棘手问题" class="headerlink" title="我遇到的棘手问题"></a>我遇到的棘手问题</h3><p> 问题描述：<br> 在一段富文本中；有很多空格，导致这些空格联为一体，不能折行，直到遇见第一个字符才折行；导致文本溢出；<br> 复现条件：</p>
<ol>
<li><p>部分安卓手机（oppo）</p>
</li>
<li><p>京东app（非极速版）<br>两个条件缺一不可，因为尝试了在有问题的手机，自带和qq浏览器时，是没有问题的；同时极速版的京东app也是没有问题的；</p>
<p>富文本结构如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>...很多个空白span标签</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是要展示的文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>尝试属性：<strong>white-space</strong>；这个属性的合并空格在此处是不生效的；因为文本的空格是由多个span标签分割的；本身就不属于连续空格；所以合并空格不起作用；<br>尝试属性：<strong>line-break</strong>;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;&lt;p style=&#x27;text-align: right; line-height: 22px; text-indent: 24px; margin-top: 0px; margin-right: 21px; margin-bottom: 0px;&#x27;&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;font-family:宋体&#x27;&gt;&lt;span style=&#x27;font-family:;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#x27;color: rgb(0, 0, 0); font-size: 21px;&#x27;&gt;邵武市人民法院&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="可能的解决方案"><a href="#可能的解决方案" class="headerlink" title="可能的解决方案"></a>可能的解决方案</h3><p>解决方案一：</p>
</li>
</ol>
<ul>
<li><p>将富文本的父盒子元素设置为font-size：0；可以解决这个问题；但是存在风险，一旦文字未设置字体，则继承字体为0；文字就会不展示；所以弃用该方案；</p>
<p>解决方案二：</p>
</li>
<li><p>使用正则将空格的span标签去掉；<br>尝试方案：<br>word-break: break-all;<br>white-space: pre-line;<br>line-break: anywhere;</p>
</li>
<li><p>–不管用；</p>
</li>
</ul>
<p>   最后：<br>   如果谁能帮忙解决此问题，欢迎留言；</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>深色模式的应用</title>
    <url>/2021/06/28/Dark%20Mode%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是深色模式"><a href="#什么是深色模式" class="headerlink" title="什么是深色模式"></a>什么是深色模式</h2><p>深色模式（也有人叫暗黑模式）确实不是人机界面领域的新概念了。曾几何时，绿色字符呈现在漆黑屏幕上的模式就是我们所拥有的全部。如今的屏幕色彩越来越丰富，但深色模式依然存在，到底为什么呢？</p>
<p>从使用场景上来说，深色模式是区别于夜间模式的；</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/182489/30/9416/274406/60c9ba13Efd22ff87/6597418d9c70ebaa.png" alt="夜间模式和暗黑模式"></p>
<p>深色模式对浅色主题的一种场景化补充，是满足用户日间的使用需求，让使用者更加专注自己的操作任务，带来视觉沉浸感；所以深色模式在信息内容的表达上会更注重视觉性；</p>
<p>同时，设置深色模式，会降低设备屏幕发出的亮度，目前的中高端手机大多采用OLED屏幕，这一材质自发光的特性使得屏幕能够独立控制单个像素是否发光，深色主题会降低设备屏幕发出的亮度，同时仍能满足最低色彩对比度。</p>
<p>而传统的夜间模式更注重于弱光场景下的体验。是从用户的健康角度出发考虑的，当用户舒服的躺在被窝里，或关灯玩手机时，通过降低屏幕亮度和对比度，不会过于刺眼，以达到帮助保护眼睛的效果。夜间模式在亮光环境使用时很可能并不保证所有信息都具有可读性。</p>
<h2 id="深色模式的优点"><a href="#深色模式的优点" class="headerlink" title="深色模式的优点"></a>深色模式的优点</h2><p><strong>优点一：提升视觉沉浸感；</strong>让使用者更加专注自己的操作和界面内容。</p>
<p><strong>优点二：减少屏幕明度；</strong>缩小屏幕显示内容与环境光强度的差距，减少眼睛的负担。</p>
<p><strong>优点三：降低耗电量；</strong>根据谷歌官方数据来看，采用OLED屏幕的手机在「深色模式」下，耗电量可以大幅度下降。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/187331/38/8517/900974/60c9ba0aE142e2f54/82ddb0c68d23406a.png" alt="耗电量对比"></p>
<p><strong>优点四：营造高端感；</strong>深色模式给人以高级、神秘的语义象征，相比于浅色模式，深色模式藏着更多可能性。</p>
<h2 id="深色模式行业内的设计规范"><a href="#深色模式行业内的设计规范" class="headerlink" title="深色模式行业内的设计规范"></a>深色模式行业内的设计规范</h2><h3 id="Material-Design的深色模式"><a href="#Material-Design的深色模式" class="headerlink" title="Material Design的深色模式"></a>Material Design的深色模式</h3><h4 id="（一）应用原则："><a href="#（一）应用原则：" class="headerlink" title="（一）应用原则："></a>（一）应用原则：</h4><p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/179829/7/9465/83901/60c9ba13Ed33d3fcc/aa4d232f7b7d1074.png" alt="应用原则"></p>
<p><strong>1. 灰色而不是黑色</strong></p>
<p>使用深灰色而不是黑色来表示具有更宽深度范围的环境中的高度与空间。(解释：由于深色主题中无法像常规MD设计中使用阴影，因此使用不同亮度的灰色来表示Z轴的空间关系，不以纯黑色作为大范围使用的底色可以提供更宽的色域来体现Z轴深度关系)</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/195982/32/8337/164966/60c9ba14Eae908532/f551baeef1e10bdc.png" alt="Z轴"></p>
<p>简单说下Z轴概念：</p>
<p>一般来说，在平面的界面中想要表现出立体感和深度，我们会通过物体阴影或者透视关系来表现。在 Material Design 中，Z 轴概念的引入则可以轻松解决这个问题。下图中，组件在 Z 轴处于不同的高度，间接影响着阴影的表现。</p>
<p>那么引入 Z 轴难道只是为了画个阴影？当然不是的！更重要的还是用于表现出 UI 组件的次序及重要程度。下图中 Card View 在 Z 轴上低于 App bar，因为正常来说 Card View 上下滚动时是被遮挡在 App bar 之下的；而 FAB 处于最高的位置（8dp），因为它的重要程度是最高的，并且高于 App bar 上的 actions。</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/178783/31/9496/155679/60c9ba14Ea29d32b4/70e81aa90c01bf5b.png" alt="Z轴说明"></p>
<p><strong>2. 颜色与强调</strong></p>
<p>在深色主题中只用有限的颜色用来做强调，从而使大部分区域都使用深色。</p>
<p><strong>3. 节约能源</strong></p>
<p>在需要效率的产品（例如带有 OLED 屏幕的设备）中，通过减少光像素的使用来延长电池寿命。</p>
<p><strong>4. 增强可访问性</strong></p>
<p>通过满足可访问性颜色对比度标准来满足常规深色模式用户（例如弱视用户）的需求。</p>
<h4 id="（二）特性-amp-特点："><a href="#（二）特性-amp-特点：" class="headerlink" title="（二）特性&amp;特点："></a>（二）特性&amp;特点：</h4><ul>
<li><strong>对比度：</strong>深色表面和 100% 白色正文的对比度至少为 15.8:1</li>
<li><strong>深度：</strong>在更高的海拔水平上，组件通过显示较浅的表面颜色来表达深度</li>
<li><strong>去饱和度：</strong>原色去饱和度，因此它们在所有高度级别都通过了至少 4.5:1</li>
<li><strong>有限的颜色：</strong>大表面使用深色表面颜色，具有有限的色彩强调（浅色、不饱和和明亮、饱和的颜色）</li>
</ul>
<p>对比度可以通过万维网W3C进行颜色的对比检查，也可以进行对比度的计算；</p>
<p><a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a></p>
<h4 id="（三）层级剖析："><a href="#（三）层级剖析：" class="headerlink" title="（三）层级剖析："></a>（三）层级剖析：</h4><p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/181557/27/9165/270215/60c9b9fdEb8605f7e/f9155d62284b2df1.png" alt="层级剖析"></p>
<p>可能看起来有点混乱，但以上各层级是遵循MD的Z轴理论的，在深度上有区别，同时保证了内容的高对比度。概括下来即在转变为深色模式的同时继承了常规场景下的MD的Z轴原则(白色背景下通过阴影和颜色体现纵深)，同时还能保证了信息的获取效率。</p>
<h4 id="（四）属性："><a href="#（四）属性：" class="headerlink" title="（四）属性："></a>（四）属性：</h4><p><strong>解释：</strong>黑色主题使用深灰色而不是黑色作为组件的主要表面颜色。深灰色表面可以表现出更广泛的颜色、高度和深度，因为我们更容易看到灰色(而不是黑色)上的阴影。</p>
<p>深灰色表面还可以减少眼睛疲劳，因为深灰色表面上的浅色文字比黑色表面上的浅色文字具有更低的对比度。官方推荐的深色主题的表面颜色：#121212。</p>
<p><strong>1. 海拔高度</strong></p>
<p>在黑暗主题中，组件应当保留与较亮主题中的组件相同的默认高度级别和阴影，这需要通过表面的不同亮度来体现这种纵深高度的区别。</p>
<p><strong>海拔越高表面越轻：</strong>表面高度越高(越接近隐含光源)，表面越轻。通过应用半透明白色覆盖层来表达这种轻盈，随着表面变高，颜色变浅。深色主题表面是通过在组件表面上放置半透明覆盖层来构建的，通过应用半透明白色覆盖层，表面变得更亮，通过调整表面颜色来表达高度。</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/174284/26/15006/765623/60c9ba09E2732595e/44acb4cf44df3130.gif" alt="海拔高度"></p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/187793/23/8491/1254224/60c9b9feE4fcd4532/a2763aa3b38b037d.gif" alt="层级展示"></p>
<p>默认主题使用阴影来表达高度，而深色主题也通过调整表面颜色深浅来表达高度。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/191053/10/8512/93975/60c9b9fdEf80e1f60/1258d38fd74cb5be.jpg" alt="表面叠加的白色"></p>
<p>这些表面覆盖值旨在最大限度地提高易读性，同时确保不同的高度水平彼此可辨别。高度叠加透明度范围从最低级别的0％到最高级别的16％。叠加层阐明了组件之间的高度差异。</p>
<p><strong>2. 可访问性与对比度</strong></p>
<p>深色模式表面必须足够暗以显示白色文本。<strong>文本和背景之间至少应该达到15.8:1的对比度级别。</strong>这确保了当应用于最高(和最轻)高度的表面时，正文文本通过WCAG的AA标准至少能达到4.5:1。如果背景颜色不够深，无法在白色文本和表面之间达到至少15.8:1的对比度，则最高(和最轻)高度表面的文本将无法通过4.5:1标准。</p>
<p><strong>想要使用带有品牌色的深色该怎么应用呢？</strong></p>
<p>要创建带有品牌的深色背景，可以在推荐的深色主题背景颜色(＃121212)上叠加品牌颜色的透明度。下图的案例中颜色＃1F1B24是组合深色模式的背景颜色＃121212和8％原色的结果。</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/192675/30/8609/22126/60c9ba0aE43a2def1/464fbd97d9740828.jpg" alt="品牌颜色"></p>
<h4 id="（五）在UI应用程序中的运用"><a href="#（五）在UI应用程序中的运用" class="headerlink" title="（五）在UI应用程序中的运用"></a>（五）<strong>在UI应用程序中的运用</strong></h4><p><strong>1. 主题颜色</strong></p>
<p>所有深色主题颜色都应显示具有足够对比度的元素，当应用于所有高度的层级表面时，WCAG的AA标准至少为4.5:1。<strong>使用饱和度低的颜色，以提高可访问性。</strong></p>
<p>一个黑暗的主题应该避免使用过度饱和的颜色，饱和颜色还会在深色背景下产生光学振动，这会引起眼睛疲劳。</p>
<p>相反，不饱和的颜色可以用作更清晰的替代品。避免使用下图中这样饱和度过高的颜色，会在深色背景下造成视觉震动。</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/191041/14/7811/37254/60c9ba13Ed246893a/117f72dc173d51a3.jpg" alt="主题色"></p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/173075/19/14823/36735/60c9ba13Ee2f89469/73c7cae542788596.jpg" alt="正常模式的颜色"></p>
<p><strong>2. 主色的选择</strong></p>
<p>主要颜色是应用程序屏幕和组件中最常显示的颜色。基于Material Design深色主题的规范，请使用原色的200色调；</p>
<p><strong>特殊情况：</strong>具有浅表面的组件可以显示暗主题的主要颜色的变体。如下图中白色浮层上的文字链按钮使用的700的深色。</p>
<p><a href="https://material.io/design/color/the-color-system.html#tools-for-picking-colors">https://material.io/design/color/the-color-system.html#tools-for-picking-colors</a></p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/172153/5/14943/103779/60c9ba0aEf6af683e/75a610d26e044ba4.jpg" alt="浅表面的颜色"></p>
<p><strong>3. 辅助色的选择</strong></p>
<p>辅助颜色可用于突出UI的重要部分。在深色模式中，辅助色应该降低饱和度以满足4.5:1的对比度水平。如下图，紫色为主色，绿色为辅助色。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/175335/13/14802/106350/60c9b9feE1e4d229b/8c0b146588ebfa4c.jpg" alt="辅助色"></p>
<p><strong>4. 强调色</strong></p>
<p>在深色主题中，灰色界面占据了UI的大部分。强调色通常是浅色(不饱和柔和色)或明亮(饱和，鲜艳的色彩)，以帮助强调元素使其脱颖而出。应谨慎使用它们来强调关键元素，例如文本或按钮。</p>
<p>为了在深色主题中提供更多灵活性和可用性，建议在深色主题中使用较浅色调(200-50)，而不是默认颜色主题(饱和色调范围为900-500)。</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/187250/6/8610/30224/60c9ba0aE2adfff1d/c46a5307dc1d8a98.jpg" alt="强调色"></p>
<p><strong>5. 品牌颜色</strong></p>
<p>为了保持品牌标识，品牌颜色可以在深色主题中以完全饱和度使用，但应用应限于一个或两个品牌元素，例如徽标或品牌按钮。通过谨慎使用品牌颜色，使元素在层次结构中保持突出。</p>
<p>不饱和的颜色仍应在黑暗主题UI的其余部分中使用，如下图：</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/185733/19/9438/138111/60c9ba0aE418859ab/56b4fab7d58a0220.jpg" alt="品牌色"></p>
<p><strong>6. 错误颜色</strong></p>
<p>错误颜色用于指示<strong>错误状态</strong>。对于谷歌规范中，深色模式错误颜色为＃CF6679。这种深色主题颜色是通过采用浅色主题错误颜色(＃B00020)并使用40％白色覆盖物照亮它来创建的，该颜色通过了AA级对比度标准。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/179716/34/9453/26700/60c9b9feE5ec79c5f/66ea00ca5237a4b2.jpg" alt="错误颜色"></p>
<p><strong>7. 文字颜色</strong></p>
<p>深色背景下的文字颜色：<br>当浅色文本出现在深色背景上(此处显示为黑色)时，应使用以下不透明度级别：</p>
<ul>
<li>高强度文本的不透明度为87％；</li>
<li>中等重点文字和提示文字的透明度为60％；</li>
<li>禁用文字的不透明度为38％；</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/177758/23/9447/20149/60c9ba13Ed0c7d7da/db18fd2512d5ec83.jpg" alt="文字颜色"></p>
<h3 id="iOS的深色模式"><a href="#iOS的深色模式" class="headerlink" title="iOS的深色模式"></a>iOS的深色模式</h3><h4 id="（一）iOS颜色"><a href="#（一）iOS颜色" class="headerlink" title="（一）iOS颜色"></a>（一）iOS颜色</h4><p>iOS引用了6中不同的灰度，在深色模式下，采用纯黑色作为背景，用不同程度的灰色来承载页面内容。</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/174515/32/15044/514260/60c9ba14E6e775226/702444aea77f71bd.png" alt="ios界面对比"></p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/187341/34/8514/75597/60c9b9fdE229a1013/caf52712a03c57e5.png" alt="白色模式和黑色模式"></p>
<h4 id="（二）层级"><a href="#（二）层级" class="headerlink" title="（二）层级"></a>（二）层级</h4><p>iOS通过背景、投影来表达层级关系。列表内容至于纯黑色背景的上方，表明层级越高的内容，背景颜色就会越亮一些；</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/188415/24/8546/446684/60c9ba14Edfa4fcf0/5a5c0a6690b39f04.png" alt="ios页面"></p>
<h2 id="深色模式的设计建议"><a href="#深色模式的设计建议" class="headerlink" title="深色模式的设计建议"></a>深色模式的设计建议</h2><p><strong>1.不要简单的将白变黑或者随意减低亮度</strong></p>
<p>通过背景颜色、卡片颜色、文字颜色来建立信息层级，让内容更好的呈现出来。</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/187709/3/8534/488168/60c9b9fcEdfd1b708/62047d9f9c9b8788.png" alt="案例"></p>
<p><strong>2.不要使用纯黑色背景和纯白色文字</strong></p>
<p>不要同时使用纯黑色（#000000）和纯白色（¥ffffff）作为文本颜色。高强度对比会对用户产生视觉疲劳。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/186388/28/7939/847658/60c9b9feE2ec807af/6d704cc92f70d96c.png" alt="纯黑纯白"></p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/176479/6/15013/822875/60c9ba0aEf8c3a5bb/b2dde989f488410d.png" alt="加入品牌色"></p>
<p><strong>3.注意UGC产品的颜色适配</strong></p>
<p>在微信公众号可以看到，部分在白色模式下很美观的排版，但是在深色模式下，出现内容看不清的情况，在设计上给到用户较好的选择，尽量避免透明图片的使用。</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/189166/8/8115/573130/60c9ba09Ee3621e2d/c348141321c6c490.png" alt="公众号"></p>
<h2 id="如何设计深色模式"><a href="#如何设计深色模式" class="headerlink" title="如何设计深色模式"></a>如何设计深色模式</h2><p><strong>1.建立色彩规范</strong></p>
<p>建立色彩规范，在在纯黑色（#000000）背景中或者（#121212）背景中，加入20%的品牌色，然后通过调整HSB的B值，得到有序的系列背景色；</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/175934/34/14983/71112/60c9ba0aEaeab3453/ee5623776364bc3d.png" alt="设计深色模式"></p>
<p><strong>2.文字规范</strong></p>
<p>在浅色模式下，我们大多数用过一套很常规的标准文字色值：#333、#666、#999、#ccc，通过查看它们的HSB可以发现，分别对应的是（H0  S0  B20）、（H0  S0  B40）、（H0  S0  B60）、（H0  S0  B80），这些文字色值也是遵循20、40、60、80序列值做颜色层级，在深色模式下，我们也可以这样做。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/187647/24/8615/185985/60c9ba0bE5ff33111/36e028e069f27281.png" alt="深色模式文字"></p>
]]></content>
  </entry>
  <entry>
    <title>H5 项目如何适配暗黑模式</title>
    <url>/2021/05/23/H5%20%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E9%80%82%E9%85%8D%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="H5-项目如何适配暗黑模式"><a href="#H5-项目如何适配暗黑模式" class="headerlink" title="H5 项目如何适配暗黑模式"></a>H5 项目如何适配暗黑模式</h2><p><strong>背景</strong></p>
<blockquote>
<p>随着 iOS 13 的发布，深色模式（Dark Mode）越来越多地出现在大众的视野中，支持深色模式已经成为现代移动应用和网站的一个潮流。</p>
</blockquote>
<p><strong>优势</strong></p>
<ul>
<li>可大幅减少耗电量（具体取决于设备的屏幕技术）。</li>
<li>为弱视以及对强光敏感的用户提高可视性。</li>
<li>让所有人都可以在光线较暗的环境中更轻松地使用设备。</li>
</ul>
<p><strong>系统兼容情况</strong></p>
<ul>
<li>macOS 10.14 引入了 darkmode</li>
<li>ios13 2019 年 3 月发布的 ios13 版本加入了 darkmode</li>
<li>Android 10 (API 级别 29) 及更高版本中提供深色主题背景</li>
<li>window10 2018.10.10</li>
</ul>
<p><strong>如何切换深色模式</strong></p>
<ol>
<li><p>iOS：“设置”–“显示与亮度”–“外观”，选择“深色”</p>
</li>
<li><p>Android：“系统设置”–“显示”–“深色模式”。</p>
</li>
</ol>
<p><strong>问题</strong></p>
<p>如果系统设置了深色模式，H5页面不做相应的处理，会出现背景色冲突、深色文字显示异常，深色图标显示异常等一些显示上的问题。</p>
<p>所以，需要对深色模式进行一些适配。</p>
<p><strong>原理</strong></p>
<ol>
<li><p>将同一个资源，创建出两种模式的样式。系统根据当前选择的样式，自动获取该样式的资源</p>
</li>
<li><p>每次系统更新样式时，应用会调用当前所有存在的元素调用对应的一些重新方法，进行重绘视图，可以在对应的方法做相应的改动</p>
</li>
</ol>
<p><strong>H5项目适配深色模式方案</strong></p>
<ol>
<li>声明 color-scheme<br>color-scheme</li>
</ol>
<p>有两种方式。</p>
<ul>
<li>meta</li>
</ul>
<p>在head中声明<meta name="color-scheme" content="light dark">，声明当前页面支持 light 和 dark 两种模式，系统切换到深色模式时，浏览器默认样式也会切换到深色；</p>
<ul>
<li>CSS<br>下面的 css 同样可以实现上面 meta 声明的效果</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>-scheme: light dark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：此声明并非为页面做自动适配，只影响浏览器默认样式</p>
</blockquote>
<ol start="2">
<li>通过 CSS 媒体查询</li>
</ol>
<p>prefers-color-scheme CSS 媒体特性用于检测用户是否有将系统的主题色设置为亮色或者暗色。</p>
<p>no-preference<br>表示系统未得知用户在这方面的选项。在布尔值上下文中，其执行结果为 false。</p>
<p>light<br>表示用户已告知系统他们选择使用浅色主题的界面。</p>
<p>dark<br>表示用户已告知系统他们选择使用暗色主题的界面。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>-scheme: light dark;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">    <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: black;</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[参考](MDN prefers-color-scheme)</p>
<blockquote>
<p>颜色较多的情况，建议使用CSS变量对颜色值进行管理</p>
</blockquote>
<ol start="3">
<li>图片适配</li>
</ol>
<p>利用picture+source标签，设置不同模式下的图片 url。</p>
<p>HTML <picture>元素通过包含零或多个 <source> 元素和一个 <img> 元素来为不同的显示/设备场景提供图像版本。浏览器会选择最匹配的子 <source> 元素，如果没有匹配的，就选择 <img> 元素的 src 属性中的URL。然后，所选图像呈现在<img>元素占据的空间中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 深色模式下的图片 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">&quot;dark.jpg&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(prefers-color-scheme: dark)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认模式下的图片 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;light.jpg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>JavaScript中判断当前模式&amp;监听模式变化</li>
</ol>
<ul>
<li>matchMedia</li>
</ul>
<p>Window 的matchMedia() 方法返回一个新的MediaQueryList 对象，表示指定的媒体查询 (en-US)字符串解析后的结果。返回的MediaQueryList 可被用于判定Document是否匹配媒体查询，或者监控一个document 来判定它匹配了或者停止匹配了此媒体查询。</p>
<ul>
<li>addListener()<br>MediaQueryList接口的addListener()方法向MediaQueryListener添加一个侦听器，该侦听器将运行自定义回调函数以响应媒体查询状态的更改。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript监听判断</span></span><br><span class="line"><span class="keyword">const</span> mediaQuery = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;(prefers-color-scheme: dark)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">darkModeHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mediaQuery.matches) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;现在是深色模式&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;现在是浅色模式&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前模式</span></span><br><span class="line">darkModeHandler()</span><br><span class="line"><span class="comment">// 监听模式变化</span></span><br><span class="line">mediaQuery.addListener(darkModeHandler)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>暗黑模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的纯函数</title>
    <url>/2021/06/28/JS%E4%B8%AD%E7%9A%84%E7%BA%AF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><p>晦涩的定义是这样的：一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用;</p>
<p>总共2点：</p>
<blockquote>
<ol>
<li>结果只依赖参数</li>
<li>执行过程中没有副作用</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo1</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">b</span>) =&gt;</span> a + b</span><br><span class="line">foo(<span class="number">2</span>) <span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// demo2</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">x, b</span>) =&gt;</span> x + b</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// demo3</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">obj, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> obj.x + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> counter = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">foo(counter, <span class="number">2</span>) <span class="comment">// =&gt; 3</span></span><br><span class="line">counter.x <span class="comment">// =&gt; 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// demo4 </span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">obj, b</span>) =&gt;</span> &#123;</span><br><span class="line">  obj.x = <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> obj.x + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> counter = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">foo(counter, <span class="number">2</span>) <span class="comment">// =&gt; 4</span></span><br><span class="line">counter.x <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// demo5</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">  obj.x = <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> obj.x + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<font color="white">

<p>分析<br>1、demo1: 不是。 因为函数结果还依赖了外部变量a<br>2、demo2: 是。<br>3、demo3: 是。 只依赖入参，不产生副作用<br>4、demo4: 不是。 产生副作用。修改了obj.x的值<br>5、demo5: 是。 对内部变量obj的修改，外部程序不可见，无副作用<br></font></p>
<ul>
<li>副作用都包含哪些？<br>1、调用 DOM API 修改页面；<br>2、发送了 Ajax 请求；<br>3、调用 window.reload 刷新浏览器；<br>4、甚至是 console.log 往控制台打印数据；</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>JS自定义功能函数(一)：动态拼接或修改url地址参数和参数值</title>
    <url>/2020/09/17/JS%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0(%E4%B8%80)%EF%BC%9A%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5%E6%88%96%E4%BF%AE%E6%94%B9url%E5%9C%B0%E5%9D%80%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E5%80%BC/</url>
    <content><![CDATA[<h3 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h3><ul>
<li>url: url地址参数；</li>
<li>params：需要拼接或修改的参数对象列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 给url后面动态拼接参数或修改参数</span><br><span class="line"> * @param url</span><br><span class="line"> * @param params</span><br><span class="line"> *&#x2F;</span><br><span class="line">function changeURLArg(url, params) &#123;</span><br><span class="line">  let resUrl &#x3D; url || &#39;&#39;</span><br><span class="line">  if (url &amp;&amp; params) &#123;</span><br><span class="line">    Object.keys(params).forEach((key, index) &#x3D;&gt; &#123;</span><br><span class="line">      if (params[key]) &#123;</span><br><span class="line">        const regExp &#x3D; new RegExp(&#96;($&#123;key&#125;&#x3D;)([^&amp;]*)&#96;, &#39;ig&#39;)</span><br><span class="line">        if (regExp.test(resUrl)) &#123;</span><br><span class="line">          resUrl &#x3D; resUrl.replace(regExp, &#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          let splitStr &#x3D; &#39;&amp;&#39;</span><br><span class="line">          if (index &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">            if (url.indexOf(&#39;?&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">              splitStr &#x3D; &#39;?&#39;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          resUrl +&#x3D; &#96;$&#123;splitStr&#125;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  return resUrl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="示例如下"><a href="#示例如下" class="headerlink" title="示例如下"></a>示例如下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const url &#x3D; &#39;https:&#x2F;&#x2F;www.jianshu.com?a&#x3D;2&#39;</span><br><span class="line">const params &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2</span><br><span class="line">&#125;</span><br><span class="line">const newUrl &#x3D; changeURLArg(url, params) &#x2F;&#x2F; https:&#x2F;&#x2F;www.jianshu.com?a&#x3D;1&amp;b&#x3D;2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript浮点数陷阱及解法</title>
    <url>/2021/05/12/JavaScript%E6%B5%AE%E7%82%B9%E6%95%B0%E9%99%B7%E9%98%B1%E5%8F%8A%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<h1 id="JavaScript-浮点数陷阱及解法"><a href="#JavaScript-浮点数陷阱及解法" class="headerlink" title="JavaScript 浮点数陷阱及解法"></a>JavaScript 浮点数陷阱及解法</h1><p>JavaScript 浮点数运算时经常遇到会 0.000000001 和 0.999999999 这样奇怪的结果，如 0.1+0.2=0.30000000000000004、1-0.9=0.09999999999999998，这其实就是浮点数误差的问题，以下内容可以理清这背后的原理以及解决方案，以及解释JS中的大数危机和四则运算中会遇到的那些坑。</p>
<h2 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h2><p>首先要清楚 JavaScript 如何存储小数的。JavaScript中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。</p>
<blockquote>
<p>这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。</p>
</blockquote>
<p>64位比特可分为以下三个部分：</p>
<ul>
<li>符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数</li>
<li>指数位E：中间的 11 位存储指数（exponent），用来表示次方数</li>
<li>尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/156975/22/20314/7618/606e7824Eef63590e/a7c0b7f7081253f9.png"></p>
<p>实际数字就可以用以下公式来计算：<br><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/146263/38/19604/6630/606e7937Ef6b5587c/b36c917c85bc5d9c.png"></p>
<blockquote>
<p>注意以上的公式遵循科学计数法的规范，在十进制是为0&lt;M&lt;10，到二进行就是0&lt;M&lt;2。也就是说整数部分只能是1，所以可以被舍去，只保留后面的小数部分。如 4.5 转换成二进制就是 100.1，科学计数法表示是 1.001*2^2，舍去1后 M = 001。E是一个无符号整数，因为长度是11位，取值范围是 0~2047。但是科学计数法中的指数是可以为负数的，所以再减去一个中间数 1023，[0,1022]表示为负，[1024,2047] 表示为正。如4.5 的指数E = 1025，尾数M为 001。</p>
</blockquote>
<p>最终公式变成：<br><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/171506/16/17128/10028/606e9890Ebfab9236/4cfc6fe37070495f.png"></p>
<p>所以 4.5 最终表示为（M=001、E=1025）：<br><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/155546/15/20598/27494/606e99d4E104fd0d6/fb12bfd433b16c19.png"></p>
<p>下面再以 0.1 例解释浮点误差的原因， 0.1 转成二进制表示为 0.0001100110011001100(1100循环)，1.100110011001100x2^-4，所以 E=-4+1023=1019；M 舍去首位的1，得到 100110011…。最终就是：<br><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/174435/17/2686/32127/606e9a35Ebf7a180b/2b0f188cc6f39fcd.png"><br>转化成十进制后为 0.100000000000000005551115123126，因此就出现了浮点误差。<br><strong>为什么 0.1+0.2=0.30000000000000004？</strong></p>
<p>计算步骤为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 0.1 和 0.2 都转化成二进制后再进行运算</span><br><span class="line">0.00011001100110011001100110011001100110011001100110011010 +</span><br><span class="line">0.0011001100110011001100110011001100110011001100110011010 &#x3D;</span><br><span class="line">0.0100110011001100110011001100110011001100110011001100111</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 转成十进制正好是 0.30000000000000004</span><br></pre></td></tr></table></figure>

<p><strong>为什么 x=0.1 能得到 0.1？</strong></p>
<p>因为 mantissa 固定长度是 52 位，再加上省略的一位，最多可以表示的数是 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度。它的长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理。于是就有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.10000000000000000555.toPrecision(16)</span><br><span class="line">&#x2F;&#x2F; 返回 0.1000000000000000，去掉末尾的零后正好为 0.1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 但你看到的 &#96;0.1&#96; 实际上并不是 &#96;0.1&#96;。不信你可用更高的精度试试：</span><br><span class="line">0.1.toPrecision(21) &#x3D; 0.100000000000000005551</span><br></pre></td></tr></table></figure>

<h2 id="大数危机"><a href="#大数危机" class="headerlink" title="大数危机"></a>大数危机</h2><p>如果整数大于 9007199254740992 会出现什么情况呢？<br>由于 E 最大值是 1023，所以最大可以表示的整数是 2^1024 - 1，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 2^1024 开始就变成了 Infinity(无穷)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Math.pow(2, 1023)</span><br><span class="line">8.98846567431158e+307</span><br><span class="line"></span><br><span class="line">&gt; Math.pow(2, 1024)</span><br><span class="line">Infinity</span><br></pre></td></tr></table></figure>

<p><strong>那么对于 (2^53, 2^63) 之间的数会出现什么情况呢？</strong></p>
<ul>
<li>(2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数</li>
<li>(2^54, 2^55) 之间的数会四个选一个，只能精确表示4个倍数</li>
<li>… 依次跳过更多2的倍数</li>
</ul>
<p>下面这张图能很好的表示 JavaScript 中浮点数和实数（Real Number）之间的对应关系。我们常用的 (-2^53, 2^53) 只是最中间非常小的一部分，越往两边越稀疏越不精确：<br><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/176423/6/2617/48239/606e9b89Eaeed9440/89563159c53755b4.jpg"></p>
<p>比如若订单系统中把订单号当作数字处理的话，随着订单号暴增，很容易超过了9007199254740992，有一种办法是把订单号改成字符串处理。</p>
<p>要想解决大数的问题你可以引用第三方库 bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生的差很多。所以原生支持大数就很有必要了，现在 TC39 已经有一个 Stage 3 的提案 proposal bigint，大数问题有望彻底解决。在浏览器正式支持前，可以使用 Babel 7.0 来实现，它的内部是自动转换成 big-integer 来计算，要注意的是这样能保持精度但运算效率会降低。</p>
<h2 id="toPrecision-vs-toFixed"><a href="#toPrecision-vs-toFixed" class="headerlink" title="toPrecision vs toFixed"></a>toPrecision vs toFixed</h2><p>数据处理时，这两个函数很容易混淆。它们的共同点是把数字转成字符串供展示使用。<strong>注意在计算的中间过程不要使用，只用于最终结果。</strong></p>
<p>不同点就需要注意一下：</p>
<ul>
<li>toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起</li>
<li>toFixed 是小数点后指定位数取整，从小数点开始数起</li>
</ul>
<p>两者都能对多余数字做凑整处理，也有些人用 toFixed 来做四舍五入，但一定要知道它是有 Bug 的。</p>
<p>如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。</p>
<p>原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！</p>
<p>解法：使用专业的四舍五入函数 Math.round() 来处理。但 Math.round(1.005 * 100) / 100 还是不行，因为 1.005 * 100 = 100.49999999999999。还需要把乘法和除法精度误差都解决后再使用 Math.round。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>如何解决浮点误差呢，首先，理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果。</p>
<h3 id="数据展示类"><a href="#数据展示类" class="headerlink" title="数据展示类"></a>数据展示类</h3><p>当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseFloat(1.4000000000000001.toPrecision(12)) &#x3D;&#x3D;&#x3D; 1.4  &#x2F;&#x2F; True</span><br></pre></td></tr></table></figure>
<p>封装成方法就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function strip(num, precision &#x3D; 12) &#123;</span><br><span class="line">  return +parseFloat(num.toPrecision(precision));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。</p>
<h3 id="数据运算类"><a href="#数据运算类" class="headerlink" title="数据运算类"></a>数据运算类</h3><p>对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 精确加法</span><br><span class="line"> *&#x2F;</span><br><span class="line">function add(num1, num2) &#123;</span><br><span class="line">  const num1Digits &#x3D; (num1.toString().split(&#39;.&#39;)[1] || &#39;&#39;).length;</span><br><span class="line">  const num2Digits &#x3D; (num2.toString().split(&#39;.&#39;)[1] || &#39;&#39;).length;</span><br><span class="line">  const baseNum &#x3D; Math.pow(10, Math.max(num1Digits, num2Digits));</span><br><span class="line">  return (num1 * baseNum + num2 * baseNum) &#x2F; baseNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上方法能适用于大部分场景。遇到科学计数法如 2.3e+1（当数字精度大于21时，数字会强制转为科学计数法形式显示）时还需要特别处理一下。</p>
]]></content>
  </entry>
  <entry>
    <title>Jest单元测试（中）</title>
    <url>/2020/09/29/Jest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jest 的目标是在大部分 JavaScript 项目中实现开箱即用，因此本身有一些默认配置，即使我们不做任何配置也可以正确运行。如果想了解这些默认配置项具体是什么，可以通过下面的方式获取：</p>
<ul>
<li><p>查看 node_modules/jest-config/build/Default.js 文件中的 defaultOptions 对象</p>
</li>
<li><p>通过以下js获取。</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defaults &#125; = <span class="built_in">require</span>(<span class="string">&#x27;jest-config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是用第二种方法获取到的 Jest 默认配置</span></span><br><span class="line">&#123;</span><br><span class="line">    automock: <span class="literal">false</span>,</span><br><span class="line">    bail: <span class="number">0</span>,</span><br><span class="line">    cache: <span class="literal">true</span>,</span><br><span class="line">    cacheDirectory: <span class="string">&#x27;/private/var/folders/3l/p3_nb2m13b9cgstcy0b3gx18ffrd_n/T/jest_80wf9x&#x27;</span>,</span><br><span class="line">    changedFilesWithAncestor: <span class="literal">false</span>,</span><br><span class="line">    clearMocks: <span class="literal">false</span>,</span><br><span class="line">    collectCoverage: <span class="literal">false</span>,</span><br><span class="line">    coveragePathIgnorePatterns: [ <span class="string">&#x27;/node_modules/&#x27;</span> ],</span><br><span class="line">    coverageProvider: <span class="string">&#x27;babel&#x27;</span>,</span><br><span class="line">    coverageReporters: [ <span class="string">&#x27;json&#x27;</span>, <span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;lcov&#x27;</span>, <span class="string">&#x27;clover&#x27;</span> ],</span><br><span class="line">    errorOnDeprecated: <span class="literal">false</span>,</span><br><span class="line">    expand: <span class="literal">false</span>,</span><br><span class="line">    forceCoverageMatch: [],</span><br><span class="line">    globals: &#123;&#125;,</span><br><span class="line">    haste: &#123; <span class="attr">computeSha1</span>: <span class="literal">false</span>, <span class="attr">throwOnModuleCollision</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    maxConcurrency: <span class="number">5</span>,</span><br><span class="line">    maxWorkers: <span class="string">&#x27;50%&#x27;</span>,</span><br><span class="line">    moduleDirectories: [ <span class="string">&#x27;node_modules&#x27;</span> ],</span><br><span class="line">    moduleFileExtensions: [ <span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;json&#x27;</span>, <span class="string">&#x27;jsx&#x27;</span>, <span class="string">&#x27;ts&#x27;</span>, <span class="string">&#x27;tsx&#x27;</span>, <span class="string">&#x27;node&#x27;</span> ],</span><br><span class="line">    moduleNameMapper: &#123;&#125;,</span><br><span class="line">    modulePathIgnorePatterns: [],</span><br><span class="line">    noStackTrace: <span class="literal">false</span>,</span><br><span class="line">    notify: <span class="literal">false</span>,</span><br><span class="line">    notifyMode: <span class="string">&#x27;failure-change&#x27;</span>,</span><br><span class="line">    prettierPath: <span class="string">&#x27;prettier&#x27;</span>,</span><br><span class="line">    resetMocks: <span class="literal">false</span>,</span><br><span class="line">    resetModules: <span class="literal">false</span>,</span><br><span class="line">    restoreMocks: <span class="literal">false</span>,</span><br><span class="line">    roots: [ <span class="string">&#x27;&lt;rootDir&gt;&#x27;</span> ],</span><br><span class="line">    runTestsByPath: <span class="literal">false</span>,</span><br><span class="line">    runner: <span class="string">&#x27;jest-runner&#x27;</span>,</span><br><span class="line">    setupFiles: [],</span><br><span class="line">    setupFilesAfterEnv: [],</span><br><span class="line">    skipFilter: <span class="literal">false</span>,</span><br><span class="line">    snapshotSerializers: [],</span><br><span class="line">    testEnvironment: <span class="string">&#x27;jest-environment-jsdom&#x27;</span>,</span><br><span class="line">    testEnvironmentOptions: &#123;&#125;,</span><br><span class="line">    testFailureExitCode: <span class="number">1</span>,</span><br><span class="line">    testLocationInResults: <span class="literal">false</span>,</span><br><span class="line">    testMatch: [ <span class="string">&#x27;**/__tests__/**/*.[jt]s?(x)&#x27;</span>, <span class="string">&#x27;**/?(*.)+(spec|test).[tj]s?(x)&#x27;</span> ],</span><br><span class="line">    testPathIgnorePatterns: [ <span class="string">&#x27;/node_modules/&#x27;</span> ],</span><br><span class="line">    testRegex: [],</span><br><span class="line">    testRunner: <span class="string">&#x27;jasmine2&#x27;</span>,</span><br><span class="line">    testSequencer: <span class="string">&#x27;@jest/test-sequencer&#x27;</span>,</span><br><span class="line">    testURL: <span class="string">&#x27;http://localhost&#x27;</span>,</span><br><span class="line">    timers: <span class="string">&#x27;real&#x27;</span>,</span><br><span class="line">    transformIgnorePatterns: [ <span class="string">&#x27;/node_modules/&#x27;</span> ],</span><br><span class="line">    useStderr: <span class="literal">false</span>,</span><br><span class="line">    watch: <span class="literal">false</span>,</span><br><span class="line">    watchPathIgnorePatterns: [],</span><br><span class="line">    watchman: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多，看起来也很头大。我们先将常用到的配置项做下归类，之后再配置对 Babel / webpack 等的支持，对这些配置项就会有大致的了解了。 Jest 配置详见： <a href="https://jestjs.io/docs/en/configuration.html">Configuring Jest</a></p>
<h3 id="Jest-配置项"><a href="#Jest-配置项" class="headerlink" title="Jest 配置项"></a>Jest 配置项</h3><ol>
<li>mock<ul>
<li>automock: 引入的模块会被自动mock</li>
<li>clearMocks: 测试前自动清除 mock.calls 和 mock.instances 属性，等价于 jest.clearAllMocks()</li>
<li>resetMocks: 测试前自动重置 mock 到初始状态，等价于 jest.resetAllMocks()</li>
<li>restoreMocks: 测试前自动恢复 mock（？？和restMock的区别），等价于 jest.restoreAllMocks()</li>
</ul>
</li>
<li>覆盖率<ul>
<li>collectCoverage: 是否搜集测试时的覆盖率</li>
<li>collectCoverageFrom: 哪些文件测试时需要进行覆盖率统计（数组，通过<a href="https://github.com/isaacs/node-glob#glob-primer">glob 模式</a>匹配）</li>
<li>coverageDirectory: 输出覆盖信息文件的目录</li>
<li>coveragePathIgnorePatterns: 哪些文件测试时不需要进行覆盖率统计（数组，通过正则匹配）</li>
<li>coverageReporters: 定义测试覆盖率报告的格式</li>
<li>coverageThreshold: 覆盖率的阈值，可按照 global 和 glob 模式分组（单位为百分比，正值表示允许的覆盖率的最小值，负值表示不通过的百分比的最大值）</li>
<li>forceCoverageMatch: 统计测试覆盖率时，测试文件默认被忽略，此项可以指定哪些文件需要被统计进来（数组，glob 模式）</li>
</ul>
</li>
<li>转换器<ul>
<li>transform: 匹配文件和对应的转换器</li>
<li>transformIgnorePatterns: 转换时要排除的文件</li>
</ul>
</li>
<li>bail<ul>
<li>停止运行测试代码时出现错误的次数</li>
</ul>
</li>
</ol>
<h3 id="Jest-配置方式"><a href="#Jest-配置方式" class="headerlink" title="Jest 配置方式"></a>Jest 配置方式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们想对 Jest 进行个性化配置，有以下方式：</p>
<ol>
<li><p>在项目中 package.json 文件中增加 “jest” 字段</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;my-project&quot;</span>,</span><br><span class="line">    <span class="string">&quot;jest&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;verbose&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 jest.config.js  </p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    verbose: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果以上两种方式不满足要求，想自定义配置文件的名称和格式，可在执行 jest 命令时增加 <code>--config &lt;path/to/file.js|cjs|mjs|json&gt; </code>，–config 选项可指定配置文件。需要注意的是如果采用json 文件，不能有 “jest” 键值。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;verbose&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="生成一个基础配置文件"><a href="#生成一个基础配置文件" class="headerlink" title="生成一个基础配置文件"></a>生成一个基础配置文件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了手动添加配置文件外，我们可以通过 Jest 提供的 Jest CLI，运行 <code>jest --init</code> 命令，运行完成后，会生成一个 jest.config.js，这个文件里每个选项都有简短的说明。</p>
<h3 id="使用-Babel"><a href="#使用-Babel" class="headerlink" title="使用 Babel"></a>使用 Babel</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于我们配置的环境是 node，它的语法是CommonJS，因此使用ES6 语法 import 时会报错。</p>
<ol>
<li><p>安装依赖</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babel 6</span></span><br><span class="line">npm install --save-dev babel-jest babel-core regenerator-runtime</span><br><span class="line"><span class="comment">// babel 7</span></span><br><span class="line">npm install --save-dev babel-jest babel-core@^<span class="number">7.0</span><span class="number">.0</span>-bridge<span class="number">.0</span> @babel/core regenerator-runtime</span><br></pre></td></tr></table></figure>
</li>
<li><p>在根目录下增加 .babelrc 文件</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;env&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行 <code>npm run test</code> 查看结果</p>
</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，安装 Jest 时，babel-jest 是会被自动安装的。当运行jest 命令时，babel-jest 会检测当前环境是否安装了 babel-core，如果安装了，会去取 .babelrc 的配置并执行 babel 对代码进行转化。 如果要避免这个行为，比如需要添加额外的预处理器，需要显式的重置 transform 配置项，因为一旦添加了 transform 配置，babel-jest 就不会自动载入了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json 重置 transform</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;jest&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;transform&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加-TypeScript-支持"><a href="#添加-TypeScript-支持" class="headerlink" title="添加 TypeScript 支持"></a>添加 TypeScript 支持</h3><ol>
<li><p>我们先创建一个 math.ts 文件：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: number, b: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接着创建测试文件 math.test.ts:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.test.ts</span></span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">from</span> <span class="string">&#x27;../src/math&#x27;</span></span><br><span class="line">describe(<span class="string">&#x27;Test Math Module&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    test(<span class="string">&#x27;should return sum value when one plus another&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        expect(sum(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 tsconfig.json 文件，添加 TypeScript 配置：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;include&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;src/**/*&quot;</span>,</span><br><span class="line">        <span class="string">&quot;__test__/**/*&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;exclude&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Jest 测试 TypeScript 代码需要借助 ts-jest 解析器，安装依赖：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -save-dev ts-jest typescript @types/jest</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 Jest</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jest.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    collectCoverage: <span class="literal">true</span>,</span><br><span class="line">    transform: &#123;</span><br><span class="line">        <span class="string">&#x27;^.+\\.tsx?$&#x27;</span>: <span class="string">&#x27;ts-jest&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 <code>npm run test</code> 查看结果</p>
</li>
</ol>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>Jest</tag>
      </tags>
  </entry>
  <entry>
    <title>Mobx和Redux区别浅析</title>
    <url>/2020/12/30/Mobx%E5%92%8CRedux%E5%8C%BA%E5%88%AB%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p>在React项目中做数据管理，Redux已经占据半边天下，为什么会出现Mobx呢，它是什么，能给我们带来什么，和Redux相比有什么优缺点呢，今天，我就自己学习的一点知识，为大家做一个简单的分享，希望让你对Mobx有一个大致的了解。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>   Mobx是什么</li>
<li>   编程思维方式的不同</li>
<li>   Store的区别</li>
<li>   储存数据形式区别</li>
<li>   操作对象方式不同</li>
<li>   代码对比</li>
<li>   Props的注入不同</li>
<li> Mobx优缺点总结</li>
</ol>
<h2 id="Mobx是什么"><a href="#Mobx是什么" class="headerlink" title="Mobx是什么"></a>Mobx是什么</h2><p>Mobx是一个透明函数响应式编程（Transparently Functional Reactive Programming，TFRP）的状态管理库，它使得状态管理简单可伸缩：<br>Anything that can be derived from the application state, should be derived. Automatically.</p>
<p>任何起源于应用状态的数据应该自动获取。<br>其原理如图：<br><img src= "/img/loading.gif" data-src="img1.png"></p>
<ol>
<li><p>   Action：定义改变状态的动作函数，包括如何变更状态；</p>
</li>
<li><p>   Store：集中管理模块状态（State）和动作（action）；</p>
</li>
<li><p> Derivation（衍生）：从应用状态中派生而出，且没有任何其他影响的数据，我们称为derivation（衍生），衍生在以下情况下存在：<br>a. 用户界面；<br>b. 衍生数据；<br>衍生主要有两种：</p>
</li>
<li><p>Computed Values（计算值）：计算值总是可以使用纯函数（pure function）从当前可观察状态中获取；</p>
</li>
<li><p>Reactions（反应）：反应指状态变更时需要自动发生的副作用，这种情况下，我们需要实现其读写操作；</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable, autorun&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> todoStore = observable(&#123;</span><br><span class="line">    <span class="comment">/* some observable state */</span></span><br><span class="line">    todos: [],</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* a derived value */</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">completedCount</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.completed).length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* a function that observes the state */</span></span><br><span class="line">autorun(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Completed %d of %d items&quot;</span>,</span><br><span class="line">        todoStore.completedCount,</span><br><span class="line">        todoStore.todos.length</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ..and some actions that modify the state */</span></span><br><span class="line">todoStore.todos[<span class="number">0</span>] = &#123;</span><br><span class="line">    title: <span class="string">&quot;Take a walk&quot;</span>,</span><br><span class="line">    completed: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// -&gt; synchronously prints: &#x27;Completed 0 of 1 items&#x27;</span></span><br><span class="line"></span><br><span class="line">todoStore.todos[<span class="number">0</span>].completed = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// -&gt; synchronously prints: &#x27;Completed 1 of 1 items&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="编程思维方式的不同"><a href="#编程思维方式的不同" class="headerlink" title="编程思维方式的不同"></a>编程思维方式的不同</h2><p>Redux更多的是遵循函数式编程（Functional Programming, FP）思想，而Mobx则更多从面相对象角度考虑问题。</p>
<p>Redux提倡编写函数式代码，如reducer就是一个纯函数（pure function），如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    (state, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 纯函数，接受输入，然后输出结果，除此之外不会有任何影响，也包括不会影响接收的参数；对于相同的输入总是输出相同的结果。</p>
<p> Mobx设计更多偏向于面向对象编程（OOP）和响应式编程（Reactive Programming），通常将状态包装成可观察对象，于是我们就可以使用可观察对象的所有能力，一旦状态对象变更，就能自动获得更新。</p>
<h2 id="store的区别"><a href="#store的区别" class="headerlink" title="store的区别"></a>store的区别</h2><p>store是应用管理数据的地方，在Redux应用中，我们总是将所有共享的应用数据集中在一个大的store中，而Mobx则通常按模块将应用状态划分，在多个独立的store中管理。</p>
<h2 id="储存数据形式区别"><a href="#储存数据形式区别" class="headerlink" title="储存数据形式区别"></a>储存数据形式区别</h2><p>Redux默认以JavaScript原生对象形式存储数据，而Mobx使用可观察对象：</p>
<ol>
<li>Redux需要手动追踪所有状态对象的变更；</li>
<li>Mobx中可以监听可观察对象，当其变更时将自动触发监听；</li>
</ol>
<h2 id="操作对象方式不同"><a href="#操作对象方式不同" class="headerlink" title="操作对象方式不同"></a>操作对象方式不同</h2><p>Redux状态对象通常是不可变的（Immutable）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> REQUEST_POST:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">      post: action.payload.post</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    retur nstate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们不能直接操作状态对象，而总是在原来状态对象基础上返回一个新的状态对象，这样就能很方便的返回应用上一状态；而Mobx中可以直接使用新值更新状态对象。</p>
<h2 id="代码对比"><a href="#代码对比" class="headerlink" title="代码对比"></a>代码对比</h2><p>在Redux应用中，我们首先需要配置，创建store，并使用redux-thunk或redux-saga中间件以支持异步action，然后使用Provider将store注入应用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; applyMiddleware, createStore &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-saga&#x27;</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; composeWithDevTools &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-devtools-extension&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">&quot;./reducers&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./containers/App/&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sagaMiddleware = createSagaMiddleware()</span><br><span class="line"><span class="keyword">const</span> middleware = composeWithDevTools(applyMiddleware(sagaMiddleware));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(rootReducer, middleware);</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line">…</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  &lt;/BrowserRouter&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Mobx应用则可以直接将所有store注入应用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useStrict &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./containers/App/&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> stores <span class="keyword">from</span> <span class="string">&#x27;./flux/index&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set strict mode for mobx</span></span><br><span class="line"><span class="comment">// must change store through action</span></span><br><span class="line">useStrict(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Provider &#123;...stores&#125;&gt;</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;/BrowserRouter&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Props的注入不同"><a href="#Props的注入不同" class="headerlink" title="Props的注入不同"></a>Props的注入不同</h2><ul>
<li>Redux</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/containers/Company.js</span></span><br><span class="line">…</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.loadData(&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml">&lt;Company</span></span><br><span class="line"><span class="xml">      infos=&#123;this.props.infos&#125;</span></span><br><span class="line"><span class="xml">      loading=&#123;this.props.loading&#125;</span></span><br><span class="line"><span class="xml">    /&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="comment">// function for injecting state into props</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    infos: state.companyStore.infos,</span><br><span class="line">    loading: state.companyStore.loading</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> bindActionCreators(&#123;</span><br><span class="line">      loadData: loadData</span><br><span class="line">  &#125;, dispatch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// injecting both state and actions into props</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, &#123; loadData &#125;)(CompanyContainer);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Mobx</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@inject(<span class="string">&#x27;companyStore&#x27;</span>)</span><br><span class="line">@observer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.companyStore.loadData(&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; infos, loading &#125; = <span class="built_in">this</span>.props.companyStore;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml">&lt;Company</span></span><br><span class="line"><span class="xml">      infos=&#123;infos&#125;</span></span><br><span class="line"><span class="xml">      loading=&#123;loading&#125;</span></span><br><span class="line"><span class="xml">    /&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Mobx优缺点总结"><a href="#Mobx优缺点总结" class="headerlink" title="Mobx优缺点总结"></a>Mobx优缺点总结</h2><ul>
<li> <strong>优点</strong></li>
</ul>
<ol>
<li><p>   学习成本少：Mobx基础知识很简单，学习了半小时官方文档和示例代码就搭建了新项目实例；而Redux确较繁琐，流程较多，需要配置，创建store，编写reducer，action，如果涉及异步任务，还需要引入redux-thunk或redux-saga编写额外代码，Mobx流程相比就简单很多，并且不需要额外异步处理库；</p>
</li>
<li><p>面向对象编程：Mobx支持面向对象编程，我们可以使用@observable and @observer，以面向对象编程方式使得JavaScript对象具有响应式能力；而Redux最推荐遵循函数式编程，当然Mobx也支持函数式编程；</p>
</li>
<li><p>模版代码少：相对于Redux的各种模版代码，如，actionCreater，reducer，saga／thunk等，Mobx则不需要编写这类模板代码；</p>
</li>
</ol>
<ul>
<li><strong>缺点</strong></li>
</ul>
<ol>
<li><p>   过于自由：Mobx提供的约定及模版代码很少，这导致开发代码编写很自由，如果不做一些约定，比较容易导致团队代码风格不统一，所以当团队成员较多时，确实需要添加一些约定；</p>
</li>
<li><p>可拓展，可维护性：也许你会担心Mobx能不能适应后期项目发展壮大呢？确实Mobx更适合用在中小型项目中，但这并不表示其不能支撑大型项目，关键在于大型项目通常需要特别注意可拓展性，可维护性，相比而言，规范的Redux更有优势，而Mobx更自由，需要我们自己制定一些规则来确保项目后期拓展，维护难易程度；</p>
</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://www.robinwieruch.de/redux-mobx">Redux &amp; Mobx</a></li>
<li><a href="https://mobx.js.org/index.html">Mobx</a></li>
</ol>
]]></content>
      <categories>
        <category>数据存储</category>
      </categories>
      <tags>
        <tag>数据存储</tag>
      </tags>
  </entry>
  <entry>
    <title>nuxt.js</title>
    <url>/2020/02/04/NuxtJS/</url>
    <content><![CDATA[<h2 id="Nuxt-js是什么？"><a href="#Nuxt-js是什么？" class="headerlink" title="Nuxt.js是什么？"></a>Nuxt.js是什么？</h2><blockquote>
<ul>
<li>一个基于 <code>Vue.js</code> 的通用应用框架</li>
<li>基于它初始化新项目的基础结构代码，或者在已有 <code>Node.js</code> 项目中使用</li>
<li>预设了利用 <code>Vue.js</code> 开发服务端渲染的应用所需要的各种配置</li>
<li>提供了一种命令叫：nuxt generate，为基于 Vue.js 的应用提供生成对应的静态站点的功能</li>
<li>为 <code>客户端/服务端</code> 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等</li>
</ul>
</blockquote>
<h2 id="Nuxt-js的特性"><a href="#Nuxt-js的特性" class="headerlink" title="Nuxt.js的特性"></a>Nuxt.js的特性</h2><blockquote>
<ul>
<li>基于 Vue.js</li>
<li>自动代码分层</li>
<li>服务端渲染</li>
<li>强大的路由功能，支持异步数据</li>
<li>静态文件服务</li>
<li>ES6/ES7 语法支持</li>
<li>打包和压缩 JS 和 CSS</li>
<li>HTML头部标签管理</li>
<li>本地开发支持热加载</li>
<li>集成ESLint</li>
<li>支持各种样式预处理器： SASS、LESS、 Stylus等等</li>
<li>支持HTTP/2 推送</li>
</ul>
</blockquote>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── assets&#x2F;        # 资源目录 assets 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript</span><br><span class="line">├── components&#x2F;    # 组件目录 components 用于组织应用的 Vue.js 组件。Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。</span><br><span class="line">├── layouts&#x2F;       # 布局目录 layouts 用于组织应用的布局组件</span><br><span class="line">├── middleware&#x2F;    # middleware 目录用于存放应用的中间件</span><br><span class="line">├── pages&#x2F;         # 页面目录 pages 用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。</span><br><span class="line">├── plugins&#x2F;       # 插件目录 plugins 用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件</span><br><span class="line">├── server&#x2F;        # </span><br><span class="line">├── static&#x2F;        # 静态文件目录 static 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。 服务器启动的时候，该目录下的文件会映射至应用的根路径 &#x2F; 下</span><br><span class="line">├── store&#x2F;         # 用于组织应用的 Vuex 状态树 文件。 Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置</span><br><span class="line">├── nuxt.config.js # 用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置</span><br><span class="line">├── package.json   # 用于描述应用的依赖关系和对外暴露的脚本接口</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Nuxt.js 默认的配置涵盖了大部分使用情形，可通过 nuxt.config.js 来覆盖默认的配置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  build: &#123;&#125;,       <span class="comment">// 根据服务端需求，自定义 webpack 的构建配置，如babel配置、devServer配置等</span></span><br><span class="line">  cache: <span class="literal">true</span>,     <span class="comment">// 开启组件缓存策略以提升渲染性能</span></span><br><span class="line">  css: [],         <span class="comment">// 配置全局的 CSS 文件、模块、库</span></span><br><span class="line">  dev: <span class="literal">true</span>,       <span class="comment">// 配置 Nuxt.js 应用是开发模式还是生产模式</span></span><br><span class="line">  env: &#123;&#125;,         <span class="comment">// 配置在客户端和服务端共享的环境变量, 通过 process.env.* 或 context.*来使用</span></span><br><span class="line">  generate: &#123;&#125;,    <span class="comment">// 配置 Nuxt.js 应用生成静态站点的具体方式，当运行 nuxt generate 命令或在编码中调用 nuxt.generate() 时，Nuxt.js 会使用 generate 属性的配置</span></span><br><span class="line">  head: &#123;&#125;,        <span class="comment">// 配置应用默认的meta标签</span></span><br><span class="line">  loading: &#123;&#125;,     <span class="comment">// 用于个性化定制 Nuxt.js 使用的加载组件, 在页面切换的时候，Nuxt.js 使用内置的加载组件显示加载进度条。可以定制它的样式，禁用或者创建自己的加载组件</span></span><br><span class="line">  modules: [],     <span class="comment">// modules是Nuxt.js扩展，可以扩展它的核心功能并添加无限的集成</span></span><br><span class="line">  modulesDir: [],  <span class="comment">// 用于设置路径解析的模块目录，例如：webpack resolveLoading，nodeExternal和postcss</span></span><br><span class="line">  plugins: [],     <span class="comment">// 用于配置那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件</span></span><br><span class="line">  rootDir: <span class="string">&#x27;&#x27;</span>,     <span class="comment">// 用于配置 Nuxt.js 应用的根目录，该配置项的一个限制是应用的 node_modules 目录必须在 rootDir 目录内</span></span><br><span class="line">  router: &#123;&#125;,      <span class="comment">// 用于覆盖 Nuxt.js 默认的 vue-router 配置</span></span><br><span class="line">  srcDir: <span class="string">&#x27;&#x27;</span>,      <span class="comment">// 用于配置应用的源码目录路径，默认值为 rootDir 的值</span></span><br><span class="line">  transition: &#123;&#125;   <span class="comment">// 用于个性化配置应用过渡效果属性的默认值，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>Nuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。</p>
<h3 id="基础路由"><a href="#基础路由" class="headerlink" title="基础路由"></a>基础路由</h3><p>假设 pages 的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pages&#x2F;</span><br><span class="line">--| user&#x2F;</span><br><span class="line">-----| index.vue</span><br><span class="line">-----| one.vue</span><br><span class="line">--| index.vue</span><br></pre></td></tr></table></figure>
<p>那么，Nuxt.js 自动生成的路由配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router: &#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">      path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      component: <span class="string">&#x27;pages/index.vue&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">      path: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">      component: <span class="string">&#x27;pages/user/index.vue&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">&#x27;user-one&#x27;</span>,</span><br><span class="line">      path: <span class="string">&#x27;/user/one&#x27;</span>,</span><br><span class="line">      component: <span class="string">&#x27;pages/user/one.vue&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>在 Nuxt.js 里面定义带参数的动态路由，需要创建对应的以下划线作为前缀的 Vue 文件 或 目录。</p>
<p>假设 pages 的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pages&#x2F;</span><br><span class="line">--| _slug&#x2F;</span><br><span class="line">-----| comments.vue</span><br><span class="line">-----| index.vue</span><br><span class="line">--| users&#x2F;</span><br><span class="line">-----| _id.vue</span><br><span class="line">--| index.vue</span><br></pre></td></tr></table></figure>
<p>Nuxt.js 生成对应的路由配置表为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router: &#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">      path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      component: <span class="string">&#x27;pages/index.vue&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">&#x27;users-id&#x27;</span>,</span><br><span class="line">      path: <span class="string">&#x27;/users/:id?&#x27;</span>,</span><br><span class="line">      component: <span class="string">&#x27;pages/users/_id.vue&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">&#x27;slug&#x27;</span>,</span><br><span class="line">      path: <span class="string">&#x27;/:slug&#x27;</span>,</span><br><span class="line">      component: <span class="string">&#x27;pages/_slug/index.vue&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">&#x27;slug-comments&#x27;</span>,</span><br><span class="line">      path: <span class="string">&#x27;/:slug/comments&#x27;</span>,</span><br><span class="line">      component: <span class="string">&#x27;pages/_slug/comments.vue&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>定制化默认的 html 模板，只需要在应用根目录下创建一个 app.html 的文件。</p>
<p>默认模板为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> &#123;&#123; <span class="attr">HTML_ATTRS</span> &#125;&#125;&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    &#123;&#123; HEAD &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> &#123;&#123; <span class="attr">BODY_ATTRS</span> &#125;&#125;&gt;</span></span><br><span class="line">    &#123;&#123; APP &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>举个例子，可以修改模板添加 IE 的条件表达式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 9]&gt;&lt;html lang=&quot;en-US&quot; class=&quot;lt-ie9 ie9&quot; &#123;&#123; HTML_ATTRS &#125;&#125;&gt;&lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt;</span><span class="tag">&lt;<span class="name">html</span> &#123;&#123; <span class="attr">HTML_ATTRS</span> &#125;&#125;&gt;</span><span class="comment">&lt;!--&lt;![endif]--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    &#123;&#123; HEAD &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> &#123;&#123; <span class="attr">BODY_ATTRS</span> &#125;&#125;&gt;</span></span><br><span class="line">    &#123;&#123; APP &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>Nuxt.js 允许我们扩展默认的布局，或在 layout 目录下创建自定义的布局。</p>
<h3 id="默认布局"><a href="#默认布局" class="headerlink" title="默认布局"></a>默认布局</h3><p>可通过添加 layouts/default.vue 文件来扩展应用的默认布局。需要在布局文件中添加 <code>&lt;nuxt/&gt;</code> 组件用于显示页面的主体内容。</p>
<p>默认布局的源码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nuxt</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h3><p>通过编辑 layouts/error.vue 文件来定制化错误页面，这个布局文件不需要包含 <code>&lt;nuxt/&gt;</code> 标签。可以把这个布局文件当成是显示应用错误（404，500等）的组件。</p>
<p>举一个个性化错误页面的例子 layouts/error.vue:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;error.statusCode === 404&quot;</span>&gt;</span>页面不存在<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>应用发生错误异常<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nuxt-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>首 页<span class="tag">&lt;/<span class="name">nuxt-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  props: [<span class="string">&#x27;error&#x27;</span>],</span></span><br><span class="line"><span class="javascript">  layout: <span class="string">&#x27;blog&#x27;</span> <span class="comment">// 可以为错误页面指定自定义的布局</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><p>页面组件实际上是 Vue 组件，只不过 Nuxt.js 为这些组件添加了一些特殊的配置项（对应 Nuxt.js 提供的功能特性）以便能快速开发通用应用。</p>
<p>Nuxt.js 为页面提供的特殊配置项：</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">asyncData</td>
<td align="left">最重要的一个键, 支持异步数据处理，会在组件（限于页面组件）每次加载之前被调用。它可以在服务端或路由更新之前被调用,另外该方法的第一个参数为当前页面组件的上下文对象。Nuxt.js 会将asyncData 返回的数据融合组件 data 方法返回的数据一并返回给当前组件。</td>
</tr>
<tr>
<td align="center">fetch</td>
<td align="left">与 asyncData 方法类似，用于在渲染页面之前获取数据填充应用的状态树（store）。不同的是 fetch 方法不会设置组件的数据。</td>
</tr>
<tr>
<td align="center">head</td>
<td align="left">配置当前页面的 Meta 标签</td>
</tr>
<tr>
<td align="center">layout</td>
<td align="left">指定当前页面使用的布局（layouts 根目录下的布局文件）</td>
</tr>
<tr>
<td align="center">loading</td>
<td align="left">如果设置为false，则阻止页面自动调用,</td>
</tr>
<tr>
<td align="center">transition</td>
<td align="left">指定页面切换的过渡动效</td>
</tr>
<tr>
<td align="center">scrollToTop</td>
<td align="left">渲染页面前是否需要将当前页面滚动至顶部</td>
</tr>
<tr>
<td align="center">validate</td>
<td align="left">用于校验 动态路由的参数</td>
</tr>
<tr>
<td align="center">middleware</td>
<td align="left">指定页面的中间件，中间件会在页面渲染之前被调用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ssr</tag>
        <tag>nuxt.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hooks的常见应用及一些原理</title>
    <url>/2021/01/28/React%20Hooks%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="类组件（class）"><a href="#类组件（class）" class="headerlink" title="类组件（class）"></a>类组件（class）</h2><p>类组件的缺点：</p>
<ul>
<li>大型组件很难拆分和重构，也很难测试</li>
<li>业务逻辑分散在组件的各个方法中，导致重复逻辑或关联逻辑</li>
<li>组件类引入复杂的编程模式，比如render、props</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">buttonText</span>: <span class="string">&quot;Click me, please&quot;</span> &#125;;</span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">buttonText</span>: <span class="string">&quot;Thanks, been clicked!&quot;</span> &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; buttonText &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;buttonText&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h2><p>目的：React团队希望，组件不要变成复杂的容器，最好只是数据流的管道，开发者可以根据需要组合管道。<strong>完全不使用类就能写出一个全功能组件</strong></p>
<p>React很早就支持函数组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法有重大限制，必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。</p>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>React核心思想是将页面拆成一堆独立的、可复用的组件，并且用自上而下的数据流串联起来。但是在实际项目中很多组件冗长且难以复用。<br>React Hooks要解决的问题是<strong>状态逻辑复用</strong>。<br><strong>React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。</strong><br>React默认提供了一些常用函数，同时也允许封装自己的钩子，React约定，所有钩子函数一律用use前缀命名，意思是为函数引入外部功能。 </p>
<p>4种常见函数：  </p>
<ul>
<li>useState()</li>
<li>useContext()</li>
<li>useReducer()</li>
<li>useEffect()</li>
</ul>
<h2 id="useState-状态钩子"><a href="#useState-状态钩子" class="headerlink" title="useState(状态钩子)"></a>useState(状态钩子)</h2><p>纯函数不能有状态，useState用于为函数组件引入状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">          Click me</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>useState接收状态初始值，返回一个数组，第一个是状态的当前值，第二个是函数，用来更新状态 *(约定命名为set+状态变量名)*。</p>
<p>count是怎么做到更新的呢？<br>在上例中count只是一个数字，就像下面这行代码一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>组件第一渲染时，从useState拿到初始值0，调用setCount,组件重新渲染，拿到1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span>; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">1</span>; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击两次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">2</span>; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>更新状态，React会重新渲染组件，每一次都拿到独立的count状态，但是这个状态在一次渲染过程中是常量</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleAlertClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">&#x27;You clicked on: &#x27;</span> + count);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleAlertClick&#125;&gt;</span><br><span class="line">        Show alert</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：react根据顺序来保存和使用state</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一次渲染</span></span><br><span class="line"><span class="keyword">const</span> [age, setAge] = useState(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> [fruit, setFruit] = useState(<span class="string">&#x27;banana&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> [todos, setTodos] = useState([&#123; <span class="attr">text</span>: <span class="string">&#x27;Learn Hooks&#x27;</span> &#125;]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次渲染</span></span><br><span class="line">useState(<span class="number">42</span>);  <span class="comment">//读取状态变量age的值（这时候传的参数42直接被忽略）</span></span><br><span class="line">useState(<span class="string">&#x27;banana&#x27;</span>);  <span class="comment">//读取状态变量fruit的值（这时候传的参数banana直接被忽略）</span></span><br><span class="line">useState([&#123; <span class="attr">text</span>: <span class="string">&#x27;Learn Hooks&#x27;</span> &#125;]); <span class="comment">//...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>若将代码改为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> showFruit = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> [age, setAge] = useState(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(showFruit) &#123;</span><br><span class="line">  <span class="keyword">const</span> [fruit, setFruit] = useState(<span class="string">&#x27;banana&#x27;</span>);</span><br><span class="line">  showFruit = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> [todos, setTodos] = useState([&#123; <span class="attr">text</span>: <span class="string">&#x27;Learn Hooks&#x27;</span> &#125;]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次渲染</span></span><br><span class="line">useState(<span class="number">42</span>);  <span class="comment">//读取状态变量age的值（这时候传的参数42直接被忽略）</span></span><br><span class="line"><span class="comment">// useState(&#x27;banana&#x27;);  </span></span><br><span class="line">useState([&#123; <span class="attr">text</span>: <span class="string">&#x27;Learn Hooks&#x27;</span> &#125;]); <span class="comment">//读取到的却是状态变量fruit的值，导致报错</span></span><br></pre></td></tr></table></figure>

<h2 id="useContext-共享状态钩子"><a href="#useContext-共享状态钩子" class="headerlink" title="useContext(共享状态钩子)"></a>useContext(共享状态钩子)</h2><p>有两个组件，我们希望共享他们的状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">    &lt;Navbar/&gt;</span><br><span class="line">    &lt;Messages/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>首先用到React Context，在组件外部建立一个Context（?）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AppContext = React.createContext(&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>之后用AppContext将组件封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;AppContext.Provider value=&#123;&#123;</span><br><span class="line">    username: <span class="string">&#x27;superawesome&#x27;</span></span><br><span class="line">&#125;&#125;&gt;</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">        &lt;Navbar/&gt;</span><br><span class="line">        &lt;Messages/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/AppContext.Provider&gt;</span><br></pre></td></tr></table></figure>
<p>AppContext.Provider提供了一个Context对象，该对象可以被子组件共享</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username &#125; = useContext(AppContext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;my name is &#123;username&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Content</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username &#125; = useContext(AppContext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;Hello, &#123;username&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，react规定我们必须把hooks写在函数的最外层，不能写在ifelse等条件语句当中，来确保hooks的执行顺序一致。</p>
<h2 id="useReducer-action钩子"><a href="#useReducer-action钩子" class="headerlink" title="useReducer(action钩子)"></a>useReducer(action钩子)</h2><p>React本身不提供状态管理功能，通常需要使用外部库，最常用的是Redux</p>
<p>Redux核心概念：组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态。  </p>
<p>Reducer 函数的形式是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(state, action) =&gt; newState</span><br></pre></td></tr></table></figure>

<p>useReducer用来引入Reducer</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br></pre></td></tr></table></figure>
<p>下面是一个计数器</p>
<p>Reducer</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)  &#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="string">&#x27;countUp&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span>  &#123;</span><br><span class="line">            ...state,</span><br><span class="line">            count: state.count + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span>  state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [state, dispatch] = useReducer(myReducer, &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;countUp&quot;</span> &#125;)&#125;&gt;+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">        &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="useEffect-副作用钩子"><a href="#useEffect-副作用钩子" class="headerlink" title="useEffect(副作用钩子)"></a>useEffect(副作用钩子)</h2><p>可将useEffect视为componentDidMount，componentDidUpdate 和 componentWillUnmount 的组合。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  setLoading(<span class="literal">true</span>);</span><br><span class="line">  fetch(<span class="string">`https://cnodejs.org/api/v1/topics?page=<span class="subst">$&#123;pageId&#125;</span>`</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      setTitle(data.data[<span class="number">0</span>].title);</span><br><span class="line">      setLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, [pageId]);</span><br></pre></td></tr></table></figure>

<p>useEffect接收两个参数。第一个是函数，放所需执行的代码，放在componentDidMount里面的代码，可以直接放在useEffect中，第二个参数是一个数组，里面是Effect的依赖项，数组发生变化，useEffect就会执行。第二个参数可以省略，每次渲染就会执行useEffect。  </p>
<p><em>effect是如何读取到最新的count值，并且执行的？</em>  </p>
<p>我们已经知道count是某个特定渲染中的常量。事件处理函数“看到”的是属于它那次特定渲染中的count状态值。对于effects也同样如此，<strong>并不是count的值在“不变”的effect中发生了改变，而是effect 函数本身在每一次渲染中都不相同。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次渲染</span></span><br><span class="line"> useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  fetch(<span class="string">`https://cnodejs.org/api/v1/topics?page=<span class="subst">$&#123;<span class="number">1</span>&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次渲染</span></span><br><span class="line"> useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  fetch(<span class="string">`https://cnodejs.org/api/v1/topics?page=<span class="subst">$&#123;<span class="number">2</span>&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>React会记住你提供的effect函数，在每次DOM更改后调用它，并且，effect函数“看到”，都是它那次的特定的值</p>
<p><em>关于依赖</em></p>
<p><strong>effect中用到的所有组件内的值都要包含在依赖中</strong>，如果设置了错误的依赖项，会怎么样呢？</p>
<p>比如,将一个类组件的定时器改写成useEffect</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.interval = <span class="built_in">setInterval</span>(<span class="built_in">this</span>.tick, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.interval);</span><br><span class="line">  &#125;</span><br><span class="line">  tick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="built_in">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可能会想，我只想运行一次effect，开启一次定时器，清除一次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它只递增了一次，为什么呢？是因为定时器函数被清除了吗？</p>
<p>React只会在浏览器绘制后运行effect。这使得你的应用更流畅，因为大部分effects不会阻塞屏幕更新，Effect的清除同样被延迟了。<strong>上一次的effect会在重新渲染后被清除掉</strong></p>
<p>因为依赖是我们告诉effect需要重新执行的依据，第一次渲染中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setCount(count + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setCount(<span class="number">0</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>而我们的依赖为[],effect不会重新执行，所以之后每一次其实都在调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setCount(<span class="number">0</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="两种解决办法"><a href="#两种解决办法" class="headerlink" title="两种解决办法"></a>两种解决办法</h3><ul>
<li><p>在依赖中包含所有effect中用到的组件内的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ol>
<li>依赖项过多</li>
<li>定时器会在每一次count改变后被清除</li>
</ol>
</li>
<li><p>修改effect内部确保包含的值只在需要时发生变更（减少依赖）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, [count]);</span><br><span class="line"></span><br><span class="line">=&gt; </span><br><span class="line"></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure>
<p>React知道当前状态值，我们只需要告诉react去递增，不需要告诉他具体的值</p>
</li>
</ul>
<h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>我们还可以将hooks代码封装起来，变成自定义的hooks，方便共享</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useTitle = <span class="function">(<span class="params">pageId</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> [title, setTitle] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setLoading(<span class="literal">true</span>);</span><br><span class="line">      fetch(<span class="string">`https://cnodejs.org/api/v1/topics?page=<span class="subst">$&#123;pageId&#125;</span>`</span>)</span><br><span class="line">        .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">        .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          setTitle(data.data[<span class="number">0</span>].title);</span><br><span class="line">          setLoading(<span class="literal">false</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, [pageId]);</span><br><span class="line">    <span class="keyword">return</span> [loading, title]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结束。。。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>React高阶组件</title>
    <url>/2021/09/26/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="React-高阶组件"><a href="#React-高阶组件" class="headerlink" title="React 高阶组件"></a>React 高阶组件</h1><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p>
<blockquote>
<p>具体而言，高阶组件是参数为组件，返回值为新组件的函数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EnhancedComponent &#x3D; higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure>
<p>组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p>
<p>HOC 在 React 的第三方库中很常见，例如 Redux 的 connect 和 Relay 的 createFragmentContainer。</p>
<p>在本文档中，我们将讨论为什么高阶组件有用，以及如何编写自己的 HOC 函数。</p>
<h2 id="使用-HOC-解决横切关注点问题"><a href="#使用-HOC-解决横切关注点问题" class="headerlink" title="使用 HOC 解决横切关注点问题"></a>使用 HOC 解决横切关注点问题</h2><p>组件是 React 中代码复用的基本单元。但你会发现某些模式并不适合传统组件。</p>
<p>例如，假设有一个 CommentList 组件，它订阅外部数据源，用以渲染评论列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CommentList extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      &#x2F;&#x2F; 假设 &quot;DataSource&quot; 是个全局范围内的数据源变量</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    &#x2F;&#x2F; 订阅更改</span><br><span class="line">    DataSource.addChangeListener(this.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    &#x2F;&#x2F; 清除订阅</span><br><span class="line">    DataSource.removeChangeListener(this.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange() &#123;</span><br><span class="line">    &#x2F;&#x2F; 当数据源更新时，更新组件状态</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;this.state.comments.map((comment) &#x3D;&gt; (</span><br><span class="line">          &lt;Comment comment&#x3D;&#123;comment&#125; key&#x3D;&#123;comment.id&#125; &#x2F;&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍后，编写了一个用于订阅单个博客帖子的组件，该帖子遵循类似的模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BlogPost extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      blogPost: DataSource.getBlogPost(props.id)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    DataSource.addChangeListener(this.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    DataSource.removeChangeListener(this.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange() &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      blogPost: DataSource.getBlogPost(this.props.id)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;TextBlock text&#x3D;&#123;this.state.blogPost&#125; &#x2F;&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CommentList 和 BlogPost 不同 - 它们在 DataSource 上调用不同的方法，且渲染不同的结果。但它们的大部分实现都是一样的：</p>
<ul>
<li>在挂载时，向 DataSource 添加一个更改侦听器。</li>
<li>在侦听器内部，当数据源发生变化时，调用 setState。</li>
<li>在卸载时，删除侦听器。</li>
</ul>
<p>你可以想象，在一个大型应用程序中，这种订阅 DataSource 和调用 setState 的模式将一次又一次地发生。我们需要一个抽象，允许我们在一个地方定义这个逻辑，并在许多组件之间共享它。这正是高阶组件擅长的地方。</p>
<p>对于订阅了 DataSource 的组件，比如 CommentList 和 BlogPost，我们可以编写一个创建组件函数。该函数将接受一个子组件作为它的其中一个参数，该子组件将订阅数据作为 prop。让我们调用函数 withSubscription：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const CommentListWithSubscription &#x3D; withSubscription(</span><br><span class="line">  CommentList,</span><br><span class="line">  (DataSource) &#x3D;&gt; DataSource.getComments()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const BlogPostWithSubscription &#x3D; withSubscription(</span><br><span class="line">  BlogPost,</span><br><span class="line">  (DataSource, props) &#x3D;&gt; DataSource.getBlogPost(props.id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>第一个参数是被包装组件。第二个参数通过 DataSource 和当前的 props 返回我们需要的数据。</p>
<p>当渲染 CommentListWithSubscription 和 BlogPostWithSubscription 时， CommentList 和 BlogPost 将传递一个 data prop，其中包含从 DataSource 检索到的最新数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 此函数接收一个组件...</span><br><span class="line">function withSubscription(WrappedComponent, selectData) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...并返回另一个组件...</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">      this.state &#x3D; &#123;</span><br><span class="line">        data: selectData(DataSource, props)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      &#x2F;&#x2F; ...负责订阅相关的操作...</span><br><span class="line">      DataSource.addChangeListener(this.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      DataSource.removeChangeListener(this.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange() &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        data: selectData(DataSource, this.props)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      &#x2F;&#x2F; ... 并使用新数据渲染被包装的组件!</span><br><span class="line">      &#x2F;&#x2F; 请注意，我们可能还会传递其他属性</span><br><span class="line">      return &lt;WrappedComponent data&#x3D;&#123;this.state.data&#125; &#123;...this.props&#125; &#x2F;&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。</p>
<p>被包装组件接收来自容器组件的所有 prop，同时也接收一个新的用于 render 的 data prop。HOC 不需要关心数据的使用方式或原因，而被包装组件也不需要关心数据是怎么来的。</p>
<p>因为 withSubscription 是一个普通函数，你可以根据需要对参数进行增添或者删除。例如，您可能希望使 data prop 的名称可配置，以进一步将 HOC 与包装组件隔离开来。或者你可以接受一个配置 shouldComponentUpdate 的参数，或者一个配置数据源的参数。因为 HOC 可以控制组件的定义方式，这一切都变得有可能。</p>
<p>与组件一样，withSubscription 和包装组件之间的契约完全基于之间传递的 props。这种依赖方式使得替换 HOC 变得容易，只要它们为包装的组件提供相同的 prop 即可。例如你需要改用其他库来获取数据的时候，这一点就很有用。</p>
<h2 id="不要改变原始组件。使用组合。"><a href="#不要改变原始组件。使用组合。" class="headerlink" title="不要改变原始组件。使用组合。"></a>不要改变原始组件。使用组合。</h2><p>不要试图在 HOC 中修改组件原型（或以其他方式改变它）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function logProps(InputComponent) &#123;</span><br><span class="line">  InputComponent.prototype.componentDidUpdate &#x3D; function(prevProps) &#123;</span><br><span class="line">    console.log(&#39;Current props: &#39;, this.props);</span><br><span class="line">    console.log(&#39;Previous props: &#39;, prevProps);</span><br><span class="line">  &#125;;</span><br><span class="line">  &#x2F;&#x2F; 返回原始的 input 组件，暗示它已经被修改。</span><br><span class="line">  return InputComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 每次调用 logProps 时，增强组件都会有 log 输出。</span><br><span class="line">const EnhancedComponent &#x3D; logProps(InputComponent);</span><br></pre></td></tr></table></figure>

<p>这样做会产生一些不良后果。其一是输入组件再也无法像 HOC 增强之前那样使用了。更严重的是，如果你再用另一个同样会修改 componentDidUpdate 的 HOC 增强它，那么前面的 HOC 就会失效！同时，这个 HOC 也无法应用于没有生命周期的函数组件。</p>
<p>修改传入组件的 HOC 是一种糟糕的抽象方式。调用者必须知道他们是如何实现的，以避免与其他 HOC 发生冲突。</p>
<p>HOC 不应该修改传入组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function logProps(WrappedComponent) &#123;</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      console.log(&#39;Current props: &#39;, this.props);</span><br><span class="line">      console.log(&#39;Previous props: &#39;, prevProps);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      &#x2F;&#x2F; 将 input 组件包装在容器中，而不对其进行修改。Good!</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.props&#125; &#x2F;&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该 HOC 与上文中修改传入组件的 HOC 功能相同，同时避免了出现冲突的情况。它同样适用于 class 组件和函数组件。而且因为它是一个纯函数，它可以与其他 HOC 组合，甚至可以与其自身组合。</p>
<p>您可能已经注意到 HOC 与容器组件模式之间有相似之处。容器组件担任将高级和低级关注点分离的责任，由容器管理订阅和状态，并将 prop 传递给处理 UI 的组件。HOC 使用容器作为其实现的一部分，你可以将 HOC 视为参数化容器组件。</p>
<h2 id="将不相关的-props-传递给被包裹的组件"><a href="#将不相关的-props-传递给被包裹的组件" class="headerlink" title="将不相关的 props 传递给被包裹的组件"></a>将不相关的 props 传递给被包裹的组件</h2><p>HOC 为组件添加特性。自身不应该大幅改变约定。HOC 返回的组件与原组件应保持类似的接口。</p>
<p>HOC 应该透传与自身无关的 props。大多数 HOC 都应该包含一个类似于下面的 render 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  &#x2F;&#x2F; 过滤掉非此 HOC 额外的 props，且不要进行透传</span><br><span class="line">  const &#123; extraProp, ...passThroughProps &#125; &#x3D; this.props;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 将 props 注入到被包装的组件中。</span><br><span class="line">  &#x2F;&#x2F; 通常为 state 的值或者实例方法。</span><br><span class="line">  const injectedProp &#x3D; someStateOrInstanceMethod;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 将 props 传递给被包装组件</span><br><span class="line">  return (</span><br><span class="line">    &lt;WrappedComponent</span><br><span class="line">      injectedProp&#x3D;&#123;injectedProp&#125;</span><br><span class="line">      &#123;...passThroughProps&#125;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就保证了 HOC 的灵活性以及可复用性。</p>
<h2 id="最大化可组合性"><a href="#最大化可组合性" class="headerlink" title="最大化可组合性"></a>最大化可组合性</h2><p>并不是所有的 HOC 都一样。有时候它仅接受一个参数，也就是被包裹的组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const NavbarWithRouter &#x3D; withRouter(Navbar);</span><br></pre></td></tr></table></figure>

<p>HOC 通常可以接收多个参数。比如在 Relay 中，HOC 额外接收了一个配置对象用于指定组件的数据依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const CommentWithRelay &#x3D; Relay.createContainer(Comment, config);</span><br></pre></td></tr></table></figure>

<p>最常见的 HOC 签名如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; React Redux 的 &#96;connect&#96; 函数</span><br><span class="line">const ConnectedComment &#x3D; connect(commentSelector, commentActions)(CommentList);</span><br></pre></td></tr></table></figure>

<p>刚刚发生了什么？！如果你把它分开，就会更容易看出发生了什么。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; connect 是一个函数，它的返回值为另外一个函数。</span><br><span class="line">const enhance &#x3D; connect(commentListSelector, commentListActions);</span><br><span class="line">&#x2F;&#x2F; 返回值为 HOC，它会返回已经连接 Redux store 的组件</span><br><span class="line">const ConnectedComment &#x3D; enhance(CommentList);</span><br></pre></td></tr></table></figure>

<p>换句话说，connect 是一个返回高阶组件的高阶函数！</p>
<p>这种形式可能看起来令人困惑或不必要，但它有一个有用的属性。 像 connect 函数返回的单参数 HOC 具有签名 Component =&gt; Component。 输出类型与输入类型相同的函数很容易组合在一起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 而不是这样...</span><br><span class="line">const EnhancedComponent &#x3D; withRouter(connect(commentSelector)(WrappedComponent))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ... 你可以编写组合工具函数</span><br><span class="line">&#x2F;&#x2F; compose(f, g, h) 等同于 (...args) &#x3D;&gt; f(g(h(...args)))</span><br><span class="line">const enhance &#x3D; compose(</span><br><span class="line">  &#x2F;&#x2F; 这些都是单参数的 HOC</span><br><span class="line">  withRouter,</span><br><span class="line">  connect(commentSelector)</span><br><span class="line">)</span><br><span class="line">const EnhancedComponent &#x3D; enhance(WrappedComponent)</span><br></pre></td></tr></table></figure>
<p>（同样的属性也允许 connect 和其他 HOC 承担装饰器的角色，装饰器是一个实验性的 JavaScript 提案。）</p>
<p>许多第三方库都提供了 compose 工具函数，包括 lodash （比如 lodash.flowRight）， Redux 和 Ramda。</p>
<h2 id="包装显示名称以便轻松调试"><a href="#包装显示名称以便轻松调试" class="headerlink" title="包装显示名称以便轻松调试"></a>包装显示名称以便轻松调试</h2><p>HOC 创建的容器组件会与任何其他组件一样，会显示在 React Developer Tools 中。为了方便调试，请选择一个显示名称，以表明它是 HOC 的产物。</p>
<p>最常见的方式是用 HOC 包住被包装组件的显示名称。比如高阶组件名为 withSubscription，并且被包装组件的显示名称为 CommentList，显示名称应该为 WithSubscription(CommentList)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function withSubscription(WrappedComponent) &#123;</span><br><span class="line">  class WithSubscription extends React.Component &#123;&#x2F;* ... *&#x2F;&#125;</span><br><span class="line">  WithSubscription.displayName &#x3D; &#96;WithSubscription($&#123;getDisplayName(WrappedComponent)&#125;)&#96;;</span><br><span class="line">  return WithSubscription;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getDisplayName(WrappedComponent) &#123;</span><br><span class="line">  return WrappedComponent.displayName || WrappedComponent.name || &#39;Component&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>高阶组件有一些需要注意的地方，对于 React 新手来说可能并不容易发现。</p>
<h3 id="不要在-render-方法中使用-HOC"><a href="#不要在-render-方法中使用-HOC" class="headerlink" title="不要在 render 方法中使用 HOC"></a>不要在 render 方法中使用 HOC</h3><p>React 的 diff 算法（称为协调）使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 render 返回的组件与前一个渲染中的组件相同（===），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。</p>
<p>通常，你不需要考虑这点。但对 HOC 来说这一点很重要，因为这代表着你不应在组件的 render 方法中对一个组件应用 HOC：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  &#x2F;&#x2F; 每次调用 render 函数都会创建一个新的 EnhancedComponent</span><br><span class="line">  &#x2F;&#x2F; EnhancedComponent1 !&#x3D;&#x3D; EnhancedComponent2</span><br><span class="line">  const EnhancedComponent &#x3D; enhance(MyComponent);</span><br><span class="line">  &#x2F;&#x2F; 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！</span><br><span class="line">  return &lt;EnhancedComponent &#x2F;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有子组件的状态丢失。</p>
<p>如果在组件之外创建 HOC，这样一来组件只会创建一次。因此，每次 render 时都会是同一个组件。一般来说，这跟你的预期表现是一致的。</p>
<p>在极少数情况下，你需要动态调用 HOC。你可以在组件的生命周期方法或其构造函数中进行调用。</p>
<h3 id="务必复制静态方法"><a href="#务必复制静态方法" class="headerlink" title="务必复制静态方法"></a>务必复制静态方法</h3><p>有时在 React 组件上定义静态方法很有用。例如，Relay 容器暴露了一个静态方法 getFragment 以方便组合 GraphQL 片段。</p>
<p>但是，当你将 HOC 应用于组件时，原始组件将使用容器组件进行包装。这意味着新组件没有原始组件的任何静态方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义静态函数</span><br><span class="line">WrappedComponent.staticMethod &#x3D; function() &#123;&#x2F;*...*&#x2F;&#125;</span><br><span class="line">&#x2F;&#x2F; 现在使用 HOC</span><br><span class="line">const EnhancedComponent &#x3D; enhance(WrappedComponent);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 增强组件没有 staticMethod</span><br><span class="line">typeof EnhancedComponent.staticMethod &#x3D;&#x3D;&#x3D; &#39;undefined&#39; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，你可以在返回之前把这些方法拷贝到容器组件上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function enhance(WrappedComponent) &#123;</span><br><span class="line">  class Enhance extends React.Component &#123;&#x2F;*...*&#x2F;&#125;</span><br><span class="line">  &#x2F;&#x2F; 必须准确知道应该拷贝哪些方法 :(</span><br><span class="line">  Enhance.staticMethod &#x3D; WrappedComponent.staticMethod;</span><br><span class="line">  return Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但要这样做，你需要知道哪些方法应该被拷贝。你可以使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import hoistNonReactStatic from &#39;hoist-non-react-statics&#39;;</span><br><span class="line">function enhance(WrappedComponent) &#123;</span><br><span class="line">  class Enhance extends React.Component &#123;&#x2F;*...*&#x2F;&#125;</span><br><span class="line">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class="line">  return Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了导出组件，另一个可行的方案是再额外导出这个静态方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用这种方式代替...</span><br><span class="line">MyComponent.someFunction &#x3D; someFunction;</span><br><span class="line">export default MyComponent;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...单独导出该方法...</span><br><span class="line">export &#123; someFunction &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...并在要使用的组件中，import 它们</span><br><span class="line">import MyComponent, &#123; someFunction &#125; from &#39;.&#x2F;MyComponent.js&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="Refs-不会被传递"><a href="#Refs-不会被传递" class="headerlink" title="Refs 不会被传递"></a>Refs 不会被传递</h3><p>虽然高阶组件的约定是将所有 props 传递给被包装组件，但这对于 refs 并不适用。那是因为 ref 实际上并不是一个 prop - 就像 key 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。</p>
<p>这个问题的解决方案是通过使用 React.forwardRef API（React 16.3 中引入）。</p>
]]></content>
  </entry>
  <entry>
    <title>SameSiteForCookie</title>
    <url>/2021/02/03/SameSiteForCookie/</url>
    <content><![CDATA[<h1 id="Cookie、Session、Token到底是什么"><a href="#Cookie、Session、Token到底是什么" class="headerlink" title="Cookie、Session、Token到底是什么"></a>Cookie、Session、Token到底是什么</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li>通天塔页面分享至京喜小程序中交互丢失</li>
<li>定位问题为iOS14以上，跨站请求默认不再携带cookie</li>
<li>2月24号 正式宣布将在 iOS、iPad OS 13.4 和 macOS 上的 Safari 13.1 里默认完全屏蔽第三方 Cookie。</li>
<li>随后chrom80版本也做了同样操作</li>
</ol>
<p><a href="https://webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/">Full Third-Party Cookie Blocking and More</a></p>
<h3 id="HTTP是无状态的Web服务器"><a href="#HTTP是无状态的Web服务器" class="headerlink" title="HTTP是无状态的Web服务器"></a>HTTP是无状态的Web服务器</h3><blockquote>
<p>什么是无状态呢？一次对话完成后下一次对话完全不知道上一次对话发生了什么。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">洛：大爷，楼上322住的是马冬梅家吧？</span><br><span class="line">大爷：马都什么？</span><br><span class="line">夏洛：马冬梅。</span><br><span class="line">大爷：什么都没啊？</span><br><span class="line">夏洛：马冬梅啊。</span><br><span class="line">大爷：马什么没？</span><br><span class="line">夏洛：行，大爷你先凉快着吧。</span><br></pre></td></tr></table></figure>

<h3 id="让无状态的服务器记住一些事情"><a href="#让无状态的服务器记住一些事情" class="headerlink" title="让无状态的服务器记住一些事情"></a>让无状态的服务器记住一些事情</h3><blockquote>
<p>当然Web服务器是记不住东西的，我们需要一些外部的办法。</p>
</blockquote>
<h4 id="cookie的产生过程"><a href="#cookie的产生过程" class="headerlink" title="cookie的产生过程"></a>cookie的产生过程</h4><ol>
<li>浏览器第一次访问服务端时，服务器此时肯定不知道他的身份，所以创建一个独特的身份标识数据，格式为key=value，放入到Set-Cookie字段里，随着响应报文发给浏览器。</li>
<li>浏览器看到有Set-Cookie字段以后就知道这是服务器给的身份标识，于是就保存起来，下次请求时会自动将此key=value值放入到Cookie字段中发给服务端。</li>
<li>服务端收到请求报文后，发现Cookie字段中有值，就能根据此值识别用户的身份然后提供个性化的服务。</li>
</ol>
<p><img src= "/img/loading.gif" data-src="./image/http.png" alt="cookie"></p>
<h3 id="搭建一个自己的后台服务器"><a href="#搭建一个自己的后台服务器" class="headerlink" title="搭建一个自己的后台服务器"></a>搭建一个自己的后台服务器</h3><blockquote>
<p>npm install express cors body-parser http-server -S</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>) <span class="comment">// 解析参数</span></span><br><span class="line"><span class="keyword">const</span> corsOptions = &#123;</span><br><span class="line">    origin: [<span class="string">&#x27;http://10.0.49.168:8081&#x27;</span>, <span class="string">&#x27;http://localhost:8081&#x27;</span>],</span><br><span class="line">    credentials: <span class="literal">true</span>,</span><br><span class="line">    optionsSuccessStatus: <span class="number">200</span> <span class="comment">// some legacy browsers (IE11, various SmartTVs) choke on 204</span></span><br><span class="line">&#125;</span><br><span class="line">app.use(cors(corsOptions)) <span class="comment">// 解决跨域</span></span><br><span class="line">app.use(bodyParser.json()) <span class="comment">// json请求</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;</span><br><span class="line">    extended: <span class="literal">false</span></span><br><span class="line">&#125;)) <span class="comment">// 表单请求</span></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at http://127.0.0.1:8080/&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="生成cookie"><a href="#生成cookie" class="headerlink" title="生成cookie"></a>生成cookie</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.cookie(<span class="string">&#x27;cookieName&#x27;</span>, <span class="string">&#x27;cookieValue&#x27;</span>);</span><br><span class="line">    res.send(<span class="string">&#x27;&lt;p&gt;Hello World&lt;/p&gt;&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>访问<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a> 发现Set-Cookie字段</li>
<li>再次访问，cookie已经被携带进去了</li>
<li>访问<a href="http://127.0.0.1:8080/test/">http://127.0.0.1:8080/test/</a> 发现cookie被携带过去了</li>
</ol>
<h3 id="cookie的属性"><a href="#cookie的属性" class="headerlink" title="cookie的属性"></a>cookie的属性</h3><blockquote>
<p>我们知道Cookie就是服务器委托浏览器存储在客户端里的一些数据，而这些数据通常都会记录用户的关键识别信息,cookie会有一些属性用来保护，防止外泄或者窃取。<br><img src= "/img/loading.gif" data-src="./image/cookie.png"></p>
</blockquote>
<ol>
<li>Max-Age/Expires  设置cookie的过期时间，单位为秒</li>
<li>Domain 指定了Cookie所属的域名</li>
<li>Path 指定了Cookie所属的路径</li>
<li>HttpOnly 告诉浏览器此Cookie只能靠浏览器Http协议传输,禁止其他方式访问</li>
<li>Secure 告诉浏览器此Cookie只能在Https安全协议中传输,如果是Http则禁止传输</li>
<li>value 用 JavaScript 操作 Cookie 的时候注意对 Value 进行编码处理。</li>
</ol>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">&#x27;cookieexpires&#x27;</span>, <span class="string">&#x27;cookieexpires&#x27;</span>, &#123;<span class="attr">expires</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">100</span>)&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>当 Expires 属性缺省时，表示是会话性 Cookie,一般值为Session，当为会话性 Cookie 的时候，值保存在客户端内存中，并在用户关闭浏览器时失效。</li>
<li>持久性 Cookies 会保存在用户的硬盘中，直至过期或者清除 Cookie。</li>
<li>设定的日期和时间只与客户端相关，而不是服务端。</li>
</ol>
<h4 id="Max-Age"><a href="#Max-Age" class="headerlink" title="Max-Age"></a>Max-Age</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">&#x27;cookiemaxAge&#x27;</span>, <span class="string">&#x27;cookiemaxAge&#x27;</span>, &#123;<span class="attr">maxAge</span>: <span class="number">300</span>&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>Max-Age 可以为正数、负数、甚至是 0</li>
<li> max-Age 属性为正数时，浏览器会将其持久化，即写到对应的 Cookie 文件中</li>
<li>max-Age 属性为负数，则表示该 Cookie 只是一个会话性 Cookie</li>
<li>max-Age 为 0 时，则会立即删除这个 Cookie</li>
<li>Expires 和 Max-Age 都存在，Max-Age 优先级更高</li>
</ol>
<h4 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">&#x27;cookieDomain&#x27;</span>, <span class="string">&#x27;cookieDomain&#x27;</span>, &#123;<span class="attr">domain</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>访问<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a> 发现Set-Cookie字段</li>
<li>再次访问，cookie被携带进去了</li>
<li>访问<a href="http://localhost:8080/">http://localhost:8080</a> 发现cookie没有被携带过去</li>
<li>Domain 指定了 Cookie 可以送达的主机名</li>
<li>假如没有指定，那么默认值为当前文档访问地址中的主机部分</li>
<li>不能跨域设置 Cookie: 比如京东域名下的页面把 Domain 设置成百度是无效的</li>
</ol>
<h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">&#x27;cookiePath&#x27;</span>, <span class="string">&#x27;cookiePath&#x27;</span>, &#123;<span class="attr">path</span>: <span class="string">&#x27;/admin&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>访问<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a> 发现Set-Cookie字段</li>
<li>再次访问，cookie没有被携带进去了</li>
<li>访问<a href="http://127.0.0.1:8080/admin">http://127.0.0.1:8080/admin</a> 发现cookie被携带过去了</li>
<li>Path 指定了一个 URL 路径</li>
<li>Domain 和 Path 标识共同定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</li>
</ol>
<h4 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h4><ol>
<li>标记为 Secure 的 Cookie 只应通过被HTTPS协议加密过的请求发送给服务端</li>
</ol>
<h4 id="HTTPOnly"><a href="#HTTPOnly" class="headerlink" title="HTTPOnly"></a>HTTPOnly</h4><ol>
<li>设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击</li>
<li>登录态中的pin就是httponly</li>
</ol>
<h4 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。</p>
<h5 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h5><ol>
<li>Strict 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。</li>
<li>Lax 允许部分第三方请求携带 Cookie</li>
<li>None 无论是否跨站都会发送 Cookie</li>
</ol>
<h6 id="跨域和跨站"><a href="#跨域和跨站" class="headerlink" title="跨域和跨站"></a>跨域和跨站</h6><ol>
<li>同站(same-site)/跨站(cross-site)</li>
<li>同源(same-origin)/跨域(cross-origin)</li>
<li>同源策略的同源是指两个 URL 的协议/主机名/端口一致 判断是比较严格的</li>
<li>Cookie中的「同站」判断就比较宽松：只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口</li>
<li>eTLD 表示有效顶级域名</li>
<li>eTLD+1 则表示，有效顶级域名+二级域名</li>
<li><a href="http://www.jd.com/">www.jd.com</a> 和 <a href="http://www.baidu.com/">www.baidu.com</a> 是跨站</li>
<li><a href="http://www.a.jd.com/">www.a.jd.com</a> 和 <a href="http://www.b.jd.com/">www.b.jd.com</a> 是同站</li>
</ol>
<h6 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h6><p><img src= "/img/loading.gif" data-src="./image/SameSite.png"></p>
<p><a href="https://pro.jingxi.com/mini/active/2xk84tfaKUqLvStvZuExqFh4APPq/index.html?cookie=%7B%22visitkey%22:%2224741336555031603799422594%22,%22__wga%22:%221608022089230.1608022089230.1607414308064.1603799422965.1.37%22,%22PPRD_P%22:%22EA.17078.1.1-LOGID.1608022089346.405882235-CT.138631.36.4%22,%22__jda%22:%22122270672.abe16a807e8ba6679efd909f6eb9587a.1608022089155.1608022089155.1608022089155.1%22,%22__jdv%22:%22122270672%7Cdirect%7Ct_1000578828_xcx_1001_fxrk%7Cxcx%7C-%7C1608022438768%22,%22unpl%22:%22%22,%22wxapp_type%22:2,%22cd_eid%22:%22%22,%22pinStatus%22:4,%22wxapp_openid%22:%22o33sZ0a-42w18t9nPxfE40MSeWUE%22,%22wxapp_version%22:%226.12.100%22,%22buildtime%22:20201210%7D&wxAppName=jx">测试链接</a></p>
<h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><blockquote>
<p>解决方案就是设置 SameSite 为 none。</p>
</blockquote>
<p>注意点</p>
<ol>
<li>HTTP 接口不支持 SameSite=none<blockquote>
<p>如果你想加 SameSite=none 属性，那么该 Cookie 就必须同时加上 Secure 属性，表示只有在 HTTPS 协议下该 Cookie 才会被发送。</p>
</blockquote>
</li>
<li>需要 UA 检测，部分浏览器不能加 SameSite=none<blockquote>
<p>IOS 12 的 Safari 以及老版本的一些 Chrome 会把 SameSite=none 识别成 SameSite=Strict，所以服务端必须在下发 Set-Cookie 响应头时进行 User-Agent 检测，对这些浏览器不下发 SameSite=none 属性</p>
</blockquote>
</li>
</ol>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><blockquote>
<p>Cookie是存储在客户端方，Session是存储在服务端方，客户端只存储SessionId</p>
</blockquote>
<blockquote>
<p>既然浏览器已经通过Cookie实现了有状态这一需求，那么为什么又来了一个Session呢？这里我们想象一下，如果将账户的一些信息都存入Cookie中的话，一旦信息被拦截，那么我们所有的账户信息都会丢失掉。所以就出现了Session，在一次会话中将重要信息保存在Session中，浏览器只记录SessionId一个SessionId对应一次会话请求。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="./image/session.png"></p>
<h3 id="创建Session"><a href="#创建Session" class="headerlink" title="创建Session"></a>创建Session</h3><blockquote>
<p>npm install –save express-session session-file-store</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/session&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, password &#125; = req.query</span><br><span class="line">    req.session.name = name</span><br><span class="line">    req.session.password = password</span><br><span class="line">    res.json(req.session)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>访问<a href="http://127.0.0.1:8080/session?name=yyy&amp;password=123456">http://127.0.0.1:8080/session?name=yyy&amp;password=123456</a> 发现Set-Cookie字段</li>
<li>再次访问，cookie被携带进去了</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/getsession&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.json(req.session.name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>访问<a href="http://127.0.0.1:8080/getsession">http://127.0.0.1:8080/getsession</a> 返回我们之前存储的name</li>
</ol>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><blockquote>
<p>Session是将要验证的信息存储在服务端，并以SessionId和数据进行对应，SessionId由客户端存储，在请求时将SessionId也带过去，因此实现了状态的对应。而Token是在服务端将用户信息经过Base64Url编码过后传给在客户端，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息进行解密后就知道此用户是谁了，这个方法叫做JWT(Json Web Token)。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="./image/token.png"></p>
<blockquote>
<p>Token相比较于Session的优点在于，当后端系统有多台时，由于是客户端访问时直接带着数据，因此无需做共享数据的操作。</p>
</blockquote>
<h4 id="Token的优点"><a href="#Token的优点" class="headerlink" title="Token的优点"></a>Token的优点</h4><ol>
<li>简洁：可以通过URL,POST参数或者是在HTTP头参数发送，因为数据量小，传输速度也很快</li>
<li>自包含：由于串包含了用户所需要的信息，避免了多次查询数据库</li>
<li>因为Token是以Json的形式保存在客户端的，所以JWT是跨语言的</li>
<li>不需要在服务端保存会话信息，特别适用于分布式微服务</li>
</ol>
<h4 id="实现token"><a href="#实现token" class="headerlink" title="实现token"></a>实现token</h4><blockquote>
<p>npm install express-access-token cookie-parser -S</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> accessTokens = [</span><br><span class="line">    <span class="string">&quot;6d7f3f6e-269c-4e1b-abf8-9a0add479511&quot;</span>,</span><br><span class="line">    <span class="string">&quot;110546ae-627f-48d4-9cf8-fd8850e0ac7f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;04b90260-3cb3-4553-a1c1-ecca1f83a381&quot;</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> firewall = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.accessToken, <span class="string">&#x27;====&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> &#123;accessToken&#125; = req.query</span><br><span class="line">    <span class="keyword">const</span> authorized = accessTokens.includes(accessToken || req.accessToken);</span><br><span class="line">    <span class="keyword">if</span> (!authorized) <span class="keyword">return</span> res.status(<span class="number">403</span>).send(<span class="string">&#x27;Forbidden&#x27;</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attaching to route group</span></span><br><span class="line">app.use(<span class="string">&#x27;/api&#x27;</span>,</span><br><span class="line">    expressAccessToken, <span class="comment">// attaching accessToken to request</span></span><br><span class="line">    firewall, <span class="comment">// firewall middleware that handles uses req.accessToken</span></span><br><span class="line">    (req, res) =&gt; res.status(<span class="number">200</span>).send(&#123;</span><br><span class="line">        message: <span class="string">&#x27;api route&#x27;</span></span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// attaching to dedicated method, route</span></span><br><span class="line">app.get(<span class="string">&#x27;/restricted-route&#x27;</span>,</span><br><span class="line">    expressAccessToken, <span class="comment">// attaching accessToken to request</span></span><br><span class="line">    firewall, <span class="comment">// firewall middleware that handles uses req.accessToken</span></span><br><span class="line">    (req, res) =&gt; res.send(<span class="string">&#x27;Welcome to restricted page&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ol>
<li><a href="http://127.0.0.1:8080/restricted-route?accessToken=6d7f3f6e-269c-4e1b-abf8-9a0add479511">http://127.0.0.1:8080/restricted-route?accessToken=6d7f3f6e-269c-4e1b-abf8-9a0add479511</a> </li>
</ol>
<p><a href="https://github.com/wuchangming/https-mitm-proxy-handbook/blob/master/doc/Chapter3.md">HTTPS数字证书和数字证书链</a></p>
<p><a href="https://blog.swwind.me/post/certificate">给 localhost 颁发一份证书</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/101819794">一文彻底搞懂Cookie、Session、Token到底是什么</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/157">浏览器系列之 Cookie 和 SameSite 属性</a></p>
]]></content>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Script Error原因及解法</title>
    <url>/2021/09/09/Script%20Error%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<p><code>Script error</code> 可能是你遇到的最神秘的错误之一, 最让人抓狂的是这种错误没有提供完整的报错信息(错误堆栈), 让排查无从下手.</p>
<h3 id="产生Script-Error的原因"><a href="#产生Script-Error的原因" class="headerlink" title="产生Script Error的原因"></a>产生Script Error的原因</h3><p><code>Script error</code> 有时也被称为跨域错误. 当网站请求并执行一个托管在第三方域名下的脚本，就可能抛出 <code>Script error</code> 最常见的情况是采用CDN托管JS资源.为了更好地理解<code>Script error</code>, 假设有如下HTML页面，部署在 test.com 域名下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test page in http://test.com<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://another-domain.com/app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, url, line, column, error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(message, url, line, column, error);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  foo(); <span class="comment">// 调用app.js中定义的foo方法</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>假定foo方法中的内容如下, 调用了一个未被定义的bar方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// another-domain.com/app.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  bar(); <span class="comment">// ReferenceError: bar is not a function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面运行之后，捕获到的异常信息如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">=&gt;  Script error, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>其实这并不是一个<code>JavaScript bug</code>, 基于安全考虑浏览器有意隐藏其它域JS文件抛出的具体错误信息。这样可以有效避免敏感信息无意中被第三方(不受控制的)脚本捕获到，因此，浏览器只允许同域下的脚本捕获具体的错误信息。其它脚本只知道发生了一个错误，而不知具体发生了什么错误。且看 Webkit源码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bool ScriptExecutionContext::sanitizeScriptError(<span class="built_in">String</span>&amp; errorMessage, int&amp; lineNumber, <span class="built_in">String</span>&amp; sourceURL)</span><br><span class="line">    &#123;</span><br><span class="line">        KURL targetURL = completeURL(sourceURL);</span><br><span class="line">        <span class="keyword">if</span> (securityOrigin()-&gt;canRequest(targetURL))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        errorMessage = <span class="string">`Script error`</span>;</span><br><span class="line">        sourceURL = <span class="built_in">String</span>();</span><br><span class="line">        lineNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>了解了<code>Script error</code>产生的原因, 接下来看看如何解决这类问题。</p>
<h3 id="解法1-开启CORS跨域资源共享"><a href="#解法1-开启CORS跨域资源共享" class="headerlink" title="解法1: 开启CORS跨域资源共享"></a>解法1: 开启CORS跨域资源共享</h3><p>为了跨域捕获<code>javaScript</code>异常，分两步走</p>
<h4 id="第一步-添加-crossorigin-”anonymous”属性"><a href="#第一步-添加-crossorigin-”anonymous”属性" class="headerlink" title="第一步: 添加 crossorigin=”anonymous”属性"></a>第一步: 添加 crossorigin=”anonymous”属性</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://another-domain.com/app.js&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这一步告诉浏览器，目标脚本通过匿名方式获取。这意味着请求脚本时没有潜在的用户身份信息(如cookies、HTTP 证书等)发送到服务端</p>
<h4 id="第二步-添加跨域HTTP响应头"><a href="#第二步-添加跨域HTTP响应头" class="headerlink" title="第二步: 添加跨域HTTP响应头"></a>第二步: 添加跨域HTTP响应头</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//test.com</span></span><br></pre></td></tr></table></figure>
<p>注：大部分主流CDN默认添加了<code>Access-Control-Allow-Origi</code>属性, 如下是CDN的一个示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl --head https://retcode.xxxcdn.com/retcode/bl.js | grep -i <span class="string">&quot;access-control-allow-origin&quot;</span></span><br><span class="line"></span><br><span class="line">=&gt; access-control-allow-origin: *</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>完成上述两步之后，跨域脚本的报错就可以通过<code>window.onerror</code>捕获到，回到之前的案例，重新运行之后，捕获到的结果是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="string">&quot;ReferenceError: bar is not defined&quot;</span>, <span class="string">&quot;http://another-domain.com/app.js&quot;</span>, <span class="number">2</span>, <span class="number">1</span>, [<span class="built_in">Object</span> <span class="built_in">Error</span>]</span><br></pre></td></tr></table></figure>
<h4 id="解法2-try-catch"><a href="#解法2-try-catch" class="headerlink" title="解法2: try catch"></a>解法2: try catch</h4><p>有时候，不容易往HTTP请求响应头里面添加跨域属性，这时还可以考虑<code>try catch</code>这个候选方案回到之前的案例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test page in http://test.com<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://another-domain.com/app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, url, line, column, error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(message, url, line, column, error);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">    foo(); <span class="comment">// 调用app.js中定义的foo方法</span></span></span><br><span class="line"><span class="javascript">  &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">throw</span> e; </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>再次运行，输出结果如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">ReferenceError</span>: bar is not defined</span><br><span class="line">  at foo (http:<span class="comment">//another-domain.com/app.js:2:3)</span></span><br><span class="line">  at http:<span class="comment">//test.com/:15:3</span></span><br><span class="line"></span><br><span class="line">=&gt; <span class="string">&quot;Script error.&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>可以看出来， <code>try catch</code>中的<code>console</code>语句输出了完整的信息, 但<code>window.onerror</code>中只能捕获<code>Script error</code> 基于这个特点，可以在<code>catch</code>语句中，将捕获的异常手动上报。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>微前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Sketch-冷门小技巧</title>
    <url>/2020/12/28/Sketch-%E5%86%B7%E9%97%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>俗话说：<strong>工欲善其事，必先利其器</strong>，工匠想要做好他的的工作，一定要先让工具锋利。设计师想做好设计，提高工作效率，就得熟悉sketch的一些软件的的小技巧，或者经验总结，提升我们的作图效率和规范我们的设计稿；</p>
<h3 id="技巧一：分割线-用-fill-代替-border"><a href="#技巧一：分割线-用-fill-代替-border" class="headerlink" title="技巧一：分割线-用 fill 代替 border"></a>技巧一：分割线-用 fill 代替 border</h3><p>做设计稿的时候，大部分同学都用375 * 667尺寸做设计，这种尺寸的设计稿会用到0.5像素的分割线，这个时候我们如果使用边框的话，分割线底部会遇到没有对齐的情况，造成设计稿的不严谨，在375尺寸做设计的时候，我们可以用形状填充代替border。整个页面的列表就是整齐有序的。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/141033/15/18373/132235/5fd811fdE4f00e5d6/1d8494a1d5f422ac.png" alt="案例页面"></p>
<h3 id="技巧二：尽量用iphoneX做页面设计"><a href="#技巧二：尽量用iphoneX做页面设计" class="headerlink" title="技巧二：尽量用iphoneX做页面设计"></a>技巧二：尽量用iphoneX做页面设计</h3><p>因为 X 的尺寸（375 *  812）与 8 的尺寸（375 * 667）宽度上是一致的，所以用 iphone X 还是用  iphone 8 在宽度上是没有任何差异化影响的；</p>
<p>而使用 iphone X 尺寸的画板设计，我们不需要额外考虑任何适配成本，8的做法和X的做法一致，因为 iOS 的官方 UI kit 中，已经将顶部刘海和底部的 Home Indicator 预留好了，所以完全按照在 8 的画板中的做法去做就好了，而我们却可以同时感受设计稿在 8 和 X 两种尺寸中的效果，也便于注意特殊吸底元素的适配关系，一举两得。</p>
<p>还有一点：使用  iphone X 做设计，在项目复盘的过程中或者准备作品集的时候，我们不需要再次修改自己的设计稿，样机展示上更好看～</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/136512/29/19962/155128/5fd81207E8f427023/defa7615ff0e3ac4.png" alt="iphone 界面"></p>
<h3 id="技巧三：旋转副本功能"><a href="#技巧三：旋转副本功能" class="headerlink" title="技巧三：旋转副本功能"></a>技巧三：旋转副本功能</h3><p>我们想做一个同样形状不同角度组成的图标时，例如加载图标、分类图标等，新建一个图形选择旋转副本功能，填写想要复制的个数，复制之后的形状通过中间的手柄调成想要的角度，就得到了我我们想要的形状，提高效率，具体操作如下；</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/143507/23/18503/96518/5fd81202E205ff5c7/8547952b82026be0.png" alt="旋转副本案例"></p>
<h3 id="技巧四：巧用描边的虚线做设计"><a href="#技巧四：巧用描边的虚线做设计" class="headerlink" title="技巧四：巧用描边的虚线做设计"></a>技巧四：巧用描边的虚线做设计</h3><p>比如我们想做一个仪表盘，除了上述的旋转副本的方式，还有一个便捷的方式可以做出仪表盘的设计，就是巧用描边设置。先设置描边宽度，然后调整虚线和间隔的参数，就得到了仪表盘的效果。可以根据自己想要的效果调整不同的参数，方便快捷。</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/152863/22/10054/181702/5fd81202E95b3cff7/fc02499fecbf91b4.png" alt="小技巧分享-分割线做仪表盘"></p>
<h3 id="技巧五：sketch颜色配置"><a href="#技巧五：sketch颜色配置" class="headerlink" title="技巧五：sketch颜色配置"></a>技巧五：sketch颜色配置</h3><p>在用sketch做设计的时候，我们会发现有时候导出来的图片相比于sketch源文件有点偏灰偏暗，那是因为我们没有对设计稿做正确的的颜色设置。Sketch 色彩设置修改路径如下：</p>
<ul>
<li>Sketch →偏好设置→sRGB IEC61966-2.1</li>
<li>文件→修改颜色描述文件→sRGB IEC61966-2.1</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/131934/14/19929/1186607/5fd81200E70ef7a3f/05ec329c803fbf1a.png" alt="颜色配置"></p>
<h3 id="技巧六：如何用阴影快速的做表格"><a href="#技巧六：如何用阴影快速的做表格" class="headerlink" title="技巧六：如何用阴影快速的做表格"></a>技巧六：如何用阴影快速的做表格</h3><p>以前我们制作的表单的时候，都是先画大的表单，再用横向、竖向分割线分割出表格，这样有个缺点，就是更改单个表格的大小很麻烦，需要移动横竖分割线，比较影响效率，其实还有一种很便捷的方法就是利用1px投影做表格，我们只需要给每个矩形表格添加对应的x、y方向的阴影，再将所有矩形拼接成表达，需要改变单个表格大小的时候，只需要全选，修改单个举行的参数即可。</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/143262/5/18357/39729/5fd81200E35d9cdd6/3047cd41d75951b3.png" alt="表单"></p>
<h3 id="技巧七：检查器支持简单的加减乘除运算"><a href="#技巧七：检查器支持简单的加减乘除运算" class="headerlink" title="技巧七：检查器支持简单的加减乘除运算"></a>技巧七：检查器支持简单的加减乘除运算</h3><p>Sketch检查器的文本输入框支持加减乘除等数学运算，选择一个图层，并在输入框中使用+，–，*，或/等数字运算符号即可。如下图所示，一个500px大小的正方形，在宽度输入框中做“500/4”的除法运算后，正方形的宽度变成了125。通过这样的方式，我们可以快速运算形状等分或者布局宽度大小的运算，特别是在设计稿通常要计算黄金比例或者多倍图的情况下。</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/142507/1/18130/108330/5fd81202E8ba23a27/f0a1b3297051111c.png" alt="形状参数运算"></p>
<h3 id="技巧八：sketch文件压缩"><a href="#技巧八：sketch文件压缩" class="headerlink" title="技巧八：sketch文件压缩"></a>技巧八：<strong>sketch文件压缩</strong></h3><p>界面设计中，有什么列表是需要配置图片的，在源文件中应用很多高清图后，往往会让整个sketch文件变的很大，一是传输不方便，另一个也会导致文件卡顿，反应慢。此时可以使用图层-图片-最小尺寸来对文件进行快速压缩。</p>
<h3 id="技巧九：毛玻璃效果制作"><a href="#技巧九：毛玻璃效果制作" class="headerlink" title="技巧九：毛玻璃效果制作"></a>技巧九：毛玻璃效果制作</h3><p>最近毛玻璃效果的图标突然火了起来，sketch也有相应的功能制作毛玻璃效果，那就是背景模糊工具，跟高斯模糊属性在一起～大家平时用到的高斯模糊效果较多，可能忽略了同属性下的动感模糊、背景模糊等功能。毛玻璃制作效果很简单，想要模糊哪个图层，就给它上层的图层增加背景模糊效果即可</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/132870/32/20188/264337/5fd81201Ed98b68df/1aadc9f642615cc0.png" alt="毛玻璃效果"></p>
<h3 id="技巧十：拖动画板生成图片"><a href="#技巧十：拖动画板生成图片" class="headerlink" title="技巧十：拖动画板生成图片"></a>技巧十：<strong>拖动画板生成图片</strong></h3><p>当我们想将画板内容生成图片，不用再导出图片再拖进sketch，只需要制作导出项，如果所示的预设区域，当鼠标长按鼠标左键，图片上出现小抓手，再将图片直接拖进画板，就生成图片了。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/142116/3/18597/163190/5fd81201E41be08f4/bd42b428dca1c757.png" alt="拖动画板"></p>
]]></content>
      <categories>
        <category>组件设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Sketch组件化设计</title>
    <url>/2020/11/04/Sketch%E7%BB%84%E4%BB%B6%E5%8C%96%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>互联网设计的不断发展，设计提效推动着设计思维的转变。我们不仅要完成业务需求的设计，在关注视觉表现的基础上，还需要加强对项目协同和体验的关注，逐步形成组件化思维做设计。我们不设计界面，我们是设计构成界面的元素。</p>
<p>那什么是组件呢？</p>
<p>组件是经过设计元素解耦，具有标准规范和可复用场景的基本模块。从字面上理解：“组”是设计元素的组合方式，“件”由不同的元件组成。当我们把页面中的不同结构做成组件化，再把不同的组件组成页面，当我们替换组件内容中的元素时，页面中的元素也被替换了。原子设计是就是组件化设计的核心思想。</p>
<p>那组件和设计规范又有什么样的关系？毕竟他们都有颜色、图标、文字、弹窗等相同内容。我觉得这两者应该是相辅相成、相对独立又相互包含，比如工厂里的零件包，里边有螺丝钉、螺丝帽、生产组装说明书，设计规范就类比一纸详细的产品生产组装说明书，组件库则更像是一堆零件+使用说明书，零件的组装就是依照生产组装说明书组装。那我们组件库也是依附于当前的设计规范产生，同时未来我们也将依据设计规范来产出新的符合规范的组件。</p>
<h2 id="原子理论"><a href="#原子理论" class="headerlink" title="原子理论"></a>原子理论</h2><p>说到UI组件库，几乎每篇文章都会说原子理论。在化学中，原子是化学变化中的最小粒子，物体都是由原子构成，原子组合构成分子，分子组合构成有机物，最终形成了宇宙万物。2013年前端工程师 Brad Forst 将此理论运用在界面设计中，形成一套设计系统，包含5个层面：原子、分子、组织、模板、页面。</p>
<p>原子设计就是抽取最小的设计元素，然后对这些小元素进行拼合，形成一个个组件。比如一个页面，有导航、banner、列表、底部导航等模块组成，我们可以将导航、banner、底部导航、列表等分别设计成一个个小组件，再将四个模块的组件拼接成一个页面，提高设计效率。<strong>这是原子设计最基础的理论。</strong>根据这个我们搭建出完整且庞大的组件系统。</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/128988/27/17427/58198/5fa29725Ef6a26d57/c1329f8dbfd048dd.png" alt="图片 1.png"></p>
<h3 id="原子"><a href="#原子" class="headerlink" title="原子"></a>原子</h3><p>原子是化学变化中的最小粒子，也是设计系统中最小的单位。原子包括调色板，分割线，字体、标题、段落文本等单个元素，这些元素有个特点就是最小元素不可再切割，如下图：搜索框、搜索图标、搜索文案，都是一个个原子。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/145661/26/13212/88454/5fa29727E9c22c289/4c0fdc5ceb1ddfad.png" alt="图片 1.png"></p>
<h3 id="分子"><a href="#分子" class="headerlink" title="分子"></a>分子</h3><p>原子排列组合构成了分子。在界面中多以「组件」的形式存在，例如：<a href="https://www.uisdc.com/topic/%E5%AF%BC%E8%88%AA">导航</a>栏、标签栏、搜索框、按钮、弹窗、banner等。</p>
<h3 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h3><p>原子、分子排列组合构成了组织，在界面中多以「模块」的形式存在，例如：商品列表、内容卡片、入口模块、瀑布流图等。</p>
<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><p>原子、分子、组织排列组合构成了模板，在界面中也称为「原型图」，例如：电商展示原型、外卖点单原型、店铺详情原型、商户管理原型、商品分类等。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/155064/11/4692/161542/5fa29722E2fbb58bc/219a17997e8d16a3.png" alt="图片 1.png"></p>
<h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>模板填充了真实的内容（图片、文字等）后形成页面，也就是常说的「视觉稿」，例如：商品列表页、外卖点单页、教育课程页、资讯管理页等。</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/126446/38/17371/1347857/5fa29725Ea1395b3a/7040189dbae686b2.png" alt="图片 1.png"></p>
<h2 id="组件化的优点"><a href="#组件化的优点" class="headerlink" title="组件化的优点"></a>组件化的优点</h2><h3 id="统一：保证视觉、交互"><a href="#统一：保证视觉、交互" class="headerlink" title="统一：保证视觉、交互"></a>统一：保证视觉、交互</h3><ul>
<li>整个产品不同模块的业务按照统一规范使用，提升整个产品的视觉交互统一性，减少开发样式，提升开发效率。比如日历控件，在整个产品中就应该以一种形式存在，如果一会儿是左右滚动，一会儿是上下滚动，一会儿是下拉列表，就会比较杂乱；</li>
<li>避免不同设计师创造同一功能的不同样式的组件控件；</li>
<li>统一交互设计规则，减少用户操作的困惑，提升产品的体验；</li>
<li>统一视觉风格，保证统一的产品调性。设计师应该找到最合适的方案，做成组件并处处保持统一；</li>
</ul>
<h3 id="高效：提升设计效率"><a href="#高效：提升设计效率" class="headerlink" title="高效：提升设计效率"></a>高效：提升设计效率</h3><ul>
<li>一套设计规范衍生两套组件库，分别为 Sketch ui 组件库和 Auxre 元件库。Sketch ui 组件面向对象为视觉设计师，Auxre 元件库面向对象为交互设计师和产品经理。设计师和产品经理通过拖动组件搭建界面，节约时间，提升工作效率；</li>
<li>减少和缩短设计组件控件的时间，不需要对同一功能组件重新定义，提升设计效率，将更多的时间放在流程体验和设计推动上；</li>
<li>在前期创建组件考虑好组件逻辑，做好每种状态。快速利用组件搭建完整页面，替换原子、分子元素，提升设计效率；</li>
</ul>
<h3 id="灵活："><a href="#灵活：" class="headerlink" title="灵活："></a>灵活：</h3><ul>
<li>在创建组件的时候设置好智能布局，可以灵活的手动改变组件控件的宽度和高度，或者组件根据文本内容自适应；</li>
</ul>
<h3 id="复用：方便后续修改和延续"><a href="#复用：方便后续修改和延续" class="headerlink" title="复用：方便后续修改和延续"></a>复用：方便后续修改和延续</h3><ul>
<li>增加模块的复用性，不同设计师对于相同模块的设计，可以利用组件直接复用；组件必定是高频复用的，通过建立完整的组件库，根据业务场景变更可以直接修改组件，复用到页面中；</li>
</ul>
<h3 id="协作：方便不同设计师协作"><a href="#协作：方便不同设计师协作" class="headerlink" title="协作：方便不同设计师协作"></a>协作：方便不同设计师协作</h3><ul>
<li>团队成员增加或减少，都不必焦虑，新人可以通过设计规范和组件库迅速熟悉项目并上手;</li>
</ul>
<h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><h3 id="（一）组件命名"><a href="#（一）组件命名" class="headerlink" title="（一）组件命名"></a>（一）组件命名</h3><p>组件的命名逻辑遵循父子级命名（举个栗子🌰：太太爷爷 / 太爷爷 / 爷爷 / 爸爸 / 儿子 / 孙子  😄），在sketch中命名时，通过／符号表示层级结构，Sketch会识别到该符号，并自动生成相应的架构。</p>
<p>命名举例：XX页面 / XX分类 / xx模块 / xx组件 / 组件状态</p>
<p><strong>当然，建议我们用英文对组件命名</strong></p>
<h3 id="（二）组件分类"><a href="#（二）组件分类" class="headerlink" title="（二）组件分类"></a>（二）组件分类</h3><p><strong>原生组件</strong>，顾名思义就是系统本身自带的组件类型，例如按钮、导航、弹窗等等。</p>
<p><strong>扩展组件</strong>，是基于原有组件基础，进行功能扩展，例如在导航栏上加下拉操作，在弹窗中加操作项等等。</p>
<p><strong>自定义组件</strong>，所谓自定义组件就是原本系统中没有，我们根据产品特点创造出来的特有组件。</p>
<p><strong>封装组件</strong>，是指对产品中经常出现的一系列场景页面进行组合封装的复杂组件。</p>
<p>这四个概念中，原生组件和扩展组件都属于系统（Android &amp; iOS官方规范）导向的类型，所以我们暂且统称为基础组件；这类组件存在于大部分App中，例如导航栏、工具栏、弹窗、toast、按钮等就是基础组件。</p>
<p>自定义组件和封装组件，具有较强的产品功能导向，因此称为属性组件。这类组件跟产品功能有较强的关联性，比如效率管理App中常用的日历组件，视频App常用的播放器组件，读书App内的推书列表组件、金融App内的行情趋势组件等。</p>
<p>做这样的区分，可以让我们对组件有更加充分的理解，两个类别的组件在构建时也存在较大的差异，区别对待可以帮助我们更好的理解、构建和调用；有了明确的定义，我们在构建组件库时就能明确类型，合理规划，有效的进行搭建的前期工作。</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/140090/1/13266/136756/5fa2972dE875da4d2/954415d3dced3220.png" alt="图片 1.png"></p>
<h3 id="（三）组件响应式"><a href="#（三）组件响应式" class="headerlink" title="（三）组件响应式"></a>（三）组件响应式</h3><p>先了解一下响应式布局的一些设置：靠边固定、固定尺寸、固定宽度、高度，还有一些布局方式：从左往右、从右往左、居中布局等；</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/131725/19/14828/128016/5fa29721Ea9478a72/91a0964f5eceba9a.png" alt="图片 1.png"></p>
<p>我们在创建组件的时候可以选择性赋予不同方向的属性，赋予属性之后组件内容增加或减少会根据设置的方向改变组件的宽高。只能存在一种属性或者无属性。</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/130294/40/14852/1349787/5fa2972dE42c21aaf/e0a06220aec10b89.gif" alt="图片 1.png"></p>
<p>如下图的案例：头像、产品信息可以采用左对齐布局，右边的按钮可以采取从右向左布局；</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/124389/22/17480/255995/5fa29722Ee8d88d6a/3dfa2de996458435.png" alt="图片 1.png"></p>
<h3 id="（四）组件应用"><a href="#（四）组件应用" class="headerlink" title="（四）组件应用"></a>（四）组件应用</h3><p>制作完组件库的 sketch 部署之后我们就需要把它真正地应用起来了。</p>
<p>我们可以通过 sketch/首选项/添加组件库的方式将我们刚刚部署完的 sketch导入。之后就可以在 sketch/置入/组件中找到对应的文件直接进行拖拽元素使用。</p>
<p>如何进行云同步呢？</p>
<p>首先我们需要做的是登录 sketch cloud 账户，登录 sketch cloud 账户之后，我们需要将组件库源文件上传成为 cloud 文档（sketch&gt;文件&gt;打开 cloud 文档&gt;新 cloud 文档）。这里我们还可以点击已上传的 cloud 组件库文档进行编辑和更新，之后记得在 sketch cloud 里添加同事。这样一来所有设计同事都可以在 sketch 里更新下载新的组件库直接拖拽使用（一般 cloud 组件云更新后 sketch 的右上角都有「红色通知提示」，是可以直接点开更新下载的）。</p>
<h2 id="框架化思维做组件"><a href="#框架化思维做组件" class="headerlink" title="框架化思维做组件"></a>框架化思维做组件</h2><p>文章上部分我们说了Sketch的组件化，现在来说一下组件设计内容框架化。</p>
<h3 id="什么是框架化？"><a href="#什么是框架化？" class="headerlink" title="什么是框架化？"></a>什么是框架化？</h3><p>框架化设计，即在盒子里做设计。前端页面上所有的html元素都可以看作是盒子，即整个html页面就是由无数个盒子通过特定的布局结合在一起的，每个盒子包括内容（content）、内边距（padding）、边框（border）、外边距（margin），我们在做界面设计时，也可以遵循盒子模型做设计。</p>
<h3 id="框架化设计的案例"><a href="#框架化设计的案例" class="headerlink" title="框架化设计的案例"></a>框架化设计的案例</h3><p>接下来通过几个案例来解释怎么把页面框架化。</p>
<h4 id="用框架化做一个日历组件"><a href="#用框架化做一个日历组件" class="headerlink" title="用框架化做一个日历组件"></a><strong>用框架化做一个日历组件</strong></h4><p>如下图：</p>
<p>比我们要做一个如下的日历提醒相关的页面，我们要先分析一下页面的组成元素，日历需要有头部(所处年月)、上下翻页按钮、日期、星期、状态（今天、事件、提醒、选中日历）等。怕思维混乱可以先在思维导图中将所有状态列出来，然后在sketch中罗列出各种状态的组件。</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/144811/28/13317/185911/5fa29721Ee0cd32a8/2216a9a2abe74d1f.png" alt="图片 1.png"></p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/154008/6/4714/149699/5fa29720E42338290/c5801607c178c21f.png" alt="图片 1.png"></p>
<p><strong>接下来，我们可以将页面元素都按照盒子模型做成一个个组件。</strong></p>
<ul>
<li><p>所处年月一栏有左右箭头和年月，我们可以将这三个元素放在长方形框内，做成一个长方形的盒子模型；</p>
</li>
<li><p>日历中的日期、星期可以根据自身需求放在长方形或者正方形的盒子内，做出日期的不同状态。保证同样的大小可以便于我们做组件替换；</p>
</li>
<li><p>分割线同理，也可以放在盒子里作框架化。</p>
<p>如下图，左边就是我们通过框架化做出来的日历的分子组件。右图是将分子组件组合起来的日历控件。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/151712/29/4742/220615/5fa29726E180f2b45/a0cc5339e7e6947a.png" alt="图片 1.png"></p>
</li>
</ul>
<p>通过下图对比，左边是没有用框架化做的UI界面，右边是用框架化做的UI界面，显然右边的页面整齐有序。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/141848/11/13196/126517/5fa29721E3eb1287e/04c5cb9aaa2d0e65.png" alt="图片 1.png"></p>
<p>做好日历组件，我们可以在当前文档中找到当前组件，选中任意想替换的分子元素进行替换，提高设计效率。</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/137192/38/14753/1351365/5fa2972aEe8576784/479b660e1e9e8951.png" alt="图片 1.png"></p>
<h4 id="用框架化做一个理财产品列表"><a href="#用框架化做一个理财产品列表" class="headerlink" title="用框架化做一个理财产品列表"></a><strong>用框架化做一个理财产品列表</strong></h4><p>如下图，左边是没有框架化做的理财列表组件，右边是框架化的列表，右边相对左边会工整有序一点。</p>
<p>需要注意的是：</p>
<ul>
<li>在按钮做组件的时候，在布局约束的时候要选择好从左往右布局，这样在填充文字的时候按钮宽度可以根据文字自动扩展；</li>
<li>文本字符不确定时，要规范好最长文本宽度：如七日年化一行，需要规范最大宽度和距离右侧文本的固定距离；</li>
<li><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/143854/19/13340/254746/5fa29720Ee41d822d/b03367281bc22e1f.png" alt="图片 1.png"></li>
</ul>
<h2 id="优秀的组件库推荐"><a href="#优秀的组件库推荐" class="headerlink" title="优秀的组件库推荐"></a>优秀的组件库推荐</h2><p>IBM公司设计组件库   <a href="https://www.ibm.com/design/language/">https://www.ibm.com/design/language/</a></p>
<p>蚂蚁金融组件库   <a href="https://ant.design/index-cn">https://ant.design/index-cn</a></p>
<p>奥迪公司组件库   <a href="https://www.audi.com/ci/en/guides/user-interface/introduction.html">https://www.audi.com/ci/en/guides/user-interface/introduction.html</a></p>
<p>苹果Apple 设计组件及规范<a href="https://developer.apple.com/design/human-interface-guidelines/ios/overview/themes/">https://developer.apple.com/design/human-interface-guidelines/ios/overview/themes/</a></p>
<p>谷歌google 设计组件及规范 <a href="https://material.io/">https://material.io/</a></p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>Sketch</tag>
        <tag>设计组件</tag>
      </tags>
  </entry>
  <entry>
    <title>StoryBook+TypseScript组件库搭建</title>
    <url>/2020/12/28/StoryBook-TypseScript%E7%BB%84%E4%BB%B6%E5%BA%93%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>组件库的存在可以大大提高开发效率。但就像盖房子一样，地基先打好，并且可能需要晾晒几天，之后的建筑才能更牢固。今天我就自己按照官方文档搭建的storybook组件库给大家做一个分享。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>   创建项目库：</li>
<li>   引入storybook</li>
<li>   配置storybook环境代码及处理报错</li>
<li>   编写组件</li>
<li>   增加Class作用域</li>
<li>   预览组件</li>
<li>   发布组件</li>
</ol>
<h2 id="创建组件库"><a href="#创建组件库" class="headerlink" title="创建组件库"></a>创建组件库</h2><ol>
<li><p>   如果你已经有自己的任何一个（React+TS）项目，不用管里面的其他项目文件，这个项目就可以用。但是注意要删除所有的.lock文件。因为在storybook初始化的时候，.lock文件可能会导致安装storybook失败。</p>
</li>
<li><p>   如果没有项目库，你可以自己在空文件夹中执行$ npx create-react-app echo-rui  –typescript 命令来创建自己的项目。这里关于React配置TS我就不做介绍了，具体可以参考网上配置。</p>
</li>
</ol>
<h2 id="引入StoryBook"><a href="#引入StoryBook" class="headerlink" title="引入StoryBook"></a>引入StoryBook</h2><p>在已有项目命令行执行$ npx sb init  此操作命令根据你当前的package.json文件自动配置需要的storybook环境，包括适配TS的一些配置。安装大概需要3分钟。安装完成后，就可以看到命令行窗口提示:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm run storybook</span><br></pre></td></tr></table></figure>
<p>来预览效果</p>
<p><img src= "/img/loading.gif" data-src="1.png"></p>
<h2 id="配置storybook环境代码及处理报错"><a href="#配置storybook环境代码及处理报错" class="headerlink" title="配置storybook环境代码及处理报错"></a>配置storybook环境代码及处理报错</h2><p>运行的预览效果是在init的时候，会在src/stories下面生成3个demo组件，Button、Page、Header<br>运行时可能会报错的消息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">loose must be same ...</span><br></pre></td></tr></table></figure>
<p>解决办法：将babel.config中加入‘loose: true’</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>, </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;loose&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;corejs&quot;</span>: <span class="string">&quot;3&quot;</span>, <span class="comment">// 声明 corejs 版本</span></span><br><span class="line">        <span class="string">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;@babel/preset-react&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;react-hot-loader/babel&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@babel/plugin-proposal-object-rest-spread&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;loose&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ], <span class="comment">// 支持类属性写法</span></span><br><span class="line">    [<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>, &#123; <span class="string">&quot;legacy&quot;</span>: <span class="literal">true</span> &#125;], <span class="comment">// 支持装饰器语法</span></span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;react-css-modules&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        generateScopedName: <span class="string">&#x27;[local]___[hash:base64:5]&#x27;</span>,</span><br><span class="line">        exclude: <span class="string">&#x27;node_modules&#x27;</span>,</span><br><span class="line">        filetypes: &#123;</span><br><span class="line">          <span class="string">&#x27;.scss&#x27;</span>: &#123;</span><br><span class="line">            syntax: <span class="string">&#x27;postcss-scss&#x27;</span>,</span><br><span class="line">            <span class="comment">// plugins: [&#x27;postcss-nested&#x27;]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决报错信息后，重新运行 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm run storybook</span><br></pre></td></tr></table></figure>

<p>命令，预览页面，可以看到页面在本地6006端口（默认配置）运行</p>
<p><img src= "/img/loading.gif" data-src="4.png"></p>
<p>此时生成的demo组件类型是根据项目环境生产的，即如果你配置了TS环境，生成的文件类型就是.tsx否则就是.js文件</p>
<h2 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h2><ol>
<li>   在src下创建components文件夹，将组件分类放在components/下，组件使用.tsx后缀。本项目使用了scss文件。</li>
<li>   可以自己直接本地编辑一个简单组件或者从之前的项目中直接拷贝一个TS组件。</li>
<li>   如果想要预览效果，此时就需要书写components/mycomponent/ mycomponent.stories.tsx文件。<br>书写格式及具体内容可以参考项目初始化的时候，生成的demo文件。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// also exported from &#x27;@storybook/react&#x27; if you can deal with breaking changes in 6.1</span></span><br><span class="line"><span class="keyword">import</span> &#123; Story, Meta &#125; <span class="keyword">from</span> <span class="string">&#x27;@storybook/react/types-6-0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Button, ButtonProps &#125; <span class="keyword">from</span> <span class="string">&#x27;./Button&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  title: <span class="string">&#x27;Example/Button&#x27;</span>,</span><br><span class="line">  component: Button,</span><br><span class="line">  argTypes: &#123;</span><br><span class="line">    backgroundColor: &#123; <span class="attr">control</span>: <span class="string">&#x27;color&#x27;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125; <span class="keyword">as</span> Meta;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Template: Story&lt;ButtonProps&gt; = <span class="function">(<span class="params">args</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> &#123;<span class="attr">...args</span>&#125; /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Primary = Template.bind(&#123;&#125;);</span><br><span class="line">Primary.args = &#123;</span><br><span class="line">  primary: <span class="literal">true</span>,</span><br><span class="line">  label: <span class="string">&#x27;Button&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Secondary = Template.bind(&#123;&#125;);</span><br><span class="line">Secondary.args = &#123;</span><br><span class="line">  label: <span class="string">&#x27;Button&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Large = Template.bind(&#123;&#125;);</span><br><span class="line">Large.args = &#123;</span><br><span class="line">  size: <span class="string">&#x27;large&#x27;</span>,</span><br><span class="line">  label: <span class="string">&#x27;Button&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Small = Template.bind(&#123;&#125;);</span><br><span class="line">Small.args = &#123;</span><br><span class="line">  size: <span class="string">&#x27;small&#x27;</span>,</span><br><span class="line">  label: <span class="string">&#x27;Button&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>.stories.tsx文件相当于一个单独的页面，所以需要给其配置Meta标签，并且设置title,component即当前组件，通过import方式引入。</p>
<p>Story使用其渲染功能（Canvas）将args绑定在渲染模板上，即可实现切换按钮展示不同组件模式功能。<br>.stories.tsx文件是支持在storybook中预览的文件（作用是本地预览）其实和使用组件没有什么关系。具体storybook的预览原理请参考我的另一篇博客**<strong>**</strong></p>
<h2 id="增加样式作用域"><a href="#增加样式作用域" class="headerlink" title="增加样式作用域"></a>增加样式作用域</h2><ul>
<li>我们书写的组件，如果两个组件的class一样的话，样式就会被污染覆盖。解决这个问题，需要配置css-modules给样式增加哈希值，具体配置如下：</li>
<li><ol>
<li>babel.config.js中</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;react-hot-loader/babel&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@babel/plugin-proposal-object-rest-spread&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;loose&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ], <span class="comment">// 支持类属性写法</span></span><br><span class="line">    [<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>, &#123; <span class="string">&quot;legacy&quot;</span>: <span class="literal">true</span> &#125;], <span class="comment">// 支持装饰器语法</span></span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;react-css-modules&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        generateScopedName: <span class="string">&#x27;[local]___[hash:base64:5]&#x27;</span>,</span><br><span class="line">        exclude: <span class="string">&#x27;node_modules&#x27;</span>,</span><br><span class="line">        filetypes: &#123;</span><br><span class="line">          <span class="string">&#x27;.scss&#x27;</span>: &#123;</span><br><span class="line">            syntax: <span class="string">&#x27;postcss-scss&#x27;</span>,</span><br><span class="line">            <span class="comment">// plugins: [&#x27;postcss-nested&#x27;]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>在.storybook/webpack.config.js中配置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mjs|jsx?)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="built_in">require</span>.resolve(<span class="string">&#x27;babel-loader&#x27;</span>),</span><br><span class="line">            options: &#123;</span><br><span class="line">              cacheDirectory: path.join(</span><br><span class="line">                appDirectory,</span><br><span class="line">                <span class="string">&#x27;/node_modules/.cache/storybook&#x27;</span></span><br><span class="line">              ),</span><br><span class="line">              babelrc: <span class="literal">false</span>,</span><br><span class="line">              plugins: [</span><br><span class="line">                [</span><br><span class="line">                  <span class="built_in">require</span>.resolve(<span class="string">&#x27;babel-plugin-react-docgen&#x27;</span>),</span><br><span class="line">                  &#123;</span><br><span class="line">                    DOC_GEN_COLLECTION_NAME: <span class="string">&#x27;STORYBOOK_REACT_CLASSES&#x27;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        include: [appDirectory],</span><br><span class="line">        exclude: [path.join(appDirectory, <span class="string">&#x27;/node_modules&#x27;</span>)]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(ts|tsx)$/</span>,</span><br><span class="line">        loader: <span class="built_in">require</span>.resolve(<span class="string">&#x27;ts-loader&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.md$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="built_in">require</span>.resolve(<span class="string">&#x27;raw-loader&#x27;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(s*)css$/</span>,</span><br><span class="line">        sideEffects: <span class="literal">true</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="built_in">require</span>.resolve(<span class="string">&#x27;style-loader&#x27;</span>),</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="built_in">require</span>.resolve(<span class="string">&#x27;css-loader&#x27;</span>),</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">1</span>,</span><br><span class="line">              modules: &#123;</span><br><span class="line">                localIdentName: <span class="string">&#x27;[local]___[hash:base64:5]&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="3">
<li>注意：Typescript中使用css-modules解析css，需要使用className={style.class}才能正确解析.ts文件中的类，并且加上哈希值。</li>
</ol>
</li>
</ul>
<h2 id="预览组件"><a href="#预览组件" class="headerlink" title="预览组件"></a>预览组件</h2><ul>
<li>执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm run storybook </span><br></pre></td></tr></table></figure>

<p>就可以看到组件运行的样子。恭喜你，已经拥有一个自己写的组件并且可以本地预览效果了。之后其他成员想看组件效果，可以直接在这个组件库下面执行预览命令。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><ul>
<li>发布到npm之前需要先完善一下README.md文档。同时，根目录下创建一个.npmignore文件。登录自己的npm账号，最后执行npm publish ,发布即可</li>
</ul>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Storybook-typescript重构</title>
    <url>/2020/12/28/Storybook-typescript%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<p>TypeScript流行开来，大型项目的开发目前大多都已经加入了这一强类型校验语言，那么我们之前搭建的组件库引入TypeScript就显得势在必行。怎样在已有组件库项目中配置相关内容并且很好兼容之前组件。本文就是我的践行之路，写出来自己的经历，供大家借鉴，指正。</p>
<h2 id="背景-React-StoryBook"><a href="#背景-React-StoryBook" class="headerlink" title="背景 React + StoryBook"></a>背景 React + StoryBook</h2><ol>
<li>   StoryBook是什么</li>
<li>   StoryBook预览结构</li>
<li>   StoryBook文件结构</li>
<li>   引入TypeScript依赖</li>
<li>   修改配置文件config</li>
<li>   预览组件</li>
<li>   发布组件</li>
</ol>
<h2 id="StoryBook是什么"><a href="#StoryBook是什么" class="headerlink" title="StoryBook是什么"></a>StoryBook是什么</h2><ol>
<li>   Storybook是一个UI工具，组件库，可以让我们的项目开发，更高效，更独立。他可以让你只写组件，而不用开始一个大型项目，开发组件的同时，组件开发完成，只要在项目中引用，便可以快速搭建起一个页面。</li>
<li>   Storybook的开发，不依赖项目，就可以本地预览，查看效果，自己调试。独立完成组件的开发。</li>
</ol>
<h2 id="Storybook预览结构"><a href="#Storybook预览结构" class="headerlink" title="Storybook预览结构"></a>Storybook预览结构</h2><ol>
<li>   编辑好的组件，都放在左侧侧边栏上面，当你点击任何一个组件实现预览的时候，Storybook都会在右侧画布里面插入一个iframe：</li>
</ol>
<p><img src= "/img/loading.gif" data-src="img3.png"></p>
<p>你可以在这个iframe中看到组件的基本Dom结构，包括它生成后的class及内容。<br>2.    右侧的预览窗口同时提供了工具栏，可以切换工具以查看不同状态下的组件预览格式。<img src= "/img/loading.gif" data-src="img1.png"><br>3.    调整方式包括：放大、缩小、背景色、位置等。<br>4.    Docs选项显示的是自动生成的组件文档（基于源代码），使用文档在与团队<br>开发并且共享组件的时候很有用处。<br>5.    Storybook还提供了可以自定义的工具栏，但是这需要自己手动安装Storybook的插件。<br>6.    画布下方的controls可以动态的与组件进行数据的交互，相当于我们平常的控制台样式管理打开的模式下，手动的调试一些边缘情况，以查看它的展示效果。<br>7.    画布下方的Actions，顾名思义，是检查动作的按钮，可以在点击等时间中，查看输出状态。就是控制台的功能了。</p>
<p><img src= "/img/loading.gif" data-src="img2.png"></p>
<h2 id="Storybook文件结构"><a href="#Storybook文件结构" class="headerlink" title="Storybook文件结构"></a>Storybook文件结构</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.storybook/main.js   <span class="comment">//storybook入口文件</span></span><br><span class="line">.storybook/prwview.js  <span class="comment">// 本地预览入口文件</span></span><br><span class="line">src/component/mycomponent.js   <span class="comment">// 组件js文件</span></span><br><span class="line">src/component/mycomponent.css  <span class="comment">// 组件样式文件</span></span><br><span class="line">src/component/mycomponent.stories.js  <span class="comment">// 组件预览文件</span></span><br><span class="line">src/index.js<span class="comment">// 组件开发入口文件</span></span><br><span class="line">index.js  <span class="comment">// 入口文件</span></span><br><span class="line">package.json  <span class="comment">// 配置文件</span></span><br><span class="line">babel.config.json   <span class="comment">// 配置文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="引入Storybook依赖"><a href="#引入Storybook依赖" class="headerlink" title="引入Storybook依赖"></a>引入Storybook依赖</h2><p>运行的预览效果是在init的时候，会在src/stories下面生成3个demo组件，Button、Page、Header<br>运行时可能会报错的消息：</p>
<p>命令窗口执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install typescript –s</span><br></pre></td></tr></table></figure>

<p>安装typescript</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Npm install @types/react-css-modules</span><br></pre></td></tr></table></figure>

<p>安装支持TS的css作用域，支持styleName</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Npm install @types/react</span><br></pre></td></tr></table></figure>


<h2 id="修改配置文件config"><a href="#修改配置文件config" class="headerlink" title="修改配置文件config"></a>修改配置文件config</h2><ol>
<li>   在babel.config.js中增加typescript配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    presets: [</span><br><span class="line">      [<span class="string">&#x27;@babel/env&#x27;</span>, &#123; <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>, <span class="attr">corejs</span>: <span class="number">3</span> &#125;],</span><br><span class="line">      <span class="string">&#x27;@babel/react&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;@babel/typescript&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="string">&#x27;@babel/plugin-transform-runtime&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;@babel/proposal-object-rest-spread&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;@babel/transform-react-jsx&#x27;</span>,</span><br><span class="line">      <span class="comment">// [&quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125;],</span></span><br><span class="line">      <span class="string">&#x27;@babel/proposal-class-properties&#x27;</span>,</span><br><span class="line">      [</span><br><span class="line">        <span class="string">&#x27;babel-plugin-react-css-modules&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          generateScopedName: <span class="string">&#x27;[local]___[hash:base64:5]&#x27;</span>,</span><br><span class="line">          exclude: <span class="string">&#x27;node_modules&#x27;</span>,</span><br><span class="line">          filetypes: &#123;</span><br><span class="line">            <span class="string">&#x27;.scss&#x27;</span>: &#123;</span><br><span class="line">              syntax: <span class="string">&#x27;postcss-scss&#x27;</span>,</span><br><span class="line">              plugins: [<span class="string">&#x27;postcss-nested&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>   增加tsconfig.json文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;dist/build/&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;module&quot;</span>: <span class="string">&quot;esnext&quot;</span>,</span><br><span class="line">      <span class="string">&quot;target&quot;</span>: <span class="string">&quot;esnext&quot;</span>,</span><br><span class="line">      <span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>,</span><br><span class="line">      <span class="string">&quot;typeRoots&quot;</span>: [<span class="string">&quot;./@types&quot;</span>, <span class="string">&quot;./node_modules/@types&quot;</span>], </span><br><span class="line">      <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;suppressImplicitAnyIndexErrors&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;src&quot;</span>],</span><br><span class="line">  <span class="string">&quot;exclude&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;config&quot;</span>,</span><br><span class="line">    <span class="string">&quot;public&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>   新增.storybook/webpack.common.config.js文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> appDirectory = fs.realpathSync(process.cwd())</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// your custom plugins</span></span><br><span class="line">  ],</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mjs|jsx?)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="built_in">require</span>.resolve(<span class="string">&#x27;babel-loader&#x27;</span>),</span><br><span class="line">            options: &#123;</span><br><span class="line">              cacheDirectory: path.join(</span><br><span class="line">                appDirectory,</span><br><span class="line">                <span class="string">&#x27;/node_modules/.cache/storybook&#x27;</span></span><br><span class="line">              ),</span><br><span class="line">              babelrc: <span class="literal">false</span>,</span><br><span class="line">              plugins: [</span><br><span class="line">                [</span><br><span class="line">                  <span class="built_in">require</span>.resolve(<span class="string">&#x27;babel-plugin-react-docgen&#x27;</span>),</span><br><span class="line">                  &#123;</span><br><span class="line">                    DOC_GEN_COLLECTION_NAME: <span class="string">&#x27;STORYBOOK_REACT_CLASSES&#x27;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        include: [appDirectory],</span><br><span class="line">        exclude: [path.join(appDirectory, <span class="string">&#x27;/node_modules&#x27;</span>)]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(ts|tsx)$/</span>,</span><br><span class="line">        loader: <span class="built_in">require</span>.resolve(<span class="string">&#x27;ts-loader&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.md$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="built_in">require</span>.resolve(<span class="string">&#x27;raw-loader&#x27;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(s*)css$/</span>,</span><br><span class="line">        sideEffects: <span class="literal">true</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="built_in">require</span>.resolve(<span class="string">&#x27;style-loader&#x27;</span>),</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="built_in">require</span>.resolve(<span class="string">&#x27;css-loader&#x27;</span>),</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">1</span>,</span><br><span class="line">              modules: &#123;</span><br><span class="line">                localIdentName: <span class="string">&#x27;[local]___[hash:base64:5]&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// &#123;</span></span><br><span class="line">          <span class="comment">//   loader: &#x27;typings-for-css-modules-loader&#x27;,</span></span><br><span class="line">          <span class="comment">//   options: &#123;</span></span><br><span class="line">          <span class="comment">//     importLoaders: 1,</span></span><br><span class="line">          <span class="comment">//     modules: true,</span></span><br><span class="line">          <span class="comment">//     namedExport: true,</span></span><br><span class="line">          <span class="comment">//     sass: true,</span></span><br><span class="line">          <span class="comment">//     localIdentName: &#x27;[local]___[hash:base64:5]&#x27;</span></span><br><span class="line">          <span class="comment">//   &#125;</span></span><br><span class="line">          <span class="comment">// &#125;,</span></span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="built_in">require</span>.resolve(<span class="string">&#x27;postcss-loader&#x27;</span>),</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: <span class="string">&#x27;postcss&#x27;</span>,</span><br><span class="line">              postcss: &#123;&#125;,</span><br><span class="line">              syntax: <span class="string">&#x27;postcss-scss&#x27;</span>,</span><br><span class="line">              plugins: <span class="function">() =&gt;</span> [</span><br><span class="line">                <span class="built_in">require</span>(<span class="string">&#x27;postcss-nested&#x27;</span>),</span><br><span class="line">                <span class="built_in">require</span>(<span class="string">&#x27;postcss-flexbugs-fixes&#x27;</span>),</span><br><span class="line">                <span class="built_in">require</span>(<span class="string">&#x27;postcss-preset-env&#x27;</span>)(&#123;</span><br><span class="line">                  autoprefixer: &#123;</span><br><span class="line">                    flexbox: <span class="string">&#x27;no-2009&#x27;</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  stage: <span class="number">3</span></span><br><span class="line">                &#125;),</span><br><span class="line">                <span class="built_in">require</span>(<span class="string">&#x27;postcss-aspect-ratio-mini&#x27;</span>),</span><br><span class="line">                <span class="built_in">require</span>(<span class="string">&#x27;postcss-write-svg&#x27;</span>)(&#123; <span class="attr">utf8</span>: <span class="literal">false</span> &#125;),</span><br><span class="line">                <span class="built_in">require</span>(<span class="string">&#x27;postcss-px-to-viewport&#x27;</span>)(&#123;</span><br><span class="line">                  viewportWidth: <span class="number">750</span>,</span><br><span class="line">                  viewportHeight: <span class="number">1334</span>,</span><br><span class="line">                  unitPrecision: <span class="number">3</span>,</span><br><span class="line">                  viewportUnit: <span class="string">&#x27;vw&#x27;</span>,</span><br><span class="line">                  selectorBlackList: [<span class="string">&#x27;.ignore&#x27;</span>, <span class="string">&#x27;.hairlines&#x27;</span>],</span><br><span class="line">                  minPixelValue: <span class="number">1</span>,</span><br><span class="line">                  mediaQuery: <span class="literal">false</span></span><br><span class="line">                &#125;),</span><br><span class="line">                <span class="built_in">require</span>(<span class="string">&#x27;postcss-viewport-units&#x27;</span>),</span><br><span class="line">                <span class="built_in">require</span>(<span class="string">&#x27;cssnano&#x27;</span>)(&#123;</span><br><span class="line">                  preset: [</span><br><span class="line">                    <span class="string">&#x27;advanced&#x27;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                      reduceIdents: <span class="literal">false</span>,</span><br><span class="line">                      zindex: <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  ],</span><br><span class="line">                  autoprefixer: <span class="literal">false</span>,</span><br><span class="line">                  <span class="string">&#x27;postcss-zindex&#x27;</span>: <span class="literal">false</span></span><br><span class="line">                &#125;)</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(svg|ico|jpg|jpeg|png|gif|eot|otf|webp|ttf|woff|woff2|cur|ani)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="built_in">require</span>.resolve(<span class="string">&#x27;file-loader&#x27;</span>),</span><br><span class="line">        query: &#123; <span class="attr">name</span>: <span class="string">&#x27;static/media/[name].[hash:8].[ext]&#x27;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mp4|webm|wav|mp3|m4a|aac|oga)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="built_in">require</span>.resolve(<span class="string">&#x27;url-loader&#x27;</span>),</span><br><span class="line">        query: &#123; <span class="attr">limit</span>: <span class="number">10000</span>, <span class="attr">name</span>: <span class="string">&#x27;static/media/[name].[hash:8].[ext]&#x27;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.stories\.[j|t]sx?$/</span>,</span><br><span class="line">        loaders: [<span class="built_in">require</span>.resolve(<span class="string">&#x27;@storybook/source-loader&#x27;</span>)],</span><br><span class="line">        enforce: <span class="string">&#x27;pre&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>   修改.storybook/main.js文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> custom = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.config.js&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// stories: [&#x27;../src/**/*.stories.tsx&#x27;],</span></span><br><span class="line">  addons: [</span><br><span class="line">    <span class="string">&#x27;@storybook/addon-actions/register&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@storybook/addon-knobs/register&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@storybook/addon-notes/register-panel&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@storybook/addon-events/register&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@storybook/addon-cssresources/register&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@storybook/addon-storysource&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@storybook/addon-links/register&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@storybook/addon-backgrounds/register&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@storybook/addon-options/register&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@storybook/addon-viewport/register&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@storybook/addon-a11y/register&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  webpackFinal: <span class="keyword">async</span> config =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...config,</span><br><span class="line">      <span class="built_in">module</span>: &#123; ...config.module, <span class="attr">rules</span>: custom.module.rules &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>   修改.storybook/preview.js文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// automatically import all files ending in *.stories.js</span></span><br><span class="line">addDecorator(</span><br><span class="line">  withInfo(&#123;</span><br><span class="line">    inline: <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">addDecorator(withCssResources);</span><br><span class="line">addDecorator(centered);</span><br><span class="line">addDecorator(withA11y);</span><br><span class="line"></span><br><span class="line">addParameters(&#123;</span><br><span class="line">  options: &#123;</span><br><span class="line">    isFullscreen: <span class="literal">false</span>,</span><br><span class="line">    showAddonsPanel: <span class="literal">true</span>,</span><br><span class="line">    showSearchBox: <span class="literal">false</span>,</span><br><span class="line">    panelPosition: <span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">    theme: create(&#123;</span><br><span class="line">      base: <span class="string">&#x27;light&#x27;</span>,</span><br><span class="line">      brandTitle: <span class="string">&#x27;PAIMAI UI&#x27;</span>,</span><br><span class="line">      brandUrl: <span class="string">&#x27;https://zpsy.jd.com/&#x27;</span>,</span><br><span class="line">      gridCellSize: <span class="number">12</span></span><br><span class="line">    &#125;),</span><br><span class="line">    hierarchySeparator: <span class="regexp">/\/|\./</span>,</span><br><span class="line">    hierarchyRootSeparator: <span class="regexp">/\|/</span>,</span><br><span class="line">    enableShortcuts: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  viewport: &#123;</span><br><span class="line">    defaultViewport: <span class="string">&#x27;iphonex&#x27;</span>,</span><br><span class="line">    viewports: INITIAL_VIEWPORTS</span><br><span class="line">  &#125;,</span><br><span class="line">  backgrounds: [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;white&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;#fff&#x27;</span>, <span class="attr">default</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;black&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;#000&#x27;</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  cssresources: [</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="string">`bluetheme`</span>,</span><br><span class="line">      code: <span class="string">`&lt;style&gt;body &#123; background-color: lightblue; &#125;&lt;/style&gt;`</span>,</span><br><span class="line">      picked: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">addDecorator(<span class="function">(<span class="params">storyFn, context</span>) =&gt;</span> withConsole()(storyFn)(context));</span><br><span class="line">setConsoleOptions(&#123;</span><br><span class="line">  panelExclude: []</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStories</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> req = <span class="built_in">require</span>.context(<span class="string">&#x27;../src/components&#x27;</span>, <span class="literal">true</span>, <span class="regexp">/.stories.[j|t]sx?/</span>);</span><br><span class="line">  req.keys().forEach(<span class="function"><span class="params">filename</span> =&gt;</span> req(filename));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configure(loadStories, <span class="built_in">module</span>);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>   新增.storybook/tsconfig.json文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;extends&quot;</span>: <span class="string">&quot;../tsconfig&quot;</span>,</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>,</span><br><span class="line">    <span class="string">&quot;isolatedModules&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;noEmit&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>   修改index.js为index.tsx</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;Button&#x27;</span>;</span><br><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;Header&#x27;</span>;</span><br><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;GoTop&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>注意：正确按照TS格式书写组件，并且应用style.class实现样式作用域问题，如果要使用ES6语言 import styles from ../index.scss 需要增加.index.css.d.ts文件，以声明变量并导出。<br>如果使用了   插件，可以自动生成.css.d.ts但是该插件使用要求babel要降级版本，所以我的项目没有使用这个功能，需要手动添加.css.d.ts文件。如果你有好的方法，请留言</p>
<h2 id="预览组件"><a href="#预览组件" class="headerlink" title="预览组件"></a>预览组件</h2><ul>
<li>执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm run storybook </span><br></pre></td></tr></table></figure>

<p>就可以看到组件运行的样子。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><ul>
<li>发布到npm之前需要先完善一下README.md文档。同时，根目录下创建一个.npmignore文件。登录自己的npm账号，最后执行npm publish ,发布即可</li>
</ul>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Taro(一)</title>
    <url>/2020/09/27/Taro(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Taro 是一套遵循 React 语法规范的 多端开发 解决方案。</p>
</blockquote>
<p>现如今市面上端的形态多种多样，Web、React-Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。<br>使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ 小程序、快应用、H5、React-Native 等）运行的代码。</p>
<h3 id="一、-Taro-的安装与使用"><a href="#一、-Taro-的安装与使用" class="headerlink" title="一、 Taro 的安装与使用"></a>一、 Taro 的安装与使用</h3><h4 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm install -g @tarojs/cli</span><br><span class="line">taro -V</span><br></pre></td></tr></table></figure>

<h4 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h4><p>使用命令创建模板项目</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ taro init myApp</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/103870/1/7228/130625/5df9f76cEa2862a32/b0e215cd4608795e.png"></p>
<h5 id="1-2-1-微信小程序"><a href="#1-2-1-微信小程序" class="headerlink" title="1.2.1 微信小程序"></a>1.2.1 微信小程序</h5><p>选择微信小程序模式，需要自行下载并打开微信开发者工具，然后选择项目根目录进行预览</p>
<p>微信小程序编译预览及打包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># npm script</span><br><span class="line">$ npm run dev:weapp</span><br><span class="line">$ npm run build:weapp</span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-百度小程序"><a href="#1-2-2-百度小程序" class="headerlink" title="1.2.2 百度小程序"></a>1.2.2 百度小程序</h5><p>选择百度小程序模式，需要自行下载并打开百度开发者工具，然后在项目编译完后选择项目根目录下 dist 目录进行预览</p>
<p>百度小程序编译预览及打包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># npm script</span><br><span class="line">$ npm run dev:swan</span><br><span class="line">$ npm run build:swan</span><br></pre></td></tr></table></figure>

<h5 id="1-2-3-支付宝小程序"><a href="#1-2-3-支付宝小程序" class="headerlink" title="1.2.3 支付宝小程序"></a>1.2.3 支付宝小程序</h5><p>选择支付宝小程序模式，需要自行下载并打开支付宝小程序开发者工具，然后在项目编译完后选择项目根目录下 dist 目录进行预览</p>
<p>支付宝小程序编译预览及打包：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># npm script</span><br><span class="line">$ npm run dev:alipay</span><br><span class="line">$ npm run build:alipay</span><br></pre></td></tr></table></figure>

<h5 id="1-2-4-H5"><a href="#1-2-4-H5" class="headerlink" title="1.2.4 H5"></a>1.2.4 H5</h5><p>H5 编译预览及打包：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># npm script</span><br><span class="line">$ npm run dev:h5</span><br><span class="line"></span><br><span class="line"># 仅限全局安装</span><br><span class="line">$ taro build --type h5 --watch</span><br></pre></td></tr></table></figure>

<h5 id="1-2-5-React-Native"><a href="#1-2-5-React-Native" class="headerlink" title="1.2.5 React Native"></a>1.2.5 React Native</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># npm script</span><br><span class="line">$ npm run dev:rn</span><br></pre></td></tr></table></figure>

<h4 id="1-3-更新-Taro"><a href="#1-3-更新-Taro" class="headerlink" title="1.3 更新 Taro"></a>1.3 更新 Taro</h4><p>Taro 提供了更新命令来更新 CLI 工具自身和项目中 Taro 相关的依赖。</p>
<p>更新 taro-cli 工具</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># taro</span><br><span class="line">$ taro update self</span><br><span class="line"># npm</span><br></pre></td></tr></table></figure>

<p>更新项目中 Taro 相关的依赖，这个需要在你的项目下执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ taro update project</span><br></pre></td></tr></table></figure>

<h2 id="二、Taro-开发说明与注意事项"><a href="#二、Taro-开发说明与注意事项" class="headerlink" title="二、Taro 开发说明与注意事项"></a>二、Taro 开发说明与注意事项</h2><h3 id="2-1-微信小程序开发工具的配置"><a href="#2-1-微信小程序开发工具的配置" class="headerlink" title="2.1 微信小程序开发工具的配置"></a>2.1 微信小程序开发工具的配置</h3><blockquote>
<p>由于 Taro 编译后的代码已经经过了转义和压缩，因此还需要注意微信开发者工具的项目设置</p>
</blockquote>
<pre><code>    - 设置关闭 ES6 转 ES5 功能
    - 设置关闭上传代码时样式自动补全
    - 设置关闭代码压缩上传
</code></pre>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/100565/6/7188/257424/5df9fa77E88d2aac4/e3008671ba3e0e2b.png"></p>
<h3 id="2-2-Taro-与-React-的差异"><a href="#2-2-Taro-与-React-的差异" class="headerlink" title="2.2 Taro 与 React 的差异"></a>2.2 Taro 与 React 的差异</h3><p>由于微信小程序的限制，React 中某些写法和特性在 Taro 中还未能实现，后续将会逐渐完善。 截止到本小册发布前，Taro 的最新版本为 1.1，因此以下讲解默认版本为 1.1</p>
<h4 id="2-2-1-暂不支持在-render-之外的方法定义-JSX"><a href="#2-2-1-暂不支持在-render-之外的方法定义-JSX" class="headerlink" title="2.2.1 暂不支持在 render() 之外的方法定义 JSX"></a>2.2.1 暂不支持在 render() 之外的方法定义 JSX</h4><p>由于微信小程序的 template 不能动态传值和传入函数，Taro 暂时也没办法支持在类方法中定义 JSX</p>
<p>无效情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">_render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">renderHeader</span>(<span class="params">showHeader</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> showHeader &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  renderHeader = <span class="function">(<span class="params">showHeader</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> showHeader&amp; &amp; <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>解决方案</p>
<p>在 render 方法中定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; showHeader, showMain &#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> header = showHeader &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line">    <span class="keyword">const</span> main = showMain &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Main</span> /&gt;</span></span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &#123;header&#125;</span><br><span class="line">        &#123;main&#125;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-不能在包含-JSX-元素的-map-循环中使用-if-表达式"><a href="#2-2-2-不能在包含-JSX-元素的-map-循环中使用-if-表达式" class="headerlink" title="2.2.2 不能在包含 JSX 元素的 map 循环中使用 if 表达式"></a>2.2.2 不能在包含 JSX 元素的 map 循环中使用 if 表达式</h4><p>无效情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> element = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">const</span> isOdd = number % <span class="number">2</span></span><br><span class="line">  <span class="keyword">if</span> (isOdd) &#123;</span><br><span class="line">    element = <span class="xml"><span class="tag">&lt;<span class="name">Custom</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> isOdd = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (number % <span class="number">2</span>) &#123;</span><br><span class="line">    isOdd = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOdd &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Custom</span> /&gt;</span></span></span><br><span class="line">&#125;)...</span><br></pre></td></tr></table></figure>

<p>解决方案<br>尽量在 map 循环中使用条件表达式或逻辑表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isOdd = number % <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> isOdd ? <span class="xml"><span class="tag">&lt;<span class="name">Custom</span> /&gt;</span></span> : <span class="literal">null</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isOdd = number % <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> isOdd &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Custom</span> /&gt;</span></span></span><br><span class="line">&#125;)...</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-不能使用-Array-map-之外的方法操作-JSX-数组"><a href="#2-2-3-不能使用-Array-map-之外的方法操作-JSX-数组" class="headerlink" title="2.2.3 不能使用 Array.map 之外的方法操作 JSX 数组"></a>2.2.3 不能使用 Array.map 之外的方法操作 JSX 数组</h4><p>Taro 在小程序端实际上把 JSX 转换成了字符串模板，而一个原生 JSX 表达式实际上是一个 React/Nerv 元素(react - element)的构造器，因此在原生 JSX 中你可以对任何一组 React 元素进行操作。但在 Taro 中你只能使用 map 方法，Taro 转换成小程序中 wx:for…</p>
<p>无效情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test.push(<span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span>)</span><br><span class="line"></span><br><span class="line">numbers.forEach(<span class="function"><span class="params">numbers</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (someCase) &#123;</span><br><span class="line">    a = <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test.shift(<span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span>)</span><br><span class="line"></span><br><span class="line">components.find(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> component === <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">components.some(<span class="function"><span class="params">component</span> =&gt;</span> component.constructor.__proto__ === <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span>.constructor)</span><br><span class="line"></span><br><span class="line">numbers.filter(<span class="built_in">Boolean</span>).map(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span></span><br><span class="line">&#125;)...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决方案</p>
<p>先处理好需要遍历的数组，然后再用处理好的数组调用 map 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">numbers.filter(isOdd).map(<span class="function">(<span class="params">number</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</span><br><span class="line">  <span class="comment">// do you thing with array</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = array.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span></span><br><span class="line">&#125;)...</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-不能在-JSX-参数中使用匿名函数"><a href="#2-2-4-不能在-JSX-参数中使用匿名函数" class="headerlink" title="2.2.4 不能在 JSX 参数中使用匿名函数"></a>2.2.4 不能在 JSX 参数中使用匿名函数</h4><p>无效情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;View onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.handleClick()&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;View onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleClick(e)&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;View onClick=&#123;<span class="function">() =&gt;</span> (&#123;&#125;)&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;View onClick=&#123;<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;View onClick=&#123;<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;<span class="built_in">this</span>.handleClick(e)&#125;&#125; /&gt;...</span><br></pre></td></tr></table></figure>

<p>解决方案<br>使用 bind 或 类参数绑定函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;View onClick=&#123;<span class="built_in">this</span>.props.hanldeClick.bind(<span class="built_in">this</span>)&#125; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-不能在-JSX-参数中使用对象展开符"><a href="#2-2-5-不能在-JSX-参数中使用对象展开符" class="headerlink" title="2.2.5 不能在 JSX 参数中使用对象展开符"></a>2.2.5 不能在 JSX 参数中使用对象展开符</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">微信小程序组件要求每一个传入组件的参数都必须预先设定好，而对象展开符则是动态传入不固定数量的参数。所以 Taro 没有办法支持该功能</span><br></pre></td></tr></table></figure>

<p>无效情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;View &#123;...this.props&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;View &#123;...props&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Custom &#123;...props&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>解决方案<br>开发者自行赋值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id, title &#125; = obj</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">id</span>=<span class="string">&#123;id&#125;</span> <span class="attr">title</span>=<span class="string">&#123;title&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<h4 id="2-2-6-不允许在-JSX-参数（props）中传入-JSX-元素"><a href="#2-2-6-不允许在-JSX-参数（props）中传入-JSX-元素" class="headerlink" title="2.2.6 不允许在 JSX 参数（props）中传入 JSX 元素"></a>2.2.6 不允许在 JSX 参数（props）中传入 JSX 元素</h4><p>由于微信小程序内置的组件化的系统不能通过属性（props） 传函数，而 props 传递函数可以说是 React 体系的根基之一，我们只能自己实现一套组件化系统。而自制的组件化系统不能使用内置组件化的 slot 功能。两权相害取其轻，我们暂时只能不支持该功能…</p>
<p>无效情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Custom child=&#123;<span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span>&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Custom child=&#123;<span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span>&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Custom child=&#123;<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &lt;View /&gt; &#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Custom child=&#123;ary.map(<span class="function"><span class="params">a</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span>)&#125; /&gt;...</span><br></pre></td></tr></table></figure>

<p>解决方案</p>
<p>通过 props 传值在 JSX 模板中预先判定显示内容，或通过 props.children 来嵌套子组件</p>
<h4 id="2-2-7-不支持无状态组件（Stateless-Component"><a href="#2-2-7-不支持无状态组件（Stateless-Component" class="headerlink" title="2.2.7 不支持无状态组件（Stateless Component)"></a>2.2.7 不支持无状态组件（Stateless Component)</h4><p>由于微信的 template 能力有限，不支持动态传值和函数，Taro 暂时只支持一个文件自定义一个组件。为了避免开发者疑惑，暂时不支持定义 Stateless Component</p>
<p>无效情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span> (<span class="params">ary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ary.map(<span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span></span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>解决方案<br>使用 class 定义组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-命名规范"><a href="#2-3-命名规范" class="headerlink" title="2.3 命名规范"></a>2.3 命名规范</h3><blockquote>
<p>Taro 函数命名使用驼峰命名法，如 onClick，由于微信小程序的 WXML 不支持传递函数，函数名编译后会以字符串的形式绑定在 WXML 上，囿于 WXML 的限制，函数名有三项限制</p>
</blockquote>
<ul>
<li>方法名不能含有数字</li>
<li>方法名不能以下划线开头或结尾</li>
<li>方法名的长度不能大于 20</li>
</ul>
<p>请遵守以上规则，否则编译后的代码在微信小程序中会报以下错误</p>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/87738/9/7332/17577/5df9ff7eE715eec9b/966323412d6b2362.png"></p>
<h3 id="2-4-推荐安装-ESLint-编辑器插件"><a href="#2-4-推荐安装-ESLint-编辑器插件" class="headerlink" title="2.4 推荐安装 ESLint 编辑器插件"></a>2.4 推荐安装 ESLint 编辑器插件</h3><blockquote>
<p>Taro 有些写法跟 React 有些差异，可以通过安装 ESLint 相关的编辑器插件来获得人性化的提示。由于不同编辑器安装的插件有所不同，具体安装方法请自行搜索，这里不再赘述。 如下图，就是安装插件后获得的提示</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/103489/37/7243/55767/5df9fff4Ee73bff7f/b3f4a7ffbee37766.png"><br><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/85984/2/7273/51273/5dfa0006Eebdddea8/d35778fc64fcb4bb.png"></p>
<h3 id="2-5-最佳编码方式"><a href="#2-5-最佳编码方式" class="headerlink" title="2.5 最佳编码方式"></a>2.5 最佳编码方式</h3><p>组件传递函数属性名以 on 开头</p>
<p>在 Taro 中，父组件要往子组件传递函数，属性名必须以 on 开头</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 Custom 组件，传入 handleEvent 函数，属性名为 `onTrigger`</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  handleEvent () &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Custom onTrigger=&#123;<span class="built_in">this</span>.handleEvent&#125;&gt;&lt;/Custom&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>这是因为，微信小程序端组件化是不能直接传递函数类型给子组件的，在 Taro 中是借助组件的事件机制来实现这一特性，而小程序中传入事件的时候属性名写法为 bindmyevent 或者 bind:myevent</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 --&gt;</span><br><span class="line">&lt;component-tag-name bindmyevent=<span class="string">&quot;onMyEvent&quot;</span> /&gt;</span><br><span class="line">&lt;!-- 或者可以写成 --&gt;</span><br><span class="line">&lt;component-tag-name bind:myevent=<span class="string">&quot;onMyEvent&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以 Taro 中约定组件传递函数属性名以 on 开头，同时这也和内置组件的事件绑定写法保持一致了…</p>
</blockquote>
<p>小程序端不要在组件中打印传入的函数</p>
<blockquote>
<p>前面已经提到小程序端的组件传入函数的原理，所以在小程序端不要在组件中打印传入的函数，因为拿不到结果，但是 this.props.onXxx &amp;&amp; this.props.onXxx() 这种判断函数是否传入来进行调用的写法是完全支持的…</p>
</blockquote>
<p>小程序端不要将在模板中用到的数据设置为 undefined</p>
<ul>
<li>由于小程序不支持将 data 中任何一项的 value 设为 undefined ，在 setState 的时候也请避免这么用。你可以使用 null 来替代。</li>
<li>小程序端不要在组件中打印 this.props.children<br>在微信小程序端是通过<slot /> 来实现往自定义组件中传入元素的，而 Taro 利用 this.props.children 在编译时实现了这一功能， this.props.children 会直接被编译成 <slot /> 标签，所以它在小程序端属于语法糖的存在，请不要在组件中打印它…</li>
</ul>
<p>组件 state 与 props 里字段重名的问题</p>
<blockquote>
<p>不要在 state 与 props 上用同名的字段，因为这些被字段在微信小程序中都会挂在 data 上</p>
</blockquote>
<p>小程序中页面生命周期 componentWillMount 不一致问题</p>
<blockquote>
<p>由于微信小程序里页面在 onLoad 时才能拿到页面的路由参数，而页面 onLoad 前组件都已经 attached 了。因此页面的 componentWillMount 可能会与预期不太一致。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line">render () &#123;</span><br><span class="line">  <span class="comment">// 在 willMount 之前无法拿到路由参数</span></span><br><span class="line">  <span class="keyword">const</span> abc = <span class="built_in">this</span>.$router.params.abc</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Custom</span> <span class="attr">adc</span>=<span class="string">&#123;abc&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line">componentWillMount () &#123;</span><br><span class="line">  <span class="keyword">const</span> abc = <span class="built_in">this</span>.$router.params.abc</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    abc</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">render () &#123;</span><br><span class="line">  <span class="comment">// 增加一个兼容判断</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.state.abc &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Custom</span> <span class="attr">adc</span>=<span class="string">&#123;abc&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于不需要等到页面 willMount 之后取路由参数的页面则没有任何影响…</p>
<p>JS 编码必须用单引号</p>
<blockquote>
<p>在 Taro 中，JS 代码里必须书写单引号，特别是 JSX 中，如果出现双引号，可能会导致编译错误</p>
</blockquote>
<p>process.env 的使用</p>
<blockquote>
<p>不要以解构的方式来获取通过 env 配置的 process.env 环境变量，请直接以完整书写的方式 process.env.NODE_ENV 来进行使用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法，不支持</span></span><br><span class="line"><span class="keyword">const</span> &#123; NODE_ENV = <span class="string">&#x27;development&#x27;</span> &#125; = process.env</span><br><span class="line"><span class="keyword">if</span> (NODE_ENV === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>预加载</p>
<blockquote>
<p>在微信小程序中，从调用 Taro.navigateTo、Taro.redirectTo 或 Taro.switchTab 后，到页面触发 componentWillMount 会有一定延时。因此一些网络请求可以提前到发起跳转前一刻去请求</p>
</blockquote>
<p>Taro 提供了 componentWillPreload 钩子，它接收页面跳转的参数作为参数。可以把需要预加载的内容通过 return 返回，然后在页面触发 componentWillMount 后即可通过 this.$preloadData 获取到预加载的内容。…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;isFetching: &#x27;</span>, <span class="built_in">this</span>.isFetching)</span><br><span class="line">    <span class="built_in">this</span>.$preloadData</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;res: &#x27;</span>, res)</span><br><span class="line">        <span class="built_in">this</span>.isFetching = <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillPreload (params) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.fetchData(params.url)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fetchData () &#123;</span><br><span class="line">    <span class="built_in">this</span>.isFetching = <span class="literal">true</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<h2 id="三、Taro-设计思想及架构"><a href="#三、Taro-设计思想及架构" class="headerlink" title="三、Taro 设计思想及架构"></a>三、Taro 设计思想及架构</h2><blockquote>
<p>在 Taro 中采用的是编译原理的思想，所谓编译原理，就是一个对输入的源代码进行语法分析，语法树构建，随后对语法树进行转换操作再解析生成目标代码的过程。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/101345/4/7530/111644/5dfb2b48E9468adee/09047741c9f8f1df.jpg"></p>
<h3 id="3-1-抹平多端差异"><a href="#3-1-抹平多端差异" class="headerlink" title="3.1 抹平多端差异"></a>3.1 抹平多端差异</h3><blockquote>
<p>基于编译原理，我们已经可以将 Taro 源码编译成不同端上可以运行的代码了，但是这对于实现多端开发还是远远不够。因为不同的平台都有自己的特性，每一个平台都不尽相同，这些差异主要体现在不同的组件标准与不同的 API 标准以及不同的运行机制上</p>
</blockquote>
<p>以小程序和 Web 端为例</p>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/87426/27/7379/152288/5dfb2b8cEd4e996b3/02037e0fffccd6cc.jpg"></p>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/98319/40/7361/187816/5dfb2d0fEfcfda683/2f3b4dc8630fbde3.jpg"></p>
<ul>
<li>可以看出小程序和 Web 端上组件标准与 API 标准有很大差异，这些差异仅仅通过代码编译手段是无法抹平的，例如你不能直接在编译时将小程序的 <view /> 直接编译成 <div />，因为他们虽然看上去有些类似，但是他们的组件属性有很大不同的，仅仅依靠代码编译，无法做到一致，同理，众多 API 也面临一样的情况。针对这样的情况，Taro 采用了定制一套运行时标准来抹平不同平台之间的差异</li>
<li>这一套标准主要以三个部分组成，包括标准运行时框架、标准基础组件库、标准端能力 API，其中运行时框架和 API 对应 @taro/taro，组件库对应 @tarojs/components，通过在不同端实现这些标准，从而达到去差异化的目的…</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/93445/39/7473/158350/5dfb2d3dEcd279015/cab4ef9c8243289e.jpg"></p>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/97728/16/7375/181825/5dfb2d9dEce97b447/7a456dadbee16f13.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>css垂直居中的方式</title>
    <url>/2020/09/29/css%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于前端来说，用CSS实现垂直居中是常见的工作，但自从flex出现后，因为做的差不多都是移动端的页面，大家基本上都用flex了。为了方便大家写PC端样式时可以少走弯路，我把之前工作中用到过的和别人总结的垂直居中方式一并总结在这里。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本的DOM结构如下：</p>
<pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;parent&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div id=&lt;span class=&quot;string&quot;&gt;&amp;quot;child&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
<h2 id="margin-top-padding-top"><a href="#margin-top-padding-top" class="headerlink" title="margin-top / padding-top"></a>margin-top / padding-top</h2><ul>
<li><p>示例</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-top: 50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---- 或者 ----</span><br><span class="line"></span><br><span class="line">.parent &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    padding-top: 50px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>兼容性</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/134743/34/11064/106929/5f728f81Ea80a9300/28f5d6b365a0926f.png" alt="margin兼容性"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本来我是不打算写这种方式的，但笨方法也是一种方法。</p>
<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><ul>
<li>示例  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    height: 300px;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>兼容性</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/143413/30/9644/176104/5f71e12bE5ff9c425/76b6644fb23fd202.png" alt="flex兼容性"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flex在移动端的兼容性都很好，但是如果要在PC端使用的话，IE 10 以下就不要考虑了，IE 10 和11 也有一些兼容性问题需要注意：<a href="https://caniuse.com/?search=flex">flex兼容性</a>。</p>
<h2 id="绝对定位-transform"><a href="#绝对定位-transform" class="headerlink" title="绝对定位 + transform"></a>绝对定位 + transform</h2><ul>
<li><p>示例</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    height: 300px;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: <span class="number">50</span>%;</span><br><span class="line">    transform: translate(<span class="number">0</span>, -<span class="number">50</span>%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>兼容性<br><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/149912/26/9726/615389/5f728c2eE37d4379f/9ed28cd717b71f0f.jpg" alt="transform兼容性"></p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform是CSS 3的属性，自然对IE 8 及以下是不兼容的，IE 9 以上使用前缀就可以了。</p>
<h2 id="绝对定位-负margin"><a href="#绝对定位-负margin" class="headerlink" title="绝对定位 + 负margin"></a>绝对定位 + 负margin</h2><ul>
<li><p>示例</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    height: 300px;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: <span class="number">50</span>%;</span><br><span class="line">    margin-top: -50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>兼容性</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/134743/34/11064/106929/5f728f81Ea80a9300/28f5d6b365a0926f.png" alt="负margin兼容性"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种实现方式的兼容性没什么好质疑的，CSS 2 的属性，兼容到IE 6（虽然我们早就不考虑IE 678 的兼容性了）。这种方式不够灵活的一点是，margin值必须指定为自身高度的一半，这就意味着这种实现方式只适用于child高度明确的情况。负margin在工作中还有许多应用场景，比如在父级宽高一定的情况下扩充子级宽高，利用负margin做叠加，和padding配合实现左右div等高等等。总之，在写样式的时候要记得margin可以为负的哦。</p>
<h2 id="table-cell"><a href="#table-cell" class="headerlink" title="table-cell"></a>table-cell</h2><ul>
<li><p>示例</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    height: 300px;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>兼容性</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/131536/2/11264/121529/5f72996eE7a195372/a618f17f7355f385.png" alt="table-cell兼容性"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种实现方式不兼容IE 67，Firefox 2 有一些bug，但鉴于目前Firefox 2的版本占比为0，使用table-cell是不用考虑兼容性的问题的。这个例子只是展示table-cell这个属性在垂直居中中的作用，实际工作中我们常常使用table的一整套DOM。由于浏览器生成table会进行多次重排重绘，非常损耗性能，因此如果不是后台系统或者要展示比较规范的表格类型的数据的时候，尽量选择其他的实现方式。</p>
<h2 id="绝对定位-margin-auto"><a href="#绝对定位-margin-auto" class="headerlink" title="绝对定位 + margin: auto"></a>绝对定位 + margin: auto</h2><ul>
<li><p>示例</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    height: 300px;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: <span class="number">0</span>;</span><br><span class="line">    bottom: <span class="number">0</span>;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>兼容性</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/117341/34/19063/116030/5f72dd25E6b06c156/7587b74748408b51.png" alt="margin:auto兼容性"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图是margin: auto的兼容性。需要注意的是图中标“1”的浏览器，在怪异模式下是不支持margin:auto的。如果你对怪异模式很陌生，那么记得保证你的html页面开头是<!doctype html><html>这样的声明就行，这段声明可以保证你的页面以标准模式渲染。</p>
<h2 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用grid其实已经超出我们在开头规定的DOM结构的范围了，但是因为grid和flex相比，可以更轻易的实现二维布局，所以还是现在这里认识一下<br>吧。使用grid实现垂直居中的DOM结构如下：</p>
<pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;parent&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;child1&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;child&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;child2&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和之前规定的DOM结构相比，我们在在子级增加了两个辅助的div，通过设置子级三个div的高度来实现中间div的垂直居中。如果不设置grid-template-rows的话，三个子级div会是相同的高度，也是垂直居中的。</p>
<pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.parent &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    height: 300px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    display: grid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    grid-template-rows: 50px 200px 50px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
<ul>
<li>兼容性</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/151511/20/1122/210584/5f72e54fEe1fe1377/b237b0fb200f4e77.png" alt="margin:auto兼容性"></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;嗯，grid最大的问题就是兼容性。PC就不要考虑了，M的如果你的项目不需要兼容那些飘红的浏览器，就可以先用起来了。grid详细的兼容性在这里：<a href="https://caniuse.com/?search=grid">grid兼容性</a>。</p>
<h2 id="line-height-vertical-align"><a href="#line-height-vertical-align" class="headerlink" title="line-height + vertical-align"></a>line-height + vertical-align</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道使用line-height实现文本的垂直居中，同样的，我们也可以使用line-height和vertical-align实现图片的垂直居中。</p>
<pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;parent&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;img &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;child&amp;quot;&lt;/span&gt; src=&lt;span class=&quot;string&quot;&gt;&amp;quot;demo.jpg&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .parent &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        line-height: 300px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .child &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        width: 100px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        height: 100px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vertical-align: middle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照line-height可以使inline元素垂直居中的思路，我们也可以利用line-height实现任意div的垂直居中，前提是设置其为 inline-block：</p>
<pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.parent &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    height: 300px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line-height: 300px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.child &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    display: inline-block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    width: 100px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    height: 100px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vertical-align: middle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么要把line-height放到最后，是因为vertical-align:middle并不是真正的垂直居中（见下图），而且各个浏览器、IOS和安卓的渲染还有些差异，如果你的项目对还原设计稿的要求很高，这个方案就放弃吧。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/111590/26/19209/21454/5f72f305Ee1d903b0/9941c632da17521b.png" alt="垂直居中偏差"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（完结）</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>垂直居中</tag>
      </tags>
  </entry>
  <entry>
    <title>css行高line-height的一些理解</title>
    <url>/2020/09/29/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在工作中遇到过设置行高不生效的问题，仔细研究后才知道自己对行高的理解远远不够，因此特地在这里总结一下。看一个比较简单的例子：</p>
<pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .parent &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        line-height: 40px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .child &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        line-height: 20px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        background-color: red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;parent&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;span &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;child&amp;quot;&lt;/span&gt;&amp;gt;我的行高是20px我的行高是20px我的行高是20px我的行高是20px我的行高是20px我的行高是20px我的行高是20px我的行高是20px&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;p &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;child&amp;quot;&lt;/span&gt;&amp;gt;---我的行高是20px我的行高是20px我的行高是20px我的行高是20px我的行高是20px我的行高是20px我的行高是20px我的行高是20px---&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的一段代码中，父级div的line-height是40px，子级span和p的line-height为20px。按照我之前的理解，line-height就是设置字体行高的，设置什么是什么就是了，这种明确指定像素的情况，不就是20px嘛。好吧，看看结果：</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/149728/21/9503/71634/5f707f4aE06b483ea/4c4763d52b7292da.png" alt="简单的例子的结果"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yeah～，不是我认为的结果，p标签和span标签显示的行高完全是不同的。还是先熟悉下相关的概念吧。</p>
<h2 id="要熟悉的概念"><a href="#要熟悉的概念" class="headerlink" title="要熟悉的概念"></a>要熟悉的概念</h2><h3 id="内联盒模型"><a href="#内联盒模型" class="headerlink" title="内联盒模型"></a>内联盒模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一说到盒模型，我们都会立马想到 margin、padding、content、border、box-sizing等，但这个只是 CSS 中盒模型的块级盒模型（block box）。我们今天要说的是另外一个被我们忽略掉的内联盒模型（inline box）。内联盒指的是盒子内部的构建模型，作用上关键是内容区域（conetnt）。</p>
<p><img src= "/img/loading.gif" data-src="https://pic2.zhimg.com/v2-52951e8e4d1bebb7a3d060a7674e6f81_1440w.jpg?source=172ae18b" alt="内联盒模型"></p>
<ul>
<li>内联盒子（inline box）分为内联盒子和匿名内联盒子。内联盒子不会让内容成块显示，而是排成一行。</li>
<li>行框盒子（line box）每一行就是一个行框盒子，由许多内联盒子（inline box）组成。</li>
<li>幽灵空白节点 （struct），每个行框盒子之前都有一个。</li>
</ul>
<h3 id="幽灵空白节点"><a href="#幽灵空白节点" class="headerlink" title="幽灵空白节点"></a>幽灵空白节点</h3><blockquote>
<p>Each line box starts with a zero-width inline box with the element’s font and line height properties. We call that imaginary box a “strut”.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面是规范中对幽灵空白节点的定义：每个行框盒子（line box）的前面都有一个0宽度的内联盒子（inline box），这个内联盒子有字体和行高的属性，被称做struct。因为这个内联盒子在页面上看不到，也无法通过脚本获取，但却真实存在，有点像文字节点一样（with the element’s font and line height properties）影响着页面的渲染，因此这个struct被我们成为“幽灵空白节点”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，幽灵空白节点的出现的前提是文档声明必须是 HTML5 文档声明（<!doctype html><html>），如果是 HTML5 之前的文档声明，幽灵空白节点是不存在的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先来看下幽灵空白节点吧。</p>
<pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .parent &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        background-color: lightgrey;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .child1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        display: inline-block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;parent&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;span &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;child1&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;parent&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;p &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;child2&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果见下图。可以看到，父级div没有设置高度，span标签里没有文字，但最终的渲染结果是父级是有高度的，这个高度就是幽灵空白节点造成的。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/135899/16/10998/10438/5f715271E6ba5f83f/54a53b6f62b3ead9.png" alt="幽灵空白节点"></p>
<p>眼尖的你可能会提出质疑：既然每个行框盒子之前都有一个空白幽灵节点，为什么要设置span标签为inline-blcok。嗯，这里再补充一段规范。</p>
<blockquote>
<p>Line boxes are created as needed to hold inline-level content within an inline formatting context.<br><strong><br>Line boxes that contain no text, no preserved white space, no inline elements with non-zero margins, padding, or borders, and no other in-flow content (such as images, inline blocks or inline tables), and do not end with a preserved newline must be treated as zero-height line boxes.<br></strong><br>for the purposes of determining the positions of any elements inside of them, and must be treated as not existing for any other purpose.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;意思就是说：如果一个line box里没有文字、空格、非0的margin或padding或border的inline元素、或其他in-flow内容（比如图片、inline-block 或 inline-table元素），且不以保留的换行符结束的话，就会被视作高度为0的line box。换言之，如果只有一个空的span标签，是不会有空白幽灵节点出现的。</p>
<h2 id="结论与理解"><a href="#结论与理解" class="headerlink" title="结论与理解"></a>结论与理解</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先抛出网上大佬们给出的结论：</p>
<ul>
<li>行内元素的line-height属性是去设置该元素所在行框盒子（line box）的行高，行框盒子取其内部所有内联盒子的行高的最大值，定为当前行的行高</li>
<li>换行后生成新的行框盒子，新生成的行的行高，重新在当前行包含的内联盒子的行高中取最大值</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照上面的结论，我们先画出内联盒模型：</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/136071/12/10921/81186/5f713c1dEfcf1719b/d2f96148dc90fa81.png" alt="内联盒模型"></p>
<ul>
<li>先解释span标签包裹的文字为什么行高是40px。由上文我们可以知道，幽灵空白节点和文本节点一样，有行高的属性，因为自身没有设置line-height， 因此继承了父级 div 的行高 40px。由span标签组成的inline box 的高度则由自身的行高决定，为20px。 这样，第一行的行框盒子line box的行高取struct和inline box的最大值，就是40px。如果要使span标签上的line-height 生效，那么按照最大值的原则，必须要给span大于40的行高才行。由于换行产生了新的行框盒子（line box），第二行和第三行的内联盒模型和第一行是一致的，行高同样为40px。</li>
<li>至于p标签包裹的文字为什么行高是20px，就很好理解了，因为没有幽灵空白节点呗。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再看一个稍微复杂那么一点点的情况：</p>
<pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .parent &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line-height: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.child1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line-height: 20px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    background-color: red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.child2 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line-height: 40px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    background-color: green;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.child3 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line-height: 80px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    background-color: blue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;p &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;parent&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;span &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;child1&amp;quot;&lt;/span&gt;&amp;gt;我的行高是20px我的行高是20px我的行高是20px我的行高是20px我的行高是20px我的行高是20px&amp;lt;/span&amp;gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;em &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;child2&amp;quot;&lt;/span&gt;&amp;gt;我的行高是40px我的行高是40px我的行高是40px我的行高是40px我的行高是40px我的行高是40px&amp;lt;/em&amp;gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;b &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;child3&amp;quot;&lt;/span&gt;&amp;gt;我的行高是80px我的行高是80px我的行高是80px我的行高是80px我的行高是80px我的行高是80px&amp;lt;/b&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果见下图，如果你能清楚的解释原因，就说明我讲明白了。</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/131124/36/10700/81711/5f71db32E940ae3f0/e5b1ba96639168e2.png" alt="练习"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（完结）</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>line-height</tag>
      </tags>
  </entry>
  <entry>
    <title>git分支管理策略</title>
    <url>/2021/02/23/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="git分支管理策略"><a href="#git分支管理策略" class="headerlink" title="git分支管理策略"></a>git分支管理策略</h1><p><font size='4'>概述</font></p>
<img src= "/img/loading.gif" data-src="./assets/img/git分支管理策略.png" width = "70%" alt="图片名称" align=center />

<h2 id="git-flow工作流"><a href="#git-flow工作流" class="headerlink" title="git flow工作流"></a>git flow工作流</h2><blockquote>
<p>Git的特色之一就是可以<font color='red'><em>灵活的建立分支</em></font>，因为有分支的存在，才构成了多工作流的特色。<br><br>同时因为其灵活性，也应运而生出<font color='red'><em>分支杂乱</em></font>的问题，像下图这样：<br></p>
</blockquote>
<img src= "/img/loading.gif" data-src="./assets/img/杂乱的分支.png" width = "40%" alt="图片名称" align=center />

<blockquote>
<p>为了解决杂乱的工作流，而产生的<font color='red'><em>分支管理策略</em></font> <br></p>
</blockquote>
 <img src= "/img/loading.gif" data-src="./assets/img/flow工作流.png" width = "40%" alt="图片名称" align=center />

<p><a href="#%E4%B8%89%E5%A4%A7git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5">三大git分支管理策略</a></p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><strong>长生命周期分支</strong></p>
<ol>
<li><strong>主分支Master</strong></li>
</ol>
<img src= "/img/loading.gif" data-src="./assets/img/主分支.png" width = "30%" alt="图片名称" align=center />

<blockquote>
<p>有且仅有一个，<font color='red'><em>用于发布版本</em></font>，每个版本发布需打tag <br/><br>tag名为  <font color='red'><em>&lt;版本号&gt;_&lt;发布时间&gt;</em></font> <br/><br>建议使用<font color='red'><em>–no-ff参数</em></font> <br/></p>
</blockquote>
<p><a href="#--no-ff%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></p>
<ol start="2">
<li><strong>开发分支Develop</strong></li>
</ol>
<blockquote>
<p>日常开发分支</p>
</blockquote>
<img src= "/img/loading.gif" data-src="./assets/img/开发分支.png" width = "30%" alt="图片名称" align=center />

<p><strong>短生命周期分支</strong></p>
<ol>
<li><strong>功能分支</strong></li>
</ol>
<blockquote>
<p>为了开发某个功能<font color='red'><em>从dev分支</em></font>分出来 <br/><br>开发完成后要合并入dev分支 <br/><br>采用<font color='red'><em>fearure-</em></font>的命名方式 <br/><br>使用后应该<font color='red'><em>删除</em></font> <br/></p>
</blockquote>
<img src= "/img/loading.gif" data-src="./assets/img/功能分支.png" width = "30%" alt="图片名称" align=center />

<ol start="2">
<li><strong>预发布分支</strong></li>
</ol>
<blockquote>
<p>在发布正式版本之前用于测试 <br/><br>从<font color='red'><em>dev分支</em></font>分离出来，测试没问题后分别合并进master及dev分支 <br/><br>如发现BUG，从分支分离出fix分支，修复问题后分别合并进该分支及dev分支 <br/><br>采用<font color='red'><em>release-</em></font>命名方式 <br/><br>使用后应该<font color='red'><em>删除</em></font> <br/></p>
</blockquote>
<ol start="3">
<li><strong>修复BUG分支</strong></li>
</ol>
<blockquote>
<p>修复线上BUG分支 <br/><br>从<font color='red'><em>master分支</em></font>分离出来，修复BUG后分别合并进master及dev分支并打好tag <br/><br>采用<font color='red'><em>fix-[tag]</em></font>命名方式 <br/><br>使用后应该<font color='red'><em>删除</em></font> <br/></p>
</blockquote>
<img src= "/img/loading.gif" data-src="./assets/img/修复BUG分支.png" width = "30%" alt="图片名称" align=center />

<h2 id="commit-message"><a href="#commit-message" class="headerlink" title="commit message"></a>commit message</h2><p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;feat(index): 完成sayhello需求开发&#x27;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>作用</strong></li>
</ol>
<ul>
<li><strong>显示上次发布后的变动</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git log &lt;last tag&gt; HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>可以过滤某些commit（比如文档改动），便于快速查找信息</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git log &lt;last release&gt; HEAD --grep feature</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>可以直接从commit生成Change log</strong></li>
</ul>
<ol start="2">
<li><strong>格式</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>任何一行都不得超过72个字符，为了避免自动换行影响美观。</p>
</blockquote>
<ol start="3">
<li><strong>参数说明</strong></li>
</ol>
<ul>
<li>type（必需）用于说明 commit 的类别</li>
</ul>
<blockquote>
<p><font color='red' size='3'>feat：</font> 新功能（feature） <br/><br><font color='red' size='3'>fix：</font> 修补bug <br/><br><font color='red' size='3'>docs：</font> 文档（documentation） <br/><br><font color='red' size='3'>style：</font> 格式（不影响代码运行的变动） <br/><br><font color='red' size='3'>refactor：</font> 重构（即不是新增功能，也不是修改bug的代码变动） <br/><br><font color='red' size='3'>test：</font> 增加测试 <br/><br><font color='red' size='3'>chore：</font> 构建过程或辅助工具的变动 <br/></p>
</blockquote>
<ul>
<li>scope（可选）用于说明 commit 影响的范围</li>
<li>subject（必需）commit 目的的简短描述</li>
</ul>
<ol start="4">
<li><strong>工具</strong></li>
</ol>
<p><strong>1) Commitizen</strong></p>
<blockquote>
<p>一个撰写合格 Commit message 的工具。</p>
</blockquote>
<ul>
<li>全局安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g commitizen</span><br></pre></td></tr></table></figure>

<ul>
<li>在项目中初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git commit命令，一律改为使用git cz</p>
</blockquote>
<p><strong>2) validate-commit-msg</strong></p>
<blockquote>
<p>校验commit是否符合规范</p>
</blockquote>
<p><a href="https://www.npmjs.com/package/validate-commit-msg">配置方法</a></p>
<p><strong>3) conventional-changelog</strong></p>
<blockquote>
<p>生成 Change log 的工具</p>
</blockquote>
<ul>
<li>全局安装</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g conventional-changelog-cli</span><br></pre></td></tr></table></figure>

<ul>
<li>在项目中生成上次发布以来的log</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">conventional-changelog -p angular -i CHANGELOG.md -w</span><br></pre></td></tr></table></figure>

<ul>
<li>生成所有发布的change log</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">conventional-changelog -p angular -i CHANGELOG.md -w -r <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="git使用技巧"><a href="#git使用技巧" class="headerlink" title="git使用技巧"></a>git使用技巧</h2><ol>
<li><strong>别名</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config alias.co checkout</span><br><span class="line">git config alias.ad &#39;add .&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之后直接使用git ad \ git co 即可</p>
</blockquote>
<ol start="2">
<li><strong>超级log</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</span><br><span class="line"></span><br><span class="line">git config --global alias.llg &#39;log --graph --decorate --oneline --simplify-by-decoration --all&#39;</span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><font color='blue' size='3'><strong>开发新功能</strong></font></p>
<ol>
<li>自<font color='red' size='3'>dev分支</font>新建分支feature-sayhello分支</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git pull</span><br><span class="line">git checkout -b feature-sayhello</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>开发完成后合并到dev分支，合并前需要<font color='red' size='3'>先pull远程分支代码</font>，并且在<font color='red' size='3'>预合并分支处理冲突</font>后再合并</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git pull</span><br><span class="line">git checkout -b merge</span><br><span class="line">git merge --no--ff feature-sayhello</span><br><span class="line">git checkout dev</span><br><span class="line">git merge --no--ff merge</span><br><span class="line">git branch -D merge</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自dev分支创建release-v1.0分支，提交测试</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git checkout -b release-v1<span class="number">.0</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试通过后分别合并至dev分支及master分支，合并前需要<font color='red' size='3'>先pull远程分支代码</font>，并且<font color='red' size='3'>预合并分支处理冲突</font>后再合并</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git pull</span><br><span class="line">git checkout -b merge</span><br><span class="line">git merge --no--ff release-v1<span class="number">.0</span></span><br><span class="line">git checkout dev</span><br><span class="line">git merge --no--ff merge</span><br><span class="line">git branch -D merge</span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line">git checkout -b merge</span><br><span class="line">git merge --no--ff release-v1<span class="number">.0</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge --no--ff merge</span><br><span class="line">git branch -D merge</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在master分支打上tag</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git tag v1<span class="number">.0_21</span><span class="number">.2</span><span class="number">.3</span></span><br><span class="line">git push origin v1<span class="number">.0_21</span><span class="number">.2</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>删除开发分支</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git branch -D feature-sayhello</span><br><span class="line">git branch -D release-v1<span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p><font color='blue' size='3'><strong>修复线上问题</strong></font></p>
<ol>
<li>自<font color='red' size='3'>master分支</font>新建fixbug分支，指向出问题的tag</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git checkout -b fixbug-v1<span class="number">.0</span> v1<span class="number">.0_21</span><span class="number">.2</span><span class="number">.2</span>    </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修复问题并测试通过后分别合并至dev及master分支，合并前需要<font color='red' size='3'>先pull远程分支代码</font>，并且<font color='red' size='3'>预合并分支处理冲突</font>后再合并</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git pull</span><br><span class="line">git checkout -b merge</span><br><span class="line">git merge --no--ff fixbug-v1<span class="number">.0</span></span><br><span class="line">git checkout dev</span><br><span class="line">git merge --no--ff merge</span><br><span class="line">git branch -D merge</span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line">git checkout -b merge</span><br><span class="line">git merge --no--ff fixbug-v1<span class="number">.0</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge --no--ff merge</span><br><span class="line">git branch -D merge</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在master分支打上tag</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git tag v1<span class="number">.3_21</span><span class="number">.2</span><span class="number">.2</span> -m <span class="string">&#x27;fixbug:修复线上问题&#x27;</span></span><br><span class="line">git push origin v1<span class="number">.3_21</span><span class="number">.2</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>删除fixbug分支</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git branch -D fixbug-v1<span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p><font color='blue' size='3'><strong>线上回退至指定tag</strong></font></p>
<ol>
<li>切换至master分支</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>指针定向至指定tag</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git reset --hard v1<span class="number">.4_21</span><span class="number">.2</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>强制推送回滚</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure>

<p><font color='blue' size='3'><strong>日常上下班</strong></font></p>
<ol>
<li>下班前commit更改并push至远程</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;docs(readme): MARKDOWN文档书写&#x27;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>上班第一件事pull远程dev分支，并合并到自己的开发分支</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git pull</span><br><span class="line">git checkout feature-sayhello</span><br><span class="line">git checkout -b merge</span><br><span class="line">git merge dev</span><br><span class="line">git checkout feature-sayhello</span><br><span class="line">git merge merge</span><br><span class="line">git branch -D merge</span><br></pre></td></tr></table></figure>

<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="–no-ff参数说明"><a href="#–no-ff参数说明" class="headerlink" title="–no-ff参数说明"></a>–no-ff参数说明</h2><ol>
<li>未使用–no-ff参数</li>
</ol>
<img src= "/img/loading.gif" data-src="./assets/img/不使用no.png" width = "30%" alt="图片名称" align=center />

<ol start="2">
<li>使用–no-ff参数</li>
</ol>
<img src= "/img/loading.gif" data-src="./assets/img/使用no.png" width = "30%" alt="图片名称" align=center />

<p><a href="#%E9%95%BF%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%88%86%E6%94%AF">长生命周期分支</a></p>
<h2 id="三大git分支管理策略"><a href="#三大git分支管理策略" class="headerlink" title="三大git分支管理策略"></a>三大git分支管理策略</h2><ol>
<li>Git Flow是 Vincent Driessen 2010 年发布出来的他自己的分支管理模型，属于强流程性，使用度非常高，比较适合开发技术能力中等的团队作战。</li>
<li>GitHub Flow 是大型程序员交友社区 GitHub 制定并使用的工作流模型，由 scott chacon 在 2011 年 8月 31 号正式发布。<ul>
<li>只有一个长期分支 master ,而且 master 分支上的代码，永远是可发布状态,一般 master 会设置 protected 分支保护，只有有权限的人才能推送代码到 master 分支。</li>
<li>如果有新功能开发，可以从 master 分支上检出新分支。</li>
<li>在本地分支提交代码，并且保证按时向远程仓库推送。</li>
<li>当你需要反馈或者帮助，或者你想合并分支时，可以发起一个 pull request。</li>
<li>当 review 或者讨论通过后，代码会合并到目标分支。</li>
<li>一旦合并到 master 分支，应该立即发布。</li>
</ul>
</li>
<li>GitLab Flow是 GitLab 的 CEO Sytse Sijbrandij 在 2014 年 9月 29 正式发布出来的。</li>
</ol>
<p><a href="#%E5%88%86%E6%94%AF">分支</a></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p><strong>列出所有tag</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>

<p><strong>新建一个tag在当前commit</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag [tag]</span><br></pre></td></tr></table></figure>

<p><strong>新建一个tag在指定commit</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag [tag] [commit]</span><br></pre></td></tr></table></figure>

<p><strong>删除本地tag</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d [tag]</span><br></pre></td></tr></table></figure>

<p><strong>删除远程tag</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br></pre></td></tr></table></figure>

<p><strong>查看tag信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git show [tag]</span><br></pre></td></tr></table></figure>

<p><strong>提交指定tag</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push [remote] [tag]</span><br></pre></td></tr></table></figure>

<p><strong>提交所有tag</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push [remote] --tags</span><br></pre></td></tr></table></figure>

<p><strong>新建一个分支，指向某个tag</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>



<h3 id="延申阅读"><a href="#延申阅读" class="headerlink" title="延申阅读"></a>延申阅读</h3><p><a href="https://www.mdeditor.tw/pl/p7L4">Git操作指南: 企业级项目分支管理流程 - SourceTree Mac 版</a><br><a href="https://zhuanlan.zhihu.com/p/50063660">git 三大分支管理策略</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://developer.ibm.com/zh/articles/os-cn-git-and-github-5/">git flow分支管理策略</a><br><a href="https://cloud.tencent.com/developer/article/1592957">Git flow实践</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用git命令清单</a><br><a href="https://mp.weixin.qq.com/s/N3XDI8wSSgi9IX-cSbaCuw">自动化版本控制</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">commit规范</a><br><a href="https://www.ruanyifeng.com/blog/2012/07/git.html">阮一峰</a><br><a href="https://www.cnblogs.com/spec-dog/p/11043371.html">分支管理项目简单实践</a><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a><br><a href="https://zhuanlan.zhihu.com/p/72946397">Git分支管理实践-撤销</a></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo的个人博客搭建</title>
    <url>/2020/09/11/hexo/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建博客其实很简单，但要注意很多细节问题，之前本人也搭建过博客，那时也踩过一些坑，但是现在重新搭建博客，感觉自己又把之前踩过的坑又踩了一遍。所以为了避免以后搭建博客采坑，所以在此记录一下搭建博客的全流程以及一些注意事项。<br>本文搭建的博客基于<a href="https://hexo.io/zh-cn/">Hexo</a>，主题选用<a href="https://demo.jerryc.me/posts/21cfbf15/">Butterfly</a>，使用<a href="https://travis-ci.com/">Travis CI</a>自动部署到Github Pages和Coding Pages上，并在腾讯云上申请个人域名与博客进行绑定。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>安装Hexo并初始化博客，这个没啥好说的，按照<a href="https://hexo.io/zh-cn/">Hexo官网</a>指示安装初始化即可。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g     <span class="comment"># 全局安装hexo-cli脚手架，如果不想全局安装，那就使用npx安装</span></span><br><span class="line">$ hexo init blog              <span class="comment"># 初始化博客</span></span><br><span class="line">$ <span class="built_in">cd</span> blog                     <span class="comment"># 进入博客根目录</span></span><br><span class="line">$ npm install                 <span class="comment"># 安装依赖</span></span><br><span class="line">$ hexo s                      <span class="comment"># 本地预览</span></span><br></pre></td></tr></table></figure>

<h2 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h2><p>本文的博客使用<a href="https://github.com/jerryc127/hexo-theme-butterfly/tree/master">Butterfly</a>，个人觉得这个主题比较好看，大家可以根据自己的喜好进行选择。</p>
<h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>在博客根目录中执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b 3.0.1 https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 此处我们使用的主题版本是3.0.1，建议大家固定使用一个主题版本，因为不同的主题版本的配置有所不同。在每次自动化部署时都需要重新安装主题，如果指定的是<code>master</code>，那每次安装的都是最新版本，会导致部署失败！</p>
<p>这里所说的版本，即tag，大家可以到主题的仓库中查找最新的tag并使用。</p>
<p><img src= "/img/loading.gif" data-src="tag.png" alt="主题tag"></p>
<h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>修改站点配置文件_config.yml，把主题改为 butterfly</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure>

<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>如果你没有 pug 以及 stylus 的渲染器，请下载安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>

<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>把主题文件夹中的 _config.yml 复制到 Hexo 根目录里，同时重新命名为 _config.butterfly.yml。</p>
<p>Hexo 会自动合并主题中的_config.yml 和 _config.butterfly.yml 里的配置，如果存在同名配置，会使用_config.butterfly.yml 的配置，其优先度较高。</p>
<h3 id="配置标签页"><a href="#配置标签页" class="headerlink" title="配置标签页"></a>配置标签页</h3><ul>
<li>1.在博客根目录中输入<code>hexo new page tags</code></li>
<li>2.找到 source/tags/index.md 这个文件</li>
<li>3.修改为：<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-08-29 19:14:29</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="配置分类页"><a href="#配置分类页" class="headerlink" title="配置分类页"></a>配置分类页</h3><ul>
<li>1.在博客根目录中输入<code>hexo new page categories</code></li>
<li>2.找到 source/categories/index.md 这个文件</li>
<li>3.修改为：<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-08-29 19:15:35</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="配置友情链接"><a href="#配置友情链接" class="headerlink" title="配置友情链接"></a>配置友情链接</h3><ul>
<li>1.在博客根目录中输入<code>hexo new page link</code></li>
<li>2.找到 source/link/index.md 这个文件</li>
<li>3.修改为：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 友情链接</span><br><span class="line">date: 2020-08-29 19:10:49</span><br><span class="line">type: &quot;link&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<ul>
<li>4.添加友情链接：</li>
</ul>
<p>在博客目录中的 source/_data，创建一个文件 link.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">class:</span></span><br><span class="line">  <span class="attr">class_name:</span> <span class="string">友链</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="attr">1:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">YolkPie</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://yolkpie.net/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">/img/yolkpie.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">前端研发部</span></span><br><span class="line">    <span class="attr">2:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">Yolk</span> <span class="string">CLI</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://yolkpie.net/yolk-cli/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">/img/yolkcli.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">前端项目脚手架</span></span><br><span class="line">    <span class="attr">3:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">Yolk</span> <span class="string">Works</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://yolkpie.net/yolkworks-list/#/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">/img/yolkworks.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">海量模板及组件</span></span><br></pre></td></tr></table></figure>

<h3 id="配置关于自己"><a href="#配置关于自己" class="headerlink" title="配置关于自己"></a>配置关于自己</h3><ul>
<li>1.在博客根目录中输入<code>hexo new page about</code></li>
<li>2.找到 source/about/index.md 这个文件</li>
<li>3.修改为：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 关于我</span><br><span class="line">date: 2020-08-29 19:16:57</span><br><span class="line">type: &quot;about&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="配置博客语言"><a href="#配置博客语言" class="headerlink" title="配置博客语言"></a>配置博客语言</h3><p>修改博客配置文件 <code>_config.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<h3 id="配置导航菜单"><a href="#配置导航菜单" class="headerlink" title="配置导航菜单"></a>配置导航菜单</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">文章:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure>

<h3 id="配置相关图片"><a href="#配置相关图片" class="headerlink" title="配置相关图片"></a>配置相关图片</h3><p>包括网站图标、头像、首页顶部图片、文章页面顶部默认图、文章封面默认图、其他页面顶部默认图等等。</p>
<p>如果想要使用本地图片，在<code>source</code>目录下创建<code>img</code>目录，在图片放到该目录下，这样我们就可以使用<code>/img/avatar.jpg</code>访问到本地图片。</p>
<h3 id="配置本地搜索"><a href="#配置本地搜索" class="headerlink" title="配置本地搜索"></a>配置本地搜索</h3><ul>
<li>1.安装 <code>hexo-generator-search</code><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></li>
<li>2.修改站点配置文件_config.yml，添加：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>3.修改主题配置文件_config.butterfly.yml<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="配置评论"><a href="#配置评论" class="headerlink" title="配置评论"></a>配置评论</h3><p>本博客的评论基于<a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md">Gitalk</a>，Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。</p>
<ul>
<li>1.选择一个公共github存储库（已存在或创建一个新的github存储库）用于存储评论，一般选择我们的Github Pages。</li>
<li>2.创建 GitHub Application，如果没有<a href="https://github.com/settings/applications/new">点击这里申请</a>，<code>Authorization callback URL</code>填写当前使用插件页面的域名。</li>
<li>3.修改主题配置文件_config.butterfly.yml<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">你的client</span> <span class="string">id</span> </span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">你的client</span> <span class="string">secret</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">你的github仓库</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="string">你的github用户名</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">该仓库的拥有者或协作者</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment"># en, zh-CN, zh-TW, es-ES, fr, ru</span></span><br><span class="line">  <span class="attr">perPage:</span> <span class="number">10</span> <span class="comment"># Pagination size, with maximum 100.</span></span><br><span class="line">  <span class="attr">distractionFreeMode:</span> <span class="literal">false</span> <span class="comment"># Facebook-like distraction free mode.</span></span><br><span class="line">  <span class="attr">pagerDirection:</span> <span class="string">last</span> <span class="comment"># Comment sorting direction, available values are last and first.</span></span><br><span class="line">  <span class="attr">createIssueManually:</span> <span class="literal">false</span> <span class="comment"># Gitalk will create a corresponding github issue for your every single page automatically</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><ul>
<li><a href="https://demo.jerryc.me/posts/4aa8abbe/">Butterfly 安装文档(三) 主题配置-1</a></li>
<li><a href="https://demo.jerryc.me/posts/ceeb73f/">Butterfly 安装文档(四) 主题配置-2</a></li>
</ul>
<h2 id="写篇博客"><a href="#写篇博客" class="headerlink" title="写篇博客"></a>写篇博客</h2><p>一般博客会引用一些图片，如果想要使用本地图片，则配置<code>_config.yml</code>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>执行<code>hexo new &lt;title&gt;</code>创建一篇文章，可以发现<code>source/_posts</code>目录下多出了<code>&lt;title&gt;</code>目录及<code>&lt;title&gt;.md</code>，其中<code>&lt;title&gt;.md</code>用于我们写博客，<code>&lt;title&gt;</code>目录用于存放我们博客使用的图片。</p>
<p>文章的配置，下面是我本篇文章的配置，大家可以参考：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">基于Hexo的个人博客搭建</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-08-30 10:45:29</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">hexo,Butterfly</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">搭建博客其实很简单，但要注意很多细节问题，之前本人也搭建过博客，那时也踩过一些坑，但是现在重新搭建博客，感觉自己又把之前踩过的坑又踩了一遍。所以为了避免以后搭建博客采坑，所以在此记录一下搭建博客的全流程以及一些注意事项。</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">/img/hexo.jpg</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="string">hexo.jpg</span></span><br></pre></td></tr></table></figure>

<ul>
<li>title：文章标题</li>
<li>tags：文章标签</li>
<li>categories：文章分类</li>
<li>cover：文章封面</li>
<li>top_img：文章顶部图片</li>
</ul>
<h2 id="github托管"><a href="#github托管" class="headerlink" title="github托管"></a>github托管</h2><p>将我们博客的源代码托管到github上，在github上创建代码仓库，将我们博客的源代码push上去即可。</p>
<h2 id="github-pages"><a href="#github-pages" class="headerlink" title="github pages"></a>github pages</h2><p>新建一个repo，仓库名字为<code>xxx.github.io</code>，其中xxx为你github的username。</p>
<h2 id="coding-pages"><a href="#coding-pages" class="headerlink" title="coding pages"></a>coding pages</h2><ul>
<li>1.新建一个<code>coding.net</code>团队，如果你已经拥有自己的团队，那么久不需要创建团队了。</li>
<li>2.创建一个DevOps项目。</li>
<li>3.在项目下创建代码仓库，用于托管博客静态资源，仓库名字为<code>xxx.coding.io</code>。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="project.png" alt="project"></p>
<h2 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h2><ul>
<li><p>1.在博客根目录下创建<code>.travis.yml</code>文件，并写入自动化脚本：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">-b</span> <span class="number">3.0</span><span class="number">.1</span> <span class="string">https://github.com/jerryc127/hexo-theme-butterfly.git</span> <span class="string">themes/butterfly</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cp</span> <span class="string">-rf</span> <span class="string">source/img/*</span> <span class="string">themes/butterfly/source/img/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;$&#123;U_NAME&#125;&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;$&#123;U_EMAIL&#125;&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">&quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cp</span> <span class="string">-rf</span> <span class="string">public/*</span> <span class="string">yujihu.github.io/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./yujihu.github.io</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&#x27;travis-ci auto build yujihu-blog&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">&quot;$&#123;P_BRANCH&#125;&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">../</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">&quot;https://$&#123;U_NAME2&#125;:$&#123;CO_TOKEN&#125;@$&#123;CO_REF&#125;&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cp</span> <span class="string">-rf</span> <span class="string">public/*</span> <span class="string">yujihu.coding.io/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./yujihu.coding.io</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&#x27;travis-ci auto build yujihu-blog&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">&quot;$&#123;P_BRANCH&#125;&quot;</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>node_js: 与我们本地开发的node.js版本保持一致。</p>
</li>
<li><p>before_install：全局安装hexo脚手架。</p>
</li>
<li><p>install：安装博客的依赖。</p>
</li>
<li><p>script： 此处为生成博客静态资源的代码，需要将source/img复制到themes/butterfly/source/img下面，否则会导致图片无法访问。</p>
</li>
<li><p>after_success：生成成功后，将静态资源分别提交至github pages和coding pages仓库。</p>
</li>
<li><p>环境变量：<code>$&#123;***&#125;</code> 这块后面会提到。</p>
</li>
<li><p>2.Github 增加一个 Personal access tokens，位置在<a href="https://github.com/settings/tokens">Settings/Developer settings</a>。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="token.png" alt="token"></p>
<ul>
<li>3.Coding 增加一个访问令牌，位置在<code>个人账户设置/访问令牌</code>。 </li>
</ul>
<p><img src= "/img/loading.gif" data-src="coding.png" alt="token"></p>
<ul>
<li>4.进入<a href="https://travis-ci.com/">Travis CI</a>，使用 Github登陆， 进入<a href="https://travis-ci.com/dashboard">dashboard</a>，此时应该可以看到你刚创建的项目。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="travis1.png" alt="travis1"></p>
<ul>
<li>5.进入该项目的setting，配置环境变量</li>
</ul>
<p><img src= "/img/loading.gif" data-src="travis2.png" alt="travis2"></p>
<blockquote>
<p>GH_REF: Github Pages项目地址<code>github.com/[name]/[name].github.io.git</code>注意去掉 https://。<br>CO_REF: Coding Pages项目地址<code>e.coding.net/[name]/[name].coding.io/[name].coding.io.git</code>注意去掉 https://。<br>GH_TOKEN: Github Token，是通过上面第2步拿到的。<br>CO_TOKEN: Coding Token，是通过上面第3步拿到的。<br>P_BRANCH: 要上传的分支，这里我们要传到 master。<br>U_EMAIL: 你的 Github 邮箱。<br>U_NAME: 你的 Github 用户名。<br>U_NAME2: 你的 Coding 用户名，这个很关键，一定要设置正确。</p>
</blockquote>
<ul>
<li>6.将博客源代码push到远程仓库，我们可以发现<code>Travis CI</code>会开启一次自动构建。</li>
</ul>
<h2 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h2><p>1.在腾讯云上购买一个域名，首年一般很便宜，大家可以先买一年试试，域名可以不备案，但需要实名认证。<br>2.开启Github Pages，在[name].github.io的setting中进行配置。</p>
<p><img src= "/img/loading.gif" data-src="github2.png" alt="github2"></p>
<p>3.开启Coding Pages, 在<code>项目/持续部署/静态网站</code>下进行配置。</p>
<p><img src= "/img/loading.gif" data-src="coding2.png" alt="coding2"><br><img src= "/img/loading.gif" data-src="coding3.png" alt="coding3"></p>
<p>4.配置域名解析</p>
<p>进入刚刚购买域名的管理控制台，配置域名解析规则，境内CNAME到Coding Pages，境外CNAME到Github Pages.</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>line-height的一些原理</title>
    <url>/2021/07/22/line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h2><p>“行高”，顾名思义是指的一行文字的高度，按照我们的理解,行高指的应该是两行文字间基线的距离。<br><img src= "/img/loading.gif" data-src="base_line.jpg" alt="这是图片"><br>vertical-align中有top,middle,baseline,bottom与之是由关联的。但是由于中英文的差异，所以基线在中文中可能并不适用，实际表现不符合预期</p>
<h3 id="行高的作用"><a href="#行高的作用" class="headerlink" title="行高的作用"></a>行高的作用</h3><p>CSS中起高度作用的除了我们熟知的height，另外line-height在css中也起了高度的作用，如果一个标签未定义高度（包括百分比高度），那么最终表现的高度一定是由line-height起作用的。</p>
<p>之前，在我的认知中，若不设置高度，父盒子的高度应该是由内层文字撑起来的，但是是不是这样呢?</p>
<p>我们来看一个实验：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;test1&quot;</span>&gt;测试&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;test2&quot;</span>&gt;测试&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.test1 &#123;</span><br><span class="line">  font-size: 20px;</span><br><span class="line">  line-height: <span class="number">0</span>;</span><br><span class="line">  border:1px solid #cccccc; </span><br><span class="line">  background:#eeeeee;</span><br><span class="line"></span><br><span class="line">  margin: 40px auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.test2 &#123;</span><br><span class="line">  font-size: <span class="number">0</span>;</span><br><span class="line">  line-height: 20px;</span><br><span class="line">  border:1px solid #cccccc; </span><br><span class="line">  background:#eeeeee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="%E4%BC%81%E4%B8%9A%E5%92%9A%E5%92%9A20210204150236.png" alt="这是图片"></p>
<p>结果可以看出，div是由line-height撑开的，并不是我们之前认为的由文字撑开。</p>
<p>那么line-height是怎么产生高度的呢？在inline box中，有个line box（行框盒子）,line box没有其他特性，只有高度。所以一个没有设置高度的div的高度是由一个一个line box的高度堆砌而成。  </p>
<p>其实line box也不是真正的生产者，在它之中，还包含着一个inline box（内联盒子），包括span等… line box会取line-height最高的值来呈现。</p>
<h3 id="行高的垂直居中性"><a href="#行高的垂直居中性" class="headerlink" title="行高的垂直居中性"></a>行高的垂直居中性</h3><p>行高还有一个重要特性，即垂直居中性。line-height的最终表现是通过line box（行框盒子）呈现的，而无论line box所占据的高度有多少，无论比文字大还是比文字小，它都会以文字的中垂线对称分布，我们就是利用这一特性来实现文字或图片的垂直居中。</p>
<p><img src= "/img/loading.gif" data-src="2009-11-28_002310.png" alt="这是图片"></p>
<p>test1，line box高度为0，但是还是以文字的中垂线对称分布。</p>
<h3 id="单行或多行文字居中的应用"><a href="#单行或多行文字居中的应用" class="headerlink" title="单行或多行文字居中的应用"></a>单行或多行文字居中的应用</h3><h4 id="1-单行文字垂直居中"><a href="#1-单行文字垂直居中" class="headerlink" title="1.单行文字垂直居中"></a>1.单行文字垂直居中</h4><p>网上都是这么说的，把line-height值设置为height一样大小的值可以实现单行文字的垂直居中。这句话确实是正确的，但其实也是有问题的。问题在于height，看我的表述：“把line-height设置为您需要的box的大小可以实现单行文字的垂直居中”。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;single_line&quot;</span>&gt;</span><br><span class="line">        &lt;span&gt;单行文字居中&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">.single_line &#123;</span><br><span class="line">  border: 1px dashed #cccccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.single_line span &#123;</span><br><span class="line">  line-height: 40px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="QQ%E5%9B%BE%E7%89%8720210322113259.png" alt="这是图片"></p>
<h4 id="2-多行文字垂直居中"><a href="#2-多行文字垂直居中" class="headerlink" title="2.多行文字垂直居中"></a>2.多行文字垂直居中</h4><p>之前常见的多行文字居中常见的有flex、table等，而现在，我们同样可以利用line-height来实现。因为行高的垂直居中性，并且它可以撑起盒子的高度，所以我们用line-height来代替外层盒子的height。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;mulit_line&quot;</span>&gt;</span><br><span class="line">    &lt;span style=&#123;&#123;<span class="attr">fontSize</span>:<span class="number">12</span>&#125;&#125;&gt;</span><br><span class="line">        Xx这里是高度为<span class="number">150</span>像素的标签内的多行文字，文字大小为12Px。</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        这里是第二行，用来测试多行的显示效果。</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">.mulit_line &#123;</span><br><span class="line">  line-height: 150px;</span><br><span class="line">  border: 1px dashed #cccccc;</span><br><span class="line">  padding-left: 5px;</span><br><span class="line">&#125;</span><br><span class="line">.mulit_line span &#123;</span><br><span class="line">  display: -moz-inline-stack;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  line-height: <span class="number">1.</span>4em;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="QQ%E5%9B%BE%E7%89%8720210322103735.png" alt="这是图片"></p>
<h2 id="line-height坑人的默认值：normal"><a href="#line-height坑人的默认值：normal" class="headerlink" title="line-height坑人的默认值：normal"></a>line-height坑人的默认值：normal</h2><p>line-height 的值可以是一个长度或者是一个数字，它的默认值是 normal。那么，normal 是什么呢？我们经常将 normal 理解为 1，或者 1.2，甚至连 CSS 规格文档都没有提到这一问题。</p>
<h3 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h3><p>一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;a&quot;</span>&gt;Ba&lt;/span&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;b&quot;</span>&gt;Ba&lt;/span&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;c&quot;</span>&gt;Ba&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">p  &#123; font-size: 100px &#125;</span><br><span class="line">.a &#123; font-family: Helvetica &#125;</span><br><span class="line">.b &#123; font-family: Gruppo    &#125;</span><br><span class="line">.c &#123; font-family: Catamaran &#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="QQ%E5%9B%BE%E7%89%8720210322104320.png" alt="这是图片"><br>相同的font-size，得出的span高度却是不同的，这是为什么呢？<br>原因在于字体本身，一款字体会定义一个em-square，它是用来盛放字符的容器，一般设定为宽高均为1000，但是也可能是1024、2048等<br><img src= "/img/loading.gif" data-src="v2-4c684524b8d37789295f6db964201c74_720w.png" alt="这是图片"><br>字体度量都是基于这个相对单位设置的，包括 ascender、descender、capital height、x-height 等。注意这里面的值是允许相对于 em-square 出去（bleed outside）的<br><img src= "/img/loading.gif" data-src="v2-7f1590fecc2f79484b22f38e2869d83b_720w.jpg" alt="这是图片"><br>在浏览器中绘制时，字体会按照你的font-size缩放。</p>
<p>我们把 Catamaran 字体放到 FontForge 中，分析它的字体度量：</p>
<ul>
<li>em-square 是 1000</li>
<li>ascender 是 1100，descender 是 540。通过测试发现，macOS 上的浏览器使用了 HHead Ascent 和 HHead Descent 值，Windows 上的浏览器使用了 Win Ascent 和 Win Descent（而且两个平台上的值不一样）。我们还看到 Capital Height 是 680，X height 是 485。<br><img src= "/img/loading.gif" data-src="v2-8fa5fa46b571db21c79bda208d6263c3_720w.png" alt="这是图片"></li>
</ul>
<p>这意味着 Catamaran 字体占据了 1100 + 540 个相对单位，尽管它的 em-square 只有 1000 个相对单位，所以当我们设置 font-size:100px 时，这个字体里的文字高度是 164px。这个计算出来的高度决定了 HTML 元素的 content-area（内容区域）。你可以认为 content-area 就是 background 作用的区域。</p>
<p>我们还能看出大写字母的高度是 68px，小写字母的高度（x-height）是 49px。所以 1ex = 49px，1em = 100px，而不是 164px。（em 是基于 font-size，而不是基于计算出来的高度）</p>
<p><img src= "/img/loading.gif" data-src="v2-cb05dd4dc6908e522c0f69392ed1fe87_r.png" alt="这是图片"></p>
<p>如果我们修改一下最初的 HTML 代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    Good design will be better.</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;a&quot;</span>&gt;Ba&lt;/span&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;b&quot;</span>&gt;Ba&lt;/span&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;c&quot;</span>&gt;Ba&lt;/span&gt;</span><br><span class="line">    We get to make a consequence.</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="v2-cc56c718642f701c3f8739ee7a4453cf_r.png" alt="这是图片"></p>
<p>可以看到，第二行的高度略高，这就是之前提到的，line box会取最大的inline box的高度，而不是content-area的高度。</p>
<p><em>这句话是什么意思呢？</em><br>一个inline box（内联元素）包含两个高度：content-area和virtual-area（实际区域，可以理解成line-height，这是作者自定义的单词）<br><img src= "/img/loading.gif" data-src="v2-efe30b60d553cb6237f9c0cbdebb240b_720w.png" alt="这是图片"></p>
<p>注：<em>按这种理解，line-height表示的并不是两个baseline之间的距离。个人感觉有些争议，，，</em></p>
<p><img src= "/img/loading.gif" data-src="v2-0301a379ebf7d2dfcbb995c4a2cfc7fa_r.jpg" alt="这是图片"></p>
<p>virtual-area 和 content-area 高度的差异叫做 leading。leading 的一半会被加到 content-area 顶部，另一半会被加到底部。因此 content-area 总是处于 virtual-area 的中间。</p>
<p>计算出来的 line-height（也就是 virtual-area 的高度）可以等于、大于或小于 content-area。如果 virtual-area 小于 content-area，那么 leading 就是负的，因此 line-box 看起来就比内容还矮了。</p>
<p>常见的内联元素：</p>
<ul>
<li>可替换的内联元素，如 img / input / svg 等</li>
<li>inline-block 元素，以及所有 display 值以 inline- 开头的元素，如 inline-table / inline-flex</li>
<li>处于某种特殊格式化上下文的内联元素，例如 flexbox 元素中的子元素都处于 flex formatting context（弹性格式化上下文）中，这些子元素的 display 值都是「blockified」</li>
</ul>
<p>如果你将其 height 设置为 auto 的话，那么其高度的取值就是 line-height，其 content-area 的取值也是 line-height</p>
<p><img src= "/img/loading.gif" data-src="v2-924b688268ae43ff1c6ccda3bec78123_r.png" alt="这是图片"></p>
<p>现在为止，还是没有解释line-height:normal。</p>
<p>回到上图：<br><img src= "/img/loading.gif" data-src="v2-8fa5fa46b571db21c79bda208d6263c3_720w.png" alt="这是图片"><br>除了EM Size还看到了许多其他值，</p>
<ul>
<li>常规的 Ascent/Descent：ascender 是 770，descender 是 230，用于渲染字符。</li>
<li>规格 Ascent/Descent：ascender 是 1100，descender 是 540。用于计算 content-area 的高度</li>
<li>规格 Line Gap：用于计算 line-height: normal</li>
</ul>
<p>在 Catamaran 这款字体中，Line Gap 的值是 0，那么 line-height: normal 的结果就跟 content-area 的高度一样，是 1640 相对单位。<br>content-area 100/1000*(1100+540)</p>
<p>100px/1000个相对单位*(上半部分相对单位数量+下半部分单位数量)</p>
<p>为了对比，我们再看看 Arial 字体，它的 em-square 是 2048，ascender 是 1854，descender 是 434，line gap 是 67。那么当 font-size: 100px 时，</p>
<ul>
<li>其 content-area 的高度就是 100/2048*(1854+434) = 111.72，约为 112px；</li>
<li>其 line-height: normal 的结果就是 100/2048*(67+1854+434) 约为 115px。</li>
</ul>
<p>所有这些值都是由字体设计师设置的。</p>
<p>当 line-height 的值是一个数字时，其实就是相对 font-size 的倍数，而不是相对于 content-area。所以 line-height:1 很有可能使得 virtual-area 比 content-area 矮，从而引发很多其他的问题。</p>
<p><img src= "/img/loading.gif" data-src="v2-01f0ec3f893c7162af0b6104cfc304e5_720w.png" alt="这是图片"></p>
<p>不仅仅是 line-height:1 有问题，电脑上的 1117 款字体中，大概有 1059 款字体的 line-height 比 1 大，最低的是 0.618，最高的是 3.378。这说明，字体之间行高差距非常大。</p>
<p>line-box 计算的一些细节：</p>
<ul>
<li>对于内联元素，padding 和 border 会增大 background 区域，但是不会增大 content-area（不是 line-box 的高度）。一般来说你无法再屏幕上看到 content-area。margin-top 和 margin-bottom 对两者都没有影响。</li>
<li>对于可替换内联元素（replaced inline elements）、inline-block 元素和 blockified 内联元素，padding、margin 和 border 会增大 height（译者注：注意 margin），因此会影响 content-area 和 line-box 的高度</li>
</ul>
<p>现在我们终于得到一个结果：line-height:normal是由字体计算得出，并且它会对line box的表现产生影响。</p>
<p>我得出的结论是，当我们要规定居中时，除了要考虑子元素的line-height，同时也要考虑父元素，因为父元素也有默认的normal，会对高度产生影响，所以我们在父元素中，用line-height取代height来呈现高度，能达到最好的结果</p>
<p>结束。。。。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/25808995">https://zhuanlan.zhihu.com/p/25808995</a></li>
<li><a href="https://www.zhangxinxu.com/wordpress/2009/11/css%e8%a1%8c%e9%ab%98line-height%e7%9a%84%e4%b8%80%e4%ba%9b%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%e5%8f%8a%e5%ba%94%e7%94%a8/">https://www.zhangxinxu.com/wordpress/2009/11/css%e8%a1%8c%e9%ab%98line-height%e7%9a%84%e4%b8%80%e4%ba%9b%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%e5%8f%8a%e5%ba%94%e7%94%a8/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>MD To Html 的前端实现</title>
    <url>/2021/03/25/md2html%E7%9A%843%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>.md文件是markdown的一种标记语言，和html比较起来，更简单快捷，主要体现在：标记符的数量和书写上。</p>
<blockquote>
<p>标记符的数量：html文档要用N多个标记符加上css来控制样式； 而markdown文档只用到4个基本的标记符号。<br>标记符的书写：HTML文档需要&lt;开始&gt;和&lt;结束&gt;标识一个网页，而markdown文档只要在开始位置标记即可# 这是一个md文档。</p>
</blockquote>
<p>下面看看前端是如何实现.md文件转换成.html文件。</p>
<h2 id="方式一：使用i5ting-toc插件"><a href="#方式一：使用i5ting-toc插件" class="headerlink" title="方式一：使用i5ting_toc插件"></a>方式一：使用i5ting_toc插件</h2><p>需要先安装npm（安装node.js后会自带npm），然后才能安装i5ting插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install i5ting_toc -g</span><br></pre></td></tr></table></figure>
<p>执行命令行生成html文件，在输入前要进入到对应根目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i5ting_toc -f **.md</span><br></pre></td></tr></table></figure>
<p>需要注意的是：写md文档的特殊符号时记得添加空格。</p>
<h2 id="方式二：使用gitbook"><a href="#方式二：使用gitbook" class="headerlink" title="方式二：使用gitbook"></a>方式二：使用gitbook</h2><p>同样先需要安装node，然后运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i gitbook gitbook-cli -g</span><br></pre></td></tr></table></figure>
<p>生成md文件,这个命令会生成相应的md的文件，然后在相应的文件里写你的内容即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitbook init</span><br></pre></td></tr></table></figure>
<p>md转html,生成一个_doc目录，打开就可以看到你html文件了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitbook build</span><br></pre></td></tr></table></figure>
<h2 id="方式三：利用前端代码"><a href="#方式三：利用前端代码" class="headerlink" title="方式三：利用前端代码"></a>方式三：利用前端代码</h2><p>实现原理是采用node.js搭建服务器，读取md文件转化为html片断。浏览器发送ajax请求获取片段后再渲染生成html网页。  </p>
<p><code>node代码</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> marked = <span class="built_in">require</span>(<span class="string">&#x27;marked&#x27;</span>);    <span class="comment">// 将md转化为html的js包</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">&#x27;src&#x27;</span>));  <span class="comment">//加载静态文件</span></span><br><span class="line"><span class="keyword">var</span> urlencodedParser = bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/getMdFile&#x27;</span>,urlencodedParser, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = fs.readFileSync(<span class="string">&#x27;src/test.md&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);    <span class="comment">//读取本地的md文件</span></span><br><span class="line">    res.end(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        body : marked(data)</span><br><span class="line">    &#125;));</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动端口监听</span></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8088</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> host = server.address().address;</span><br><span class="line">    <span class="keyword">var</span> port = server.address().port;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;应用实例，访问地址为 http://%s:%s&quot;</span>, host, port)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>前端</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>md-to-HTML web app<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;article&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/JavaScript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-1.11.3.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> article = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;article&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">&quot;/getMdFile&quot;</span>, <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;  </span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;数据获取成功&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            article.innerHTML = <span class="built_in">JSON</span>.parse(result).body;</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(err);</span></span><br><span class="line"><span class="handlebars"><span class="xml">            article.innerHTML = &#x27;<span class="tag">&lt;<span class="name">p</span>&gt;</span>获取数据失败<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#x27;;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>mysql 索引</title>
    <url>/2020/02/04/mysql-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引(key)是存储引擎用于快速找到记录的一种数据结构。它和一本书中目录的工作方式类似——当要查找一行记录时，先在索引中快速找到行所在的位置信息，然后再直接获取到那行记录。<br>在MySql中，索引是在存储引擎层而不是服务器层实现的，所以不同的存储引擎对索引的实现和支持都不相同。</p>
<a id="more"></a>

<h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变为顺序I/O</li>
</ul>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul>
<li>普通索引</li>
<li>UNIQUE索引</li>
<li>主键索引</li>
</ul>
<h2 id="MyISAM索引与InnoDB索引那个快"><a href="#MyISAM索引与InnoDB索引那个快" class="headerlink" title="MyISAM索引与InnoDB索引那个快"></a>MyISAM索引与InnoDB索引那个快</h2><h3 id="MyISAM索引的实现"><a href="#MyISAM索引的实现" class="headerlink" title="MyISAM索引的实现"></a>MyISAM索引的实现</h3><pre><code>  MyISAM索引文件和数据文件是分离的，索引文件仅保存记录所在页的指针（物理位置），通过这些地址来读取页，进而读取被索引的行。下图是MyISAM的索引原理图：（为了简化，一个页内只存放了两条记录。）
</code></pre>
<p><img src= "/img/loading.gif" data-src="mq1.png"><br>      上图所提供的示例表字段有Col1（ID）、Col2(age)、Col3（name）三个，其中Col1为Primary Key（主键），上图很好地说明了树中叶子保存的是对应行的物理位置。通过该值，存储引擎能顺利地进行回表查询，得到一行完整记录。同时，每个叶子页也保存了指向下一个叶子页的指针。从而方便叶子节点的范围遍历。</p>
<pre><code>  而对于二级索引，在 MyISAM存储引擎中以与上图同样的方式实现，可以看出MyISAM的索引文件仅仅保存数据记录的地址。
</code></pre>
<h3 id="InnoDB索引的实现"><a href="#InnoDB索引的实现" class="headerlink" title="InnoDB索引的实现"></a>InnoDB索引的实现</h3><ol>
<li><p>1)聚集索引</p>
<p>   与 MyISAM相同的一点是，InnoDB 也采用 B+Tree这种数据结构来实现 B-Tree索引。而很大的区别在于，InnoDB 存储引擎采用&quot;聚集索引&quot;的数据存储方式实现B-Tree索引，所谓&quot;聚集&quot;，就是指数据行和相邻的键值紧凑地存储在一起，注意 InnoDB 只能聚集一个叶子页（16K）的记录（即聚集索引满足一定的范围的记录），因此包含相邻键值的记录可能会相距甚远。</p>
</li>
</ol>
<p>注意: innodb来说,</p>
<p>1 主键索引 既存储索引值,又在叶子中存储行的数据</p>
<p>2 如果没有主键, 则会Unique key做主键</p>
<p>3 如果没有unique,则系统生成一个内部的rowid做主键.</p>
<p>4 像innodb中,主键的索引结构中,既存储了主键值,又存储了行数据,这种结构称为&quot;聚簇索引&quot;</p>
<p>下图说明了 InnoDB聚集索引的实现方式，同时也体现了一张 innoDB表的结构，可以看到，InnoDB 中，主键索引和数据是一体的，没有分开。：</p>
<p><img src= "/img/loading.gif" data-src="mq2.png"><br>这种实现方式，给予了 InnoDB 按主键检索的超高性能。可以有目的性地选择聚集索引，比如一个邮件表，可以选择用户ID来聚集数据，这样只需要从磁盘读取较少并且连续的数据页就能获得某个id的用户全部的邮件，避免了读取分散页时所耗费的随机I/O。</p>
<p>2)辅助索引</p>
<pre><code>  而对于辅助索引，InnoDB采用的方式是在叶子页中保存主键值，通过这个主键值来回表（上图）查询到一条完整记录，因此按辅助索引检索实际上进行了二次查询，效率肯定是没有按照主键检索高的。下图是辅助索引的实现方式：
</code></pre>
<p><img src= "/img/loading.gif" data-src="mq3.png"><br>      由于每个辅助索引都包含主键索引，因此，为了减小辅助索引所占空间，我们通常希望 InnoDB 表中的主键索引尽量定义得小一些（值得一提的是，MySIAM会使用前缀压缩技术使得索引变小，而InnoDB按照原数据格式进行存储。），并且希望InnoDB的主键是自增长的，因为如果主键并非自增长，插入时，由于写入时乱序的，会使得插入效率变低。</p>
<p>参考：<a href="https://blog.csdn.net/frycn/article/details/70158313">https://blog.csdn.net/frycn/article/details/70158313</a></p>
<p><a href="https://blog.csdn.net/ljfphp/article/details/80029968">https://blog.csdn.net/ljfphp/article/details/80029968</a></p>
<ol start="5">
<li>索引:用于加快查找数据的速度的一种内部机制。</li>
</ol>
<p>如何定位一个慢sql：</p>
<ol>
<li>开启慢查询日志，默认是不开启，showvariableslike&#39;%slow%、set log_slow_queries on  set long_query_time=5; 默认是10</li>
<li>mysqldumpslow –help可显示其参数的使用</li>
</ol>
<p>得到返回记录最多的20个sql</p>
<p>mysqldumpslow -s r -t 20 sqlslow.log</p>
<p>得到平均访问次数最多的20条sql</p>
<p>mysqldumpslow -s ar -t 20 sqlslow.log</p>
<p>参考：<a href="https://blog.csdn.net/sunyuhua_keyboard/article/details/81204020">https://blog.csdn.net/sunyuhua_keyboard/article/details/81204020</a></p>
<ol>
<li>explain + 慢sql</li>
<li>show profiles 细致分析mysql 生命周期和执行细节</li>
<li>sql 服务器调优（后边有介绍）</li>
</ol>
<p>先讲解explain 参考：<a href="https://www.cnblogs.com/yycc/p/7338894.html">https://www.cnblogs.com/yycc/p/7338894.html</a></p>
<p><a href="https://www.cnblogs.com/gomysql/p/3720123.html">https://www.cnblogs.com/gomysql/p/3720123.html</a></p>
<p><img src= "/img/loading.gif" data-src="mq4.png"></p>
<p>EXPLAIN select * from store_info where id in (SELECT store_info_id from attachment where file_type = 2);</p>
<p><img src= "/img/loading.gif" data-src="mq5.png"><br>Id：这是SELECT的查询序列号，id相同时 由上至下执行，id不同时，数值越大越先执行。</p>
<p>select_type: SELECT类型,可以为以下任何一种:</p>
<ul>
<li><strong>SIMPLE</strong>:简单SELECT(不使用UNION或子查询)</li>
<li><strong>PRIMARY</strong>:最外面的SELECT</li>
<li><strong>UNION</strong>:UNION中的第二个或后面的SELECT语句</li>
<li><strong>DEPENDENT UNION</strong>:UNION中的第二个或后面的SELECT语句,取决于外面的查询</li>
<li><strong>UNION RESULT</strong>:UNION 的结果</li>
<li><strong>SUBQUERY</strong>:子查询中的第一个SELECT</li>
<li><strong>DEPENDENT SUBQUERY</strong>:子查询中的第一个SELECT,取决于外面的查询</li>
<li><strong>DERIVED</strong>:导出表的SELECT(FROM子句的子查询)</li>
</ul>
<p>Table ：输出的行所引用的表</p>
<p>Type: 访问类型  ALL, index,  range, ref, eq_ref, const, system, NULL</p>
<ul>
<li><p>==system==: 表仅有一行(=系统表)。这是const联接类型的一个特例。</p>
</li>
<li><p>==const==: 表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!</p>
   <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span>\<span class="operator">*</span><span class="keyword">from</span> ( <span class="keyword">select</span>\<span class="operator">*</span><span class="keyword">from</span> t1 <span class="keyword">where</span> id<span class="operator">=</span> <span class="operator">*</span><span class="operator">*</span><span class="number">1</span><span class="operator">*</span><span class="operator">*</span> )b1;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong></strong> eq_ref:就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条</p>
</li>
<li><p><strong></strong> ref: 使用非唯一索引扫描或者唯一索引的前缀扫描，返回匹配某个单独值的记录行</p>
</li>
<li><p><strong></strong> range:索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行。显而易见的索引范围扫描是带有between或者where子句里带有&amp;lt;, &amp;gt;查询。当mysql使用索引去查找一系列值时，例如IN()和OR列表，也会显示range（范围扫描）,当然性能上面是有差异的。</p>
</li>
<li><p><strong></strong> index:该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。</p>
</li>
<li><p><strong></strong> ALL:MySQL将遍历全表以找到匹配的行。</p>
</li>
<li><p><strong></strong> NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p>
   <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span>\<span class="operator">*</span><span class="keyword">from</span> t1 <span class="keyword">where</span> id <span class="operator">=</span> (selectmin(id) <span class="keyword">from</span> t2);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>possible_keys <strong>:</strong> 指出MySQL能使用哪个索引在该表中找到行</p>
<p>key : 显示MySQL实际决定使用的键(索引)<br>key_len : 显示MySQL决定使用的键长度</p>
<p>ref : 显示使用哪个列或常数与key一起从表中选择行。</p>
<p>Rows <strong>:</strong> 显示MySQL认为它执行查询时必须检查的行数。</p>
<p><strong>Extra</strong>  <strong>:</strong></p>
<ul>
<li><p><strong></strong> Using filesort:MySQL需要额外的一次传递,以找出如何按排序顺序检索行。</p>
<p>explain select store_id from store_info where id in (1,2) ORDER BY id</p>
<p>explain select store_id from store_info where id in (1,2) ORDER BY store_id</p>
</li>
<li><p><strong></strong> Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。（覆盖索引）</p>
<p>explain select store_id from store_info where store_id in (1,2) ORDER BY store_id</p>
</li>
<li><p><strong></strong> Using temporary: 这个值表示使用了内部临时(基于内存的)表。一个查询可能用到多个临时表。有很多原因都会导致MySQL在执行查询期间创建临时表。两个常见的原因是在来自不同表的上使用了DISTINCT,或者使用了不同的ORDER BY和GROUP BY31,1312列。 A,B    b,a</p>
</li>
</ul>
<p>explain select id from store_info where id in (1,2) GROUP BY store_id</p>
<ul>
<li><p><strong></strong> Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。</p>
</li>
<li><p><strong></strong> Impossible where<br>这个值强调了where语句会导致没有符合条件的行。</p>
<pre><code>   EXPLAIN SELECT \* FROM t1 WHERE 1=2;
</code></pre>
</li>
</ul>
<p>6.覆盖索引：全值匹配 多列索引 (推荐)</p>
<p><img src= "/img/loading.gif" data-src="mq6.png"><br>EXPLAIN SELECT * from store_info  where store_id  = 1 and vender_id =2</p>
<p>如上：用多少个索引？</p>
<p><img src= "/img/loading.gif" data-src="mq7.png"><br>explain SELECT store_id  from store_info where  store_id = 1 and vender_id = 1;</p>
<p>explain SELECT store_id  from store_info where  store_id != 1 and  vender_id = 1;</p>
<p>explain SELECT store_id  from store_info where  store_id != 1;</p>
<p>explain SELECT store_id  from store_info where  store_id = 1 OR vender_id = 1;</p>
<p>explain SELECT store_id  from store_info where  store_id != 1 OR vender_id = 1;</p>
<p>explain SELECT store_id  from store_info where  store_id = 1 or vender_id = 1 ORDER BY store_id;</p>
<p>7.避免索引失效：（多列索引）</p>
<ol>
<li><p>针对多列索引，采用最左匹配法则，中间不能断（包括大约等于 小于）</p>
</li>
<li><p>不能再索引上做任何操作函数和类型转换（下面有讲）</p>
</li>
<li><p>范围查询左侧全失效，  name=&quot;&quot; and age &amp;gt; 25 and type=&quot;&quot;</p>
</li>
<li><p>尽量使用覆盖索引，用三个字段创建索引，只用其中一两个字段，尽量少用select * from  user</p>
</li>
<li><p>使用 !=   &amp;lt;&amp;gt; 会全表扫描。`</p>
<p>explain  SELECT * from store_label where label_type_id  !=1</p>
</li>
<li><p>is not null 会全表扫描。</p>
<p>explain  SELECT * from store_label where label_type_id  is not null;</p>
</li>
<li><p>Like  &quot;%ssss%&quot;  &quot;%sfds&quot;</p>
</li>
<li><p>字符串不加单引号，如：2000  （因为内部使用了 类型转换函数）。</p>
</li>
<li><p>少用or 用它连接查询导致索引失效。</p>
<p>explain  SELECT * from store_label where label_type_id  is null  or label_name like &quot;1123%&quot;;</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx location 使用指南</title>
    <url>/2020/02/04/nginx-location-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="什么是location"><a href="#什么是location" class="headerlink" title="什么是location"></a>什么是location</h2><ul>
<li>它是nginx基于http协议跟外界沟通的桥梁，用来匹配并执行一个规范化的URI，任何http请求都需要经过它的“同意”才能通过nginx的大门</li>
<li>它长什么样子呢，比如我们常见的一种配置<a id="more"></a>

</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /hello &#123;</span><br><span class="line">   <span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>/xxxx 除了这种还有没有其他的写法？ 是不是没有？ 要想知道有没有其他的写法是不是要从系统层面（api）去了解一下，才能扩展 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#location">官方</a></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;</span><br><span class="line">location @name &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>语法规则很简单，一个location关键字，后面跟着可选的修饰符，后面是要匹配的字符，花括号中是要执行的操作。</p>
<ul>
<li>修饰符<br>= 表示精确匹配。只有请求的url路径与后面的字符串完全相等时，才会命中。<br>~ 表示该规则是使用正则定义的，区分大小写。<br><del>* 表示该规则是使用正则定义的，不区分大小写。<br>^</del> 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找</li>
</ul>
<h2 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> = /a &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;wo shi /,url=$uri&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>精确匹配一个字都不能错, /a 可以，但是 /a/ 就不行</p>
<h2 id="普通匹配-和"><a href="#普通匹配-和" class="headerlink" title="普通匹配    / 和  ^~"></a>普通匹配    / 和  ^~</h2><ul>
<li>/   我们经常使用，是以其后设置的uri作为前缀来匹配请求的</li>
<li>^~  不常用的 也是以其后设置的uri作为前缀来匹配请求的</li>
<li>从概念上讲他们是一样的，实际使用也是一样的，但是他们有哪些细微差别呢？ 这个稍后讲</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /b &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;wo shi /,url=$uri&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /b &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;wo shi ^~,url=$uri&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们访问  /b 或者 /bc 或者 /ba 都是可以访问的</p>
<p>验证一下 / ,^~ 是前缀匹配，我们可以试一下 /x/b 看看能不能访问？</p>
<h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><ul>
<li>~  区分大小写  ，在其后的uri就变成了正则表达式</li>
<li>~* 不区分大小写，在其后的uri就变成了正则表达式</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span>  <span class="regexp">~ /b</span> &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;wo shi /,url=$uri&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* /b</span> &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;wo shi /,url=$uri&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面说普通匹配的时候 我们使用了location /b ,这里正则也使用了 /b 如果同时存在，他们先使用那个呢？ 为什么？这个呢也稍后讲</p>
<p>还有普通匹配试了 /x/b 返回状态404 ， 那使用正则模式呢，状态是多少？ 正则模式 /b 可以是第一个 也可是是最后一个</p>
<p>正则是不是完事了？咦，不对 好像少了点什么？ 说好的正则 我堂堂 \d \w [a-z] \d{9,11} 哪里去了，是不是感觉少了点东西</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">location  ~ &quot;/(\d&#123;1,11&#125;)&quot; &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;hi paimai,url=$uri&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是这样  我们拍卖单品页是不是这样的  paimai.jd.com/123456789<br>是不是很完美？ 有没有问题?<br>前面我们正则部分我们说了  普通模式 /b 和正则模式 /b 区别 ，回顾一下<br>我之前写的时候就遇到过这样的问题  paimai.jd.com/album/123456789 也被匹配到了</p>
<p>那么问题来了 正则模式里面怎么精确匹配</p>
<p>^/a 的意思就是，匹配以/a开头的字符串<br>.html$   的意思就是 以.html结尾</p>
<p>再重新写一下单品页的匹配方式</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">location ~* &quot;^/(\d&#123;9,11&#125;)$&quot; &#123;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;hi paimai,url=$uri&quot;</span>;</span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure>


<p>使用正则定义的location在配置文件中出现的顺序很重要。因为找到第一个匹配的正则后，查找就停止了，后面定义的正则就是再匹配也没有机会了。</p>
<p>到这里正则模式才算完了^_^</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="@ 模式"></a>@ 模式</h2><ul>
<li>这里内部的意思是指外部用户看不到的location</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> @/d &#123;</span><br><span class="line">   <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;paimai&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以试着访问一下</p>
<p>正确使用<br>error_page 404 @/d</p>
<h2 id="刚刚我们在说-普通匹配-和正则匹配里面-放了两个-这个稍后讲-的问题"><a href="#刚刚我们在说-普通匹配-和正则匹配里面-放了两个-这个稍后讲-的问题" class="headerlink" title="刚刚我们在说  普通匹配 和正则匹配里面 放了两个 这个稍后讲 的问题"></a>刚刚我们在说  普通匹配 和正则匹配里面 放了两个 这个稍后讲 的问题</h2><ol>
<li>/ 和  ^~ 普通模式里面，两个同时存在的时候 使用的是那个location,是不是有个优先级的问题</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /b &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;wo shi /,url=$uri&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /b &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;wo shi ^~,url=$uri&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>/ 和  ~  普通模式 和 匹配模式 同时存在 /b 的时候，优先使用的是那个location </li>
</ol>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /b &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;wo shi /,url=$uri&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span>  <span class="regexp">~ /b</span> &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;wo shi ~/,url=$uri&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>^~ 和  ~ 的优先级呢</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /b &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;wo shi ^~,url=$uri&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span>  <span class="regexp">~ /b</span> &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;wo shi ~/,url=$uri&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>得出的结论</p>
<p>普通匹配优先级要低于正则匹配，而^~的匹配优先级要高于正则匹配</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx基础知识</title>
    <url>/2021/03/25/nginx%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Nginx-学习手册"><a href="#Nginx-学习手册" class="headerlink" title="Nginx 学习手册"></a>Nginx 学习手册</h1><p>什么是Nginx</p>
<blockquote>
<p>简单说： Nginx 是个神奇的 Web 服务器<br>专业说：Nginx 是一个采用主从架构的 Web 服务器，可用于反向代理、负载均衡器、邮件代理和 HTTP 缓存。</p>
</blockquote>
<p>Nginx 是一个高性能的 HTTP 和反向代理服务器，特点是占用内存少，并发能力强，事实上 Nginx 的并发能力确实在同类型的网页服务器中表现较好。Nginx 专为性能优化而开发，性能是其最重要的要求，十分注重效率，有报告 Nginx 能支持高达 50000 个并发连接数。</p>
<h2 id="Nginx-知识网结构图"><a href="#Nginx-知识网结构图" class="headerlink" title="Nginx 知识网结构图"></a>Nginx 知识网结构图</h2><p><img src= "/img/loading.gif" data-src="struct.jpg" alt="Nginx 知识网结构图" title="Nginx 知识网结构图"></p>
<h2 id="Nginx专业术语"><a href="#Nginx专业术语" class="headerlink" title="Nginx专业术语"></a>Nginx专业术语</h2><p><img src= "/img/loading.gif" data-src="640.gif" alt="Nginx 专业术语" title="Nginx 专业术语"><br>Nginx 的基本特性是代理，所以你一定要明白什么是代理和反向代理。</p>
<h4 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h4><h5 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h5><p>局域网中的电脑用户想要直接访问网络是不可行的，只能通过代理服务器来访问，这种代理服务就被称为正向代理。</p>
<p><img src= "/img/loading.gif" data-src="proxy.jpg" alt="Nginx 正向代理" title="Nginx 正向代理"></p>
<blockquote>
<p>通俗讲：client1 和 client2 通过代理服务器向服务器发送请求 request1 和 request2，此时后端服务器不知道 request1 是由 client1 发送的还是 client2 发送的，但会执行（响应）操作。<br><strong>服务器</strong>不知道请求<strong>谁发起的</strong></p>
</blockquote>
<h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h5><p>客户端无法感知代理，因为客户端访问网络不需要配置，只要把请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据，然后再返回到客户端。<br>此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。</p>
<p><img src= "/img/loading.gif" data-src="r-proxy.jpg" alt="Nginx 反向代理" title="Nginx 反向代理"></p>
<blockquote>
<p>通俗讲：客户端将通过 Web 服务器发送请求. 而 Web 服务器会通过一个算法，当中最有意思的算法是轮询，直接将请求指向许多后端服务器中的一个，并通过 Web 服务器将响应返回给客户端。因此，在上面的例子中，客户端其实并不知道在与哪个后端服务器进行交互。<br><strong>客户端</strong>不知道请求<strong>是谁处理的</strong></p>
</blockquote>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>又是枯燥的一个名词：负载均衡，不过它很好理解，因为负载均衡本身就是反向代理的一个实例。</p>
<p><strong>有状态应用</strong><br><img src= "/img/loading.gif" data-src="has-status.webp" alt="有状态应用" title="有状态应用"></p>
<blockquote>
<p>如图所示，一个后端服务器 server1 存储了一些信息，服务器 server2 并不存储此信息，因此，客户端 (上图 Bob) 的交互可能会也可能不会得到想要的结果，因为它可能会与 server1 或 server2 交互。在本例中，server1 允许 Bob 查看数据文件，但 server2 不允许。因此，虽然有状态应用避免对数据库的多次 API 调用，并且（响应）速度更快，但它可能会在不同的服务器上导致这个（无法得到想要结果）问题。</p>
</blockquote>
<p><strong>无状态应用</strong><br><img src= "/img/loading.gif" data-src="no-status.webp" alt="无状态应用" title="无状态应用"></p>
<blockquote>
<p>如果我通过 Web 服务器从客户端向后端服务器 server1 发送请求，它将向客户端返回一个令牌，用于任何进一步的访问请求。客户端可以使用令牌并向 Web 服务器发送请求。此时 Web 服务器将请求连同令牌一起发送到任意后端服务器，而每个后端服务器都能提供相同的所需结果。</p>
</blockquote>
<p><strong>负载均衡与反向代理的区别</strong></p>
<blockquote>
<ul>
<li>负载均衡: 必须有 2 个或者更多的后端服务器</li>
<li>反向代理: 一台后端服务器也能运作</li>
</ul>
</blockquote>
<p>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕之后，再将结果返回给客户端。</p>
<ul>
<li>普通请求和响应过程如下图：<br><img src= "/img/loading.gif" data-src="request.webp" alt="Nginx 反向代理" title="Nginx 反向代理"></li>
</ul>
<p>但是随着信息数量增长，访问量和数据量飞速增长，普通架构无法满足现在的需求。</p>
<p>我们首先想到的是升级服务器配置，可以由于<code>摩尔定律</code>的日益失效，单纯从硬件提升性能已经逐渐不可取了，怎么解决这种需求呢？</p>
<p>我们可以增加服务器的数量，构建集群，将请求分发到各个服务器上，将原来请求集中到单个服务器的情况改为请求分发到多个服务器，也就是我们说的负载均衡。</p>
<ul>
<li>负载均衡<br><img src= "/img/loading.gif" data-src="balance.jpg" alt="Nginx 负载均衡" title="Nginx 负载均衡"></li>
</ul>
<p>假设有 15 个请求发送到代理服务器，那么由代理服务器根据服务器数量，平均分配，每个服务器处理 5 个请求，这个过程就叫做负载均衡。</p>
<h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>为了加快网站的解析速度，可以把动态页面和静态页面交给不同的服务器来解析，加快解析的速度，降低由单个服务器的压力。</p>
<ul>
<li>动静分离前<br><img src= "/img/loading.gif" data-src="before-split.jpg" alt="Nginx 动静分离前" title="Nginx 动静分离前"></li>
<li>动静分离后<br><img src= "/img/loading.gif" data-src="after-split.jpg" alt="Nginx 动静分离后" title="Nginx 动静分离后"></li>
</ul>
<h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><h4 id="Windows-安装"><a href="#Windows-安装" class="headerlink" title="Windows 安装"></a>Windows 安装</h4><p>下载地址：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a><br>下载后，解压，直接运行nginx.exe即可</p>
<h4 id="Linux-安装"><a href="#Linux-安装" class="headerlink" title="Linux 安装"></a>Linux 安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install nginx </span><br></pre></td></tr></table></figure>

<h4 id="Mac-安装"><a href="#Mac-安装" class="headerlink" title="Mac 安装"></a>Mac 安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">$ brew install Nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">$ nginx </span><br><span class="line"><span class="comment"># OR </span></span><br><span class="line">$ sudo nginx</span><br><span class="line"><span class="comment"># 默认8080端口 http://localhost:8080/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">$ nginx -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置nginx.conf 文件</span></span><br><span class="line">$ nginx -c file name </span><br><span class="line"><span class="comment"># brew 安装默认位置： /opt/homebrew/etc/nginx</span></span><br></pre></td></tr></table></figure>
<h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><p>场景一： 我们将在一个公共端口上运行两个文件夹，并设置我们想要的规则<br>本地目录结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">├── nginx-demo</span><br><span class="line">│  ├── content</span><br><span class="line">│  │  ├── first.txt</span><br><span class="line">│  │  ├── index.html</span><br><span class="line">│  │  └── index.md</span><br><span class="line">│  └── main</span><br><span class="line">│    └── index.html</span><br><span class="line">└── temp-nginx</span><br><span class="line">  └── outsider</span><br><span class="line">    └── index.html</span><br></pre></td></tr></table></figure>
<p><strong>1、添加配置的基本设置</strong><br>一定要添加 <code>events &#123;&#125;</code>，因为在 Nginx 架构中，它通常用来表示 worker 的数量。<br>用 http 告诉 Nginx 我们将在 OSI 模型 的第 7 层作业。</p>
<p>我们告诉 Nginx 监听 5000 端口，并指向 main 文件夹中的静态文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">  worker_connections  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">  server &#123;</span><br><span class="line">    listen <span class="number">5000</span>;</span><br><span class="line">    root /path/to/nginx-demo/main/; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、添加其他规则</strong><br>接下来我们将为 <code>/content</code> 和 <code>/outsider</code> URL 添加其他的规则，其中 <strong>outsider</strong> 将指向第一步中提到的根目录之外的目录。</p>
<p>这里的 <code>location /content</code>  表示无论我在叶（leaf）目录中定义了什么根（root），<strong>content</strong> 子 URL 都会被添加到定义的根 URL 的末尾。因此，当我指定 root 为 <code>root /path/to/nginx-demo/</code>时，这仅仅意味着我告诉 Nginx 在 <code>http://localhost:5000/path/to/nginx-demo/content/</code> 文件夹中显示静态文件的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">  worker_connections  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">  server &#123;</span><br><span class="line">    listen <span class="number">5000</span>;</span><br><span class="line">    root /path/to/nginx-demo/main/; </span><br><span class="line"></span><br><span class="line">    location /content &#123;</span><br><span class="line">      root /path/to/nginx-demo/;</span><br><span class="line">    &#125;   </span><br><span class="line">    location /outsider &#123;</span><br><span class="line">      root /path/temp-nginx/;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>现在 Nginx 不仅能定义 URL 根路径，还可以设置规则，这样我们就能阻止客户端访问某个文件了。</strong></p>
</blockquote>
<p><strong>3、限制访问</strong><br>接下来，我们在主服务器上编写一个规则来防止任意 .md 文件被访问。我们可以在 Nginx 中使用正则表达式，因此我们将这样定义规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location ~ .md &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、来看看代理 proxy_pass</strong><br>我们已经在5000端口上运行了服务，再起一个在8888端口上的服务,这样我们就有两个服务了。</p>
<p>我们要做的是：当客户端通过 Nginx 访问 8888 端口时，将这个请求传到 5000 端口，并将响应返回给客户端！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen <span class="number">8888</span>;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http:<span class="comment">//localhost:5000/;</span></span><br><span class="line">  &#125;</span><br><span class="line">  location /<span class="keyword">new</span> &#123;</span><br><span class="line">    proxy_pass http:<span class="comment">//localhost:5000/outsider/;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5、负载均衡</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream myserver&#123;</span><br><span class="line">  <span class="comment">#ip_hash</span></span><br><span class="line">  server 127.0.0.1:5000 weight=1;</span><br><span class="line">  server 127.0.0.1:8888 weight=2;</span><br><span class="line">  <span class="comment">#fair; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 8000;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://myserver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>负载均衡方式如下：</strong></p>
<blockquote>
<p>轮询（默认）。<br>weight，代表权，权越高优先级越高。<br>fair，按后端服务器的响应时间来分配请求，相应时间短的优先分配。<br>ip_hash，每个请求按照访问 ip 的 hash 结果分配，这样每一个访客固定的访问一个后端服务器，可以解决 Session 的问题。</p>
</blockquote>
<p><strong>6、动静分离实战</strong><br><img src= "/img/loading.gif" data-src="after-split.jpg" alt="Nginx 动静分离后" title="Nginx 动静分离后"></p>
<blockquote>
<p>纯粹将静态文件独立成单独域名放在独立的服务器上，也是目前主流方案。<br>将动态跟静态文件混合在一起发布，通过 Nginx 分开</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location /image/ &#123;</span><br><span class="line">  root /path/to/images/;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>看一下所有配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">  worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 5000;</span><br><span class="line">    root /path/to/nginx-demo/main/; </span><br><span class="line"></span><br><span class="line">    location /content &#123;</span><br><span class="line">      root /path/to/nginx-demo/;</span><br><span class="line">    &#125;   </span><br><span class="line">    location /outsider &#123;</span><br><span class="line">      root /path/temp-nginx/;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ .md &#123;</span><br><span class="line">      <span class="built_in">return</span> 403;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  server &#123;</span><br><span class="line">    listen 8888;</span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass http://localhost:5000/;</span><br><span class="line">    &#125;</span><br><span class="line">    location /new &#123;</span><br><span class="line">      proxy_pass http://localhost:5000/outsider/;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 4、负载均衡</span></span><br><span class="line">  server &#123;</span><br><span class="line">    listen 8000;</span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass http://myserver;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream myserver&#123;</span><br><span class="line">  <span class="comment">#ip_hash</span></span><br><span class="line">  server 127.0.0.1:5000 weight=1;</span><br><span class="line">  server 127.0.0.1:8888 weight=2;</span><br><span class="line">  <span class="comment">#fair; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来把服务启起来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nginx</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">$ sudo nginx</span><br></pre></td></tr></table></figure>
<p><strong>Nginx的其他命令</strong></p>
<ul>
<li>1、首次启动 Nginx Web 服务器。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nginx </span><br><span class="line"><span class="comment"># OR </span></span><br><span class="line">$ sudo nginx</span><br></pre></td></tr></table></figure></li>
<li>2、重新加载正在运行的 Nginx Web 服务器。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nginx -s reload</span><br><span class="line"><span class="comment"># OR </span></span><br><span class="line">$ sudo nginx -s reload</span><br></pre></td></tr></table></figure></li>
<li>3、停止正在运行中的 Nginx Web 服务器。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nginx -s stop</span><br><span class="line"><span class="comment"># OR </span></span><br><span class="line">$ sudo nginx -s stop</span><br></pre></td></tr></table></figure></li>
<li>4、查看系统上运行的 Nginx 进程。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps -ef | grep Nginx</span><br></pre></td></tr></table></figure>
第 4 条命令很重要，如果前 3 条命令产生了一些问题，通常你可以用第 4 条命令找到所有正在运行的 Nginx 进程并杀死进程，然后重新启动它们。</li>
</ul>
<p>要杀死一个进程，你需要 PID，再用以下命令杀死它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -9 &lt;PID&gt;</span><br><span class="line"><span class="comment"># OR </span></span><br><span class="line">$ sudo <span class="built_in">kill</span> -9 &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<p><strong>location 指令说明，该语法用来匹配 url，语法如下：</strong></p>
<blockquote>
<p>=：用于不含正则表达式的 url 前，要求字符串与 url 严格匹配，匹配成功就停止向下搜索并处理请求。<br>~：用于表示 url 包含正则表达式，并且区分大小写。<br>~*：用于表示 url 包含正则表达式，并且不区分大小写。<br>^~：用于不含正则表达式的 url 前，要求 Nginx 服务器找到表示 url 和字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再匹配。<br>如果有 url 包含正则表达式，不需要有 ~ 开头标识。</p>
</blockquote>
<p>摩尔定律<br>每18到24个月，集成电路上可容纳的元器件数目便会增加一倍，芯片的性能也会随之翻一番</p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>npm发包</title>
    <url>/2020/09/19/npm%E5%8F%91%E5%8C%85/</url>
    <content><![CDATA[<h1 id="npm发包"><a href="#npm发包" class="headerlink" title="npm发包"></a>npm发包</h1><h3 id="配置环境-安装node-js"><a href="#配置环境-安装node-js" class="headerlink" title="配置环境 安装node.js"></a>配置环境 安装node.js</h3><ul>
<li>官网下载最新的node安装包，正常安装node.js</li>
<li>安装完成后，执行 node -v, 查看是否正常安装</li>
<li>执行：sudo npm update npm -g，将npm 升级到最新</li>
<li>查看npm是否正常： npm -v</li>
</ul>
<h3 id="发包具体示例"><a href="#发包具体示例" class="headerlink" title="发包具体示例"></a>发包具体示例</h3><ul>
<li>注册npm账号，填写 用户名、密码和邮箱</li>
<li>找个位置，新建一个文件夹</li>
<li>cd 进入文件夹，执行 npm init -y, 有需要改变的内容自己再去文件修改和添加</li>
<li>使用 npm login，登录自己的 npm 账号</li>
<li>使用 npm publish，发布自己的包到 npm</li>
<li>查看自己发布的包是否成功，可以去别的项目执行 npm install 你发布的包名，下载成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line">1. 发布自己包之前，应先去 npm 官网搜索自己要发布的包名是否已经存在，已存在的包名会提交失败</span><br><span class="line">2. 自己发布的包更新时，每次都要到package.json, 将 version 修改，例如：从1.0.0改为1.0.1。然后再执行 npm publish进行更新</span><br><span class="line">整体步骤示例图片如下：</span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a><img src= "/img/loading.gif" data-src="npm-1.png"></h5><h3 id="查看自己发布的包"><a href="#查看自己发布的包" class="headerlink" title="查看自己发布的包"></a>查看自己发布的包</h3><ul>
<li><p>打开npm官网，输入你的包名，如有结果则存在 (如图)</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src= "/img/loading.gif" data-src="npm-2.png"></h4></li>
<li><p>点击个人头像 -&gt; Packages, 可查看自己已发布的所有包 (如图)</p>
</li>
</ul>
<h4 id="-2"><a href="#-2" class="headerlink" title=""></a><img src= "/img/loading.gif" data-src="npm-3.jpg"></h4>]]></content>
  </entry>
  <entry>
    <title>Nginx基础知识</title>
    <url>/2021/06/29/npx%E6%80%8E%E4%B9%88%E7%94%A8/</url>
    <content><![CDATA[<h2 id="NPX的主要作用"><a href="#NPX的主要作用" class="headerlink" title="NPX的主要作用"></a>NPX的主要作用</h2><h3 id="调用项目安装的模块"><a href="#调用项目安装的模块" class="headerlink" title="调用项目安装的模块"></a>调用项目安装的模块</h3><p>npx主要解决的问题： 调用项目内部安装的模块; 如测试工具 Mocha</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -D mocha</span><br><span class="line"></span><br><span class="line"><span class="comment"># 未使用npx 项目的根目录下执行</span></span><br><span class="line">$ node-modules/.bin/mocha --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用npx 就方便多了</span></span><br><span class="line">$ npx mocha --version</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。</p>
<p>由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 等同于 ls</span></span><br><span class="line">$ npx ls</span><br></pre></td></tr></table></figure>
<p>注意，Bash 内置的命令不在<code>$PATH</code>里面，所以不能用。比如，<code>cd</code>是 Bash 命令，因此就不能用<code>npx cd</code></p>
<h3 id="避免全局安装模块"><a href="#避免全局安装模块" class="headerlink" title="避免全局安装模块"></a>避免全局安装模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npx 将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app</span></span><br><span class="line">$ npx create-react-app my-react-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本 </span></span><br><span class="line">$ npx uglify-js@3.1.0 main.js -o ./dist/main.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块</span></span><br><span class="line"><span class="comment"># 本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。</span></span><br><span class="line">$ npx http-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># --no-install 强制使用本地模块，不下载远程模块, 如果不存在就报错</span></span><br><span class="line">$ npx --no-install http-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># --ignore-existing 忽略本地的同名模块，强制安装使用远程模块</span></span><br><span class="line">$ npx --ignore-existing create-react-app my-react-app</span><br></pre></td></tr></table></figure>

<h3 id="使用不同版本的node"><a href="#使用不同版本的node" class="headerlink" title="使用不同版本的node"></a>使用不同版本的node</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npx node@<span class="number">0.12</span><span class="number">.8</span> -v</span><br><span class="line">v0<span class="number">.12</span><span class="number">.8</span></span><br></pre></td></tr></table></figure>
<p>使用 0.12.8 版本的 Node 执行脚本。原理是从 npm 下载这个版本的 node，使用后再删掉。<br>某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些。</p>
<h4 id="p-参数"><a href="#p-参数" class="headerlink" title="-p 参数"></a>-p 参数</h4><p><code>-p</code>参数用于指定 npx 所要安装的模块，所以上面的命令可以写成下面这样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx -p node@0.12.8 node -v </span><br><span class="line">v0.12.8</span><br></pre></td></tr></table></figure>
<p>上面命令先指定安装<code>node@0.12.8</code>，然后再执行<code>node -v</code>命令。</p>
<h4 id="c-参数"><a href="#c-参数" class="headerlink" title="-c 参数"></a>-c 参数</h4><p>如果 npx 安装多个模块，默认情况下，所执行的命令之中，只有第一个可执行项会使用 npx 安装的模块，后面的可执行项还是会交给 Shell 解释。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx -p lolcatjs -p cowsay <span class="string">&#x27;cowsay hello | lolcatjs&#x27;</span></span><br><span class="line"><span class="comment"># 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>cowsay hello | lolcatjs</code>执行时会报错，原因是第一项<code>cowsay</code>由 npx 解释，而第二项命令<code>localcatjs</code>由 Shell 解释，但是<code>lolcatjs</code>并没有全局安装，所以报错。<br><code>-c</code>参数可以将所有命令都用 npx 解释。有了它，下面代码就可以正常执行了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx -p lolcatjs -p cowsay -c <span class="string">&#x27;cowsay hello | lolcatjs&#x27;</span></span><br></pre></td></tr></table></figure>
<p>-c参数的另一个作用，是将环境变量带入所要执行的命令。举例来说，npm 提供当前项目的一些环境变量，可以用下面的命令查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm run env | grep npm_</span><br></pre></td></tr></table></figure>
<p>-c参数可以把这些 npm 的环境变量带入 npx 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx -c <span class="string">&#x27;echo &quot;$npm_package_name&quot;&#x27;</span></span><br><span class="line"><span class="comment"># 输出当前项目的项目名</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>npm npx</tag>
      </tags>
  </entry>
  <entry>
    <title>React 内置 Hook 简介</title>
    <url>/2020/02/21/react-hooks/</url>
    <content><![CDATA[<p>React 内置 Hook 如下：</p>
<ul>
<li>基础 Hook<ul>
<li>useState</li>
<li>useEffect</li>
<li>useContext</li>
</ul>
</li>
<li>额外 Hook<ul>
<li>useReducer</li>
<li>useCallback</li>
<li>useMemo</li>
<li>useRef</li>
<li>useImperativeHandle</li>
<li>useLayoutEffect</li>
<li>useDebugValue</li>
</ul>
</li>
</ul>
<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(initialState);</span><br></pre></td></tr></table></figure>
<p>为函数组件添加一个内部 state，在组件重新渲染时保留 state 的值，返回一个数组，第一个值为 state 的值，第二个值为更新 state 值的函数。</p>
<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useEffect(didUpdate, [deps]);</span><br></pre></td></tr></table></figure>
<p>在函数组件的主体内，操作 DOM 、订阅事件、设置定时器、记录日志以及包含其他副作用的操作都是不允许的。<br>该 Hook 接收一个包含副作用操作的函数和一个依赖项数组，在每次渲染到屏幕之后执行副作用函数。可以为副作用函数返回一个清除副作用的函数，在组件卸载之前清除副作用。<br>当依赖项数组是一个空数组时，副作用数组只会在组件首次渲染时执行，effect 内部的 props 和 state 会一直保持其初始值。</p>
<h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useLayoutEffect(update, [deps]);</span><br></pre></td></tr></table></figure>
<p>并非所有的副作用都可以被延迟执行，在浏览器执行下一次绘制之前，用户可见的 DOM 变更就需要被同步执行，这样用户才不会感觉到视觉上的不一致。<br>该 Hook，会在所有的 DOM 变更之后同步调用 effect，可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p>
<h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure>
<p>接收一个由 React.createContext 创建的 context 对象，返回该context 对象的当前值。当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 value prop 决定。<br>该 Hook 能够让组件读取 context 值并订阅其变化，需要在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code> 来为下层组件提供 context。在 context 的值发生变化时，会触发组件的重新渲染。</p>
<p>使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">&quot;#000000&quot;</span>,</span><br><span class="line">    background: <span class="string">&quot;#eeeeee&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">    background: <span class="string">&quot;#222222&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span><br><span class="line">      &lt;Toolbar /&gt;</span><br><span class="line">    &lt;/ThemeContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemedButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> theme = useContext(ThemeContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button style=&#123;&#123; <span class="attr">background</span>: theme.background, <span class="attr">color</span>: theme.foreground &#125;&#125;&gt;</span><br><span class="line">      I am styled by theme context!</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>
<p>useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。<br>当 state 的结构较为复杂且包含多个子值或者新的 state 依赖旧的 state 时，useReducer 会比 useState 更适用。</p>
<p>使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;decrement&#x27;</span>&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>接收一个回调函数和一个依赖项数组作为参数，返回该回调函数的 memorized 版本，该回调函数仅在某个依赖项发生改变后才会更新。把该回调函数作为属性传递给子组件，当父组件重新渲染时，可以避免子组件不必要的渲染。<br>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)</p>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function">() =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>
<p>接收一个创建状态的函数和一个依赖项数组作为参数，返回一个 memorized 值，只有在某个依赖项发生变化时，才重新计算 memorized 值。</p>
<h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure>
<p>返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。<br>本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。 如果将 ref 对象以 <code>&lt;div ref=&#123;myRef&#125; /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 .current 属性设置为相应的 DOM 节点。<br>而 useRef() 和自建一个 {current: …} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。</p>
<p>使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">&quot;text&quot;</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure>
<p>在使用 ref 时，自定义暴露给父组件的实例值。</p>
<p>useImperativeHandle 应当与 forwardRef(父组件的 ref) 一起使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    focus: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">FancyInput = forwardRef(FancyInput);</span><br></pre></td></tr></table></figure>
<p>渲染 <code>&lt;FancyInput ref=&#123;inputRef&#125; /&gt;</code> 的父组件可以调用 inputRef.current.focus()。</p>
<h2 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useDebugValue(value);</span><br></pre></td></tr></table></figure>
<p>用于在 React 开发者工具中显示自定义 hook 的标签。</p>
<p>参考：<br><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html">React Hooks 官方文档</a></p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>react-native在Ios端提示用户App应用版本更新</title>
    <url>/2020/12/21/react-native%E5%9C%A8Ios%E7%AB%AF%E6%8F%90%E7%A4%BA%E7%94%A8%E6%88%B7App%E5%BA%94%E7%94%A8%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一般情况，react-native项目是集成在Ios或Android应用中，我们没有权利在rn项目中执行App应用更新操作。有时候，rn项目的部分功能依赖于App应用的最新版本，此时就需要提示用户版本更新，并跳转到应用商店。Android 端应用商店不统一，无法正确的引导用户；但在Ios端，可以快速引导用户跳转应用商店AppStore下载最新版本的App。下面的方法，以京东App为例：</p>
<h3 id="判断京东App是否需要版本升级"><a href="#判断京东App是否需要版本升级" class="headerlink" title="判断京东App是否需要版本升级"></a>判断京东App是否需要版本升级</h3><p>1）获取当前引用的版本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClientVersion</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        JDNativeSystem.getClientVersion().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(res || <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;JDNativeSystem.getClientVersion9 err!&#x27;</span>, err)</span><br><span class="line">        &#125;)</span><br><span class="line">    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）判断当前版本是否需要升级</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> miniVersion = <span class="string">&#x27;9.3.2&#x27;</span></span><br><span class="line"><span class="comment">// 比较版本号</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareVersion</span>(<span class="params">compareVersion, currentVersion</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v1 = version2Num(compareVersion)</span><br><span class="line">    <span class="keyword">var</span> v2 = version2Num(currentVersion)</span><br><span class="line">    <span class="keyword">if</span> (v1 &gt; v2) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v1 == v2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">version2Num</span>(<span class="params">version</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//将版本号转为数字</span></span><br><span class="line">        <span class="keyword">var</span> c = version.toString().split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="keyword">var</span> num_place = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;00&quot;</span>, <span class="string">&quot;000&quot;</span>, <span class="string">&quot;0000&quot;</span>]</span><br><span class="line">        <span class="keyword">var</span> r = num_place.reverse()</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> len = c[i].length</span><br><span class="line">            c[i] = r[len] + c[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> res = c.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否需要升级</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNeedUpgrade</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        getClientVersion().then(<span class="function">(<span class="params">version</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (version) &#123;</span><br><span class="line">                <span class="keyword">const</span> result = compareVersion(miniVersion, version)</span><br><span class="line">                <span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123; <span class="comment">// 不需要升级</span></span><br><span class="line">                    resolve(<span class="literal">false</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(<span class="literal">true</span>) <span class="comment">// 需要升级</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若是需要版本升级，则弹框提示用户下载最新版本App</p>
<h3 id="获取京东App在AppStore中的应用id"><a href="#获取京东App在AppStore中的应用id" class="headerlink" title="获取京东App在AppStore中的应用id"></a>获取京东App在AppStore中的应用id</h3><p>1）进入苹果应用商店<a href="https://www.apple.com/app-store/">https://www.apple.com/app-store/</a><br>2）搜索京东，获取应用列表数据<br>3）点击京东，跳转到京东详情页，根据京东详情页的链接<a href="https://apps.apple.com/us/app/%E4%BA%AC%E4%B8%9C-%E4%B8%8D%E8%B4%9F%E6%AF%8F%E4%B8%80%E4%BB%BD%E7%83%AD%E7%88%B1/id414245413">https://apps.apple.com/us/app/%E4%BA%AC%E4%B8%9C-%E4%B8%8D%E8%B4%9F%E6%AF%8F%E4%B8%80%E4%BB%BD%E7%83%AD%E7%88%B1/id414245413</a> ，可以获取到京东应用的id——414245413</p>
<h3 id="获取京东App在苹果商店的下载地址"><a href="#获取京东App在苹果商店的下载地址" class="headerlink" title="获取京东App在苹果商店的下载地址"></a>获取京东App在苹果商店的下载地址</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取京东app在苹果商店的下载地址</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJDAPPStoreInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> JDAppStoreId = <span class="number">414245413</span></span><br><span class="line">    fetch(<span class="string">`https://itunes.apple.com/CN/lookup?id=<span class="subst">$&#123;JDAppStoreId&#125;</span>`</span>)</span><br><span class="line">        .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">        .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (res &amp;&amp; res.results &amp;&amp; res.results.length) &#123;</span><br><span class="line">                <span class="built_in">this</span>.JDAppVersion = res.results[<span class="number">0</span>].version <span class="comment">// 京东App最新版本</span></span><br><span class="line">                <span class="built_in">this</span>.JDAppStoreUrl = res.results[<span class="number">0</span>].trackViewUrl <span class="comment">// 苹果应用商店京东App的下载地址</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;getJDAPPStoreInfo err!&#x27;</span>, err)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="跳转应用商店京东App下载页"><a href="#跳转应用商店京东App下载页" class="headerlink" title="跳转应用商店京东App下载页"></a>跳转应用商店京东App下载页</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Linking &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line">Linking.openURL(<span class="built_in">this</span>.JDAppStoreUrl).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err, <span class="string">&#x27;jump app store err!&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title>react-native实现沉浸式标题栏</title>
    <url>/2020/12/07/react-native%E5%AE%9E%E7%8E%B0%E6%B2%89%E6%B5%B8%E5%BC%8F%E6%A0%87%E9%A2%98%E6%A0%8F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>沉浸式标题栏，简单来说，即是透明栏，标题栏和状态栏不再是传统的黑色或白色，而是透明的，使得手机应用界面占据整个屏幕空间，页面从上向下滚动时，状态栏和标题内容慢慢由透明变成不透明，退出沉浸模式。以上交互，主要通过设置状态栏 StatusBar 和 透明度 opacity 来实现。</p>
<h3 id="设置-opacity"><a href="#设置-opacity" class="headerlink" title="设置 opacity"></a>设置 opacity</h3><p>初始情况下，标题栏和状态栏的透明度opacity为0，页面向下滚动一段距离(这里设定为标题栏的高度)后，其透明度一点点的由0变为1。<br>基本思路是：<br>const opacity = 滚动的距离 / 标题栏的高度<br>完整代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;PureComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; View, Text, ScrollView &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line"><span class="keyword">import</span> TitleBar <span class="keyword">from</span> <span class="string">&#x27;../../components/TitleBar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TitlePage</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props)</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            titleBarHeight: <span class="number">50</span> <span class="comment">// 顶部标题栏的高度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 顶部标题栏</span></span><br><span class="line">        <span class="built_in">this</span>.titleBarView = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听列表滚动事件</span></span><br><span class="line">    scrollViewScroll = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> y = event.nativeEvent.contentOffset.y</span><br><span class="line">        <span class="comment">// 设置标题栏和状态栏的透明度 titleOpacity</span></span><br><span class="line">        <span class="comment">// 当页面滚动的距离等于标题栏的高度时，其透明度变为1</span></span><br><span class="line">        <span class="keyword">const</span> scale = y * <span class="number">1.0</span> / <span class="built_in">this</span>.state.titleBarHeight</span><br><span class="line">        <span class="built_in">this</span>.titleBarView.setState(&#123;</span><br><span class="line">            titleOpacity: scale,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; titleBarHeight&#125; = <span class="built_in">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &#123;<span class="comment">/*沉浸式标题*/</span>&#125;</span><br><span class="line">                &lt;TitleBar</span><br><span class="line">                    onRef=&#123;<span class="function">(<span class="params">ref</span>) =&gt;</span> <span class="built_in">this</span>.titleBarView = ref&#125;</span><br><span class="line">                    titleBarHeight=&#123;titleBarHeight&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">                &lt;ScrollView</span><br><span class="line">                    onScroll=&#123;<span class="built_in">this</span>.scrollViewScroll&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;Text&gt;页面内容&lt;/Text&gt;</span><br><span class="line">                &lt;/ScrollView&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置-StatusBar"><a href="#设置-StatusBar" class="headerlink" title="设置 StatusBar"></a>设置 StatusBar</h3><p>在 ios 端，状态栏默认是沉浸式的默认情况下， View 的内容会从屏幕顶部开始绘制；在 android 端，状态栏会遮住主题内容，需设置状态栏是否透明</p>
<ul>
<li>barStyle 设置状态栏文本的颜色</li>
<li>translucent 指定状态栏是否透明。设置为true时，应用会在状态栏之下绘制（即所谓“沉浸式”）– android</li>
<li>backgroundColor 状态栏背景色 – android</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">_renderStatusBar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; titleOpacity &#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> backgroundColor = <span class="string">`rgba(0, 0, 0, <span class="subst">$&#123;titleOpacity&#125;</span>)`</span></span><br><span class="line">    <span class="keyword">if</span> (Platform.OS === <span class="string">&#x27;ios&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">StatusBar</span> <span class="attr">barStyle</span>=<span class="string">&#123;</span>&#x27;<span class="attr">dark-content</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Platform.OS === <span class="string">&#x27;android&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml">&lt;StatusBar</span></span><br><span class="line"><span class="xml">            backgroundColor=&#123;backgroundColor&#125;</span></span><br><span class="line"><span class="xml">            barStyle=&#123;&#x27;dark-content&#x27;&#125;</span></span><br><span class="line"><span class="xml">            translucent=&#123;true&#125;/&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置标题栏"><a href="#设置标题栏" class="headerlink" title="设置标题栏"></a>设置标题栏</h3><ul>
<li>整个标题栏的高度应该等于状态栏的高度 statusBarHeight 加上 标题模块的高度 titleBarHeight<br>获取状态栏的高度:  <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Platform, NativeModules &#125; <span class="keyword">from</span> <span class="string">&quot;react-native&quot;</span></span><br><span class="line"><span class="keyword">const</span> &#123; StatusBarManager &#125; = NativeModules</span><br><span class="line"><span class="comment">// 获取状态栏的高度</span></span><br><span class="line"><span class="keyword">const</span> getStatusBarHeight = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> OS = Platform.OS</span><br><span class="line">        <span class="keyword">if</span> (OS === <span class="string">&#x27;ios&#x27;</span>) &#123;</span><br><span class="line">            StatusBarManager.getHeight(<span class="function"><span class="params">statusBarHeight</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(statusBarHeight)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (OS === <span class="string">&#x27;android&#x27;</span>) &#123;</span><br><span class="line">            resolve(StatusBarManager || &#123;&#125;).HEIGHT || <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        resolve(<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> statusBarHeight = <span class="number">0</span></span><br><span class="line">getStatusBarHeight().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    statusBarHeight = res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>标题栏需设置成 absolute 定位，这样标题栏展示在手机主体内容上层，使得主体内容占据整个屏幕空间</li>
</ul>
<p>完整代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;PureComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    View,</span><br><span class="line">    StatusBar,</span><br><span class="line">    StyleSheet,</span><br><span class="line">    Platform</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; statusBarHeight &#125; <span class="keyword">from</span> <span class="string">&#x27;../common/globalData&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TitleBar</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props)</span><br><span class="line">        <span class="built_in">this</span>.props.onRef(<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            <span class="comment">// 背景透明度</span></span><br><span class="line">            titleOpacity: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _renderStatusBar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; titleOpacity &#125; = <span class="built_in">this</span>.state</span><br><span class="line">        <span class="keyword">const</span> backgroundColor = <span class="string">`rgba(0, 0, 0, <span class="subst">$&#123;titleOpacity&#125;</span>)`</span></span><br><span class="line">        <span class="keyword">if</span> (Platform.OS === <span class="string">&#x27;ios&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">StatusBar</span> <span class="attr">barStyle</span>=<span class="string">&#123;</span>&#x27;<span class="attr">dark-content</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Platform.OS === <span class="string">&#x27;android&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml">&lt;StatusBar</span></span><br><span class="line"><span class="xml">                backgroundColor=&#123;backgroundColor&#125;</span></span><br><span class="line"><span class="xml">                barStyle=&#123;&#x27;dark-content&#x27;&#125;</span></span><br><span class="line"><span class="xml">                translucent=&#123;true&#125;/&gt;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; titleBarHeight &#125; = <span class="built_in">this</span>.props</span><br><span class="line">        <span class="keyword">const</span> &#123; titleOpacity &#125; = <span class="built_in">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;View style=&#123;[&#123;<span class="attr">height</span>: titleBarHeight + statusBarHeight&#125;, TitleStyle.titleBarWrapper]&#125;&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>._renderStatusBar()&#125;</span><br><span class="line">                &lt;View style=&#123;[TitleStyle.titleBarBg, &#123;</span><br><span class="line">                    opacity: titleOpacity,</span><br><span class="line">                &#125;]&#125;/&gt;</span><br><span class="line">                &lt;View style=&#123;[TitleStyle.titleBarContent, &#123;</span><br><span class="line">                    marginTop: statusBarHeight,</span><br><span class="line">                    height: titleBarHeight</span><br><span class="line">                &#125;]&#125;&gt;</span><br><span class="line">                  &#123;<span class="comment">/*    标题栏主题内容*/</span>&#125;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TitleStyle = StyleSheet.create(&#123;</span><br><span class="line">    titleBarWrapper: &#123;</span><br><span class="line">        flexDirection: <span class="string">&#x27;row&#x27;</span>,</span><br><span class="line">        position: <span class="string">&#x27;absolute&#x27;</span>,</span><br><span class="line">        top: <span class="number">0</span>,</span><br><span class="line">        zIndex: <span class="number">100</span>,</span><br><span class="line">        width: <span class="string">&#x27;100%&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    titleBarContent: &#123;</span><br><span class="line">        alignItems: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">        justifyContent: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">        width: <span class="string">&#x27;100%&#x27;</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    titleBarBg: &#123;</span><br><span class="line">        position: <span class="string">&#x27;absolute&#x27;</span>,</span><br><span class="line">        top: <span class="number">0</span>,</span><br><span class="line">        height: <span class="string">&#x27;100%&#x27;</span>,</span><br><span class="line">        width: <span class="string">&#x27;100%&#x27;</span>,</span><br><span class="line">        backgroundColor: <span class="string">&#x27;#fff&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title>reactHook之useState和useEffect的原理与简单实现</title>
    <url>/2021/02/24/reactHook%E4%B9%8BuseState%E5%92%8CuseEffect%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><h4 id="实现一个state"><a href="#实现一个state" class="headerlink" title="实现一个state"></a>实现一个state</h4><p>useState接收状态初始值，返回一个数组，第一个是状态的当前值，第二个是函数，用来更新状态.</p>
<p>以<code>const [count, setCount] = useState(0)</code>为例：<br>组件第一渲染时，从useState拿到初始值0。当调用setCount(count+1)时，调用dispatch，state更新为1，之后执行render，组件重新渲染，此时拿到新的count（每一次都拿到独立的count状态，但是这个状态在一次渲染过程中是常量）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _state</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">    _state = _state || (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span> ? initialState() : initialState)</span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> curState = _state</span><br><span class="line">        <span class="keyword">const</span> newState = basicStateReducer(curState, action)</span><br><span class="line">        <span class="keyword">if</span> (curState === newState) <span class="keyword">return</span></span><br><span class="line">        _state = newState</span><br><span class="line">        render()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [_state, dispatch]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? action(state) : action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现多个state"><a href="#实现多个state" class="headerlink" title="实现多个state"></a>实现多个state</h4><p>若是多个state，该如何实现？  </p>
<p>通过数组，把多个state放在数组memoizedState中，根据索引index，更修改相应的state</p>
<ul>
<li>useState会读取memoizedState[index]</li>
<li>index由useState调用的顺序决定</li>
<li>setState会修改state，并触发组件更新<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> memoizedState = [] <span class="comment">// hooks 存放在这个数组</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span> <span class="comment">// 当前 memoizedState 下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentIndex = index</span><br><span class="line">    index++</span><br><span class="line">    memoizedState[currentIndex] = memoizedState[currentIndex] || (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span> ? initialState() : initialState)</span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> curState = memoizedState[currentIndex]</span><br><span class="line">        <span class="keyword">const</span> newState = basicStateReducer(curState, action)</span><br><span class="line">        <span class="keyword">if</span> (curState === newState) <span class="keyword">return</span></span><br><span class="line">        memoizedState[currentIndex] = newState</span><br><span class="line">        render()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [memoizedState[currentIndex], dispatch]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? action(state) : action</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, rootElement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从上面可以看出，useState要按顺序执行，不能使用条件语句，因为可能会打乱顺序。<br>注：源码中，useState是通过链表结构来实现的<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hook1 =&gt; Fiber.memoizedState </span><br><span class="line">state1 === hook1.memoizedState</span><br><span class="line"></span><br><span class="line">hook1.next =&gt; hook2 </span><br><span class="line">state2 === hook2.memoizedState</span><br></pre></td></tr></table></figure>
<h3 id="实现useEffect"><a href="#实现useEffect" class="headerlink" title="实现useEffect"></a>实现useEffect</h3>useEffect接收两个参数。第一个是函数，放所需执行的代码；第二个参数是一个数组，里面是Effect的依赖项，数组发生变化，useEffect就会执行。第二个参数可以省略，每次渲染就会执行useEffect中的函数。</li>
</ul>
<p>setState时，组件会重新渲染，此时会重新触发useEffect函数。（并不是count的值在“不变”的effect中发生了改变，而是effect函数本身在每一次渲染中都不相同）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> effectHOOKS = []</span><br><span class="line"><span class="keyword">let</span> effectIndex = <span class="number">0</span> <span class="comment">// 当前effect的下标</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback, depArray</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> effect = effectHOOKS[effectIndex]</span><br><span class="line">    <span class="keyword">const</span> deps = effect &amp;&amp; effect.deps</span><br><span class="line">    <span class="keyword">const</span> hasNoDeps = !depArray</span><br><span class="line">    <span class="keyword">const</span> hasChangedDeps = deps</span><br><span class="line">        ? !depArray.every(<span class="function">(<span class="params">el, i</span>) =&gt;</span> el === deps[i])</span><br><span class="line">        : <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasNoDeps || hasChangedDeps) &#123;</span><br><span class="line">        <span class="keyword">const</span> destroy = effect &amp;&amp; effect.destroy</span><br><span class="line">        <span class="comment">// 上一次的effect会在重新渲染后被清除掉</span></span><br><span class="line">        destroy &amp;&amp; <span class="keyword">typeof</span> destroy === <span class="string">&#x27;function&#x27;</span> &amp;&amp; destroy()</span><br><span class="line">        <span class="comment">// 执行本次的回调函数</span></span><br><span class="line">        <span class="keyword">const</span> callbackRes = callback()</span><br><span class="line">        effectHOOKS[effectIndex] = &#123;</span><br><span class="line">            ...effectHOOKS[effectIndex],</span><br><span class="line">            deps: depArray, <span class="attr">destroy</span>: callbackRes</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    effectIndex++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可知，当depArray=[]时，useEffect中的callback回调函数只执行一次。上一次的effect只会在重新渲染后被清除掉。<br>有问题的定时器组件写法，count永远是0。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// count永远是0</span></span><br><span class="line">        setCount(count + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id)</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>
<p>优化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// count永远是0</span></span><br><span class="line">        setCount(count + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id)</span><br><span class="line">&#125;, [count])</span><br><span class="line">=&gt; </span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// count传入的是当前state的值</span></span><br><span class="line">        setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(id)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;clearInterval&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react hook</tag>
      </tags>
  </entry>
  <entry>
    <title>reactHook之useState的源码解析</title>
    <url>/2021/02/24/reactHook%E4%B9%8BuseState%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>下面分析16.14.2版本react中useState的源码实现</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>当前fiber节点的数据结构是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fiberNode = &#123;</span><br><span class="line">    tag: xxx, <span class="comment">// 标记不同的组件类型</span></span><br><span class="line">    key: xxx,</span><br><span class="line">    memoizedState: &#123; <span class="comment">// hooks</span></span><br><span class="line">        baseState: xxx, <span class="comment">// 初始化 initialState， 每次 dispatch 之后的newState</span></span><br><span class="line">        memoizedState: xxx, <span class="comment">// 上次更新完之后的最终值</span></span><br><span class="line">        queue: &#123; <span class="comment">// 缓存的更新队列，</span></span><br><span class="line">            lastRenderedReducer: basicStateReducer(state, action),</span><br><span class="line">            lastRenderedState: xxx, <span class="comment">// 上次state的值</span></span><br><span class="line">            pending: <span class="literal">null</span> <span class="comment">// 存放即将更新的newState信息</span></span><br><span class="line">        &#125;,</span><br><span class="line">        next: <span class="literal">null</span>, <span class="comment">// link到下一个hooks，通过next串联每一个hooks</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 的 Hooks 是一个单向链表，Hook.next 指向下一个 Hook。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Fiber.memoizedState =&gt; hook1  state1 === hook1.memoizedState </span><br><span class="line">hook1.next =&gt; hook2           state2 === hook2.memoizedState</span><br><span class="line">hook2.next =&gt; hook3           state3 === hook2.memoizedState</span><br></pre></td></tr></table></figure>
<h4 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h4><p>react/cjs/react.development.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>resolveDispatcher返回的是ReactCurrentDispatcher.current，所以<code>useState = ReactCurrentDispatcher.current.useState</code></p>
<h3 id="首次渲染"><a href="#首次渲染" class="headerlink" title="首次渲染"></a>首次渲染</h3><p><code>ReactDOM.render(&lt;App/&gt;, rootElement)</code>，react从render开始执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render &#x3D;&gt; ... &#x3D;&gt; beginWork &#x3D;&gt; updateFunctionComponent &#x3D;&gt;  renderWithHooks</span><br></pre></td></tr></table></figure>
<p>hooks的核心渲染逻辑入口是renderWithHooks。</p>
<h4 id="renderWithHooks"><a href="#renderWithHooks" class="headerlink" title="renderWithHooks"></a>renderWithHooks</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 14762</span></span><br><span class="line">renderWithHooks()</span><br><span class="line">    <span class="comment">// 14787 核心逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; current.memoizedState !== <span class="literal">null</span>) &#123;</span><br><span class="line">      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 组件首次挂载时</span></span><br><span class="line">      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;</span><br><span class="line">    &#125;</span><br><span class="line">    =&gt;</span><br><span class="line">    <span class="number">15694</span> HooksDispatcherOnMountInDEV.useState = &#123;</span><br><span class="line">      <span class="keyword">return</span> mountState(initialState) <span class="comment">// 15766</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">15881</span> HooksDispatcherOnUpdateInDEV.useState = &#123;</span><br><span class="line">      <span class="keyword">return</span> updateState(initialState) <span class="comment">// 15939</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 14851</span></span><br><span class="line">    currentlyRenderingFiber$<span class="number">1</span> = <span class="literal">null</span>;</span><br><span class="line">    currentHook = <span class="literal">null</span>;</span><br><span class="line">    workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可知，首次挂载时，<code>useState = HooksDispatcherOnMountInDEV.useState = mountState</code>;state更新时，<code>useState = HooksDispatcherOnUpdateInDEV.useState = mountState</code></p>
<h4 id="mountState"><a href="#mountState" class="headerlink" title="mountState"></a>mountState</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 15213 第一次调用组件的 useState 时实际调用的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hook = mountWorkInProgressHook(); <span class="comment">// / 创建一个新的 Hook，并返回当前 workInProgressHook</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    initialState = initialState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;</span><br><span class="line">  <span class="keyword">var</span> queue = hook.queue = &#123;</span><br><span class="line">    pending: <span class="literal">null</span>,</span><br><span class="line">    dispatch: <span class="literal">null</span>,</span><br><span class="line">    lastRenderedReducer: basicStateReducer,</span><br><span class="line">    lastRenderedState: initialState</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 绑定当前 fiber 和 queue 到 dispatchAction 上</span></span><br><span class="line">  <span class="comment">// currentlyRenderingFiber$1是一个全局变量，表示当前正在渲染的Fiber节点</span></span><br><span class="line">  <span class="keyword">var</span> dispatch = queue.dispatch = dispatchAction.bind(<span class="literal">null</span>, currentlyRenderingFiber$<span class="number">1</span>, queue);</span><br><span class="line">  <span class="comment">// const [name, setName] = useState(&#x27;king&#x27;)</span></span><br><span class="line">  <span class="comment">// king 赋值给了 hook.memoizedState， setName表示dispatch，当调用setName(&#x27;queen&#x27;)会执行dispatchAction(&#x27;queen&#x27;)</span></span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）执行mountWorkInProgressHook()，更新hook链表，并返回当前 workInProgressHook</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 14921 创建一个新的 hook，并返回当前 workInProgressHook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountWorkInProgressHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hook = &#123;</span><br><span class="line">    memoizedState: <span class="literal">null</span>,</span><br><span class="line">    baseState: <span class="literal">null</span>,</span><br><span class="line">    baseQueue: <span class="literal">null</span>,</span><br><span class="line">    queue: <span class="literal">null</span>,</span><br><span class="line">    next: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有在第一次打开页面的时候，workInProgressHook 为空</span></span><br><span class="line">    currentlyRenderingFiber$<span class="number">1.</span>memoizedState = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 已经存在 workInProgressHook 就将新创建的这个 Hook 接在 workInProgressHook 的尾部</span></span><br><span class="line">    workInProgressHook = workInProgressHook.next = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）获取当前的workInProgressHook后，初始化了hook.memoizedState、hook.baseState、hook.queue和queue.dispatch</p>
<p>（3）basicStateReducer的源码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 15007</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）最终返回一个数组 <code>[hook.memoizedState, dispatch]</code><br>执行<code>setName(&#39;queen&#39;)</code>，其实就是执行<code>dispatch(&#39;queen&#39;)</code></p>
<p>第一次<code>const [name, setName] = useState(&#39;king&#39;)</code>，mountWorkInProgressHook()后，hook的值为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hook = &#123;</span><br><span class="line">    baseQueue: <span class="literal">null</span>,</span><br><span class="line">    baseState: <span class="string">&#x27;king&#x27;</span>,</span><br><span class="line">    memoizedState: <span class="string">&#x27;king&#x27;</span>,</span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">    queue: &#123;</span><br><span class="line">            dispatch: fucntion,</span><br><span class="line">            lastRenderedReducer: basicStateReducer(state, action),</span><br><span class="line">            lastRenderedState: <span class="string">&#x27;king&#x27;</span>,</span><br><span class="line">            pending: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二次<code>const [count, setCount] = useState(0)</code>，mountWorkInProgressHook()后，hook的值为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hook = &#123;</span><br><span class="line">    baseQueue: <span class="literal">null</span>,</span><br><span class="line">    baseState: <span class="string">&#x27;king&#x27;</span>,</span><br><span class="line">    memoizedState: <span class="string">&#x27;king&#x27;</span>,</span><br><span class="line">    queue: &#123;</span><br><span class="line">        dispatch: fucntion,</span><br><span class="line">        lastRenderedReducer: basicStateReducer(state, action),</span><br><span class="line">        lastRenderedState: <span class="string">&#x27;king&#x27;</span>,</span><br><span class="line">        pending: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    next: &#123;</span><br><span class="line">        baseQueue: <span class="literal">null</span>,</span><br><span class="line">        baseState: <span class="number">0</span>,</span><br><span class="line">        memoizedState: <span class="number">0</span>,</span><br><span class="line">        queue: &#123;</span><br><span class="line">            dispatch: fucntion,</span><br><span class="line">            lastRenderedReducer: basicStateReducer(state, action),</span><br><span class="line">            lastRenderedState: <span class="number">0</span>,</span><br><span class="line">            pending: <span class="literal">null</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dispatchAction"><a href="#dispatchAction" class="headerlink" title="dispatchAction"></a>dispatchAction</h4><p>以<code>const [name, setName] = useState(&#39;king&#39;) setName(&#39;queen&#39;)</code>为例：</p>
<p>执行<code>setName(&#39;queen&#39;)</code>，其实就是执行<code>dispatchAction(fiber, queue, &#39;queen&#39;)</code></p>
<ul>
<li>dispatchAction() 会创建 update 对象({action:’queen’})</li>
<li>将 update 加至 hook.queue 的末尾：hook.queue.pending = update</li>
<li>执行 scheduleWork()，走 updateFunctionComponent() 流程<br>核心代码：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 15564</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAction</span>(<span class="params">fiber, queue, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// action 就是传进来要更新的 state-&gt;&#x27;queen&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> update = &#123;</span><br><span class="line">    expirationTime: expirationTime,</span><br><span class="line">    suspenseConfig: suspenseConfig,</span><br><span class="line">    action: action,</span><br><span class="line">    eagerReducer: <span class="literal">null</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 这里的queue，是之前传入的hook对象中的queue，这里保留了一个引用！！（即queue发生变化，当前fiber节点的hook数据也是同步变更的）</span></span><br><span class="line">  <span class="keyword">var</span> pending = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">    update.next = update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update.next = pending.next;</span><br><span class="line">    pending.next = update;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  将update对象加至hook.queue的末尾pending中</span></span><br><span class="line">  queue.pending = update;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentState = queue.lastRenderedState;</span><br><span class="line">  <span class="comment">// currentState: king，action: queen</span></span><br><span class="line">  <span class="comment">// 将新的state queen 赋值到 update.eagerState</span></span><br><span class="line">  <span class="keyword">var</span> eagerState = lastRenderedReducer(currentState, action); </span><br><span class="line">  update.eagerReducer = lastRenderedReducer;</span><br><span class="line">  update.eagerState = eagerState;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  scheduleWork(fiber, expirationTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>setName(&#39;queen&#39;)</code>，即执行dispatchAction()后，hook变为<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hook = &#123;</span><br><span class="line">    baseQueue: <span class="literal">null</span>,</span><br><span class="line">    baseState: <span class="string">&#x27;king&#x27;</span>,</span><br><span class="line">    memoizedState: <span class="string">&#x27;king&#x27;</span>,</span><br><span class="line">    queue: &#123;</span><br><span class="line">        lastRenderedReducer: basicStateReducer(state, action),</span><br><span class="line">        lastRenderedState: <span class="string">&#x27;king&#x27;</span>,</span><br><span class="line">        pending: &#123;</span><br><span class="line">            action: <span class="string">&#x27;queen&#x27;</span>,</span><br><span class="line">            eagerState: <span class="string">&#x27;queen&#x27;</span>,</span><br><span class="line">            next: pending <span class="comment">// pedding对象，单链表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    next: &#123;</span><br><span class="line">        baseQueue: <span class="literal">null</span>,</span><br><span class="line">        baseState: <span class="number">0</span>,</span><br><span class="line">        memoizedState: <span class="number">0</span>,</span><br><span class="line">        queue: &#123;</span><br><span class="line">            lastRenderedReducer: basicStateReducer(state, action),</span><br><span class="line">            lastRenderedState: <span class="number">0</span>,</span><br><span class="line">            pending: <span class="literal">null</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
最后会执行scheduleWork(fiber, expirationTime)，经过React的调度，会带上action（setName的传参），再次进入hook组件核心渲染逻辑：renderWithHooks。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatchAction &#x3D;&gt; scheduleUpdateOnFiber &#x3D;&gt; ensureRootIsScheduled &#x3D;&gt; performConcurrentWorkOnRoot &#x3D;&gt; performUnitOfWork &#x3D;&gt; beginWork &#x3D;&gt; updateFunctionComponent </span><br><span class="line">&#x3D;&gt; renderWithHooks</span><br></pre></td></tr></table></figure>
此时，由于并非首次渲染组件，React会使用HooksDispatcherOnUpdateInDEV对象上的useState，<code>useState = HooksDispatcherOnUpdateInDEV.useState = mountState</code>。在这个useState中，会使用一个叫做updateState的函数来更新最新的state值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 14762</span></span><br><span class="line">renderWithHooks()</span><br><span class="line">    <span class="comment">// 14787 核心逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; current.memoizedState !== <span class="literal">null</span>) &#123;</span><br><span class="line">      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 组件首次挂载时</span></span><br><span class="line">      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;</span><br><span class="line">    &#125;</span><br><span class="line">    =&gt;</span><br><span class="line">    <span class="number">15694</span> HooksDispatcherOnMountInDEV.useState = &#123;</span><br><span class="line">      <span class="keyword">return</span> mountState(initialState) <span class="comment">// 15766</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">15881</span> HooksDispatcherOnUpdateInDEV.useState = &#123;</span><br><span class="line">      <span class="keyword">return</span> updateState(initialState) <span class="comment">// 15939</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> children = Component(props, secondArg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
renderWithHooks()中有一个Component()方法，用来执行App()，此时又会执行 <code>const [name, setName] = useState(&#39;king&#39;)</code>，最终调用的是<code>HooksDispatcherOnUpdateInDEV.useState(king&#39;) =&gt; updateState(&#39;king&#39;)</code>。<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><h4 id="updateState"><a href="#updateState" class="headerlink" title="updateState()"></a>updateState()</h4>由updateState可以看出，实际调用的是 updateReducer<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 15233</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateReducer(basicStateReducer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="updateReducer"><a href="#updateReducer" class="headerlink" title="updateReducer()"></a>updateReducer()</h4>updateReducer的核心代码：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 15033</span></span><br><span class="line">funtion <span class="function"><span class="title">updateReducer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> hook = updateWorkInProgressHook();</span><br><span class="line">    <span class="keyword">var</span> queue = hook.queue;</span><br><span class="line">    <span class="keyword">var</span> pendingQueue = queue.pending</span><br><span class="line">    current.baseQueue = baseQueue = pendingQueue;</span><br><span class="line">    queue.pending = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> first = baseQueue.next;</span><br><span class="line">    <span class="keyword">var</span> newState = current.baseState;</span><br><span class="line">    <span class="keyword">var</span> update = first;</span><br><span class="line">    <span class="keyword">if</span> (update.eagerReducer === reducer) &#123;</span><br><span class="line">      newState = update.eagerState;</span><br><span class="line">    &#125; </span><br><span class="line">    hook.memoizedState = newState;</span><br><span class="line">    hook.baseState = newBaseState;</span><br><span class="line">    <span class="keyword">var</span> dispatch = queue.dispatch;</span><br><span class="line">    <span class="keyword">return</span> [hook.memoizedState, dispatch]; <span class="comment">// 返回[&#x27;queen&#x27;, dispatch]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
（1）第一步执行updateWorkInProgressHook()，获取当前正在工作中的 hook <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 14941</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateWorkInProgressHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此时currentlyRenderingFiber$1.memoizedState，但是为fiber的副本，保留着fiber.memoizedState的内容</span></span><br><span class="line">  <span class="comment">// 核心代码</span></span><br><span class="line">   <span class="keyword">var</span> nextCurrentHook;</span><br><span class="line">  <span class="keyword">if</span> (currentHook === <span class="literal">null</span>) &#123; <span class="comment">// 第一次useState</span></span><br><span class="line">    <span class="keyword">var</span> current = currentlyRenderingFiber$<span class="number">1.</span>alternate;</span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nextCurrentHook = current.memoizedState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextCurrentHook = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    nextCurrentHook = currentHook.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> nextWorkInProgressHook;</span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123; <span class="comment">// 第一次useState</span></span><br><span class="line">    nextWorkInProgressHook = currentlyRenderingFiber$<span class="number">1.</span>memoizedState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.next;</span><br><span class="line">  &#125;</span><br><span class="line">  currentHook = nextCurrentHook;</span><br><span class="line">  <span class="keyword">var</span> newHook = &#123;</span><br><span class="line">    memoizedState: currentHook.memoizedState,</span><br><span class="line">    baseState: currentHook.baseState,</span><br><span class="line">    baseQueue: currentHook.baseQueue,</span><br><span class="line">    queue: currentHook.queue,</span><br><span class="line">    next: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    currentlyRenderingFiber$<span class="number">1.</span>memoizedState = workInProgressHook = newHook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgressHook = workInProgressHook.next = newHook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
第一次<code>const [name, setName] = useState(&#39;king&#39;)</code>，workInProgressHook的值为<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">workInProgressHook=&#123;</span><br><span class="line">    memoizedState: <span class="string">&quot;king&quot;</span>,</span><br><span class="line">    baseState: <span class="string">&quot;king&quot;</span>,</span><br><span class="line">    queue:&#123;</span><br><span class="line">        pending:&#123;</span><br><span class="line">            action: <span class="string">&quot;queen&quot;</span>,</span><br><span class="line">            eagerState: <span class="string">&quot;queen&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    next: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
第二次<code>const [count, setCount] = useState(0)</code>，workInProgressHook的值为<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">workInProgressHook=&#123;</span><br><span class="line">    memoizedState: <span class="number">0</span>,</span><br><span class="line">    baseState: <span class="number">0</span>,</span><br><span class="line">    queue:&#123;</span><br><span class="line">        pending:&#123;</span><br><span class="line">            action: <span class="number">0</span>,</span><br><span class="line">            eagerState: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    next: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
（2）从workInProgressHook的数据结构可以看出，我们需要更新的值就在queue.pending.eagerState/action中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (update.eagerReducer === reducer) &#123;</span><br><span class="line">   newState = update.eagerState;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
（3）更新state<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hook.memoizedState = newState;</span><br><span class="line">hook.baseState = newBaseState;</span><br><span class="line"><span class="keyword">var</span> dispatch = queue.dispatch;</span><br><span class="line"><span class="keyword">return</span> [hook.memoizedState, dispatch]; <span class="comment">// 返回[&#x27;queen&#x27;, dispatch]</span></span><br></pre></td></tr></table></figure>
将<code>&#39;queen&#39;</code>赋值给<code>hook.memoizedState</code>，返回<code>[&#39;queen&#39;, diapatch]</code>，此时的<code>name</code>已经更新为<code>&#39;queen&#39;</code></li>
</ul>
<p>由上述源码可知，useState按顺序执行的原因是，useState是通过next来查找下一个hooks</p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react hook</tag>
      </tags>
  </entry>
  <entry>
    <title>react源码之前置知识</title>
    <url>/2021/05/26/react%E6%BA%90%E7%A0%81%E4%B9%8B%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>react源码版本是17.0.2</p>
<h2 id="0-react前置知识"><a href="#0-react前置知识" class="headerlink" title="0. react前置知识"></a>0. react前置知识</h2><p>react的基本理念是实现快速响应，实现上，是将同步的更新变为异步可中断、带优先级的更新。</p>
<h3 id="0-1-源码架构"><a href="#0-1-源码架构" class="headerlink" title="0.1 源码架构"></a>0.1 源码架构</h3><p>react17源码可以分为以下模块：</p>
<ul>
<li>Scheduler（调度器）： 排序优先级，让优先级高的任务先进行Reconciler</li>
<li>Reconciler（协调器）： 找出哪些节点发生了改变，并打上不同的Tag，发生在render(更新渲染)阶段</li>
<li>Renderer（渲染器）： 将Reconciler中打好标签的节点渲染到视图上，发生在commit(提交)阶段</li>
</ul>
<h4 id="Scheduler（调度器）"><a href="#Scheduler（调度器）" class="headerlink" title="Scheduler（调度器）"></a>Scheduler（调度器）</h4><p>js是单线程，浏览器在同一时间内只能执行一个事件。若js代码执行时间过长，可能会导致以下两种情况：1）阻塞用户交互事件(比如点击事件)；2）阻塞浏览器绘制和渲染dom，造成卡帧、丢帧的现象。</p>
<blockquote>
<p>GUI渲染线程与JS引擎是互斥的，当JS引擎执行时，GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</p>
</blockquote>
<p>Scheduler存在的主要作用就是为了解决上述问题:</p>
<ol>
<li>调度优先级，高优先级的任务可以打断低优先级的任务；</li>
<li>时间切片，在事件循环中，分配一个时间片(5ms)给js执行，在这个时间片内，若是还没执行完，那就暂停js，把主线程交还给浏览器进行渲染工作，等下一轮事件继续执行js.</li>
</ol>
<p><strong>浏览器一帧的工作内容：</strong><br><img src= "/img/loading.gif" data-src="frame.png" alt="frame"><br>js脚本 =&gt; requestAnimationFrame =&gt; 重排/重绘 =&gt; requestIdleCallback </p>
<blockquote>
<p>1）浏览器的刷新频率大多是60次/秒（帧率fps），即每一帧的时长大概是16.6ms，每隔16.6ms刷新一次屏幕<br>2）requestAnimationFrame会在浏览器重新渲染之前执行，requestAnimationFrame执行间隔是由浏览器的刷新频率决定的<br>3）requestIdleCallback并不是每次都执行，而是在浏览器渲染之后，如果还有空闲时间，浏览器处于空闲状态(无更新渲染工作，无js任务)，才会执行requestIdleCallback。  </p>
</blockquote>
<p><strong>可能会造成页面卡顿的原因</strong>：（渲染间隔大于16ms，上一帧到下一帧的切换不自然）</p>
<ul>
<li>js 引擎线程耗时 → js 计算任务过大，执行时间过长，阻塞了 GUI 渲染线程</li>
</ul>
<blockquote>
<p>解决方案：降低 js 引擎线程耗时，使用算法进行优化(react的diff算法)，js任务异步可中断，使用web worker多线程</p>
</blockquote>
<ul>
<li>GUI 渲染线程回流、重绘耗时 → js 修改的样式过多，布局、重绘耗时久</li>
</ul>
<blockquote>
<p>解决方案：尽量减少重排，重排一定会引起重绘，重绘不一定引起重排</p>
</blockquote>
<p><strong>事件循环：</strong><br><img src= "/img/loading.gif" data-src="eventLoop.png" alt="eventLoop"><br>宏任务(先执行同步代码) =&gt; 全部微任务 =&gt; 重排/重绘 =&gt; 执行下一轮宏任务 =&gt; 全部微任务 =&gt; 重排/重绘 =&gt; …<br>1）所有同步任务都在主线程上执行，创建执行环境栈，用来临时保存正在执行函数的执行环境；<br>2）js引擎遇到一个异步事件后，不会一直等待其返回结果，而会将这个事件挂起，继续执行执行栈中的其他任务；<br>3）当一个异步事件返回结果后，js将这个事件回调加入到事件队列中（根据异步事件的类型，分为宏任务队列或者微任务队列）；<br>4）被放入事件队列的异步事件不会立刻执行其回调函数，而是等待当前执行栈中的所有任务都执行完毕；<br>5）当主线程执行栈处于闲置状态时，从微任务队列中取出任务，推入栈中执行；<br>6）微任务队列中的所有任务执行完毕之后，执行栈为空时，判断浏览器是否需要重新渲染，若是需要，由GUI线程接管渲染（不一定渲染）；<br>7）<strong>浏览器更新渲染完毕后，才会进行下一轮事件循环</strong>，JS线程继续接管，先取宏任务队列中排在第一位的宏任务，完毕后，紧接着执行完所有的微任务，本轮结束之后，开始检查渲染；<br>8）如此反复，这样就形成了一个无限的循环，这个过程称为“事件循环（Event Loop）”  </p>
<blockquote>
<p>每次事件循环，宏任务之间，浏览器不一定都会重新渲染，可能取决于以下因素：<br>1）同步代码、宏任务、微任务是否有对页面样式进行修改<br>2）本次循环js脚本执行时间是否超过16ms；上次渲染时间是否超过16ms<br>3）宏任务之间的时间间隔短；在一帧的时间内，多次修改dom，浏览器可能会将其合并到一起更新渲染</p>
</blockquote>
<p><strong>微任务（micro task）和宏任务（macro task）：</strong></p>
<ul>
<li>宏任务（macro task）：<br>  主代码块、DOM操作、MessageChannel、setTimeout、setInterval</li>
<li>微任务（micro task）：可以理解是在当前task执行结束后立即执行的任务，比如Promise请看下面代码：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;宏任务：setTimeout1&#x27;</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;微任务：Promise.then3&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;微任务：Promise.then4&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;宏任务：setTimeout2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;微任务：Promise.then1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;微任务：Promise.then2&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
执行结果是<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">微任务：Promise.then1</span><br><span class="line">微任务：Promise.then2</span><br><span class="line">宏任务：setTimeout1</span><br><span class="line">微任务：Promise.then3</span><br><span class="line">微任务：Promise.then4</span><br><span class="line">宏任务：setTimeout2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>react通过宏任务来实现时间切片的：</p>
<ul>
<li>宏任务是在下次事件循环中执行，不会阻塞浏览器的更新渲染；</li>
<li>浏览器更新渲染完成之后，才会执行下一轮宏任务；</li>
<li>下一轮宏任务执行时，预留5ms的时间片执行react的更新任务<br>宏任务中，MessageChannel的优先级大于setTimeout，支持MessageChannel的浏览器环境采用MessageChannel，不支持的话，采用setTimeout。</li>
</ul>
<p><strong>MessageChannel</strong>的实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line"><span class="keyword">var</span> port = channel.port2;</span><br><span class="line">requestHostCallback = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    port.postMessage(<span class="literal">null</span>); <span class="comment">// 产生宏任务</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 宏任务的回调会在下一轮事件循环执行（浏览器未渲染完成之前，不会执行下一轮事件循环）</span></span><br><span class="line">channel.port1.onmessage = performWorkUntilDeadline;</span><br></pre></td></tr></table></figure>

<h4 id="Reconciler（协调器，render阶段）"><a href="#Reconciler（协调器，render阶段）" class="headerlink" title="Reconciler（协调器，render阶段）"></a>Reconciler（协调器，render阶段）</h4><p>fiber（Virtual dom）是内存中用来描述dom结构的对象，保存DOM节点的属性、类型和dom信息；Fiber通过child、sibling、return（指向父节点）来形成Fiber树。<br>在render阶段，Reconciler会创建或者更新Fiber节点。初次渲染时，react会根据jsx生成的元素构建fiber对象；更新时，根据最新的jsx生成的元素和当前的current Fiber树做对比，构建workInProgress Fiber树，这个对比的过程就是diff算法。对比的过程中，react会给发生变化的fiber打上Tag标签，会形成一条effectList，标记更新的节点，在commit阶段把这些标签应用到真实dom上.</p>
<p><img src= "/img/loading.gif" data-src="fiber%E6%A0%91.png" alt="fiber树"><br>图中， fiberRootNode是整个项目的根节点，包含应用挂载的目标节点，记录整个应用更新过程的各种信息；rootFiber是当前应用挂载的节点，即ReactDOM.render调用后的根节点</p>
<h3 id="Renderer（渲染器）"><a href="#Renderer（渲染器）" class="headerlink" title="Renderer（渲染器）"></a>Renderer（渲染器）</h3><p>Renderer是在commit阶段工作的，Renderer会遍历render阶段形成的effectList，根据Tag标签，执行真实的DOM操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Placement = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> Update = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> PlacementAndUpdate = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> Deletion = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<h3 id="0-2-JSX"><a href="#0-2-JSX" class="headerlink" title="0.2 JSX"></a>0.2 JSX</h3><p>jsx通过<a href="https://babeljs.io/">babel编译器</a>转化为可执行的代码。在react中，jsx被编译为React.createElement 方法。<br><strong>jsx:</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;子节点&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> <span class="attr">count</span>=<span class="string">&quot;12&quot;</span> <span class="attr">key</span>=<span class="string">&quot;12&quot;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p><strong>通过babel编译后的代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转义后的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, React.createElement(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;\u5B50\u8282\u70B9&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(Counter, &#123;</span><br><span class="line">    count: <span class="string">&quot;12&quot;</span>,</span><br><span class="line">    key: <span class="string">&quot;12&quot;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>createElement函数会生成element元素：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line">    key: <span class="literal">null</span>,</span><br><span class="line">    props: &#123;&#125;,</span><br><span class="line">    ref: <span class="literal">null</span>,</span><br><span class="line">    type: ƒ App(props),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>createElement</strong><br>ReactElement是通过createElement创建的，调用该方法需要传入三个参数：type、config 和 children。<br>1）type: ReactElement的类型</p>
<ul>
<li>字符串，代表原生DOM，称为HostComponent，比如div，p</li>
<li>Class类型，继承自Component或者PureComponent的组件，称为ClassComponent</li>
<li>方法，就是functional Component</li>
<li>react原生组件，比如React.Fragment</li>
</ul>
<p>2）config：props属性对象<br>3）children：子节点集合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, children</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理参数</span></span><br><span class="line">  <span class="keyword">return</span> ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props, <span class="comment">// props 包含 children 信息，还包含除key、ref、self 和 source 以外的 config 信息</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ReactElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// 用于确定是否属于ReactElement</span></span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line">    <span class="comment">// ReactElement的类型</span></span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line">    <span class="comment">// Record the component responsible for creating this element.</span></span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0-3-react优先级"><a href="#0-3-react优先级" class="headerlink" title="0.3 react优先级"></a>0.3 react优先级</h3><p>react优先级：</p>
<ul>
<li>事件优先级：按照用户事件的交互紧急程度，划分的优先级</li>
<li>更新优先级：事件导致React产生的更新对象（update）的优先级（update.lane）</li>
<li>任务优先级：产生更新对象之后，React去执行一个更新任务，这个任务所持有的优先级</li>
<li>调度优先级：Scheduler依据React更新任务生成一个调度任务，这个调度任务所持有的优先级</li>
</ul>
<p>不同事件产生更新的优先级是不一样的，一个更新的产生导致react生成一个更新任务，不同优先级的更新会产生不同优先级的更新任务，最后这个更新任务被Scheduler调度执行。<br>交互事件 =&gt; 触发更新 =&gt; 更新任务 =&gt; Scheduler调度</p>
<h4 id="事件优先级"><a href="#事件优先级" class="headerlink" title="事件优先级"></a>事件优先级</h4><p>分为三种：</p>
<ul>
<li>离散事件（DiscreteEvent）：click、keydown、focusin等，这些事件的触发不是连续的，优先级为0。</li>
<li>用户阻塞事件（UserBlockingEvent）：drag、scroll、mouseover等，特点是连续触发，阻塞渲染，优先级为1。</li>
<li>连续事件（ContinuousEvent）：video、audio标签的timeupdate(播放位置发生改变时触发)和canplay(音频/视频可以播放时触发)，优先级最高，为2。</li>
</ul>
<h4 id="更新优先级lanes"><a href="#更新优先级lanes" class="headerlink" title="更新优先级lanes"></a>更新优先级lanes</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoLanes: Lanes = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoLane: Lane = <span class="comment">/*                          */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SyncLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000001</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SyncBatchedLane: Lane = <span class="comment">/*                 */</span> <span class="number">0b0000000000000000000000000000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> InputDiscreteHydrationLane: Lane = <span class="comment">/*      */</span> <span class="number">0b0000000000000000000000000000100</span>;</span><br><span class="line"><span class="keyword">const</span> InputDiscreteLanes: Lanes = <span class="comment">/*                    */</span> <span class="number">0b0000000000000000000000000011000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> InputContinuousHydrationLane: Lane = <span class="comment">/*           */</span> <span class="number">0b0000000000000000000000000100000</span>;</span><br><span class="line"><span class="keyword">const</span> InputContinuousLanes: Lanes = <span class="comment">/*                  */</span> <span class="number">0b0000000000000000000000011000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultHydrationLane: Lane = <span class="comment">/*            */</span> <span class="number">0b0000000000000000000000100000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultLanes: Lanes = <span class="comment">/*                   */</span> <span class="number">0b0000000000000000000111000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TransitionHydrationLane: Lane = <span class="comment">/*                */</span> <span class="number">0b0000000000000000001000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLanes: Lanes = <span class="comment">/*                       */</span> <span class="number">0b0000000001111111110000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RetryLanes: Lanes = <span class="comment">/*                            */</span> <span class="number">0b0000011110000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SomeRetryLane: Lanes = <span class="comment">/*                  */</span> <span class="number">0b0000010000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SelectiveHydrationLane: Lane = <span class="comment">/*          */</span> <span class="number">0b0000100000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NonIdleLanes = <span class="comment">/*                                 */</span> <span class="number">0b0000111111111111111111111111111</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleHydrationLane: Lane = <span class="comment">/*               */</span> <span class="number">0b0001000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> IdleLanes: Lanes = <span class="comment">/*                             */</span> <span class="number">0b0110000000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> OffscreenLane: Lane = <span class="comment">/*                   */</span> <span class="number">0b1000000000000000000000000000000</span>;</span><br></pre></td></tr></table></figure>
<h4 id="更新任务优先级"><a href="#更新任务优先级" class="headerlink" title="更新任务优先级"></a>更新任务优先级</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ImmediatePriority$1</span></span><br><span class="line"><span class="keyword">var</span> SyncLanePriority = <span class="number">15</span>; <span class="comment">// =&gt; SyncLane</span></span><br><span class="line"><span class="keyword">var</span> SyncBatchedLanePriority = <span class="number">14</span>; <span class="comment">// =&gt; SyncBatchedLane</span></span><br><span class="line"><span class="comment">// UserBlockingPriority$2</span></span><br><span class="line"><span class="keyword">var</span> InputDiscreteHydrationLanePriority = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">var</span> InputDiscreteLanePriority = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">var</span> InputContinuousHydrationLanePriority = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> InputContinuousLanePriority = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// NormalPriority$1</span></span><br><span class="line"><span class="keyword">var</span> DefaultHydrationLanePriority = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">var</span> DefaultLanePriority = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> TransitionHydrationPriority = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">var</span> TransitionPriority = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> RetryLanePriority = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> SelectiveHydrationLanePriority = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// IdlePriority$1</span></span><br><span class="line"><span class="keyword">var</span> IdleHydrationLanePriority = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> IdleLanePriority = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> OffscreenLanePriority = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// NoPriority$1</span></span><br><span class="line"><span class="keyword">var</span> NoLanePriority = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="sheduler调度优先级"><a href="#sheduler调度优先级" class="headerlink" title="sheduler调度优先级"></a>sheduler调度优先级</h4><ul>
<li>Immediate 立即执行优先级，需要同步执行的任务</li>
<li>UserBlocking 用户阻塞型优先级（250 ms 后过期），需要作为用户交互结果运行的任务（例如，按钮点击）</li>
<li>Normal 普通优先级（5 s 后过期），不必让用户立即感受到的更新</li>
<li>Low 低优先级（10 s 后过期），可以推迟但最终仍然需要完成的任务（例如，分析通知）</li>
<li>Idle 空闲优先级（永不过期），不必运行的任务（例如，隐藏界面以外的内容）</li>
</ul>
<p><strong>sheduler中的调度优先级</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> NoPriority = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> ImmediatePriority = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> UserBlockingPriority = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> NormalPriority = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> LowPriority = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> IdlePriority = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p><strong>sheduler调度优先级对应的过期时间</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> IMMEDIATE_PRIORITY_TIMEOUT = -<span class="number">1</span>; <span class="comment">// Eventually times out</span></span><br><span class="line"><span class="keyword">var</span> USER_BLOCKING_PRIORITY_TIMEOUT = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">var</span> NORMAL_PRIORITY_TIMEOUT = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span> LOW_PRIORITY_TIMEOUT = <span class="number">10000</span>; <span class="comment">// Never times out</span></span><br><span class="line"><span class="keyword">var</span> IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;</span><br></pre></td></tr></table></figure>
<p><strong>sheduler在react-dom中调度优先级</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ImmediatePriority = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">var</span> UserBlockingPriority = <span class="number">98</span>;</span><br><span class="line"><span class="keyword">var</span> NormalPriority = <span class="number">97</span>;</span><br><span class="line"><span class="keyword">var</span> LowPriority = <span class="number">96</span>;</span><br><span class="line"><span class="keyword">var</span> IdlePriority = <span class="number">95</span>;</span><br><span class="line"><span class="keyword">var</span> NoPriority = <span class="number">90</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面两个一一对应，例如NormalPriority=3对应NormalPriority$1=97</p>
</blockquote>
<p>事件产生的优先级会记录到Scheduler，由Scheduler保存起来(currentPriorityLevel)；等到react创建更新时，计算更新的优先级直接从Scheduler中拿取</p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析rem布局方案</title>
    <url>/2021/03/28/rem%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="浅析rem布局方案"><a href="#浅析rem布局方案" class="headerlink" title="浅析rem布局方案"></a>浅析rem布局方案</h1><h2 id="Rem和em"><a href="#Rem和em" class="headerlink" title="Rem和em"></a>Rem和em</h2><blockquote>
<p>em作为font-size的单位时，其代表父元素的字体大小，em作为其他属性单位时，代表自身字体大小——MDN</p>
</blockquote>
<p>比起到处写死的px值，em似乎更有张力，改动父元素的字体大小，子元素会等比例变化，这一变化似乎预示了无限可能</p>
<img src= "/img/loading.gif" data-src="./em.png" width = "40%" alt="图片名称" align=center />

<p><strong>一个小测验</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;s1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;s2&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;s5&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;s6&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.p1</span> &#123;<span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="attribute">line-height</span>: <span class="number">32px</span>;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.s1</span> &#123;<span class="attribute">font-size</span>: <span class="number">2em</span>;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.s2</span> &#123;<span class="attribute">font-size</span>: <span class="number">2em</span>; <span class="attribute">line-height</span>: <span class="number">2em</span>;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.p2</span> &#123;<span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="attribute">line-height</span>: <span class="number">2</span>;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.s5</span> &#123;<span class="attribute">font-size</span>: <span class="number">2em</span>;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.s6</span> &#123;<span class="attribute">font-size</span>: <span class="number">2em</span>; <span class="attribute">line-height</span>: <span class="number">2em</span>;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>p1：font-size: 16px; line-height: 32px</p>
</li>
<li><p>s1：font-size: 32px; line-height: 32px</p>
<blockquote>
<p>s1 em作为字体单位，相对于父元素字体大小；line-height继承父元素计算值</p>
</blockquote>
</li>
<li><p>s2：font-size: 32px; line-height: 64px</p>
<blockquote>
<p>s2 em作为行高单位时，相对于自身字体大小</p>
</blockquote>
</li>
<li><p>p2：font-size: 16px; line-height: 32px</p>
<blockquote>
<p>p2 line-height: 2自身字体大小的两倍</p>
</blockquote>
</li>
<li><p>s5：font-size: 32px; line-height: 64px</p>
<blockquote>
<p>s5 数字无单位行高，继承原始值，s5的line-height继承的2，自身字体大小的两倍</p>
</blockquote>
</li>
<li><p>s6：font-size: 32px; line-height: 64px</p>
</li>
</ul>
<blockquote>
<p>rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小——MDN</p>
</blockquote>
<h2 id="一些像素概念"><a href="#一些像素概念" class="headerlink" title="一些像素概念"></a>一些像素概念</h2><ul>
<li>物理像素：即实际的每一个物理像素，也就是移动设备上每一个物理显示单元（点）</li>
<li>设备逻辑像素（css中的px）：可以理解为一个虚拟的相对的显示块，与物理像素有着一定的比例关系，也就是下面的设备像素比</li>
<li>设备像素比（dpr）：= 物理像素 / 设备独立像素(px)</li>
</ul>
<blockquote>
<p>如果dpr为1的话，那么1px = 1物理像素，x轴y轴加起来就是1</p>
</blockquote>
<img src= "/img/loading.gif" data-src="../assets/dpr1.webp" width = "40%" alt="图片名称" align=center />

<blockquote>
<p>如果dpr为2的话，那么1px = 2物理像素，x轴y轴加起来就是4</p>
</blockquote>
<img src= "/img/loading.gif" data-src="../assets/dpr2.webp" width = "40%" alt="图片名称" align=center />


<p>以此类推</p>
<blockquote>
<p>在js中可以通过window.devicePixelRatio获取当前设备的dpr。</p>
</blockquote>
<p>这里说明一下，无论dpr多大，1px的大小通常来说是一致的，这也就意味着，随着dpr的增大，物理像素点会越来越小，这样才能容纳更多的物理像素，才能更高清，更retina</p>
<img src= "/img/loading.gif" data-src="../assets/retina.webp" width = "40%" alt="图片名称" align=center />

<p>说完基本概念，来说一下几个问题：</p>
<h2 id="retina屏图片模糊"><a href="#retina屏图片模糊" class="headerlink" title="retina屏图片模糊"></a>retina屏图片模糊</h2><blockquote>
<p>首先普及一下位图像素：一个位图像素是图片的最小数据单元，每一个单元都包含具体的显示信息（色彩，透明度，位置等等）</p>
</blockquote>
<p>那为什么在dpr高的retina屏上反而会模糊呢？看图~</p>
<img src= "/img/loading.gif" data-src="../assets/retinaHeight.webp" width = "40%" alt="图片名称" align=center />

<blockquote>
<p>在1dpr的屏幕上，位图像素和物理像素一一对应没什么问题，但是在retina屏上，由于一个px由4个甚至更多的物理像素组成，并且单个位图像素不能进一步分割，所以会出现就近取色的情况，如果取色不均，那么就会导致图片模糊。</p>
</blockquote>
<blockquote>
<p>对于这种情况，只能采用@2x、@3x这样的倍图来适配高清展示，这样侧向说明了为什么照着iphone6做的ui稿不是375，而是750的问题。</p>
</blockquote>
<p>虽然这样在dpr为1的屏幕上会导致1个物理像素上有4个位图像素，但是这种情况的取色算法更优，影响不大，不做讨论。</p>
<h2 id="1px的粗细问题"><a href="#1px的粗细问题" class="headerlink" title="1px的粗细问题"></a>1px的粗细问题</h2><blockquote>
<p>由于1px的实际大小是一样的，只是里面的物理像素数量不同，所以如果直接写1px是没问题的，不会出现粗细不同的情况，但是这样一来retina的优势也rem的作用也就没了，其实还是dpr的问题，dpr为1，那么1px就是一个物理像素，但是在retina中。1px实际可能有4、9个物理像素，ui想要的其实是1个物理像素，而不是1px，不过由于不是素所有的手机都能适配0.x，所以曲线救国，采用scale缩放或者设置meta都可以</p>
</blockquote>
<img src= "/img/loading.gif" data-src="../assets/1px.webp" width = "40%" alt="图片名称" align=center />

<h2 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h2><p>三个概念</p>
<ul>
<li>layout viewport</li>
<li>visual viewport</li>
<li>ideal viewport</li>
</ul>
<p><strong>layout viewport</strong></p>
<blockquote>
<p>最开始，pc上的页面是无法再移动端正常显示的，因为屏幕太小，会挤作一团，所以就有了viewport的概念，又称布局视口（虚拟视口），这个视口大小接近于pc，大部分都是980px</p>
</blockquote>
<p><strong>visual viewport</strong></p>
<blockquote>
<p>有了布局视口，还缺一个承载它的真是视口，也就是移动设备的可视区域-视觉视口（物理视口）,这个尺寸随着设备的不同也有不同。这样在视觉视口中创建了一个布局视口，类似overscroll:scroll;这样，可以通过滚动拖拽、缩放扩大进行较好的访问体验</p>
</blockquote>
<p><strong>ideal viewport</strong></p>
<blockquote>
<p>像上面的体验在早些年可能比较多，但是近几年几乎很少了，还是归咎于用户体验，所以，我们还需要一个视口-理想视口（同样是虚拟视口），不过这个理想视口的大小是等于布局视口的，这样用户就能得到更好的浏览体验。</p>
</blockquote>
<h2 id="一个特性"><a href="#一个特性" class="headerlink" title="一个特性"></a>一个特性</h2><blockquote>
<p>viewport有六种可以设置的常用属性：</p>
</blockquote>
<ul>
<li>width：定义layout viewport的宽度，如果不设置，大部分情况下默认是980</li>
<li>height：非常用</li>
<li>initial-scale：可以以某个比例将页面缩放\放大，你也可以用它来设置ideal viewport：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&#x27;viewport&#x27;</span> <span class="attr">content</span>=<span class="string">&#x27;initial-scale=1&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>maximum-scale：限制最大放大比例</li>
<li>minimum-scale：限制最小缩小比例</li>
<li>user-scalable：是否允许用户放大\缩小页面，默认为yes</li>
</ul>
<h2 id="rem适配方案"><a href="#rem适配方案" class="headerlink" title="rem适配方案"></a>rem适配方案</h2><blockquote>
<p>先说原理，通过meta修正1px对应的物理像素数量，在根据统一的设计稿来生成html上的动态font-size，根据dpr构造字体等误差较大的样式的mixin</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initRem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> meta = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;meta[name=&quot;viewport&quot;]&#x27;</span>);;</span><br><span class="line">  <span class="keyword">const</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line">  <span class="keyword">const</span> cliW = html.clientWidth;</span><br><span class="line">  <span class="keyword">const</span> dpr = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>;</span><br><span class="line">  meta.setAttribute(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;viewport&#x27;</span>);</span><br><span class="line">  meta.setAttribute(</span><br><span class="line">      <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">      <span class="string">`width=<span class="subst">$&#123;cliW * dpr&#125;</span>, initial-scale=<span class="subst">$&#123;<span class="number">1</span> /</span></span></span><br><span class="line"><span class="string"><span class="subst">          dpr&#125;</span> ,maximum-scale=<span class="subst">$&#123;<span class="number">1</span> <span class="regexp">/ dpr&#125;, minimum-scale=$&#123;1 /</span></span></span></span><br><span class="line"><span class="string"><span class="subst">          dpr&#125;</span>,user-scalable=no`</span></span><br><span class="line">  );</span><br><span class="line">  html.setAttribute(<span class="string">&#x27;data-dpr&#x27;</span>, dpr);</span><br><span class="line">  <span class="comment">// 这样计算的好处是，你可以直接用ui的px/100得到的就是rem大小，方便快捷，无需mixin</span></span><br><span class="line">  html.style.fontSize = <span class="number">10</span> / <span class="number">75</span> * cliW * dpr + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">initRem();</span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="built_in">window</span>.onorientationchange = initRem();</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/ek_-cdHOkVAXDUYX35-JYw">rem布局方案</a></p>
<p><a href="https://yanhaijing.com/css/2017/09/29/principle-of-rem-layout/">rem布局方案</a></p>
]]></content>
      <tags>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title>storybook</title>
    <url>/2020/09/16/storybook/</url>
    <content><![CDATA[<h1 id="storybook"><a href="#storybook" class="headerlink" title="storybook"></a>storybook</h1><h3 id="Storybook简介"><a href="#Storybook简介" class="headerlink" title="Storybook简介"></a>Storybook简介</h3><p>  Storybook是一个辅助UI控件开发的工具。通过story创建独立的控件，让每个控件开发都有一个独立的开发调试环境。<br>  Storybook的运行不依赖于项目，开发人员不用担心由于开发环境、依赖问题导致不能开发控件。<br>  Storybook支持的框架覆盖主流的框架（React、Vue、Angular）。<br>  本文将介绍使用react的项目如何配置Storybook环境。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li><p>1、安装命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i --save-dev @storybook&#x2F;react</span><br></pre></td></tr></table></figure></li>
<li><p>2、package.json中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;storybook&quot;: &quot;start-storybook -p 9001 -c .storybook&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>3、在工程根目录创建.storybook目录</p>
</li>
<li><p>4、在.storybook目录下创建config.js文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  import &#123; configure &#125; from &#39;@storybook&#x2F;react&#39;;</span><br><span class="line">  import &#39;index.scss&#39;;</span><br><span class="line">  </span><br><span class="line">  function loadStories() &#123;</span><br><span class="line">    require(&#39;.&#x2F;stories&#x2F;userStory&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">configure(loadStories, module);</span><br></pre></td></tr></table></figure></li>
<li><p>5、在项目根目录下创建stories目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; stories&#x2F;index.jsx</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123; storiesOf &#125; from &#39;@storybook&#x2F;react&#39;;</span><br><span class="line">import BasicInfo from &#39;pages&#x2F;components&#x2F;BasicInfo&#39;;</span><br><span class="line"></span><br><span class="line">storiesOf(&#39;用户信息&#39;, module)</span><br><span class="line">  .add(&#39;基础信息&#39;, () &#x3D;&gt; &lt;BasicInfo &#x2F;&gt;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="storybook-配置"><a href="#storybook-配置" class="headerlink" title="storybook 配置"></a>storybook 配置</h3><h5 id="storybook基础webpack配置只包含以下几项："><a href="#storybook基础webpack配置只包含以下几项：" class="headerlink" title="storybook基础webpack配置只包含以下几项："></a>storybook基础webpack配置只包含以下几项：</h5><ul>
<li>Babel<ul>
<li>ES2016+ Support</li>
<li>.babelrc support</li>
</ul>
</li>
<li>Webpack<ul>
<li>CSS Support</li>
<li>Image and Static File Support</li>
<li>JSON Loader</li>
</ul>
</li>
<li>在.storybook目录下增加webpack.config.js文件扩展配置 （例如）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;处理文件需要配置相应的file-loader</span><br><span class="line">  storybookBaseConfig.module.rules.push(&#123;</span><br><span class="line">    test: &#x2F;\.(gif|png|jpe?g|eot|woff|ttf|pdf)$&#x2F;,</span><br><span class="line">    loader: &#39;file-loader&#39;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#96;&#96;&#96; </span><br></pre></td></tr></table></figure>
//处理文件处理相应的样式<br>storybookBaseConfig.module.rules.push({<br>  test: /.s?css$/,<br>  use: [‘style-loader’,<br>  { loader: ‘css-loader’, options: { importLoaders: 1 } },<br>  ‘postcss-loader’],<br>  include: path.resolve(__dirname, ‘../‘),<br>});<pre><code>
</code></pre>
</li>
</ul>
<h3 id="addons"><a href="#addons" class="headerlink" title="addons"></a>addons</h3><p>  可以理解成扩展storybook功能的插件</p>
<ul>
<li><p>addon-actions</p>
<ul>
<li>可用于显示、事件处理程序接收的数据（多个事件触发可以写成对象形式）</li>
</ul>
</li>
<li><p>addon-storysource </p>
<ul>
<li>此插件主要是在插件面板中显示 story 源代码</li>
</ul>
</li>
<li><p>addon-knobs</p>
<ul>
<li>在 story 中定义了 style、visible、children 三个动态变量传入 SlidePanel 组件，其变量类型分别对应的是 boolean、object、text。在 knob 中还可以导入许多的类型约束(number, color, array)等。</li>
</ul>
</li>
<li><p>addon-notes</p>
<ul>
<li>可以在面板中添加 story 注释文本信息。  </li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3></li>
</ul>
<ul>
<li><p>1、目录结构</p>
<h5 id=""><a href="#" class="headerlink" title=""></a><img src= "/img/loading.gif" data-src="catalog.png"></h5></li>
<li><p>1、结果图</p>
<h5 id="-1"><a href="#-1" class="headerlink" title=""></a><img src= "/img/loading.gif" data-src="result.png"></h5></li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://www.learnstorybook.com/intro-to-storybook/react/zh-cn/get-started/">https://www.learnstorybook.com/intro-to-storybook/react/zh-cn/get-started/</a></li>
<li><a href="https://juejin.im/post/6844903752982331405">https://juejin.im/post/6844903752982331405</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>SameSiteForCookie</title>
    <url>/2021/05/03/threejs%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="threejs初探"><a href="#threejs初探" class="headerlink" title="threejs初探"></a>threejs初探</h2><h4 id="Three-js，-WebGL-与-OpenGL"><a href="#Three-js，-WebGL-与-OpenGL" class="headerlink" title="Three.js， WebGL 与 OpenGL"></a><strong>Three.js， WebGL 与 OpenGL</strong></h4><p>提到 Three.js，就必须说一下 OpenGL 和 WebGL。<br>OpenGL 大概许多人都有所听闻，它是最常用的跨平台图形处理开源库。<br>WebGL 就是基于 OpenGL 设计的面向 web 的 3D 图形标准，它提供了一系列 JavaScript API，通过这些 API 进行图形渲染，系统硬件会加速 3D 渲染，从而获得较高性能。<br>而 Three.js 是 JavaScript 编写的 WebGL 第三方库，通过对 WebGL 接口的封装与简化而形成的一个易用的图形库。</p>
<h4 id="WebGL-与-Three-js-对比"><a href="#WebGL-与-Three-js-对比" class="headerlink" title="WebGL 与 Three.js 对比"></a><strong>WebGL 与 Three.js 对比</strong></h4><p>通过上面的简介，我们知道 WebGL 和 Three.js 都可以进行 Web 端的 3D 图形开发。那问题来了，既然我们有了 WebGL，为什么还需要 Three.js？<br>这是因为前端工程师想要短时间上手 WebGL 还是挺有难度的。<br>WebGL 门槛相对较高，计算机图形学需要相对较多的数学知识。一个前端程序员或许还熟悉解析几何，但是还熟悉线性代数的应该寥寥无几了（比如求个逆转置矩阵试试？），更何况使用中强调矩阵运算中的物理意义，这在教学中也是比较缺失。<br>于是，Three.js 对 WebGL 提供的接口进行了非常好的封装，简化了很多细节，大大降低了学习成本。并且，几乎没有损失 WebGL 的灵活性。<br>因此，从 Three.js 入手是值得推荐的，这可以让你在较短的学习后就能面对大部分需求场景。</p>
<h4 id="three-js的整体结构"><a href="#three-js的整体结构" class="headerlink" title="three.js的整体结构"></a><strong>three.js的整体结构</strong></h4><p><img src= "/img/loading.gif" data-src="../assets/global.svg"></p>
<ul>
<li><p>首先有一个渲染器(Renderer)。这可以说是three.js的主要对象。你传入一个场景(Scene)和一个摄像机(Camera)到渲染器(Renderer)中，然后它会将摄像机视椎体中的三维场景渲染成一个二维图片显示在画布上。</p>
</li>
<li><p>其次有一个场景图 它是一个树状结构，由很多对象组成，比如图中包含了一个场景(Scene)对象 ，多个网格(Mesh)对象，光源(Light)对象，群组(Group)，三维物体(Object3D)，和摄像机(Camera)对象。一个场景(Scene)对象定义了场景图最基本的要素，并包了含背景色和雾等属性。这些对象通过一个层级关系明确的树状结构来展示出各自的位置和方向。子对象的位置和方向总是相对于父对象而言的。比如说汽车的轮子是汽车的子对象，这样移动和定位汽车时就会自动移动轮子。你可以在场景图的这篇文章中了解更多内容。</p>
</li>
<li><p>注意图中摄像机(Camera)是一半在场景图中，一半在场景图外的。这表示在three.js中，摄像机(Camera)和其他对象不同的是，它不一定要在场景图中才能起作用。相同的是，摄像机(Camera)作为其他对象的子对象，同样会继承它父对象的位置和朝向。在场景图这篇文章的结尾部分有放置多个摄像机(Camera)在一个场景中的例子。</p>
</li>
<li><p>网格(Mesh)对象可以理解为用一种特定的材质(Material)来绘制的一个特定的几何体(Geometry)。材质(Material)和几何体(Geometry)可以被多个网格(Mesh)对象使用。比如在不同的位置画两个蓝色立方体，我们会需要两个网格(Mesh)对象来代表每一个立方体的位置和方向。但只需一个几何体(Geometry)来存放立方体的顶点数据，和一种材质(Material)来定义立方体的颜色为蓝色就可以了。两个网格(Mesh)对象都引用了相同的几何体(Geometry)和材质(Material)。</p>
</li>
<li><p>几何体(Geometry)对象顾名思义代表一些几何体，如球体、立方体、平面、狗、猫、人、树、建筑等物体的顶点信息。Three.js内置了许多基本几何体 。你也可以创建自定义几何体或从文件中加载几何体。</p>
</li>
<li><p>材质(Material)对象代表绘制几何体的表面属性，包括使用的颜色，和光亮程度。一个材质(Material)可以引用一个或多个纹理(Texture)，这些纹理可以用来，打个比方，将图像包裹到几何体的表面。</p>
</li>
<li><p>纹理(Texture)对象通常表示一幅要么从文件中加载，要么在画布上生成，要么由另一个场景渲染出的图像。</p>
</li>
<li><p>光源(Light)对象代表不同种类的光。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="../assets/helloworld.svg"></p>
<p><strong>branch page1</strong></p>
<blockquote>
<p>Three.js需要使用canvas标签来绘制,如果你没有给three.js传canvas，three.js会自己创建一个 ，但是你必须手动把它添加到文档中。</p>
</blockquote>
<blockquote>
<p>摄像机默认指向Z轴负方向，上方向朝向Y轴正方向。我们将会把立方体放置在坐标原点，所以我们需要往后移一下摄像机才能显示出物体。</p>
</blockquote>
<p><strong>branch page2</strong><br><img src= "/img/loading.gif" data-src="../assets/page2.svg"></p>
<p><strong>branch page3</strong><br><img src= "/img/loading.gif" data-src="../assets/page3.svg"></p>
<h4 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h4><p><strong>branch page3</strong></p>
<blockquote>
<p>解决拉伸的问题。为此我们要将相机的宽高比设置为canvas的宽高比。 我们可以通过canvas的clientWidth和clientHeight属性来实现。</p>
</blockquote>
<blockquote>
<p>HD-DPI代表每英寸高密度点显示器(视网膜显示器)。它指的是当今大多数的Mac和windows机器以及几乎所有的智能手机。</p>
</blockquote>
<p>浏览器中的工作方式是不管屏幕的分辨率有多高使用CSS像素设置尺寸会被认为是一样的。 同样的物理尺寸浏览器会渲染出字体的更多细节。</p>
<h4 id="Three-js-中的一些概念"><a href="#Three-js-中的一些概念" class="headerlink" title="Three.js 中的一些概念"></a><strong>Three.js 中的一些概念</strong></h4><p>想在屏幕上展示 3D 物体，大体上的思路是这样的：</p>
<ol>
<li>创建一个三维空间，Three.js 称之为场景（ Scene ）</li>
<li>确定一个观察点，并设置观察的方向和角度，Three.js 称之为相机（ Camera ）</li>
<li>在场景中添加供观察的物体，Three.js 中有很多种物体，如 Mesh、Group、Line 等，他们都继承自 Object3D 类。</li>
<li>最后我们需要把所有的东西渲染到屏幕上，这就是 Three.js 中的 Renderer 的作用。</li>
</ol>
<p>下面来仔细看看这些概念吧。</p>
<p><strong>图元</strong></p>
<blockquote>
<p>Three.js 有很多图元。图元就是一些 3D 的形状，在运行时根据大量参数生成。</p>
</blockquote>
<p><a href="https://threejsfundamentals.org/threejs/lessons/zh_cn/threejs-primitives.html">图元手册</a></p>
<p><strong>branch material</strong></p>
<p><strong>场景图</strong></p>
<p><img src= "/img/loading.gif" data-src="../assets/scene.svg"></p>
<p><strong>branch scene1</strong></p>
<blockquote>
<p>地球绕着太阳转，月球绕着地球转，月球绕着地球转了一圈。从月球的角度看，它是在地球的 “局部空间 “中旋转。尽管它相对于太阳的运动是一些疯狂的像螺线图一样的曲线，但从月球的角度来看，它只需要关注自身围绕地球这个局部空间的旋转即可。</p>
</blockquote>
<p><strong>branch scene2</strong></p>
<p><img src= "/img/loading.gif" data-src="../assets/scene2.svg"></p>
<blockquote>
<p>创建地球并加入太阳场景,到底发生了什么？为什么地球和太阳一样大？为什么离太阳这么远？我居然要把摄像机从 50 单位移到 150 单位以上才能看到地球。</p>
</blockquote>
<p><strong>branch scene3</strong></p>
<p><img src= "/img/loading.gif" data-src="../assets/scene3.svg"></p>
<blockquote>
<p>sunMesh 和 earthMesh 都是 solarSystem 的子网格。三者都在旋转，现在因为 earthMesh 不是 sunMesh 的子网格，所以不再按 5 倍比例缩放。</p>
</blockquote>
<p><strong>branch scene4</strong><br><img src= "/img/loading.gif" data-src="../assets/scene4.svg"></p>
<blockquote>
<p>可以看到月亮照着螺线图形式旋转，但我们不必手动计算它。我们只需要设置我们的场景图来为我们做这件事。</p>
</blockquote>
<p><strong>材质</strong></p>
<p><img src= "/img/loading.gif" data-src="../assets/material.jpg"></p>
<ul>
<li>MeshBasicMaterial 不受光照的影响。</li>
<li>MeshLambertMaterial 只在顶点计算光照。</li>
<li>MeshPhongMaterial 则在每个像素计算光照。</li>
</ul>
<p><strong>纹理</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">loader.load(<span class="string">&#x27;https://threejsfundamentals.org/threejs/resources/images/wall.jpg&#x27;</span>, <span class="function">(<span class="params">texture</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">      map: texture,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">    scene.add(cube);</span><br><span class="line">    cubes.push(cube);  <span class="comment">// add to our list of cubes to rotate</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>纹理支持Promise加载</p>
</blockquote>
<p><strong>摄像机</strong></p>
<p><a href="https://threejsfundamentals.org/threejs/lessons/zh_cn/threejs-cameras.html">摄像机轮廓</a></p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul>
<li>Uncaught TypeError: THREE.CSS3DRenderer is not a constructor</li>
</ul>
<blockquote>
<p>CSS3DRenderer 并没有包含在 three.js 中，你需要单独引入一个 CSS3DRenderer.js（文件可以在源码的examples/js/renderer中找到）</p>
</blockquote>
<p><a href="https://www.scaugreen.cn/posts/30679/"></a></p>
<p><a href="https://zhuanlan.zhihu.com/p/27296011"></a></p>
<p><a href="https://threejsfundamentals.org/threejs/lessons/zh_cn/">Three.js 基础</a></p>
<p><a href="https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene">three js 手册</a></p>
<p><a href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-cors-permission.html">WebGL 跨域图像</a></p>
]]></content>
      <tags>
        <tag>three</tag>
      </tags>
  </entry>
  <entry>
    <title>vertical-align的一些理解</title>
    <url>/2021/07/21/vertical-align%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>首先看个具体的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .parent &#123;</span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">250px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: lightgray;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .child &#123;</span><br><span class="line"><span class="css">        <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: cornflowerblue;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码中定义了一个父元素，里面包含了两个 inline-block 的子元素，效果如下：</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/191263/40/14083/5234/60f667a6Eaa14baf3/1b3e2b32fee5334e.jpg" alt="没有文字"></p>
<p>有没有发现，我们<strong>没有定义父元素的高度，子元素也没有设置 margin-bottom，为什么父元素底部还有段间距</strong>呢？</p>
<p>还是上面的样式和 DOM 结构，我们在其中一个子元素上添加一段文字，效果又成了下面这个样子：</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/174603/21/20420/7958/60f666c7E00eec665/064780ec4f8d53aa.jpg" alt="添加了文字"></p>
<p>为什么<strong>添加了文字之后，两个子元素的对齐情况完全变了</strong>呢？</p>
<p>其实上面的现象都是与 CSS 的 vertical-align 属性有关系，希望你看完本文之后能了解为什么会产生上面的现象并处理这些对齐问题。</p>
<h1 id="vertical-align-起作用的前提"><a href="#vertical-align-起作用的前提" class="headerlink" title="vertical-align 起作用的前提"></a>vertical-align 起作用的前提</h1><p>我们有时会遇到设置了 vertical-align 的属性但是没有任何效果的情况，这是因为 vertical-align 的作用对象是有限制的。MDN 上关于 vertical-align 定义如下：</p>
<blockquote>
<p>CSS 的属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。</p>
</blockquote>
<p>也就是说，vertical-align 作用于 inline 或 table-cell 元素（当然也作用于将 display 属性设置为 inline/inline-block/table-cell 的元素）。虽然 inline 和 table-cell 元素是很基础的 CSS 知识了，我这里还是罗列了一下：</p>
<ol>
<li>inline 元素</li>
</ol>
<ul>
<li>inline： img/span/em/b/匿名元素/…</li>
<li>inline-block: input/button</li>
</ul>
<ol start="2">
<li>table-cell 元素</li>
</ol>
<ul>
<li>table-cell: td</li>
</ul>
<p>因为 table-cell 元素的对齐比较简单，使用 table 时大多也会内嵌一层 dom，单独对模块进行排版，本文的讨论范围只限于 inline 元素。</p>
<h1 id="vertical-align-的属性值"><a href="#vertical-align-的属性值" class="headerlink" title="vertical-align 的属性值"></a>vertical-align 的属性值</h1><h2 id="继承类（inherit）"><a href="#继承类（inherit）" class="headerlink" title="继承类（inherit）"></a>继承类（inherit）</h2><p>我们对 inherit 再熟悉不过了，vertical-align 是支持继承的，子元素可以从父元素继承 vertical-align 属性的值。</p>
<h2 id="文本类（text-top-text-bottom）"><a href="#文本类（text-top-text-bottom）" class="headerlink" title="文本类（text-top/text-bottom）"></a>文本类（text-top/text-bottom）</h2><p>文本类的属性值定义如下：</p>
<ul>
<li>text-top: 使元素的顶部与父元素的字体顶部对齐</li>
<li>text-bottom: 使元素的底部与父元素的字体底部对齐</li>
</ul>
<p>从定义看出，这类属性值与父元素的字体有关。我们定义父元素的字体大小为24px，3个包含了文字的子元素的字体大小分别为12px、24px和48px，对齐效果如下：</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/184967/36/14715/17623/60f6705fE00a71cd8/381a3549ccd68f67.jpg" alt="text-top"></p>
<p>为了更清楚看到对齐的边界，在设置了 vertical-align: text-top 的元素的上边缘和字体的背景进行了标注，如下：</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/176662/21/20007/21352/60f667b9E44a06d76/57ca2cd15b69ba11.jpg" alt="text-top标注"></p>
<p>上图可以看出，左侧 div 确实是与 24px 的文字的顶部对齐的。</p>
<p>再复杂一点，我们增加一个 inline-block 的 div 作为子元素，效果如下：</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/180270/12/15093/32986/60f675e5Ede949710/abe894573253645c.jpg" alt="text-top-div"></p>
<p>从上面的例子我们可以知道，text-top/text-bottom 只与父级字体大小有关系，与左右元素是没有关系的。如果我们要确定两个元素的对齐关系，不管中间是否插入元素，可以考虑使用这种对齐方式。</p>
<h2 id="线类（baseline-top-middle-bottom）"><a href="#线类（baseline-top-middle-bottom）" class="headerlink" title="线类（baseline/top/middle/bottom）"></a>线类（baseline/top/middle/bottom）</h2><p>vertical-align 中我们用的最多，遇到问题也最多的应该就是线类属性了。线类属性值的定义如下：</p>
<ul>
<li>baseline（默认值）: 使元素的基线与父元素的基线对齐</li>
<li>middle: 使元素的中部与父元素的基线加上父元素x-height（译注：x高度）的一半对齐</li>
<li>top: 使元素及其后代元素的顶部与整行的顶部对齐</li>
<li>bottom: 使元素及其后代元素的底部与整行的底部对齐</li>
</ul>
<h3 id="top-和-bottom"><a href="#top-和-bottom" class="headerlink" title="top 和 bottom"></a>top 和 bottom</h3><ul>
<li>top: 使元素及其后代元素的顶部与整行的顶部对齐</li>
<li>bottom: 使元素及其后代元素的底部与整行的底部对齐</li>
</ul>
<p>我们先来看下相对简单的 top 和 bottom，这里以 top 为例，定义中包含了两个概念，一个是元素的顶部，一个是整行的顶部。</p>
<blockquote>
<p>Align the top of the aligned subtree with the top of the line box.</p>
</blockquote>
<ul>
<li>元素的顶部：元素盒模型的顶部，包含margin</li>
<li>整行的顶部：行框盒子的顶部。如果对行框盒子不了解，请看这里：[css行高line-height的一些理解](<a href="https://yolkpie.net/2020/09/29/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/%EF%BC%89">https://yolkpie.net/2020/09/29/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/）</a></li>
</ul>
<p>下面的例子中，div 为 inline-block，右侧的字体设置了 margin-top: 20px。内联盒子和幽灵节点的标注为黄色，行框盒子的标注为绿色，可以看到，盒子的顶部是对齐的。<br><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/189699/34/14117/48245/60f68e60E1bfaa8ad/159f50fccf019ce1.jpg" alt="top的box拆分"></p>
<p>如果把中间的文字设置margin-bottom: 100px，其他子元素的对齐方式由 top 变为 bottom，效果如下：<br><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/196386/36/13857/53504/60f69068E5c17673b/0b3d7981c0208058.jpg" alt="bottom"></p>
<p>从上面的例子我们可以看到，使用 top 和 bottom 属性值时，对齐的是行框盒子的顶部或底部。遇到问题时，把行框盒子拆分下就比较容易理解了。</p>
<h3 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h3><ul>
<li>baseline（默认值）: 使元素的基线与父元素的基线对齐</li>
</ul>
<p>baseline 是无处不在的，因为 vertical-align 的默认值就是 baseline。从 baseline 的定义来看，我们需要弄清楚元素的基线是什么（<a href="https://www.w3.org/TR/CSS2/visudet.html#leading">baseline定义</a>）：</p>
<blockquote>
<p>The baseline of an ‘inline-block’ is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its ‘overflow’ property has a computed value other than ‘visible’, in which case the baseline is the bottom margin edge.</p>
</blockquote>
<p>inline-block 的基线是正常流中（非float/absolute/fixed/html根节点）最后一个内联盒子的基线，除非这个元素里既没有内联盒子或者本身的 overflow 的计算值不是 visile，这种情况下 baseline 是元素的 margin 底边缘。也就是说，如果 inline-block 中没有元素或者 overflow 属性不是 visible，这个元素的基线是 margin 底边缘，其他的情况都是最后一个内联盒子的基线。</p>
<p>我们知道，文字的基线是 x 字母的下边缘。我们可以通过这个原理来模拟父元素的基线，可以通过在父元素上添加一个 after 伪元素选择器，内容为字母 x，那么父元素的基线就是字母 x 的下边缘线。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.line-box</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来看下开头的第一个问题：为什么父元素底部还有段间距？</p>
<p>首先，我们先来确定每个子元素的基线：按照 baseline 的定义，因为两个 inline-block 的 div 中没有元素，所以这两个 div 的基线为div的下边缘。另外，每个行框盒子的最前面都有一个幽灵节点，继承了父级的行高和字体，我们可以用一个 x 来模拟这个幽灵节点，所以幽灵节点的基线就是字母 x 的下边缘。子元素的基线确定好了之后，我们来看下父元素的基线，父元素的基线是最后一个元素，也就是第二个 div 的基线，即第二个div的下边缘。让子元素的基线和父元素的基线挨个对齐（如下图），因为幽灵节点（最左侧 x）占有高度，所以父元素底部还是有段间距的。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/175280/21/20204/15111/60f6a48fE9c78ad9d/0c82afb21cb01e2a.jpg" alt="baseline"></p>
<p>这个底部间距的问题我们也会经常遇到，最常见的就是图片（对应例子中的 inline-block 的 div 元素）的底部会有间距。要去掉这个间距，有下面几种方式：</p>
<ol>
<li>设置 line-height 为 0</li>
</ol>
<p>既然产生间距的原因是幽灵空白节点产生了高度，我们设置 line-height 为 0 就可以了。</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/37070/2/15867/3913/60f667b9E3e6b1901/d61cf9162e999f21.jpg" alt="设置 line-height 为 0"></p>
<ol start="2">
<li>设置 font-size 为 0</li>
</ol>
<p>设置 font-size 为 0 的原理和设置 line-height 为 0 是一样的，都是要消灭幽灵空白节点的高度：</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/175112/38/20270/4276/60f667b8E5094edea/f07099f37888fdd5.jpg" alt="设置 font-size 为 0"></p>
<ol start="3">
<li>设置图片为 block 元素，可以消灭空白节点</li>
</ol>
<p>无话可说，但是这种情况下图片只能一行一个。</p>
<ol start="4">
<li>设置 vertical-align 为 top/bottom/middle</li>
</ol>
<p>使用这种方式的目的是使幽灵节点上移，这样底部的边距就不见了</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/177490/28/14879/3376/60f667b9E6f4eb049/b7cac5b87b1f0bc3.jpg" alt="设置 vertical-align 为 bottom"></p>
<p>我们再来看第二个问题：为什么加了字母之后对齐方式变了？</p>
<p>还是先来分析下每个子元素的基线（幽灵空白节点依然用字母 x代替），第一个 div 的基线是底边缘，第二个 div 里因为有文字，这个 div 的基线是文字的基线。父元素的基线是第二个 div 的基线，即第二个 div 中 x 的底边缘。挨个对齐后，如下图：</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/196320/22/13985/20645/60f6a706E8ee4b769/711c4b8a8c8e1073.jpg" alt="baseline+文字"></p>
<h3 id="middle"><a href="#middle" class="headerlink" title="middle"></a>middle</h3><ul>
<li>middle: 使元素的中部与父元素的基线加上父元素x-height（译注：x高度）的一半对齐</li>
</ul>
<p>直观一点，就是使元素的中部和我们在父元素上添加的 x 字母的中心对齐。通常我们使用 vertical-align 来实现垂直居中的效果。</p>
<p>我们设置子元素（可以是图片，也可以是任意长度的文字）为 inline-block, vertical-align 为middle，如下：</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/177456/35/15068/14974/60f7b5bfEd782eba6/37e1ab4dd1c3b0f6.jpg" alt="middle 近似垂直居中"></p>
<p>上图中，黄色虚线为父元素的中线，红色为各个子元素的中线，可以看到，父元素和子元素的中线是重合的。但是，上面的居中只是“近似”垂直居中，为什么呢，上面的例子中，父元素的基线应该是幽灵空白节点的基线，我们知道，因为视觉上的需要，字体的基线普遍是偏下的，所以字母 x 的中心也是在中点偏下的位置。我们把父元素的字体增大，就会看到这种差异了：</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/177479/26/15032/21212/60f7b8edE7fcfa534/5e2bceee9b52f87e.jpg" alt="middle 近似垂直居中细节"></p>
<p>那如何实现“真正”的垂直居中呢？我们首先想到的是把父元素的 font-size 或者 line-height 设置为 0，但是这种方法有局限性，比如后面要加一段文本，如果 font-size 为 0 的话文本就会被隐藏掉，line-height 为 0 的话就会失去高度。这时我们可以给父元素的最后添加一个空白的内联元素，效果如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;display:inline-block;height: 100%;vertical-align: middle;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/193366/24/14097/25238/60f7bf9eE4c58b131/9c725c1e32a17c70.jpg" alt="middle 垂直居中"></p>
<h2 id="数值类百分比类（20px-2rem-20-…）"><a href="#数值类百分比类（20px-2rem-20-…）" class="headerlink" title="数值类百分比类（20px/2rem/20%…）"></a>数值类百分比类（20px/2rem/20%…）</h2><p>数值类百分比类的定义如下：</p>
<ul>
<li>length: 使元素的基线对齐到父元素的基线之上的给定长度。可以是负数</li>
<li>percentage: 使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。可以是负数。</li>
</ul>
<p>理解了 baseline 之后，这部分已经很简单了，就是在 baseline 的基础上加上偏移。有时候我们要把文字或图片上下调几个像素的时候会使用 relative + top 来处理，这种情况下可以考虑用 vertical-align 来代替。</p>
<h2 id="上标下标类（sub-super）"><a href="#上标下标类（sub-super）" class="headerlink" title="上标下标类（sub/super）"></a>上标下标类（sub/super）</h2><p>上标下标类的属性值定义如下：</p>
<ul>
<li>sub: 使元素的基线与父元素的下标基线对齐</li>
<li>super: 使元素的基线与父元素的上标基线对齐</li>
</ul>
<p>这种对齐方式在实际中并没有用到。不过联想到 html 中 的 sup 和 sub 标签实现的是相同的功能，我们来比较下：</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/175594/25/20431/34632/60f6705fE2b77fea6/3df735778a7d5bea.jpg" alt="sup标签"></p>
<p>从图上可以看出，使用 sup 标签和设置 vertical-align 为 super，这两种对齐效果是一样的，不同的是 sup 标签里的文字要比正常的小一些（原字体的75%）。通常上标和下标都会要求字体要比正文小一些，因此我认为使用标签要比设置vertical-align更合适。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CSS 的知识点很碎，而且因为兼容性的问题表现出来的总是莫名奇妙，但还是建议大家从 CSS 的各种概念入手，遇到不清楚的情况回到盒模型、行高、字体这些最基础的含义上，才能一步步梳理清楚。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>vertical-align</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket</title>
    <url>/2020/11/20/websocket/</url>
    <content><![CDATA[<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。一开始的握手需要借助HTTP请求完成。</p>
<h3 id="原理-amp-机制"><a href="#原理-amp-机制" class="headerlink" title="原理&amp;机制"></a>原理&amp;机制</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>网站上的即时通讯是很常见的，比如网页的QQ，微信等。按照以往的技术能力通常是采用轮询等技术解决。<br>HTTP协议是非持久化的，单向的网络协议，在建立连接后只允许浏览器向服务器发出请求后，服务器才能返回相应的数据。<br>当需要即时通讯时，通过轮询在特定的时间间隔（如1秒），由浏览器向服务器发送Request请求，然后将最新的数据返回给浏览器。<br>缺点：会导致过多不必要的请求，浪费流量和服务器资源，每一次请求、应答，都浪费了一定流量在相同的头部信息上，而在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握手的动作，然后单独建立一条TCP的通信通道进行数据的传送。<br>WebSocket同HTTP一样也是应用层的协议，但是它是一种双向通信协议，是建立在TCP之上的。<br>广泛被用来做即时通讯，以替代轮询。</p>
<h4 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h4><p>WebSocket是HTML5的新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在TCP之上，同HTTP一样通过 TCP 来传输数据，但是它和 HTTP 最大不同在于：</p>
<ul>
<li>WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和<br>Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket 一样。</li>
<li>WebSocket 需要类似TCP的客户端和服务器端通过握手连接，连接成功后<br>才能相互通信。</li>
</ul>
<p>WebSocket是类似Socket的TCP长连接的通讯模式，一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。<br>在客户端断开 WebSocket 连接或 Server 端断掉连接前，不需要客户端和服务端重新发起连接请求。<br>在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。</p>
<h3 id="连接过程-amp-特点"><a href="#连接过程-amp-特点" class="headerlink" title="连接过程&amp;特点"></a>连接过程&amp;特点</h3><h4 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h4><ul>
<li>浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后<br>续都不执行。</li>
<li>TCP连接成功后，浏览器通过HTTP协议向服务器传送WebSocket支持的版本号等信息。<br>（开始前的HTTP握手）</li>
<li>服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据。</li>
<li>当收到了连接成功的消息后，通过TCP通道进行传输通信。<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4></li>
<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP<br>协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
<li>数据格式比较轻量，性能开销小，通信高效。</li>
<li>可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li>
</ul>
<h3 id="保持连接-心跳"><a href="#保持连接-心跳" class="headerlink" title="保持连接+心跳"></a>保持连接+心跳</h3><p>WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。<br>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。<br>发送方-&gt;接收方：ping<br>接收方-&gt;发送方：pong<br>ping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。<br>举例，WebSocket服务端向客户端发送ping，只需要如下代码（采用ws模块）</p>
<h3 id="主要Api"><a href="#主要Api" class="headerlink" title="主要Api"></a>主要Api</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ws &#x3D; new WebSocket(&#39;ws:&#x2F;&#x2F;localhost:80&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h4><p>readyState属性返回实例对象的当前状态，例如</p>
<ul>
<li>CONNECTING：值为0，表示正在连接。</li>
<li>OPEN：值为1，表示连接成功，可以通信了。</li>
<li>CLOSING：值为2，表示连接正在关闭。</li>
<li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch (ws.readyState) &#123;</span><br><span class="line">  case WebSocket.CONNECTING:</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.OPEN:</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.CLOSING:</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.CLOSED:</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    &#x2F;&#x2F; this never happens</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="webSocket-onopen"><a href="#webSocket-onopen" class="headerlink" title="webSocket.onopen"></a>webSocket.onopen</h4><p>实例对象的onopen属性，用于指定连接成功后的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws.onopen &#x3D; function () &#123;</span><br><span class="line">  ws.send(&#39;Hello WebSocket!&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h4><p>实例对象的onclose属性，用于指定连接关闭后的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws.onclose &#x3D; function(event) &#123;</span><br><span class="line">  const &#123;code, reason, wasClean&#125; &#x3D; event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="webSocket-onmessage"><a href="#webSocket-onmessage" class="headerlink" title="webSocket.onmessage"></a>webSocket.onmessage</h4><p>实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws.onmessage &#x3D; function(event)&#123;</span><br><span class="line">  if(typeof event.data &#x3D;&#x3D;&#x3D; String) &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="webSocket-send"><a href="#webSocket-send" class="headerlink" title="webSocket.send"></a>webSocket.send</h4><p>实例对象的send()方法用于向服务器发送数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送文本的例子。(也可以发送图片等其他文件对象)</span><br><span class="line">ws.send(&#39;your message&#39;);</span><br></pre></td></tr></table></figure>
<h4 id="webSocket-onerror"><a href="#webSocket-onerror" class="headerlink" title="webSocket.onerror"></a>webSocket.onerror</h4><p>实例对象的onerror属性，用于指定报错时的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket.onerror &#x3D; function(event) &#123;</span><br><span class="line">  console.log(event)</span><br><span class="line">  &#x2F;&#x2F;处理错误异常</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ws &#x3D; new WebSocket(&quot;wss:&#x2F;&#x2F;localhost:80&quot;);  </span><br><span class="line">ws.onopen &#x3D; function(evt) &#123;   </span><br><span class="line">  console.log(&quot;Connection open ...&quot;);   </span><br><span class="line">  ws.send(&quot;Hello WebSockets!&quot;); </span><br><span class="line">&#125;;  </span><br><span class="line">ws.onmessage &#x3D; function(evt) &#123;  </span><br><span class="line">  console.log( &quot;Received Message: &quot; + evt.data);</span><br><span class="line">  &#x2F;&#x2F;Received Message: Hello WebSockets!</span><br><span class="line">  ws.close(); </span><br><span class="line">&#125;;  </span><br><span class="line">ws.onclose &#x3D; function(evt) &#123;  </span><br><span class="line">  console.log(&quot;Connection closed.&quot;); </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="WebSocket与HTTP的不同-（图解）"><a href="#WebSocket与HTTP的不同-（图解）" class="headerlink" title="WebSocket与HTTP的不同 （图解）"></a>WebSocket与HTTP的不同 （图解）</h3><p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/142749/34/13761/207298/5fa93d0dE977b31a4/b2458a2ffda633bb.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>whistle使用实践（vase篇）</title>
    <url>/2021/03/27/whistle%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5%EF%BC%88vase%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>之前我在<a href="https://yolkpie.net/2020/12/24/whistle%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5%EF%BC%88%E5%AE%9E%E4%BE%8B%E7%AF%87%EF%BC%89/">whistle使用实践（实例篇）</a>中的 mock 数据一节中说过使用 file 或者 tpl 就能满足大部分的工作需要，但是想 mock 的数据有更大的灵活性或者数据项中间有逻辑关系，可以使用whistle.vase。因为 vase 官网已经说的很详细了，而且我在工作中一般都手动改 json 文件，也没用上过 vase，本来不打算写这篇的。但是最近部门的测试同学遇到了在页面回退时需要变更 mock 数据的情况，来找我问解决方案，这让我想起了自己之前手动改 json 文件的繁琐，因此就以此为契机，记录下 whistle.vase 来 mock 数据的方式，仅供大家参考。</p>
<p>这篇文章依然从实用性出发，只是介绍了对于前端人员最易上手的方式，如果想要了解更多，依然推荐去 <a href="https://github.com/whistle-plugins/whistle.vase">whistle.vase 官网</a>。 </p>
<h1 id="whistle-vase"><a href="#whistle-vase" class="headerlink" title="whistle.vase"></a>whistle.vase</h1><p>whistle.vase 是 whsitle 的一个插件，内置了 default、doT、dust、ejs、handlebars、jade、mock、mustache、nunjucks、swig、vm 以及用于解析自定义脚本的 script 渲染引擎，通过该插件，我们可以更灵活的控制要 mock 的数据。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>whistle.vase 不是 whistle 内置的插件（whistle 没有内置任何插件），我们还需要手动安装一下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g whistle.vase</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装成功后，可以在 whistle 控制台的 Plugins 下面看到。如果没有的话，可以重启下 whistle。</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/157098/20/15542/552298/605e9e6dE8ded985b/75e0d92dda2c8ba8.jpg" alt="whistle Plugins"></p>
<p>有两种方式可以打开 vase 的配置页面，一种是在上图中找到 vase 点进去，另一种是使用浏览器访问<a href="http://local.whistlejs.com/whistle.vase/%E3%80%82%E5%9B%A0%E4%B8%BA%E6%88%91%E4%B9%A0%E6%83%AF%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E9%85%8D%E6%89%80%E6%9C%89%EF%BC%8C%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AF%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E3%80%82">http://local.whistlejs.com/whistle.vase/。因为我习惯在一个页面配所有，采用的是第一种方式。</a></p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/156343/34/18186/548396/605e9e6cE9da59800/e3a05e272c9ee81e.jpg" alt="vase 配置界面"></p>
<p>从上图可以看到，vase 的配置页面和 whistle 长的很像，如果使用 vase 的渲染引擎 mock 数据，就要在 vase 的配置页添加。</p>
<h2 id="添加模板"><a href="#添加模板" class="headerlink" title="添加模板"></a>添加模板</h2><p>点 Create 按钮， 选择对应的渲染引擎，这里我们先选择 default。default 是 vase 的默认引擎，即直接输出设置的文本，不做任何加工。（感觉和 Values 的功能一样呢，存疑，这部分以后再了解。）</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/172683/28/616/656218/605e9e6bEb28c681a/b86f96870f45953d.jpg" alt="添加 default 模板"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>vase 的配置规则很简单，左侧是对应的文件，右侧是要匹配的规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vase:&#x2F;&#x2F;vase-file rule1 rule2 rule3</span><br></pre></td></tr></table></figure>

<p>比如，我要 mock 京东首页的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vase:&#x2F;&#x2F;hello.html https:&#x2F;&#x2F;m.jd.com&#x2F;</span><br></pre></td></tr></table></figure>

<p>访问首页，结果如下：</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/163843/40/14672/1121348/605e9e69E2a1c705c/506874b21621653f.jpg" alt="mock 京东首页"></p>
<h1 id="强大的-script"><a href="#强大的-script" class="headerlink" title="强大的 script"></a>强大的 script</h1><p>上面提到的 default 渲染引擎因为是静态的，依然解决不了灵活输出的问题，这时候就要用到我们前端人员最为熟悉的 script 了。</p>
<blockquote>
<p>script 是 vase 系统自定义的脚本解析器，保留了 JavaScript 的一些基本特性，如：基本类型、条件语句、循环体、方法等，剔除了 JavaScript 内置的一些 api，如：process、setTimeout、setInterval 等，并内置了一些方法用于读取及处理 vase 的模板、本地文件、线上文件等，且所有调用都是同步的方式。</p>
</blockquote>
<p>也就是说，除了 setTimeout 这些异步的方法之外，script 还提供了读取 vase 模板、本地和线上文件的功能，使我们能够更加灵活的获取数据源、控制输出。另外，script 还可以控制速度、分段输出、设置响应头、响应状态码、响应内容编码等，是不是很强大呢？</p>
<p>script 模板的创建很简单，在创建的时候文件使用 .js 后缀，选择 script 引擎就可以了。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/162308/22/15178/687759/605efacaEbba851a7/f8caa826f75da9bf.jpg" alt="script 创建"></p>
<p>本着一招鲜吃遍天的原则，script 是我认为的 vase 中最创新的（况且渲染时还可以使用所有上面列出来的渲染引擎，见script API 中render 方法）且是前端最容易掌握的，如果不想学其他的渲染引擎的话，我觉得这个就够了。我们先逐个看下 script 提供的方法吧。</p>
<h2 id="script-API"><a href="#script-API" class="headerlink" title="script API"></a>script API</h2><ol>
<li>out(data, delay, speed)  </li>
</ol>
<p>所有的数据都要通过该方法才能输出到响应中，也可以用 write。</p>
<ul>
<li>data：要输出的对象，可以是 json、文本，也可以是 vase 加载的资源。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出文本</span></span><br><span class="line">out(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 json</span></span><br><span class="line">out(&#123;</span><br><span class="line">    content: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 vase 加载的资源（略，详见 14:render）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>delay: 设置延迟多少毫秒输出。</li>
<li>speed: 设置输出的速度(单位kbs)。</li>
</ul>
<ol start="2">
<li>status<br>设置输出的http状态码，默认为200，也可以写成 statusCode(code);</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">out(status(500));</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>header(name, value)</li>
</ol>
<p>设置响应头。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置允许跨域的相应头</span></span><br><span class="line">out(header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>headers(obj)<br>和 header 方法一样，用于设置相应头，不同的是 headers 可以同时设置多个。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同时设置多个请求头</span></span><br><span class="line">out(headers(&#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/plain; charset=utf8&#x27;</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>file(path)<br>读取本地文件。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mac</span></span><br><span class="line">out(file(<span class="string">&#x27;/User/xxx/hello.html&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// windows</span></span><br><span class="line">out(file(<span class="string">&#x27;D:/xxx/hello.html&#x27;</span>)); </span><br></pre></td></tr></table></figure>

<ol start="6">
<li>get(url|options)  </li>
</ol>
<p>通过get方式获取线上文件，支持https及http协议。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数为url</span></span><br><span class="line">out(get(<span class="string">&#x27;https://m.jd.com/&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为options时，可以自定义请求头</span></span><br><span class="line">out(get(&#123;</span><br><span class="line">    url: <span class="string">&#x27;https://www.taobao.com/&#x27;</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;vase/x.y.z&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>post(url|options)  </li>
</ol>
<p>通过post方式获取线上文件，支持https及http协议。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 和 get 不同之处：还可以自定义表单数据</span></span><br><span class="line">out(post(&#123;</span><br><span class="line">    url: <span class="string">&#x27;https://m.jd.com/&#x27;</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;vase/x.y.z&#x27;</span></span><br><span class="line">    &#125;, </span><br><span class="line">    form: &#123;<span class="attr">key</span>:<span class="string">&#x27;value&#x27;</span>&#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>request(options)  </li>
</ol>
<p>通过自定义方式获取线上文件，支持https及http协议。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">out(request(&#123;</span><br><span class="line">    url: <span class="string">&#x27;https://m.jd.com/&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;vase/x.y.z&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>json(data)  </li>
</ol>
<p>将文本转换成json 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换字符串</span></span><br><span class="line">out(json(<span class="string">&#x27;&#123;&quot;test&quot;: 123&#125;&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换本地加载的文件内容</span></span><br><span class="line">out(json(file(<span class="string">&#x27;/User/xxx/hello.txt&#x27;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//  转换线上获取到的内容</span></span><br><span class="line">out(json(get(<span class="string">&#x27;https://m.jd.com/xxx/hello.txt&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>merge(json, …, jsonN)</li>
</ol>
<p>合并 json 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并不同来源的 json 数据</span></span><br><span class="line">out(merge(json(<span class="string">&#x27;&#123;&quot;test&quot;: 123&#125;&#x27;</span>), json(file(<span class="string">&#x27;/User/xxx/hello.txt&#x27;</span>))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// vase &gt;= v1.3.1 时，支持深度合并 merge(deepMerge, json, ..., jsonN)</span></span><br><span class="line">out(<span class="literal">true</span>, merge(json(<span class="string">&#x27;&#123;&quot;test&quot;: 123&#125;&#x27;</span>), json(file(<span class="string">&#x27;/User/xxx/hello.txt&#x27;</span>))));</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>random(arg1, …, argN)</li>
</ol>
<p>随机获取参数列表中的一个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 随机取数</span></span><br><span class="line">out(random(<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>join(arr, seperator)</li>
</ol>
<p>与数组的 join 方法一样用于拼接数组，seperator默认为’’。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回拼接好的地址</span></span><br><span class="line">out(join([<span class="string">&#x27;province&#x27;</span>, <span class="string">&#x27;city&#x27;</span>, <span class="string">&#x27;county&#x27;</span>, <span class="string">&#x27;town&#x27;</span>], <span class="string">&#x27;-&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用默认的seperator， 可以写成join(arg1, ..., argN)</span></span><br><span class="line">out(join(<span class="string">&#x27;province&#x27;</span>, <span class="string">&#x27;city&#x27;</span>, <span class="string">&#x27;county&#x27;</span>, <span class="string">&#x27;town&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>req</li>
</ol>
<p>请求对象，包含：headers、method、body、query、url、locals(=merge(req.query, req.body))。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断请求对象的 method 是否为 OPTION，是的话放过</span></span><br><span class="line"><span class="keyword">if</span> (req.method === <span class="string">&#x27;OPTION&#x27;</span>) &#123;</span><br><span class="line">    out(status(<span class="number">200</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="14">
<li>render(tpl[, locals[, engineType]])</li>
</ol>
<p>渲染模板。（这里是重点！）</p>
<ul>
<li><p>tpl：vase 的模板名称或模板字符串。</p>
</li>
<li><p>locals：可选，用于渲染的json对象。</p>
</li>
<li><p>engineType：可选，渲染引擎名称，包含 default、doT、dust、doT、ejs、jade、mock、mustache、nunjucks、swig、vm。</p>
</li>
</ul>
<p>14.1 如果tpl是字符串或数字，且 vase 里面有对应名称的模板，则会自动加载 vase 的模板内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 req.locals(=merge(req.query, req.body)) 的值作为模板的数据</span></span><br><span class="line">out(render(<span class="string">&#x27;test-tpl&#x27;</span>), req.locals);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用获取到的 json 数据作为模板的数据</span></span><br><span class="line"></span><br><span class="line">out(render(<span class="string">&#x27;test-tpl&#x27;</span>), json(get(<span class="string">&#x27;https://m.jd.com/xxx/test.txt&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果模板使用的是其他渲染引擎（如handlebars），还需要在第三个参数指定</span></span><br><span class="line">out(render(<span class="string">&#x27;test-tpl&#x27;</span>), req.locals, <span class="string">&#x27;handlebars&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>14.2 如果tpl是字符串或数字，且没有对应的vase模板，则这些字符串作为模板内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串作为模板内容</span></span><br><span class="line">out(render(<span class="string">&#x27;Hello &#123;&#123;name&#125;&#125;&#x27;</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;World&#x27;</span>&#125;, <span class="string">&#x27;handlebars&#x27;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>14.3 可以渲染线上或本地文件模板</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染线上模板</span></span><br><span class="line">out(render(get(<span class="string">&#x27;http://m.jd.com/&#x27;</span>), json(get(<span class="string">&#x27;https://m.jd.com/xxx/test.txt&#x27;</span>), <span class="string">&#x27;handlebars&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染本地文件模板</span></span><br><span class="line">out(render(file(<span class="string">&#x27;/User/xxx/test-tpl.txt&#x27;</span>), json(get(<span class="string">&#x27;https://m.jd.com/xxx/test.txt&#x27;</span>), <span class="string">&#x27;handlebars&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>从上面的 API 可以看出，vase 获取数据（本地文件、vase 模板、线上、字符串等数据内容，以及请求头内容req）、渲染数据（render 使用的模板和要渲染的数据可以有多种来源，可以使用多种渲染引擎）的方式都很灵活，还可以灵活的设置请求头和延迟时间，只要我们面对具体情况的时候善于组合，就妥妥的了。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>回到测试同学遇到的问题，简单来说，测试需要的是同一个字段可以使用不同的值（0 和 1），看了上面的 API 之后，你应该就会觉得太简单了，随机下 0 和 1 就行了，杀鸡用牛刀的感觉：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">out(random(<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>再稍微复杂点，比如在拍卖业务中，不同业务线返回的对象是不同的。那我们可以根据请求参数，渲染不同的模板或者返回不一样的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用不同模板</span></span><br><span class="line"><span class="keyword">if</span> (req.locals) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (req.locals.publishSource === <span class="string">&#x27;OPTION&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;sifa&#x27;</span>:</span><br><span class="line">            <span class="comment">// render 方法可以同样根据 req 中拿到的数进行逻辑上的处理</span></span><br><span class="line">            out(render(<span class="string">&#x27;sifa-tpl&#x27;</span>)）;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;haiguan&#x27;</span>:</span><br><span class="line">            out(render(<span class="string">&#x27;sifa-tpl&#x27;</span>)）;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    out(status(<span class="number">200</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你需要造很多条数据，也可以使用 vase 来写（当然，你也可以选一个模板来写循环）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 造100条数据</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  arr.push(&#123;</span><br><span class="line">    id: i,</span><br><span class="line">    name: <span class="string">`user<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">out(arr);</span><br></pre></td></tr></table></figure>

<p>总之，灵活运用很重要。</p>
<h1 id="追加的碎碎念"><a href="#追加的碎碎念" class="headerlink" title="追加的碎碎念"></a>追加的碎碎念</h1><p>whistle 真是个宝藏，所以我应该不会说什么不再写的 flag 了，如果再遇到具体的问题，这个系列就又要更新了。</p>
]]></content>
      <tags>
        <tag>whistle</tag>
      </tags>
  </entry>
  <entry>
    <title>whistle使用实践（实例篇）</title>
    <url>/2020/12/24/whistle%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5%EF%BC%88%E5%AE%9E%E4%BE%8B%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>作为一名前端开发，利用代理工具抓包是最基础的技能。通过抓包，我们可以获取的信息有下面这些：</p>
<ol>
<li>具体的url</li>
<li>请求的Method，Status等信息</li>
<li>请求接口携带的参数</li>
<li>请求头信息（cookie、UA、请求参数等）</li>
<li>返回头信息（返回结果、是否支持跨域等）</li>
</ol>
<p>这部分和其他的代理工具没什么区别，都在Network模块里，不熟悉的话多点点就找到了。需要啰嗦几句的是，如果页面出问题，我们抓包的排查步骤是什么：首先确认控制台是否报错（见下节），确认页面地址及url携带的参数是否正确，还要确认要加载的静态资源或者接口的请求是否有非200的情况，当然，如果确切知道问题出在哪个接口上，直接查看接口的请求头和返回值信息就行了。</p>
<h1 id="查看控制台报错"><a href="#查看控制台报错" class="headerlink" title="查看控制台报错"></a>查看控制台报错</h1><p>远程调试页面或者线上页面出现问题时，我们希望能够看到控制台的报错。这里有三种实现方式：</p>
<ul>
<li>使用log规则</li>
<li>在页面注入vConsole</li>
<li>使用Weinre</li>
</ul>
<p>如果只是简单查看控制台报错的话，经常用的是前两种方式，Weinre我会在下文中的Weinre模块单独说明。这里以查看京东首页的控制台内容来举例。</p>
<h2 id="使用log规则"><a href="#使用log规则" class="headerlink" title="使用log规则"></a>使用log规则</h2><p>使用log规则很简单，在Rules里增加以下规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//m.jd.com/ log://</span></span><br></pre></td></tr></table></figure>
<p>规则添加完成后，切换到Network模块，刷新京东首页，在左侧的请求中找到<a href="https://m.jd.com/%E5%B9%B6%E9%80%89%E4%B8%AD%EF%BC%8C%E5%9C%A8%E5%8F%B3%E4%BE%A7%E9%80%89%E4%B8%ADTools%E6%A0%87%E7%AD%BE%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E7%9A%84%E4%BF%A1%E6%81%AF%E4%BA%86%E3%80%82">https://m.jd.com/并选中，在右侧选中Tools标签，就可以看到控制台打印的信息了。</a></p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/152818/39/11356/1022862/5fe45986Eba613fd6/c7bc33721f017f2d.jpg" alt="控制台信息"></p>
<h2 id="在页面注入vConsole"><a href="#在页面注入vConsole" class="headerlink" title="在页面注入vConsole"></a>在页面注入vConsole</h2><p>在页面注入cConsole其实就是使用了whsitle的js规则，该规则在响应中追加脚本，如果响应是html文档，则自动用<code>&lt;script&gt;&lt;/script&gt;</code>包装后插入</p>
<blockquote>
<p>vConsole.js 文件地址：<a href="http://wechatfe.github.io/vconsole/lib/vconsole.min.js?v=3.3.0">http://wechatfe.github.io/vconsole/lib/vconsole.min.js?v=3.3.0</a></p>
</blockquote>
<ol>
<li>在Values中增加vConsole.js，并把从上面链接获取到的vConsole.js的内容粘贴到新增的vConsole.js中</li>
<li>在vConsole.js中追加初始化逻辑：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">window</span>.VConsole();</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">3. 在Rules中配置如下规则：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> js</span><br><span class="line">https:<span class="comment">//m.jd.com/ js://&#123;vConsole.js&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>刷新京东主页，就可以在页面右下角看到vConsole了，点击vConsole，就可以看到控制台的信息了<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/154434/11/11513/852204/5fe45fb5Ec33d1d66/3b1229d5e9d38030.jpg" alt="vConsole"></li>
</ol>
<p>就我个人而言，我比较习惯使用注入vConsle的方式，因为可以同时使用多台设备，输出的内容互不影响，而且使用vConsole可以查看localStorage和sessionStorage等缓存信息。</p>
<h1 id="配Host"><a href="#配Host" class="headerlink" title="配Host"></a>配Host</h1><p>配置方式和我们使用SwitchHosts的软件配置host的方式一样。比如开发时需要使用jd.com的域名才能使用登录态，可以这样配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dev.jd.com是我经常用的，表示开发环境，可以随便叫 XXX.jd.com</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> dev.jd.com</span><br></pre></td></tr></table></figure>

<p>如果一个IP对应多个域名，可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> dev.jd.com dev1.jd.com</span><br></pre></td></tr></table></figure>

<h1 id="代理域名"><a href="#代理域名" class="headerlink" title="代理域名"></a>代理域名</h1><p>比如预发环境接口域名为xxx-api.m.jd.com，线上域名是api.m.jd.com，如果遇到预发环境在发布或者预发环境有问题，而我们在做的任务只涉及到前端的改动，这时候我们可以使用whistle暂时将域名的接口先代理为线上，预发好了再关掉代理就行了。这样子我们就可以不必在我们代码上来回做更改，也不必频繁启动项目了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将域名为xxx-api.m.jd.com的请求代理到api.m.jd.com</span></span><br><span class="line">xxx-api.m.jd.com api.m.jd.com</span><br></pre></td></tr></table></figure>

<h1 id="代理端口"><a href="#代理端口" class="headerlink" title="代理端口"></a>代理端口</h1><p>比如我启动的项目端口是3000，我用80又不想重启项目（懒的有点过分哈），可以这样代理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dev.jd.com dev.jd.com:<span class="number">3000</span></span><br></pre></td></tr></table></figure>

<p>这样子即使启动的是3000，我们依然可以使用dev.jd.com。</p>
<h1 id="代理https"><a href="#代理https" class="headerlink" title="代理https"></a>代理https</h1><p>有时候因为HSTS，请求被转成https，或者某些app只能打开https的请求。这时候可以使用whislte将https请求代理成http：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//dev.jd.com http://dev.jd.com</span></span><br></pre></td></tr></table></figure>
<p>这样子即使是用https访问，页面也可以正常打开。</p>
<h1 id="mock数据"><a href="#mock数据" class="headerlink" title="mock数据"></a>mock数据</h1><p>在项目开发中，经常遇到的情况是前端静态页和交互好了，后端接口没完成或者没数据，或者说有些数据的状态不易获得，这时候，使用mock数据来开发是比较高效的手段。还有一种情况是线上遇到问题，我们需要拿不同状态的数据去复现。（将mock的数据写在代码里也是一种方式，但这种会涉及代码的改动，不建议这样做，首先是因为我们要保证代码逻辑和mock数据的分离，另一个原因是如果不是开发环境，这种方式也不适用）</p>
<p>拿获取用户是否是新用户的接口举例，这个接口支持JSONP和非JSONP两种形式</p>
<h2 id="mock非JSONP请求"><a href="#mock非JSONP请求" class="headerlink" title="mock非JSONP请求"></a>mock非JSONP请求</h2><blockquote>
<p><a href="https://api.m.jd.com/api?appid=paimai&amp;functionId=queryNewComerInfo&amp;body=%7B%7D">https://api.m.jd.com/api?appid=paimai&amp;functionId=queryNewComerInfo&amp;body={}</a></p>
</blockquote>
<p>我们需要先在Files或者Values添加名为queryNewComerInfo.json的文件，并在这个文件里根据接口文档要求的数据格式创建假数据：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code:0,</span><br><span class="line">    data:</span><br><span class="line">        &#123;</span><br><span class="line">            newComerFlag:false,</span><br><span class="line">            pin:&quot;XXXXXXX&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">    datas:[],</span><br><span class="line">    message:&quot;操作成功&quot;,</span><br><span class="line">    statusCode:200</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再在Rules里添加规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用正则匹配queryNewComerInfo的方法，返回queryNewComerInfo.json里的内容</span></span><br><span class="line">/functionId=queryNewComerInfo/ file:<span class="comment">//&#123;queryNewComerInfo.json&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="mock-JSONP-请求"><a href="#mock-JSONP-请求" class="headerlink" title="mock JSONP 请求"></a>mock JSONP 请求</h2><blockquote>
<p><a href="https://api.m.jd.com/api?appid=paimai&amp;functionId=queryNewComerInfo&amp;body=%7B%7D&amp;_=1608811151553&amp;jsonp=Zepto1608810637767">https://api.m.jd.com/api?appid=paimai&amp;functionId=queryNewComerInfo&amp;body={}&amp;_=1608811151553&amp;jsonp=Zepto1608810637767</a></p>
</blockquote>
<p> 如果访问上面的地址，JSONP请求返回的数据是这样的：<br> <figure class="highlight"><table><tr><td class="code"><pre><span class="line">Zepto1608810637767(</span><br><span class="line">    &#123;</span><br><span class="line">    code: 0,</span><br><span class="line">    data: &#123;</span><br><span class="line">        newComerFlag: false,</span><br><span class="line">        pin: &quot;XXXXXXX&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">        datas: [ ],</span><br><span class="line">        message: &quot;操作成功&quot;,</span><br><span class="line">        statusCode: 200</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p> 熟悉JSONP的应该都知道，返回内容的回调函数名称Zepto1608810637767和url中jsonp（默认为callback）的参数值保持一致的。因为jsonp的参数值是随机的，我们就不能使用json格式的数据直接返回。这里我们要用到whislte的tpl：</p>
<blockquote>
<p>tpl基本功能跟file一样可以做本地替换，但tpl内置了一个简单的模板引擎，可以把文件内容里面{name}替换请求参数对应的字段(如果不存在对应的自动则不会进行替换)，一般可用于mock jsonp的请求。</p>
</blockquote>
<p>所以，如果请求是JSONP，我们就需要在返回结果的json中使用{jsonp}来替换url中jsonp的参数值：</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;jsonp&#125;(</span><br><span class="line">    &#123;</span><br><span class="line">    code: 0,</span><br><span class="line">    data: &#123;</span><br><span class="line">        newComerFlag: false,</span><br><span class="line">        pin: &quot;XXXXXXX&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">        datas: [ ],</span><br><span class="line">        message: &quot;操作成功&quot;,</span><br><span class="line">        statusCode: 200</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>whsitle规则配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/functionId=queryNewComerInfo/ tpl:<span class="comment">//&#123;queryNewComerInfo.json&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果以上还不能满足mock数据的要求，想mock的数据有更大的灵活性或者数据项中间有逻辑关系，可以使用<a href="https://github.com/whistle-plugins/whistle.vase">whistle.vase</a></p>
<blockquote>
<p>vase插件内置default、doT、dust、ejs、handlebars、jade、mock、mustache、nunjucks、swig、vm及用于解析自定义脚本的script等渲染引擎，通过该whistle插件，可以通过模板结合相应的引擎mock开发过程中需要的json、html、图片等数据，也可以通过script来自定义脚本更加灵活的获取模板及数据，控制输出等（如果只是静态数据不需要借助模板引擎批量生成，直接利用whistle的 file 或 xfile 即可实现）</p>
</blockquote>
<p>工作中我基本上用的都是whistle的file或者tpl，如果数据项有逻辑关系，我觉得手动修改json文件就可以满足需要了，这里不再对vase多做说明，<a href="https://github.com/whistle-plugins/whistle.vase">whistle.vase</a>官网也说的很清楚了，有兴趣的可以自己去了解。</p>
<h1 id="使用Weinre"><a href="#使用Weinre" class="headerlink" title="使用Weinre"></a>使用Weinre</h1><p>whistle集成了weinre的功能，用于调试远程页面特别是移动端的页面。<br>配置方式是：<code>pattern weinre://key</code></p>
<p>比如我要调试京东主页。在whistle中的配置如下，这里的key就是honepage：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//m.jd.com/ weinre://homepage</span></span><br></pre></td></tr></table></figure>

<p>配置完之后，点击页面顶部的Weinre，就可以看到一条homepage的数据（配置规则中不指定key，默认为anonymous）：<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/155708/16/3330/237012/5fec1465Ecfb6517a/d399c319383ef160.jpg" alt="weinre"></p>
<p>点击homepage，显示如下：<br><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/157577/18/688/562109/5fec14e3E05672fea/55603df3d5f7323d.jpg" alt="weinre"></p>
<p>从上图我们看到，weinre中有我们在浏览器中常用的Elements、Resources、Network、TimeLine、Console等模块。<br>Targets表示当前符合过滤规则的页面，显示为none表示没有。我们使用配置好代理的手机打开<a href="https://m.jd.com/%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%8F%91%E7%8E%B0Targets%E4%B8%AD%E5%A4%9A%E4%BA%86%E6%9D%A1%E8%AE%B0%E5%BD%95%EF%BC%9A">https://m.jd.com/，就会发现Targets中多了条记录：</a><br><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/159465/6/668/607563/5fec16acEad4410fc/64a1619cf4cab11a.jpg" alt="weinre"><br>这时候我们点击页面上的Elements、Console等模块，就可以和看到对应的页面的内容了：<br><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/156879/24/3306/2128832/5fec170dE67da5de7/8e75d2736994cac4.jpg" alt="weinre"></p>
<p>在Elements中选中对应的DOM节点，对应的手机端就会和浏览器一样标注出DOM的位置，这对我们查看DOM有没有正确渲染是很有用的：<br><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/159371/15/644/1970789/5fec189dE5b74bea6/9c2e9cc7d43353a6.jpg" alt="weinre"><br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/160851/39/83/1764028/5fec18c6Eee4af1f7/9c35ed315b9e8807.png" alt="weinre"></p>
]]></content>
      <tags>
        <tag>whistle</tag>
      </tags>
  </entry>
  <entry>
    <title>一个进度条优化的例子</title>
    <url>/2021/06/29/%E4%B8%80%E4%B8%AA%E8%BF%9B%E5%BA%A6%E6%9D%A1%E4%BC%98%E5%8C%96%E7%9A%84%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<h2 id="一个进度条优化的例子"><a href="#一个进度条优化的例子" class="headerlink" title="一个进度条优化的例子"></a>一个进度条优化的例子</h2><blockquote>
<p>功能很简单：实现一个类似抖音视频下放的播放进度条, 进度条随着视频的长度而进行增长，视频暂停，进度条的动画也会随之暂停</p>
</blockquote>
<p>接下来看看大部分人是怎么写的，为什么说思路和性能不好。 以react为例<br>主要实现功能：</p>
<ul>
<li>支持播放、暂停、重播</li>
<li>播放结束后，播放次数+1，并重新开始播放</li>
</ul>
<h3 id="不推荐的写法"><a href="#不推荐的写法" class="headerlink" title="不推荐的写法"></a>不推荐的写法</h3><p>组件部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span>  <span class="comment">//  递增进度的定时器</span></span><br><span class="line"><span class="keyword">let</span> totalTime = <span class="number">3000</span>  <span class="comment">// 假设视频播放为3s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [progress, setProgress] = useState(<span class="number">0</span>)  <span class="comment">// 进度</span></span><br><span class="line">    <span class="keyword">const</span> [isPlay, setIsPlay] = useState(<span class="literal">false</span>)  <span class="comment">// 是否播放</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setProgress的递增逻辑</span></span><br><span class="line">    <span class="keyword">const</span> handlerProgress = <span class="function"><span class="params">pre</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre &lt; <span class="number">100</span>) <span class="keyword">return</span> pre + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">          alert(<span class="string">&#x27;播放结束&#x27;</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>   <span class="comment">// 播放结束，重新开始播放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始播放 &amp;&amp; 暂停播放</span></span><br><span class="line">    <span class="keyword">const</span> handleVideo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setIsPlay(!isPlay)</span><br><span class="line">        isPlay</span><br><span class="line">        ? <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">        : timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> setProgress(handlerProgress), totalTime / <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重播</span></span><br><span class="line">    <span class="keyword">const</span> replay = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setIsPlay(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span>(timer) <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        setProgress(<span class="number">0</span>)</span><br><span class="line">        timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> setProgress(handlerProgress), totalTime / <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div id=<span class="string">&quot;root&quot;</span>&gt;</span><br><span class="line">            &lt;button onClick=&#123;handleVideo&#125;&gt;&#123; isPlay ? <span class="string">&#x27;暂停&#x27;</span> : <span class="string">&#x27;播放&#x27;</span> &#125;&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;replay&#125;&gt;重播&lt;/button&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">                &lt;div className=<span class="string">&quot;progress&quot;</span> style=&#123;&#123; <span class="attr">width</span>: <span class="string">`<span class="subst">$&#123;progress&#125;</span>%`</span> &#125;&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>样式部分</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.progress</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果是这个样子的<br><img src= "/img/loading.gif" data-src="%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA.gif" alt="进度条效果演示" title="进度条效果演示"></p>
<blockquote>
<p>为什么说这种写法不太好呢？因为我们是通过定时器来快速递增变量progress以此来实现进度增加的，变量每次改变都会驱动视图重新计算渲染，这必然是性能很差的。（有肉眼可见的小卡顿哦）<br>除此之外呢？其实还有一个造成卡顿的原因，你们不妨猜猜看。</p>
</blockquote>
<h3 id="推荐的写法"><a href="#推荐的写法" class="headerlink" title="推荐的写法"></a>推荐的写法</h3><p>组件部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.jsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> totalTime = <span class="number">3000</span>  <span class="comment">// 假设视频播放为3s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isPlay, setIsPlay] = useState(<span class="literal">false</span>)  <span class="comment">// 是否播放</span></span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)  <span class="comment">// 播放次数</span></span><br><span class="line">    <span class="keyword">const</span> [type, setType] = useState(<span class="number">0</span>)   <span class="comment">// 使用哪个动画。0: @keyframes play; 1: @keyframes replay;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 暂停 &amp;&amp; 播放</span></span><br><span class="line">    <span class="keyword">const</span> handleVideo = <span class="function">() =&gt;</span> setIsPlay(!isPlay);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重播</span></span><br><span class="line">    <span class="keyword">const</span> replay = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setIsPlay(<span class="literal">true</span>)</span><br><span class="line">        setType(type ? <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动画结束时触发的事件</span></span><br><span class="line">    <span class="keyword">const</span> end = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setCount(count + <span class="number">1</span>)  <span class="comment">// 播放次数 +1</span></span><br><span class="line">        replay()   <span class="comment">// 重新开始播放</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div id=<span class="string">&quot;root&quot;</span>&gt;</span><br><span class="line">            &lt;button onClick=&#123;handleVideo&#125;&gt;&#123; isPlay ? <span class="string">&#x27;暂停&#x27;</span> : <span class="string">&#x27;播放&#x27;</span> &#125;&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;replay&#125;&gt;重播&lt;/button&gt;</span><br><span class="line">            &lt;span&gt;&#123; <span class="string">`播放次数为：<span class="subst">$&#123;count&#125;</span>`</span> &#125;&lt;/span&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">                &lt;div </span><br><span class="line">                    className=&#123;<span class="string">`progress <span class="subst">$&#123;isPlay ? <span class="string">&#x27;play&#x27;</span> : <span class="string">&#x27;pause&#x27;</span>&#125;</span>`</span>&#125; </span><br><span class="line">                    style=&#123;&#123;</span><br><span class="line">                        animationDuration: <span class="string">`<span class="subst">$&#123;totalTime&#125;</span>ms`</span>,</span><br><span class="line">                        animationName: <span class="string">`<span class="subst">$&#123;type ? <span class="string">&#x27;replay&#x27;</span> : <span class="string">&#x27;play&#x27;</span>&#125;</span>`</span></span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                    onAnimationEnd=&#123;end&#125;  <span class="comment">// 动画结束时的事件</span></span><br><span class="line">                /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>样式部分</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> play &#123;   </span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> replay &#123;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.progress</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.progress</span><span class="selector-class">.play</span> &#123;     <span class="comment">/* 使animation动画启动 */</span></span><br><span class="line">    <span class="attribute">animation-play-state</span>: running;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.progress</span><span class="selector-class">.pause</span> &#123;    <span class="comment">/* 使animation动画暂停 */</span></span><br><span class="line">    <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们设置了两个@keyframes动画是为了在使进度条重新播放时可以做一个切换，即点击 “重播” 时，直接切换到另一个动画，就可以实现进度条从0开始递增</p>
<p>同时我们还设置了两个类名的样式，分别用于控制动画的播放和暂停</p>
<p>播放完成时，播放次数+1的功能可以通过事件animationend来监听即可</p>
<p>同样的，来看一下这套方案的效果图（跟前一套方案功能一模一样）<br><img src= "/img/loading.gif" data-src="%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA.gif" alt="进度条效果演示" title="进度条效果演示"></p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>第二种方案虽然性能很好，但是与第一种方案一样，存在另外一个隐藏的性能问题 &gt;&gt;&gt;&gt;<br><strong>缺陷：这两种方案都会引发频繁的重排和重绘</strong><br>可以借助chrome devtools performance来验证一下页面的情况<br><img src= "/img/loading.gif" data-src="%E6%80%A7%E8%83%BD1.gif" alt="性能1" title="性能1"></p>
<ul>
<li>小小的一个进度条触发了那么那么多次重排和重绘，那么它到底有什么影响呢？</li>
</ul>
<p>简单回顾一下： <strong>重排与重绘</strong></p>
<ul>
<li><p>重排：浏览器需要重新计算元素的几何属性，而且其他元素的几何属性或位置可能也会因此改变受到影响。</p>
</li>
<li><p>重绘：不是所有的DOM变化都影响元素的几何属性，如果改变元素的背景色并不影响它的宽度和高度，这种情况，只会发生一次重绘，而不会发生重排，因为元素的布局没改变</p>
</li>
</ul>
<p>所以知道了重排和重绘造成的严重问题后，我们马上对其进行分析优化</p>
<h3 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h3><p>先看一个传统的图：<br><img src= "/img/loading.gif" data-src="%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93.webp" alt="页面渲染" title="页面渲染"><br>页面的渲染，大体上走的就是这5个流程。当然也有办法跳过中间某些步骤，例如避免Layout和Paint</p>
<blockquote>
<p>再来回顾一下，引起重排和重绘的操作吧！</p>
</blockquote>
<blockquote>
<p>触发重排的因素：添加或删除可见的DOM元素、改变元素位置、元素的尺寸改变（包括：外边距、内边距、边框、高度等）、内容改变（如：文本改变或图片被另外一个不同尺寸的图片替代）、浏览器窗口尺寸的改变、通过display: none隐藏⼀个DOM节点等</p>
</blockquote>
<blockquote>
<p>触发重绘的因素：重排必定触发重绘（重要）、通过visibility: hidden隐藏⼀个DOM节点、修改元素背景色、修改字体颜色等</p>
</blockquote>
<p>那么我们前面写的代码中到底是哪里触发了重排和重绘呢？简单检查一下，不难发现两种方案都是在不停改变元素的width，元素的宽度一改变必然会引起重排和重绘，更何况是超频繁的改变呢！</p>
<p><strong>解决方案：启用GPU加速，避开重排和重绘的环节，将进度条单独提升到一个图层，即不影响其它元素</strong></p>
<p>针对第二套方案来优化，我们只需要改css即可</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> play &#123;     <span class="comment">/* 通过transform来启用GPU加速，跳过重排重绘阶段 */</span></span><br><span class="line">    <span class="number">0%</span> &#123;  </span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">scaleX</span>(<span class="number">0</span>);  <span class="comment">/* 用 scaleX 来代替 width */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>) <span class="built_in">scaleX</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> replay &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>) <span class="built_in">scaleX</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.progress</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;   <span class="comment">/* 初始宽度为100%，因为我们要对其缩放 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    will-change: transform;   <span class="comment">/* 通过will-change告知浏览器提前做好优化准备 */</span></span><br><span class="line">    <span class="attribute">animation-timing-function</span>: linear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.progress</span><span class="selector-class">.play</span> &#123;    </span><br><span class="line">    <span class="attribute">animation-play-state</span>: running;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.progress</span><span class="selector-class">.pause</span> &#123;   </span><br><span class="line">    <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里简单解释一下translateX和scaleX的数值设置。设置进度条width: 100%，我们通过scaleX(0.5)将其缩放一半，可以发现进度条长度为容器的一半且居中，此时我们就需要通过translateX(-25%)将其向左平移到最左端，为什么是-25%呢？因为进度条占了容器的一半且居中，表明左右的留白正好分别是(100% - 50%) / 2 = 25%，所以也不难得知当初始状态scaleX(0)时，translateX的值为-(100% - 0%) / 2 = -50%</p>
<p>这么做了以后，我们再次用performance检验一下<br><img src= "/img/loading.gif" data-src="%E6%80%A7%E8%83%BD2.gif" alt="性能2" title="性能2"></p>
<p>可以很明显地看到页面重排重绘的次数减少了很多很多，剩余的基本都是页面最基本的重排和重绘了。<br>接下来给你们展示一下到底优化了多少性能<br>先用刚极致优化完的跑一下performance<br><img src= "/img/loading.gif" data-src="%E6%80%A7%E8%83%BD3.webp" alt="性能3" title="性能3"><br>看图中右侧，FPS基本是稳定在55 ~ 70之间<br>再来看看文章开头第一种方案的performance跑分<br><img src= "/img/loading.gif" data-src="%E6%80%A7%E8%83%BD4.webp" alt="性能4" title="性能4"><br>看图中右侧，FPS基本是稳定在32 ~ 50之间</p>
<p>可以很清楚得看到，优化前的FPS波动非常严重，即不够稳定，所以容易出现卡顿问题；而优化后的FPS的变化是不大的，整体变化趋势比较平，几乎是一直线</p>
<p>在这样一个极简页面中，我们优化后性能都大约提升了大约40% ~ 54%</p>
<p>那么如果在正常的项目中，考虑到页面的复杂性，我们优化后的方案既避免了页面反复得计算渲染，又避免了重绘回流，可想而知在那种情形下性能的提升应该是远不止40% ~ 54%的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>启用GPU加速会将元素提升到单独的一个图层中，我们可以通过chrome devtools layers来查看<br><img src= "/img/loading.gif" data-src="%E6%80%BB%E7%BB%931.webp" alt="总结1" title="总结1"></p>
<p>这里就分别展示一下我们优化前和优化后的页面分层情况吧</p>
<p><strong>「优化前」</strong><br><img src= "/img/loading.gif" data-src="%E4%BC%98%E5%8C%96%E5%89%8D.webp" alt="优化前" title="优化前"><br>很明显地看到，整个页面就只有document层，即进度条没有被分层出来</p>
<p><strong>「优化后」</strong><br><img src= "/img/loading.gif" data-src="%E4%BC%98%E5%8C%96%E5%90%8E.webp" alt="优化后" title="优化后"><br>同样也很明显地可以看到，进度条被单独分出来一个图层了</p>
]]></content>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>中台系统设计（二）关于字体</title>
    <url>/2020/09/30/%E4%B8%AD%E5%8F%B0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%832/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>字体是界面设计中最基本的构成之一，是页面中重要的元素。对用户的阅读体验有着至关重要的作用。选择字体是一个具有创造性和情感的过程，因为不同的字体传达出不同的情感，展示不一样的品牌调性。在制定规范时科学的定义字体规范系统，不仅能够有效的表达出不同的设计风格，还能通过定义字体的字型、字阶、字重、字体颜色、字体行高间距，有效帮助设计师在设计界面时使用字体达到统一性和整体性，保证界面有良好的阅读体验。</p>
<p><img src= "/img/loading.gif" data-src="%E5%AD%97%E4%BD%93.jpg" alt="字体"></p>
<h2 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h2><p>以下分别是Sketch、ps、Figma的字符面板，从以下三款流行的设计软件就可以看出字体的一些属性：分别是：字形、字体、字型。</p>
<p><img src= "/img/loading.gif" data-src="%E4%B8%BB%E6%B5%81%E8%AE%BE%E8%AE%A1%E8%BD%AF%E4%BB%B6%E5%AD%97%E7%AC%A6%E9%9D%A2%E6%9D%BF.png" alt="中台系统设计（二）关于字体和按钮"></p>
<ul>
<li>Font 译为：字型，是指字的粗细、宽度和样式，是一套具有同样风格和尺寸的字形。（如：Regular_16pt_SF-UI）</li>
<li>Typeface 译为：字体，是指一整套的字形，一个或多个字型的多尺寸的集合，例如「SF-UI」里有不同粗细（Regular、Blod、Light）和不同宽度（12pt、14pt、20pt）。</li>
<li>Glyph ：译为：字形，是指单个字的形体或是字体的骨骼。 同一字可以有不同的字形，而不影响其表达的意思，例如汉字中的「令」字，第三笔可以是一点或一撇， 最末两笔可以作「ㄗ」或「マ」。</li>
</ul>
<p><strong>Font 和 Typeface 常常被混淆，其实可以这样理解，前者指一种设计，后者指具体的产品。</strong></p>
<p><img src= "/img/loading.gif" data-src="Font%E3%80%81Typeface%E3%80%81Glyph%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="Font、Typeface、Glyph的关系"></p>
<h2 id="系统字体选择"><a href="#系统字体选择" class="headerlink" title="系统字体选择"></a>系统字体选择</h2><p>在选用系统字体时需要考虑在不同系统的兼容性，大家都知道在不同的操作系统及不同的游览器中默认显示的字体是不一样的，并且相同字体在不同操作系统里面渲染的效果也不尽相同。在做字体规范时需要提供一套系统完整的字族，里面不仅需要包含系统默认的界面字体，还需要一套有利于屏幕显示的备用字体，方便维护不同系统及浏览器的实现，保证在任何场景保持良好的阅读性和可读性。</p>
<p><img src= "/img/loading.gif" data-src="%E7%B3%BB%E7%BB%9F%E5%AD%97%E4%BD%93.png" alt="系统字体"></p>
<ul>
<li><p><strong>-apple-system是在以WebKit为内核的浏览器</strong>，比如苹果的Safari中调用苹果系统macOS、iOS、watchOS、tvOS中默认字体，目前一般情况下英文使用的是San Francisco，中文使用的是PingFang。<strong>BlinkMacSystemFont是在Chrome中调用苹果系统的字体。</strong></p>
</li>
<li><p>Segoe UI针对Windows and Windows Phone等系统。PingFang SC是苹果为中国用户打造了一款全新中文字体，整体样式看上去更加简洁，字族共6个字体：极细体、纤细体、细体、常规体、中黑体、中粗体。Hiragino Sans GB是是Hiragino KakuGothic的简体中文版，有常规体和粗体两种，冬青黑体是一款清新的专业印刷字体，其小字在屏幕显示时足够清晰。Microsoft YaHei是从Vista开始，微软提供了这款新的字体，它是一款无衬线的黑体类字体，并且拥有Regular、Bold两种粗细的字重，字重有效提高了字体的层级显示效果。目前这款字体已经成为Windows游览器中最值得使用的中文字体。从Win8开始，微软雅黑又加入了Light这款更细的字重，对于喜欢细字体的设计或开发人员又多了一个新的选择。</p>
</li>
<li><p><strong>Helvetica Neue、sans-serif主要是系统备用兜底字体。</strong>Helvetica Neue在没有El Capitan versions系统的电脑中是最流行的，所以作为兜底，sans-serif也是常见的兜底字体；</p>
</li>
<li><p> ‘Apple Color Emoji’, ‘Segoe UI Emoji’, ‘Segoe UI Symbol’ 针对在macOS和Windows显示emoji，主要是系统的emoji。</p>
</li>
</ul>
<p>附：在Web设计中使用UI系统字体快读实用指南<a href="https://www.smashingmagazine.com/2015/11/using-system-ui-fonts-practical-guide/">https://www.smashingmagazine.com/2015/11/using-system-ui-fonts-practical-guide/</a></p>
<h2 id="定义字体规范"><a href="#定义字体规范" class="headerlink" title="定义字体规范"></a>定义字体规范</h2><h3 id="字体大小-字号"><a href="#字体大小-字号" class="headerlink" title="字体大小-字号"></a>字体大小-字号</h3><p>字号大小决定了信息的层级和主次关系，合理有序的字号设置能让界面信息清晰易读、层次分明，相反，糟糕无序的字号使用会让界面混乱不堪，影响阅读体验。</p>
<p>我们确定正文字号后，辅助文字信息层级低的内容和标题也就随之确定了。那这个正文字号到底该定义多少呢？参考一些主流的网站，大部分网站的正文都采用了14px的文字大小。也有一些网站是12px的文字大小。对于为什么设置14px大小的文字作为正文文字，蚂蚁金服的Ant Design的设计规范中对此做了说明。Ant Desugn3.0的时候对主字号进行了研究：<strong>基于电脑显示器阅读距离（50 cm）以及最佳阅读角度（0.3）对 Ant Design 的主字体进行了一次升级，从原先的 12 上升至 14，以保证在多数常用显示器上的用户阅读效率最佳。</strong></p>
<p><img src= "/img/loading.gif" data-src="%E6%AD%A3%E6%96%87%E5%AD%97%E4%BD%93.png" alt="正文字体"></p>
<p>我们再说说为什么网页上的字号要定义偶数字号呢？因为Windows自带的点阵宋体从Vista开始只提供12px、14px、16px三个大小的点阵。所以，如果13px、15px、17px虽然每个字的空间大了1px但是点阵却没变，从视觉上会显得略稀疏，可能导致显示效果不佳。所以我们在网页设计时，尽量采用偶数字号作为字体大小。</p>
<h3 id="字阶行高"><a href="#字阶行高" class="headerlink" title="字阶行高"></a>字阶行高</h3><p>字阶和行高决定着一套字体系统的动态和秩序。字阶指的是一系列有规律的不同尺寸的字体，行高可以理解成一个包裹在字体外面的无形的盒子。行高=字号+行间距；</p>
<p><img src= "/img/loading.gif" data-src="%E5%AD%97%E9%98%B6%E5%92%8C%E8%A1%8C%E9%AB%98.png" alt="字阶和行高"></p>
<p><strong>在一个系统设计中（展示型页面除外），建议字阶的选择尽量控制在 3-5 种之间，保持克制的原则。</strong></p>
<p>关于字体的行高，默认是字号的1.5倍。有时候跟我们的品牌调性也会适当缩小和增大行高。</p>
<p><img src= "/img/loading.gif" data-src="%E8%A1%8C%E9%AB%98.png" alt="行高"></p>
<h3 id="字重"><a href="#字重" class="headerlink" title="字重"></a>字重</h3><p>Weight：译为字重，是指字体笔画的粗细，字体中很重要一个概念，不同字重传递出来视觉感受完全不一样。一般在字体家族名后面注名Thin、Light、Regular、Blod、Black、Heavy等。不同的字体设计师划分的字重各有不同，例如「苹方」字体就有6种不同的字重。</p>
<p>轻字重：传递出轻盈放松的视觉感受，常配合粗的字重使用，在一些辅助信息，说明文案时候使用；</p>
<p>重字重：视觉感受庄重，很重要，常用在重点强调的文字，页面大标题，数字，引导行动操作点上等；</p>
<p><strong>字号和字重共同作用下，界面中的信息才能体现出主次关系，信息层次才会明确。</strong></p>
<p>字重的选择同样基于秩序、稳定、克制的原则，多数情况下，只需要出现regular和medium两种情况下，分别对应代码中的 400 和 500 。在英文字体加粗的情况下会采用 semibold 的字体重量，对应代码中的600。</p>
<p><strong>注意仿粗字：</strong>在用PS进行界面设计时，不要用软件自带的文本加粗，它不仅破坏了字体本身的美感，还改变了文字原本的字宽，小字体下会模糊不清，合理的方式是使用字体本身的字重来控制粗细。</p>
<p><strong>注意超细体的字体</strong>：字重超细的字体要谨慎使用。如果你设计的文本是装饰性或者网站品牌调性是需要细体展示的，可以用细体文字，前提也是不能影响文字的阅读。如果是需要用户能清晰阅读的，就要特别慎重。</p>
<h3 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h3><p>文本颜色如果和背景颜色太接近就会难以阅读，且字阶颜色相近就达不到信息层级清晰的效果，且参考ACAG的标准，将正文文本、标题、背景之间保持在7:1以上的对比度。规范如下：</p>
<p><img src= "/img/loading.gif" data-src="%E6%96%87%E5%AD%97%E9%A2%9C%E8%89%B2.png" alt="文字颜色"></p>
<h2 id="常用的选择字体网站"><a href="#常用的选择字体网站" class="headerlink" title="常用的选择字体网站"></a>常用的选择字体网站</h2><h3 id="Adobe-Fonts"><a href="#Adobe-Fonts" class="headerlink" title="Adobe Fonts"></a>Adobe Fonts</h3><p>网址：<a href="https://fonts.adobe.com/">https://fonts.adobe.com/</a></p>
<p>第一个是Adonbe旗下的Adobe Font，该网站的西文字体比较全，而且会有一些推荐的字体包：设计师常用的字体、UX字体包、适合印刷的字体等；可以快速找到想要的字体，而且还可以改变字体大小，实时预览。缺点就是该网站的字体大部分都是要收费的，我们可以通过购买使用喜欢的字体，毕竟这是个知识付费的时代。</p>
<p>![Adobe 字体](Adobe 字体.png)</p>
<h3 id="Google-Fonts"><a href="#Google-Fonts" class="headerlink" title="Google Fonts"></a>Google Fonts</h3><p>网址：<a href="http://www.googlefonts.cn/">http://www.googlefonts.cn/</a></p>
<p>Google Fonts的下载功能非常便捷，我们可以免费下载所有喜欢的字体，Google Fonts包含超过1400种不同的字体，其中包含最著名的：Open Sans和Roboto字体，他们是Android系统使用的默认字体。</p>
<p>![Google Font](Google Font.png)</p>
<h3 id="求字体网"><a href="#求字体网" class="headerlink" title="求字体网"></a>求字体网</h3><p>网址：<a href="http://www.qiuziti.com/fontlist">http://www.qiuziti.com/fontlist</a></p>
<p>设计师在做设计时常常会遇到某些网站或海报使用的字体特别喜欢，但是苦恼无法获取改字体的信息导致无法下载使用，求字体网解决了此痛点。你可以将喜欢的字体进行截图并上传到网站进行字体识别，识别出具体的字体后，会提供出字体下载链接或者字体信息，解决设计师们喜欢某个字体而找不到的烦恼。</p>
<p><img src= "/img/loading.gif" data-src="%E6%B1%82%E5%AD%97%E4%BD%93%E7%BD%91.png" alt="求字体网"></p>
<h3 id="字由-amp-iFonts-字体网站"><a href="#字由-amp-iFonts-字体网站" class="headerlink" title="字由 &amp; iFonts 字体网站"></a>字由 &amp; iFonts 字体网站</h3><p>字由网站：<a href="https://www.hellofont.cn/">https://www.hellofont.cn/</a></p>
<p>iFonts网站：<a href="https://51ifonts.com/clientdown">https://51ifonts.com/clientdown</a></p>
<p>字由 和 iFonts也是比较推荐的两个软件。字由网站将全部字体进行整理分类方便用户快捷寻找字体，并且有个分类是免费商用字体库，避免了设计师因为不清楚字体版权导致版权纠纷问题。此有网站有两大亮点，第一是此网站在设计师选用字体时有个实际运用预览效果，直观的看到字体在实际使用效果，第二是网站提供客户端下载，在客户端中点击下载以后可直接进行在设计工具中直接使用。</p>
<p><img src= "/img/loading.gif" data-src="%E5%AD%97%E4%BD%93%E5%AE%A2%E6%88%B7%E7%AB%AF.png" alt="字体客户端"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>中台系统设计定义规范时：</p>
<ul>
<li>需要有体系化的思路：对于标题文字、次要文字、辅助文字、文字链接等文字类型作统一的定义，在项目在根据实际情况调整我们的设计规范。</li>
<li>避免没有意义的增加各种字号，增加系统的字阶等，减少相近大小的字号设定。</li>
<li>在需要拉开差距的时候可以尝试在字阶中选择差异较大的字体大小，会让字阶之间产生一种微妙的韵律感。</li>
</ul>
<p>参考：<a href="https://ant.design/index-cn">https://ant.design/index-cn</a></p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>规范</tag>
        <tag>中台</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么选择使用TS</title>
    <url>/2021/06/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8TS/</url>
    <content><![CDATA[<h1 id="为什么选择使用TS"><a href="#为什么选择使用TS" class="headerlink" title="为什么选择使用TS"></a>为什么选择使用TS</h1><p>一个非常有争议性的观点：由于 TypeScript 具有更强的可扩展性 并且 可以带给开发者更好的体验，开发者应该更愿意选择 TypeScript 而不是 JavaScript。</p>
<p><strong>开发者回避使用 TypeScript 的三个借口</strong></p>
<ol>
<li>它让 JavaScript 更像 Java 和 .NET</li>
</ol>
<p>优秀的 JavaScript 开发者会提醒你避免使用 OOP 的风格。太多开发者一上来就写个class的原因通常是因为 他/她 是从OOP背景过来的 —— 在Java，你不能光秃秃地定义一个常量，一个函数或者一个表达式，你得先有个类，然后在类里定义一个静态不可变的属性 （public static final 三连） 才能产生一个常量，类似的，也只能在类里定义一个（静态或者非静态）的方法才能让函数有容身之地<br><a href="https://zhuanlan.zhihu.com/p/158956514">在大部分场景下不鼓励使用JavaScript class</a></p>
<blockquote>
<p>问题的关键是：TypeScript 不会改变 JavaScript，它只是被加到 JavaScript 中。</p>
</blockquote>
<ol start="2">
<li>它使代码变得不必要的冗长/复杂</li>
</ol>
<p>TypeScript 意味着更多的代码，但这些东西是元数据ーー它有助于描述你正在操纵的数据，从而降低了整体的认知成本。</p>
<blockquote>
<p>TypeScript 通过减少记忆成本和消除打开不相关的文件手动检查类型 来提高开发速度。</p>
</blockquote>
<ol start="3">
<li>脚本不需要类型，应用程序需要</li>
</ol>
<p>如果你想创建一个使用鼠标拖动 div 的程序，那么你只需要编写一个小型的 JS 脚本。添加类型是没有意义的。在编写大多数脚本时（就用途而言，简单的程序调用内置方法并处理很少的数据），JavaScript 通常就足够了，添加类型会不必要地增加冗长性。</p>
<blockquote>
<p>对于较大的应用程序,TypeScript 允许我们描述数据结构，而不必记住或手动查阅它们。我们的 IDE 和编译器可以捕获我们所犯的任何错误</p>
</blockquote>
<p><strong>TS是谁写给谁看/用的？</strong></p>
<p>TS是定义者给使用者写的。为了让使用者更方便（VSCode提示）以及更安全（约束）的使用他提供的方法或者类。</p>
<ol>
<li>VSCode提示</li>
</ol>
<p>定义者指定了一个方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name: string</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么作为使用者可以通过VSCode准确了解到该函数的参数和返回值</p>
<p><img src= "/img/loading.gif" data-src="./assets/vscode.webp"></p>
<ol start="2">
<li>巧用注释</li>
</ol>
<p>为了更完美的展示提示信息，我们还可以添加注释</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** foo function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>count string size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name: string</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时使用者会看到</p>
<p><img src= "/img/loading.gif" data-src="./assets/640.webp"></p>
<ol start="3">
<li>类型推断</li>
</ol>
<p>TypeScript 强大的静态类型检查系统的一个基本特性是 类型推断。根据每个变量的初始值，重新赋值 或 依赖关系，TypeScript 可以推导出每个变量可赋的最具体的类型。</p>
<p>让我们假设我们有 users，一个 User 对象数组，然后我们可以取出一个有特定 ID 的用户：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = users.find(<span class="function"><span class="params">u</span> =&gt;</span> u.id === <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>因为用户是 User[] 类型的，并且基于 Array.find() 的函数签名，所以 TypeScript 知道 user 会是 User 类型。因此，为它定义类型是多余的：</p>
<blockquote>
<p>值得注意的一点，如果项目路径配置了别名，那么可能引入的方法没有正确提示，此时只需要在tsconfig.json这里的compilerOptions选项添加一个paths配置</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;paths&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;@/*&quot;</span>: [<span class="string">&quot;src/*&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例展示TypeScript是多么的有用</strong></p>
<ol>
<li>Vue: 难以理解的 “payload”</li>
</ol>
<p>VueX 为 Vue 应用程序提供了一个中央状态，帮开发者避免在组件之间杂乱的传递 props。</p>
<p>为了修改存储的状态，我们定义了一个变异函数，该函数接受两个参数: 当前的 state 和一个包含更改信息的 payload。</p>
<p>假设我们希望保持用 JavaScript 对象表示的待办事项的中心状态。我们可以使用空数组初始化状态，如下所示:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">  todos: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以定义一个 mutation，使我们能够更新这个待办事项列表：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateTodos: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> &#123;</span><br><span class="line">  state.todos = payload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这足够简单了。但是我们必须从另一个模块中调用这个 mutation，比如一个组件。如果没有明确的类型，我们就需要猜测（或者回忆） updatetodo 需要一个 Todo 对象列表。这不是件好事。</p>
<p>事情不止于此。假设另一个开发人员加入了我们的团队，我们要求他们修改 updateTodos这个 mutation，以便它也更新状态的另一部分，比如一个跟踪已完成的待办事项数量的变量（由 someTodo.isComplete 得到）。</p>
<p>要做到这一点，开发人员必须首先确定 payload 的类型，包括以下步骤：</p>
<p>开发者必须假定当前版本的 updateTodos 是正确的（即 payload 和 state.todos是相同类型）</p>
<p>开发者必须一路滚动到初始化状态对象的代码位置，以检查 todos 的类型（或者，如果 updateTodos 已经被调用，在代码中搜索调用的位置）。</p>
<p>开发者必须确定每个 to-do 对象的结构，才能确定它是已经被完成了。</p>
<p>在这一切结束之后，由于一路上所做的所有假设，开发者除了测试一下，没有其他方法来检查解决方案的正确性。</p>
<p>通过定义 Todo 类型并将 payload 的类型指定为 Todo[] ，我们就解决了所有这些问题。</p>
<p>毫无疑问，至少在这种情况下，TypeScript 为开发团队提供了一个有重大价值的优势，提高准确性、减少开发者的头痛、加快开发速度并且降低类似 bug 的发生几率。</p>
<ol start="2">
<li>为 JSON 响应 添加类型</li>
</ol>
<p>许多 JavaScript 应用程序会向远程 API 发出网络请求来获取数据。通常，在使用这些 API 时，我们会在开发时了解期望收到的响应的结构。</p>
<p>例如，假设我们正在从后端获取数据。我们的后端团队编写了全面的文档，详细描述了每个请求和响应对象的结构。</p>
<p>文档提到，每个响应都有以下结构:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;success&quot;</span> or <span class="string">&quot;failure&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可以生成如下的 TypeScript 数据定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface ApiResponse &#123;</span><br><span class="line">  status: <span class="string">&quot;success&quot;</span> | <span class="string">&quot;failure&quot;</span>;</span><br><span class="line">  data: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以参数化 ApiResponse 来指定它的数据字段的类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface ApiResponse&lt;T&gt; &#123;</span><br><span class="line">  status: <span class="string">&quot;success&quot;</span> | <span class="string">&quot;failure&quot;</span>;</span><br><span class="line">  data: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们的 API 方法在返回类型方面可以更加具体:：例如，我们可以返回一个ApiResponse&lt;User[]&gt; 表示用户列表，而不是仅仅返回一个 ApiResponse。</p>
<p>让我们来看看这是如何提高开发速度的。假设你有一个从后端获取用户列表的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">ApiResponse</span>&lt;<span class="title">User</span>[]&gt;&gt; </span>&#123; </span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在组件中使用它来获取用户信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> getUsers();</span><br></pre></td></tr></table></figure>

<p>然后我们映射用户信息得到他们的姓名:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userNames = users.map(<span class="function"><span class="params">u</span> =&gt;</span> u.name);</span><br></pre></td></tr></table></figure>

<p>对吧？</p>
<p>错。你发现错误了吗？可能没有，但静态类型检查会。我们忘记了响应包含我们 首先需要处理的 success 和 data 字段。多亏了 TypeScript，我们的 IDE 可以立即捕捉到这个错误。</p>
<p>对于新手 JavaScript 开发者来说，处理 API 响应是一个常见的 “问题”。</p>
<p>随着 JavaScript 经验的提升，你将养成每次都手动检查 API 客户端响应类型的习惯。但 TypeScript 帮你做了这些事之后，难道你还需要要为这些问题烦心吗？它不仅节省时间，还能防止疏忽引发的问题。</p>
<p>现在想象一下，你正在从一个体育 API 中获取数据。你使用 /upcoming 拉取即将开始的体育比赛数据。API 文档提供了以下响应结构：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="number">247283</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;New York Knicks at Atlanta Hawks&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2021-05-23T02:00:00+00:00&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;competitors&quot;</span>: [<span class="string">&quot;New York Knicks&quot;</span>, <span class="string">&quot;Atlanta Hawks&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;venue&quot;</span>: <span class="string">&quot;Madison Square Garden&quot;</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不使用 TypeScript，你将不得不频繁参考文档来了解响应中的字段及其类型。如果多个团队成员正在处理这段代码，那么你必须与您的团队共享这些文档。</p>
<p>这意味着更多的时间，更多的努力，更大的犯错几率。出现越来越多的坏事，情况越来越糟。</p>
<p>但是使用 TypeScript，只需添加一个类型定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface SportsApiResponse &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  name: string;</span><br><span class="line">  date: string;</span><br><span class="line">  competitors: [string, string];</span><br><span class="line">  venue: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，任何时候你使用 SportsApiResponse，你都会准确地知道哪些字段可用以及它们的类型。这样可以节省大量的时间，并最大限度地减少字段名拼写错误或将字符串错当成数字的可能性。</p>
<p><strong>参考</strong><br><a href="https://juejin.cn/post/6953500339425247246">为什么要用那么复杂的TS</a><br><a href="https://zhuanlan.zhihu.com/p/158956514">应该在JavaScript中使用Class吗？</a><br><a href="https://betterprogramming.pub/the-bad-reasons-people-avoid-typescript-and-the-better-reasons-why-they-shouldnt-86f8d98534de">应当使用 TypeScript 的更有说服力的原因</a></p>
]]></content>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title>京东小程序-爬坑路-一</title>
    <url>/2020/10/13/%E4%BA%AC%E4%B8%9C%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%88%AC%E5%9D%91%E8%B7%AF-%E4%B8%80/</url>
    <content><![CDATA[<h3 id="京东小程序开发经验谈-一"><a href="#京东小程序开发经验谈-一" class="headerlink" title="京东小程序开发经验谈-一"></a>京东小程序开发经验谈-一</h3><p>简介：</p>
<p>京麦小程序基于京东小程序，京东小程序又基于微信小程序。他们的关系（此处指功能）；微信小程序&gt;京东小程序&gt;京麦小程序。<br>京麦小程序支持的，京东小程序肯定支持，但是反过来，京东小程序支持的，京麦就不一定支持了，这也是我做京麦时参考京东小程序文档踩过的坑，都是心酸泪，因为京麦没有使用文档都是参考京东小程序文档，分享的问题适用于京东小程序和京麦小程序。<br>下面我就我做的-拍卖管理（京麦小程序）遇到的问题，和大家分享一下，如有错误之处，望指正。</p>
<h3 id="新开Webview与H5"><a href="#新开Webview与H5" class="headerlink" title="新开Webview与H5"></a>新开Webview与H5</h3><ul>
<li>1.使用时地址参数一定要转义，否则丢失参数；</li>
<li>2.小程序新开webview页面播放视频会有问题，部分手机不兼容，使用jd.openJMWebView方法，打开H5页面；</li>
</ul>
<h3 id="网络请求POST"><a href="#网络请求POST" class="headerlink" title="网络请求POST"></a>网络请求POST</h3><ul>
<li>1.网络请求post需要content-type设置成application/json；</li>
<li>2.需要后端做处理才能按照正常的post请求返回结果，否则会返回空；</li>
</ul>
<h3 id="Rich-text富文本转义"><a href="#Rich-text富文本转义" class="headerlink" title="Rich-text富文本转义"></a>Rich-text富文本转义</h3><ul>
<li>1.富文本目前没有文档支持，参考微信小程序试用，div\span\img标签试用没有问题，但是也有很多不支持。具体需要一个个尝试；</li>
</ul>
<h3 id="登录态问题"><a href="#登录态问题" class="headerlink" title="登录态问题"></a>登录态问题</h3><ul>
<li>1.登录态总是会掉，需要匹配出具体接口返回值，给出提示，目前没有登录页面供再次登录，只能重新进入；</li>
<li>2.小程序新开webview页面播放视频会有问题，部分手机不兼容，使用jd.openJMWebView方法，打开H5页面；</li>
</ul>
<h3 id="navigitative"><a href="#navigitative" class="headerlink" title="navigitative"></a>navigitative</h3><ul>
<li>1.如果自定义的头部，在页面中再次定义头部时，不生效</li>
</ul>
<h3 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h3><ul>
<li>1.使用jd.storage时，如果没有设置key而直接读取key时会报错，需要做容错处理，或者在页面开始就附一个初始值；</li>
</ul>
<h3 id="IOS省略行样式问题"><a href="#IOS省略行样式问题" class="headerlink" title="IOS省略行样式问题"></a>IOS省略行样式问题</h3><ul>
<li>1.做一行超出隐藏时，需要设置text的display属性为block，不可以为inline-block,否则IOS不生效，安卓可以；</li>
</ul>
<h3 id="关于埋点"><a href="#关于埋点" class="headerlink" title="关于埋点"></a>关于埋点</h3><ul>
<li>1.埋点需要引入京东已经封装好的js,然后调用js暴露的方法即可，可以分为手动埋点和自动埋点。具体参考文档；</li>
<li>2.<a href="https://mp.jd.com/docs/dev/API/interface/openMiniProgram0.html">京麦小程序埋点</a></li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>开始使用版本为京麦5.6.0，当前问题也是在此版本基础上，如果后续京麦有升级，可能会避免部分问题，此分享仅供5.6.0版本参考，后续版本可自己尝试</p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>京东小程序-爬坑路-二</title>
    <url>/2020/10/13/%E4%BA%AC%E4%B8%9C%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%88%AC%E5%9D%91%E8%B7%AF-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="京东小程序开发经验谈-二"><a href="#京东小程序开发经验谈-二" class="headerlink" title="京东小程序开发经验谈-二"></a>京东小程序开发经验谈-二</h3><p>简介：</p>
<p>京麦小程序基于京东小程序，京东小程序又基于微信小程序。他们的关系（此处指功能）；微信小程序&gt;京东小程序&gt;京麦小程序。<br>京麦小程序支持的，京东小程序肯定支持，但是反过来，京东小程序支持的，京麦就不一定支持了，这也是我做京麦时参考京东小程序文档踩过的坑，都是心酸泪，因为京麦没有使用文档都是参考京东小程序文档，分享的问题适用于京东小程序和京麦小程序。<br>继经验一后续开发继续经验总结，现在做如下汇总。</p>
<h3 id="picker组件-三级联动（使用禁忌）"><a href="#picker组件-三级联动（使用禁忌）" class="headerlink" title="picker组件-三级联动（使用禁忌）"></a>picker组件-三级联动（使用禁忌）</h3><ul>
<li>1.picker三级联动时，它的父元素，包括它本身，都不可以使用jd:if=某变量来动态的控制它的显示和隐藏，因为这会导致切换二级时，三级不跟随联动，其原因是绑定的column-change事件不生效，组件在动态渲染时不支持绑定函数，这个结果被京麦组件的同事认证，且微信小程序有相同的问题，动态渲染的组件不支持绑定事件函数，这个我不是很能理解，但是事实就是切换不生效；</li>
<li>2.如果有需要就是要动态渲染，可以找别的方法来隐藏它，幸好，我的需要不需要去动态渲染；</li>
</ul>
<h3 id="picker及checkbox组件value值属性不可更改"><a href="#picker及checkbox组件value值属性不可更改" class="headerlink" title="picker及checkbox组件value值属性不可更改"></a>picker及checkbox组件value值属性不可更改</h3><ul>
<li>1.我们在做单项选择picker时，使用场景是将选中的选项记录在一个公共变量里面，然后使用它，等到接口返回这个变量时，我们绑定到picker的value值上面。此时，绑定的值一定要和之前的picker渲染的值类型保持一致，如果表单提交需要修改选中值的类型，就在提交时做统一格式化处理，接口返回时也要再处理回来，否则绑定会不生效，此时picker会默认第一个选项，而不是已经选择的选项。</li>
</ul>
<h3 id="img标签及背景图的使用问题"><a href="#img标签及背景图的使用问题" class="headerlink" title="img标签及背景图的使用问题"></a>img标签及背景图的使用问题</h3><ul>
<li>1.image标签不支持gif图片地址，同时IOS小程序里面不支持http的链接地址，图片会不显示。</li>
<li>2.css背景图不可以使用相对路径（IOS），需要替换成https的链接</li>
</ul>
<h3 id="图片上传问题"><a href="#图片上传问题" class="headerlink" title="图片上传问题"></a>图片上传问题</h3><ul>
<li>1.不要相信模拟器效果，要在真机上调试。模拟器选择图片返回base64地址，真机却不是。</li>
<li>2.京麦小程序会抽取相册本地地址，返回本地链接，生成链接为jdfile://*.png *为数字和字母的随机串，且，不论图片是Gif、png、jpg何种格式，生成链接都是.png后缀，因此不可以用生成链接判断是何种类型。</li>
<li>3.安卓上传图片经过压缩处理，很快。但是选择多张时不同手机有不同问题，选择9张，总是显示3张成功，考虑不支持同时压缩多张照片。</li>
<li>4.IOS可以选择9张照片，但是IOS上传图片会很慢，可能没有压缩的原因，点击原图和不点击原图都没有区别。同时，IOS如果图片没有在本地而在云端，会获取地址失败而无法上传</li>
</ul>
<h3 id="Scroll-view标签问题"><a href="#Scroll-view标签问题" class="headerlink" title="Scroll-view标签问题"></a>Scroll-view标签问题</h3><ul>
<li>1.不要相信模拟器的效果，要在真机上试试，scroll-view在使用X方向的滚动时，模拟器就没有效果，不能实现滚动，真机可以</li>
</ul>
<h3 id="原生组件问题"><a href="#原生组件问题" class="headerlink" title="原生组件问题"></a>原生组件问题</h3><ul>
<li>1.Textarea标签不可以放在scroll-view里面，会导致文本框固定定位的bug,一直在页面中间位置。</li>
<li>2.Textarea不可以使用fixed定位，如果使用需要给它增加特殊属性。</li>
<li>3.高版本的安卓或者IOS对于textarea的auto-foucs不生效</li>
<li>4.Textarea是原生组件，高于任何层级，因此，如果页面有点击蒙层，或者confirm等浮层出现，textarea都会在它们之上，无法避免，提供的cover-view组件也不好用，使用限制更多。所以，页面有蒙层谨慎使用原生组件</li>
<li>5.关于原生组件层级问题，微信小程序也有，避免方法五花八门，我使用的textarea就是在页面的时候将其隐藏，用一个div占位，掩人耳目，等到点击div时，去触发textarea的显示。不用时将其隐藏，避免其他蒙层出现时textarea在其上悬浮。</li>
<li>6.Video、canvas等原生组件也有层级最高问题，目前没有解决</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>开始使用版本为京麦5.6.0，当前问题也是在此版本基础上，如果后续京麦有升级，可能会避免部分问题，此分享仅供5.6.0版本参考，后续版本可自己尝试</p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>京东小程序上手</title>
    <url>/2020/06/19/%E4%BA%AC%E4%B8%9C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<h3 id="京东小程序上手"><a href="#京东小程序上手" class="headerlink" title="京东小程序上手"></a>京东小程序上手</h3><p>官网：<a href="https://mp.jd.com/">https://mp.jd.com</a></p>
<p>简介：</p>
<ul>
<li>京东小程序 是一种全新的开放模式，可以被便捷地获取和传播。它令终端用户获取更好的使用体验，为商家实现线上线下的交易闭环，给开发者提供一种快速开发方式。</li>
<li>京东小程序只需一次开发即可运行在京东 APP、京东金融 APP、京麦 APP 三端。京东 APP、京东金融 APP 会开放特定的能力，对优质小程序还会开放多个高流量入口，包含扫码、搜索、消息等多种方式触达。而京麦 APP 小程序主要用于商家工具插件的开发定制。<br>&emsp;&emsp;<img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/107303/25/14976/412607/5eaa4a5eE2f1e3361/7d683f2da11a6589.png"></li>
</ul>
<h3 id="体验京东小程序"><a href="#体验京东小程序" class="headerlink" title="体验京东小程序"></a>体验京东小程序</h3><p>京东小程序开发平台为开发者提供快捷API、及组件预览工具，可在项目开始前对京东小程序开发进行了解。</p>
<ul>
<li>使用京东APP扫描下方小程序码可以预览该 Demo</li>
</ul>
<p>&emsp;&emsp;<img src= "/img/loading.gif" data-src="https://img30.360buyimg.com/jos/s200x200_jfs/t1/67027/16/10678/172663/5d81cf50E90cfad52/e47514f2ffd7aeac.jpg"></p>
<ul>
<li>使用京麦APP扫描下方小程序码可以预览该 Demo</li>
</ul>
<p>&emsp;&emsp;<img src= "/img/loading.gif" data-src="https://img30.360buyimg.com/jos/s200x200_jfs/t1/69950/29/10582/253200/5d80d0a7Ee67af940/f87d7b1208040c86.png"></p>
<ul>
<li>使用京东金融APP扫描下方小程序码可以预览该 Demo</li>
</ul>
<p>&emsp;&emsp;<img src= "/img/loading.gif" data-src="https://img30.360buyimg.com/jos/s200x200_jfs/t1/52275/30/11065/236344/5d81cfc4E9506400b/f5f2e1b323428b15.png"></p>
<h3 id="开发者内测申请"><a href="#开发者内测申请" class="headerlink" title="开发者内测申请"></a>开发者内测申请</h3><p>京东小程序采用京东 pin 登录，初次登录京东小程序平台需要填写邀请码，若无邀请码可点击下方获取邀请码申请。</p>
<p>邀请码通过验证之后，需要按照入驻指引进行详细的主体信息登记，完善身份信息。</p>
<p>审核通过后，可以进入京东小程序控制台，创建小程序。</p>
<h3 id="开发前准备工作"><a href="#开发前准备工作" class="headerlink" title="开发前准备工作"></a>开发前准备工作</h3><ul>
<li><a href="https://mp.jd.com/">创建京东小程序</a></li>
</ul>
<p>进入京东小程序平台，创建京东小程序，一个账号下最多可以创建10个京东小程序。小程序创建成功后，可在我的小程序页查看小程序的AppID，AppID是小程序的唯一标识。</p>
<ul>
<li>安装京东小程序开发者工具</li>
</ul>
<p>京东小程序开发者工具是类似与微信开发者工具的IDE，方便预览和调试京东小程序。新建项目时需要填写AppID。</p>
<ul>
<li><a href="https://mp.jd.com/docs/design/">设计规范</a></li>
</ul>
<p>京东小程序有自己一套关于颜色字体、图片&amp;图标等的设计规范。</p>
<ul>
<li><a href="https://mp.jd.com/docs/dev/">开发指南</a></li>
</ul>
<p>在正式开发之前，需要了解京东小程序的框架、组件、API及相关工具。其中框架和组件与微信小程序类似，如果有过微信小程序的开发经验，可以轻松上手。同时提供丰富的京东原生API，可以方便的调起京东提供的能力，如获取用户信息，本地存储，支付功能等。</p>
<h3 id="开发京东小程序"><a href="#开发京东小程序" class="headerlink" title="开发京东小程序"></a><a href="https://mp.jd.com/docs/dev/">开发京东小程序</a></h3><p>打开京东小程序开发者工具，新建项目，填写AppID等。生成项目的目录结构与微信小程序类似。</p>
<p>一个完整的小程序源码包含app.json、app.js、以及各个页面组成。</p>
<p>app.json、app.js，必须放在项目的根目录，如下：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>app.js</td>
<td>是</td>
<td>小程序主逻辑文件</td>
</tr>
<tr>
<td>app.json</td>
<td>是</td>
<td>小程序全局公共配置</td>
</tr>
<tr>
<td>app.jxss</td>
<td>否</td>
<td>小程序全局公共样式表，作用于每个页面</td>
</tr>
</tbody></table>
<p>单个小程序页面由如下四个文件组成：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>js</td>
<td>是</td>
<td>页面逻辑</td>
</tr>
<tr>
<td>jxml</td>
<td>是</td>
<td>页面结构</td>
</tr>
<tr>
<td>json</td>
<td>否</td>
<td>页面配置</td>
</tr>
<tr>
<td>jxss</td>
<td>否</td>
<td>页面样式表</td>
</tr>
</tbody></table>
<p><strong>注意：为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名</strong></p>
<p>下面是一个小程序的文件结构示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── app.js</span><br><span class="line">├── app.json</span><br><span class="line">├── app.jxss</span><br><span class="line">└── pages</span><br><span class="line">    │── index</span><br><span class="line">    │   ├—— index.jxml</span><br><span class="line">    │   ├── index.js</span><br><span class="line">    │   ├── index.json</span><br><span class="line">    │   └── index.jxss</span><br><span class="line">    └── detail</span><br><span class="line">        ├── detail.jxml</span><br><span class="line">        └── detail.js</span><br></pre></td></tr></table></figure>

<p>为了体验京东小程序开发，我用京东小程序开发了一个简单版的辅助服务频道页。</p>
<ul>
<li>h5: <a href="https://fzfw.m.jd.com/">https://fzfw.m.jd.com/</a></li>
</ul>
<p>&emsp;&emsp;<img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/s200x200_jfs/t1/115234/37/5178/9125/5eb260b3E31b296ba/8ea68b50dcaacef7.png"></p>
<ul>
<li>京东小程序：openapp.jdmobile://virtual?params={ “category”: “jump”,”des”: “vapp”,”appId”:”aof243422f121024a1”, “vapptype”: “2”}</li>
</ul>
<p>&emsp;&emsp;<img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/s200x200_jfs/t1/111155/18/5271/113448/5eb26107E990a41ec/4f0fa893d3a6ceac.jpg"></p>
<h3 id="开发过程中遇到的问题"><a href="#开发过程中遇到的问题" class="headerlink" title="开发过程中遇到的问题"></a>开发过程中遇到的问题</h3><ul>
<li>1.修改代码不会自动重启小程序；</li>
<li>2.添加新模块需要重启开发者工具；</li>
<li>3.图片url省略协议（开头为//）时，真机调试会转为单个/开头，导致无法显示图片；</li>
<li>4.无法真机调试；</li>
<li>5.有时无法查看页面元素；</li>
<li>6.网络请求中无法查看图片相关请求;</li>
<li>7.新建page不方便;</li>
<li>8.开发者工具中无法显示webview的内容。</li>
</ul>
<h3 id="开放能力"><a href="#开放能力" class="headerlink" title="开放能力"></a><a href="https://mp.jd.com/docs/dev/API/interface/ability.html">开放能力</a></h3><p>京东小程序将营销、交易、支付、会员等各项业务能力以接口的形式开放给开发者，以满足开发者的业务诉求，同时减轻开发者的工作量</p>
<p>目前京东能力中心为开发者提供了如下能力：</p>
<ul>
<li>登录：用户授权登录后，开发者可以获得用户的唯一标识</li>
<li>手机号授权：在获得用户授权后，且在充分保护用户隐私的前提下，获取用户手机号</li>
<li>用户信息：开发者可以在获得用户授权的前提下获得用户的相关的信息</li>
<li>分享：用户可以便捷的分享小程序给微信好友，或分享至朋友圈</li>
<li>关注：将关注按钮移至顶部导航栏，方便用户更便捷的进行关注操作</li>
<li>支付能力：唤起京东支付组件，用户确认收款方和金额后选择支付方式</li>
<li>会员能力：与京东PLUS能力深度结合</li>
<li>账号信息：获取当前小程序信息</li>
<li>跳转：<ul>
<li>小程序跳转小程序</li>
<li>小程序跳转至宿主APP页面</li>
</ul>
</li>
<li>唤起：<ul>
<li>APP内唤起小程序</li>
<li>APP外唤起小程序</li>
</ul>
</li>
<li>位置：通过用户授权获取用户当前地理位置信息</li>
<li>二维码<ul>
<li>标准二维码：开发者可以生成标准二维码，用户通过京东app扫描标准二维码，即可打开相关小程序</li>
<li>多码合一：开发者可以将现有二维码和小程序进行绑定。当用户使用京东app扫码时，可以打开相关小程序</li>
</ul>
</li>
<li>设置<ul>
<li>在小程序设置页里控制授权状态</li>
<li>获取用户当前设置</li>
</ul>
</li>
</ul>
<h3 id="跳转与唤起"><a href="#跳转与唤起" class="headerlink" title="跳转与唤起"></a>跳转与唤起</h3><h4 id="小程序跳转小程序"><a href="#小程序跳转小程序" class="headerlink" title="小程序跳转小程序"></a><a href="https://mp.jd.com/docs/dev/API/interface/openMiniProgram0.html">小程序跳转小程序</a></h4><p>当开发者拥有多个小程序时，可以通过小程序间互相跳转，完善小程序生态。</p>
<ul>
<li><p>打开指定的小程序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jd.navigateToMiniProgram(&#123;</span><br><span class="line">  appId: <span class="string">&#x27;&#x27;</span>,                             <span class="comment">// 要打开的小程序 appId</span></span><br><span class="line">  path: <span class="string">&#x27;pages/my/my?from=detail&#x27;</span>,       <span class="comment">// 打开的页面路径，如果为空则打开首页</span></span><br><span class="line">  extraData: &#123;                           <span class="comment">// 传递的数据，目标小程序可在 App.onLaunch()，App.onShow() 中获取到传递的数据</span></span><br><span class="line">    foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  envVersion: <span class="string">&#x27;release&#x27;</span>,                 <span class="comment">// 要打开的小程序版本，包括：开发版、体验版、正式版，仅在当前小程序为开发版或体验版时此参数有效；如果当前小程序是正式版，则打开的小程序必定是正式版。</span></span><br><span class="line">  <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;&#125;,                       <span class="comment">// 调用成功的回调函数</span></span><br><span class="line">  <span class="function"><span class="title">fail</span>(<span class="params">err</span>)</span> &#123;&#125;,                          <span class="comment">// 调用失败的回调函数</span></span><br><span class="line">  <span class="function"><span class="title">complete</span>(<span class="params"></span>)</span> &#123;&#125;                          <span class="comment">// 调用结束的回调函数（调用成功、失败都会执行）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>返回到上一个小程序：只有在当前小程序是被其他小程序打开时可以调用成功</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jd.navigateBackMiniProgram(&#123;</span><br><span class="line">  extraData: &#123;                           <span class="comment">// 传递的数据，目标小程序可在 App.onLaunch()，App.onShow() 中获取到传递的数据</span></span><br><span class="line">    name: <span class="string">&#x27;cortana&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;&#125;,                       <span class="comment">// 调用成功的回调</span></span><br><span class="line">  <span class="function"><span class="title">fail</span>(<span class="params">err</span>)</span> &#123;&#125;,                          <span class="comment">// 调用失败的回调函数</span></span><br><span class="line">  <span class="function"><span class="title">complete</span>(<span class="params"></span>)</span> &#123;&#125;                          <span class="comment">// 调用结束的回调函数（调用成功、失败都会执行）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="小程序跳转到宿主页面"><a href="#小程序跳转到宿主页面" class="headerlink" title="小程序跳转到宿主页面"></a><a href="https://mp.jd.com/docs/dev/API/interface/toNative.html">小程序跳转到宿主页面</a></h4><p>京东小程序支持跳转到宿主app原生页面、H5页面。</p>
<ul>
<li>不支持跳转到宿主外部和打开外部APP</li>
<li>需要提前知道要跳转到的目标页面的openapp协议或route协议地址</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jd.navigateToNative(&#123;</span><br><span class="line">  dataParam: &#123;                            <span class="comment">// 跳转的参数</span></span><br><span class="line">    url: <span class="string">&#x27;openapp.jdmobile://virtual&#x27;</span>,    <span class="comment">// 目标页面的openapp协议地址，目前仅支持openapp协议和route协议</span></span><br><span class="line">    params: &#123;                             <span class="comment">// 携带的自定义参数，key value 格式</span></span><br><span class="line">        category:<span class="string">&quot;jump&quot;</span>,</span><br><span class="line">        des:<span class="string">&quot;jdmpCenter&quot;</span>,</span><br><span class="line">        param:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;&#125;,                        <span class="comment">// 调用成功的回调函数</span></span><br><span class="line">  <span class="function"><span class="title">fail</span>(<span class="params">err</span>)</span> &#123;&#125;,                           <span class="comment">// 调用失败的回调函数</span></span><br><span class="line">  <span class="function"><span class="title">complete</span>(<span class="params"></span>)</span> &#123;&#125;                           <span class="comment">// 调用结束的回调函数（调用成功、失败都会执行）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="宿主app内的H5页面打开指定的小程序"><a href="#宿主app内的H5页面打开指定的小程序" class="headerlink" title="宿主app内的H5页面打开指定的小程序"></a><a href="https://mp.jd.com/docs/dev/API/interface/openMiniProgram.html">宿主app内的H5页面打开指定的小程序</a></h4><p>宿主app内的原生页面和h5页面，都可以直接通过openapp协议的地址来打开指定的小程序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.localtion.href = <span class="string">`openapp.jdmobile://virtual?params=&#123;&quot;category&quot;:&quot;jump&quot;,&quot;des&quot;:&quot;jdmp&quot;,&quot;appId&quot;:&quot;aoxxxxxxxx&quot;,&quot;vapptype&quot;:&quot;1&quot;,&quot;path&quot;:&quot;page/index/index&quot;,&quot;param&quot;:&#123;&quot;xx&quot;:&quot;xxxx&quot;,&quot;xx&quot;:&quot;xxx&quot;&#125;&#125;`</span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>appId</td>
<td>string</td>
<td>是</td>
<td>要打开的小程序的原始id，可从小程序控制台获取</td>
</tr>
<tr>
<td>vapptype</td>
<td>string</td>
<td>是</td>
<td>打开的小程序的类型，1 对应线上正式小程序 2 体验版小程序 3 真机调试（暂未开放）</td>
</tr>
<tr>
<td>path</td>
<td>string</td>
<td>是</td>
<td>要打开的小程序的某个页面，空的时候，默认打开小程序首页</td>
</tr>
<tr>
<td>param</td>
<td>string</td>
<td>是</td>
<td>自定义字段，{} 里面可以自由配置key，value，这些key值，可在小程序onLaunch的生命周期回调中获取</td>
</tr>
</tbody></table>
<h4 id="宿主app内的原生页面打开指定的小程序"><a href="#宿主app内的原生页面打开指定的小程序" class="headerlink" title="宿主app内的原生页面打开指定的小程序"></a><a href="https://mp.jd.com/docs/dev/API/interface/openMiniProgram.html">宿主app内的原生页面打开指定的小程序</a></h4><p>与h5打开页面类似，直接通过openapp协议的地址来打开指定的小程序</p>
<h4 id="宿主外部环境，如微信APP、浏览器打开指定的小程序"><a href="#宿主外部环境，如微信APP、浏览器打开指定的小程序" class="headerlink" title="宿主外部环境，如微信APP、浏览器打开指定的小程序"></a><a href="https://mp.jd.com/docs/dev/API/interface/openMiniProgram.html">宿主外部环境，如微信APP、浏览器打开指定的小程序</a></h4><p>外部环境，需要将目标小程序拼接成如下链接格式，通过通用唤起中间页来打开制定的小程序:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;h5static.jd.com&#x2F;vapp&#x2F;appdau&#x2F;index.html?appId&#x3D;xxxxxxx&amp;type&#x3D;1&amp;path&#x3D;page%2findex%2findex.html%3fname%3daa</span><br></pre></td></tr></table></figure>

<p>其中，appId和type同openapp协议的 appId 和 vapptype 完全一致，path后面的路径，需要url encode，path中的?后面的自定义参数值，同上述 openapp 协议中param 字段一样，可在 app.js 中 onLaunch 回调中获取。</p>
<h3 id="使用Taro开发京东小程序"><a href="#使用Taro开发京东小程序" class="headerlink" title="使用Taro开发京东小程序"></a><a href="https://jelly.jd.com/exp/detail?id=5dc95ebeb73b47015299a89f">使用Taro开发京东小程序</a></h3><p>Taro 是京东零售-用户体验设计部-多终端研发部推出的一套遵循 React 语法规范的多端统一开发解决方案，也是京东小程序官方推荐的开发框架。</p>
<p>使用 Taro 开发不但能更规范、更有效率地编码， 畅享 React 生态的各种工具。更重要的是只需编写一份代码，即可运行在各种平台：京东/微信/百度/支付宝/字节跳动/QQ小程序、快应用、H5、React-Native 等。</p>
<ul>
<li>1.安装 Taro 的 CLI 工具：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g @tarojs/cli</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>已安装 Taro 的同学请注意更新 Taro 版本，Taro 自 1.3.20 后支持转换京东小程序。</p>
</blockquote>
<ul>
<li><p>2.使用 CLI 创建项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g @tarojs/cli</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3.安装京东小程序开发依赖</p>
</li>
</ul>
<p>因为小程序处于内测阶段，CLI 工具默认没有安装京东小程序相关开发依赖，所以需要手动安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install @tarojs/taro-jd</span></span><br></pre></td></tr></table></figure>

<ul>
<li>4.配置执行脚本</li>
</ul>
<p>在 package.json 中添加如下两条开启京东小程序项目的脚本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build:jd&quot;</span>: <span class="string">&quot;taro build --type jd&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev:jd&quot;</span>: <span class="string">&quot;npm run build:jd -- --watch&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>5.本地开发</li>
</ul>
<p>进入项目根目录，运行<code>npm run dev:jd</code>，使用 CLI 编译项目，根据 <a href="http://taro-docs-in.jd.com/taro/">Taro 文档</a>进行开发。</p>
<p>Taro 遵循 React 语法规范，它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用 JSX 语法，让代码具有更丰富的表现力，使用 Taro 进行开发可以获得和 React 一致的开发体验。</p>
<ul>
<li>6.调试</li>
</ul>
<p>使用京东小程序开发者工具进行调试，打开 IDE 工具，点击“新建项目”，项目路径指向 Taro 项目根目录中的输出目录 dist。</p>
<p>开发者可以给编译命令带上 watch 参数：taro build –type jd –watch，Taro 即会监听源代码的变化，及时编译项目并输出到 dist 目录。</p>
<p>但是目前 IDE 还没有监听文件变化而重新进行编译，因此每次改动源代码后需要手动点击 IDE 的编译按钮以刷新页面。</p>
<ul>
<li>7.注册页面</li>
</ul>
<p>当创建了新页面之后，我们还要告诉应用我们创建的这个页面，也就是在应用注册这个页面，打开 src/app.jsx ，在对应 App 组件的 config.pages 属性里面添加刚刚创建的帖子详情页的路径。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://mp.jd.com/docs/introduction/">京东小程序官网-介绍</a></li>
<li><a href="https://mp.jd.com/docs/dev/">京东小程序官网-开发</a></li>
<li><a href="https://jelly.jd.com/exp/detail?id=5dc95ebeb73b47015299a89f">使用 Taro 快速开发京东小程序</a></li>
<li><a href="https://juejin.im/post/5ea0e8efe51d4546d171110a">一杯茶的时间，上手 Taro 京东小程序开发</a></li>
<li><a href="https://cf.jd.com/pages/viewpage.action?pageId=226255440">接入京东小程序</a></li>
<li><a href="http://taro-docs-in.jd.com/taro/docs/README.html">Taro官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>从设计着手保护用户隐私</title>
    <url>/2020/12/30/%E4%BB%8E%E8%AE%BE%E8%AE%A1%E7%9D%80%E6%89%8B%E4%BF%9D%E6%8A%A4%E7%94%A8%E6%88%B7%E9%9A%90%E7%A7%81/</url>
    <content><![CDATA[<p>用户隐私安全在产品设计中是很重要的一个环节。我们每天都会使用到各式各样的APP，有金融的，社交的，电商的…而这些APP里面又储存着我们重要的隐私信息。如登录密码、存款金额、身份信息等。因此今天总结一下，一些主流产品在用户隐私方面的做法与设计点，为我们日后对用户隐私信息设计时，能有一些思考和帮助。</p>
<p>用户的隐私安全很重要，涉及的范围和角度也很多。首先先说说用户协议和隐私保护。</p>
<h3 id="一、用户协议和隐私保护"><a href="#一、用户协议和隐私保护" class="headerlink" title="一、用户协议和隐私保护"></a>一、用户协议和隐私保护</h3><p>依稀记得，2017年支付宝年度账单，有个页面下有一行特别小的字儿：“我同意《芝麻服务的用户协议》”，且选择状态是已选状态，默认帮助用户选择同意，意思就是我们默认允许支付宝收集我们的信息，包括在第三方已保存的信息，引起了很大的负面影响，随后芝麻信用道歉说：初衷没错，只是方式错误…</p>
<p>“用户协议”作为一种格式合同，是产品用来和用户签约授权的方式，原则意义上，它是具备法律效力的。产品提供“用户协议”完成的是对用户的<strong>“提前告知”</strong>动作，但用户信息的获取和使用，应该严格遵守《网络安全法》，做到让用户<strong>知情和同意</strong>，不能过度采集，更不可滥用数据。在我们大众的认知里，是没有对这个用户协议引起足够的重视，大家普遍认为它是没有法律依据的，也不会去了解接下来我们该尽到哪些义务和责任，如果用户没有仔细阅读用户协议，发生纠纷，会被认为是自身的疏忽问题，想要维权是非常麻烦的。</p>
<p>所以从设计上，我们要：</p>
<ul>
<li>对于“用户协议”中重要的条款和内容要以<strong>加粗、标色、下划线</strong>等方式提醒用户，尽到提示和说明的义务。</li>
<li>用户协议和隐私选项，最好是让用户自己点击勾选，用户如果忘记勾选，点击“登录”后可以使用弹窗提醒勾选。尽量不要默认勾选用户隐私协议。</li>
</ul>
<h3 id="二、密码输入保护隐私"><a href="#二、密码输入保护隐私" class="headerlink" title="二、密码输入保护隐私"></a>二、密码输入保护隐私</h3><p>密码是我们登录各大APP的钥匙，也是我们的信息数据得以保障的依据。在这方面的保护上，各种app都有不同的方式。无论在设计手法上，还是系统功能上。</p>
<h4 id="1-iOS录屏与截图后：隐藏密码"><a href="#1-iOS录屏与截图后：隐藏密码" class="headerlink" title="1. iOS录屏与截图后：隐藏密码"></a><strong>1. iOS录屏与截图后：隐藏密码</strong></h4><p>iOS一贯对用户隐私的高度重视，在各个APP上填写密码时被屏幕录制与截图功能所监控，苹果也能通过自有技术进行检测与保密处理。保存后的图片与视频里会自动隐藏掉密码输入的痕迹，包括加密符号与键盘输入时的字符。以下是京东、淘宝、金融软件及视频软件在截图后，密码一栏被隐藏；</p>
<p>bilibili的防偷窥捂眼睛，在设计上更有趣。用户输入账户时，动漫人物的眼睛是睁开的，在用户输入密码时，人物的眼睛会捂住，给用户一种可信任依赖的感觉。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/157353/17/472/119020/5feafaa3E88240db7/879c67efbe842b7d.png" alt="登陆账号时保护隐私"></p>
<h4 id="2-录屏涉及到密码做黑屏处理"><a href="#2-录屏涉及到密码做黑屏处理" class="headerlink" title="2.录屏涉及到密码做黑屏处理"></a><strong>2.录屏涉及到密码做黑屏处理</strong></h4><p>华为手机录屏功能除了在操作方式上打通多种渠道使操作更方便,在功能的细节设计上也下了很大功夫。比如,在播放录制好的视频时,只要是涉及到密码、解锁等用户隐私相关页面,华为录屏就会将页面进行黑屏遮挡,不少用户误以为是录屏出现了bug,背后实则是华为手机为了保护用户数据安全做出的人性化设计。</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/150753/31/13299/136140/5feafaa4Ec6750293/8732e383a43d8d32.png" alt="华为手机黑屏"></p>
<h4 id="3-银行app-自定义键盘"><a href="#3-银行app-自定义键盘" class="headerlink" title="3.银行app-自定义键盘"></a><strong>3.银行app-自定义键盘</strong></h4><p>目前几乎所有的银行app的数字键盘都是自定义的，这是为什么呢？</p>
<p>一是：银监会要求银行开发移动产品时必须使用加密键盘；二是：因为打乱的键盘会防止密码被类似按钮记录器之类的东西记录，如果键盘每次都是打乱供用户输入的，密码就会被辨别成为无用的随机信息。三：防偷窥。一般偷窥密码的人会偷瞄我们点按屏幕的位置，记住位置就有较大几率拿到我们的真实密码。但这种自定义的无序键盘实际上用户体验来说并不是很好，当用户很着急支付的时候，对于这种无序键盘真的想爆粗口。</p>
<p>突然发现除了银行app，互联网金融app为什么没有做无序密码处理呢？大致做了猜想：一是：银监会或者政策上并没有对支付宝或者微信做要求（当然，最基础的安全支付还是很有必要的），二是：这种有很大用户量的软件，会在产品研发上极度重视用户体验。支付宝和微信如何在密码键盘上，如何做到既安全又便捷呢？</p>
<ul>
<li><strong>技术上安全；</strong></li>
<li><strong>用户体验设计上，让用户感知到安全；</strong></li>
</ul>
<p><strong>技术上的安全：</strong>记得有篇文章说过：支付宝可以通过指压、接触面积、重力变化，连续间隔时间等，可以帮助判断是否是本人操作。用户操作手机的习惯也是进行风险判定的一个重要维度。每个人的行为都会有自己的习惯，就好像走路的姿势、笔迹一样。每个人触控手机屏幕的方式不同，而手机上是有很多传感器的，所以可以通过指压等操作，帮助判断是否是本人操作。</p>
<p><strong>用户体验设计上：</strong>微信初次转账页面，有一行小文字，微信安全支付，支付宝会有环境安全检测，告知用户可以安全支付。还有招行app自定义键盘上会有招商银行安全支付的文字，一些文字提示也能从视觉上让用户感知到安全感。</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/159938/25/404/80030/5feafaa3E2cca2581/b43a10e3ec87d6e4.png" alt="安全支付"></p>
<h3 id="三、资产金额隐藏保护"><a href="#三、资产金额隐藏保护" class="headerlink" title="三、资产金额隐藏保护"></a>三、资产金额隐藏保护</h3><p>金融app对于个人账户的总资产可以自定义隐藏和显示，从视觉上保护资产不外泄。但个人觉得资产隐藏这部分还有更多设计可以突破，比如，总资产位置我们不展示****，可以用简短的文案代替，增加趣味性，比如隐藏资产的时候显示：空空如也？</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/160418/35/391/114519/5feafaa4E6ead0a16/bb517ed8c876dc90.png" alt="金额敏感信息"></p>
<h3 id="四、匿名模式设计"><a href="#四、匿名模式设计" class="headerlink" title="四、匿名模式设计"></a>四、匿名模式设计</h3><h4 id="1-电商、外卖等平台匿名评价"><a href="#1-电商、外卖等平台匿名评价" class="headerlink" title="1.电商、外卖等平台匿名评价"></a>1.电商、外卖等平台匿名评价</h4><p>为什么会出现匿名评价的需求呢？通过真实的评价改善服务质量是评价系统的终极目的，而匿名评价存在的必要性则在于减少用户评论时的顾虑，增加评论的客观性，同时督促被评价人在各方面提升自己。</p>
<p>这个心理诉求很好理解，拿三个场景举例：</p>
<ul>
<li>购买了特殊物品，分享了使用体验，不希望被熟人看到；</li>
<li>商家服务还可以但产品不行，想给出低分但面子过不去，希望商家不知道是自己评的；</li>
<li>商家服务特别差，但又怕差评后遭商家报复，所以选择匿名评价；</li>
</ul>
<p>因为买家差评，被商家寄恐怖物品；因外卖太慢，给骑手差评遭到骑手吐唾沫；这样的例子举不胜举；所以衍生了匿名评价功能；保护用户隐私，但我们以为的匿名真的匿名了吗？这个很值得商榷。</p>
<p>匿名服务在设计上还是有一些差别的：我认为京东的设计对我来说是比较友好的，京东默认是匿名评价，用户如果想实名可以选择取消选择；饿了么和淘宝默认是公开选择的，如果用户没有手动选择，或者忽视这一选项，可能会给用户造成一些不好的体验。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/152439/39/12454/266315/5feafaa4Ee83546a2/af8c78b5e1d23bd3.png" alt="匿名评价"></p>
<h4 id="2-嘀嗒、嘀嘀打车平台匿名评价"><a href="#2-嘀嗒、嘀嘀打车平台匿名评价" class="headerlink" title="2.嘀嗒、嘀嘀打车平台匿名评价"></a>2.嘀嗒、嘀嘀打车平台匿名评价</h4><p>滴答拼车除了自动匿名评价外，会对差评的内容进行延迟发布，通过时间差来避免用户遭到司机的恶意骚扰。</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/160437/11/419/223213/5feafaa3E6d4b4d8d/3022775b32bb392a.png" alt="出行评价"></p>
<h4 id="3-QQ社交软件截图隐藏用户名和头像"><a href="#3-QQ社交软件截图隐藏用户名和头像" class="headerlink" title="3.QQ社交软件截图隐藏用户名和头像"></a>3.QQ社交软件截图隐藏用户名和头像</h4><p>QQ在用户进行截图的以后，可以选择抹去用户名和头像，减少用户再二次手动模糊用户名和头像的操作，一方面保护了用户隐私，一方面方便了用户操作。如下图所示，这个模糊操作很厉害，估计当事人看到了也看不出是自己吧～hhh～</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/150700/25/13421/588858/5feafaa6E54cfd03c/065f6d75bbc60ed9.png" alt="image-20201229173110028"></p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>从输入一个URL谈前端优化</title>
    <url>/2021/05/25/%E4%BB%8E%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E8%B0%88%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="从输入一个URL谈前端优化"><a href="#从输入一个URL谈前端优化" class="headerlink" title="从输入一个URL谈前端优化"></a>从输入一个URL谈前端优化</h1><p><strong>DNS查询</strong></p>
<p>与服务器交互首先要进行DNS查询，得到服务器的IP地址，浏览器会首先查询自己的缓存，之后会查询本地HOSTS，如果仍然没找到会发起向DNS服务器查询的请求。</p>
<blockquote>
<p>在这里我们可以做的优化不多，DNS是我们相对不可控的一个条件，但我们仍然可以做的一个优化策略是预查询。</p>
</blockquote>
<ul>
<li>进行DNS预查询</li>
</ul>
<p>在文档顶部我们可以将我们即将要请求的地址的DNS预先查询，通过插入一个link标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;https:&#x2F;&#x2F;xxx.com&#x2F;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>来告知浏览器我们将要从这个地址(通常会是存放静态资源的CDN的地址)拉取数据。</p>
<p><strong>建立HTTP(TCP)连接</strong></p>
<p>得到服务器IP之后，首先进行三次握手，之后会进行SSL握手(HTTPS)，SSL握手时会向服务器端确认HTTP的版本。</p>
<p>针对这方面的优化，前端可做的事情不多，主要是服务器端的事情，不过仍然要了解一下前端可以看得到的策略。</p>
<ul>
<li>keep-alive</li>
</ul>
<p>由于TCP的可靠性，每条独立的TCP连接都会进行一次三次握手，握手往往会消耗大部分时间，真正的数据传输反而会少一些(当然取决于内容多少)。<br>HTTP1.0和HTTP1.1为了解决这个问题在header中加入了<strong>Connection: Keep-Alive</strong>，keep-alive的连接会保持一段时间不断开，后续的请求都会复用这一条TCP，不过由于管道化的原因也会发生队头阻塞的问题。</p>
<p>HTTP1.1默认开启Keep-Alive，HTTP1.0可能现在不多见了，如果你还在用，可以升级一下版本，或者带上这个header。</p>
<ul>
<li>HTTP2</li>
</ul>
<p>HTTP2相对于HTTP1.1的一个主要升级是多路复用，多路复用通过更小的二进制帧构成多条数据流，交错的请求和响应可以并行传输而不被阻塞，这样就解决了HTTP1.1时复用会产生的队头阻塞的问题，同时HTTP2有首部压缩的功能，如果两个请求首部(headers)相同，那么会省去这一部分，只传输不同的首部字段，进一步减少请求的体积。</p>
<p>Nginx开启HTTP2的方式特别容易，只需要加一句http2既可开启：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> listen 443 ssl http2; # 加一句 http2.</span><br><span class="line"> server_name domain.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>缓存</li>
</ul>
<p>缓存通过复用之前的获取过的资源，可以显著提高网站和应用程序的性能，合理的缓存不仅可以节省巨大的流量也会让用户二次进入时身心愉悦，如果一个资源完全走了本地缓存，那么就可以节省下整个与服务器交互的时间，如果整个网站的内容都被缓存在本地，那即使离线也可以继续访问(很酷，但还没有完全很酷)。</p>
<p>HTTP缓存主要分为两种，一种是强缓存，另一种是协商缓存，都通过Headers控制。</p>
<p><img src= "/img/loading.gif" data-src="./640.png"></p>
<ol>
<li>强缓存</li>
</ol>
<p>强缓存根据请求头的<strong>Expires</strong>和<strong>Cache-Control</strong>判断是否命中强缓存，命中强缓存的资源直接从本地加载，不会发起任何网络请求。</p>
<p>Cache-Control的值有很多:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age=&lt;seconds&gt;</span><br><span class="line">Cache-Control: max-stale[=&lt;seconds&gt;]</span><br><span class="line">Cache-Control: min-fresh=&lt;seconds&gt;</span><br><span class="line">Cache-control: no-cache</span><br><span class="line">Cache-control: no-store</span><br><span class="line">Cache-control: no-transform</span><br><span class="line">Cache-control: only-<span class="keyword">if</span>-cached</span><br></pre></td></tr></table></figure>

<p>常用的有<strong>max-age</strong>，<strong>no-cache</strong>和<strong>no-store</strong>。</p>
<p>max-age 是资源从响应开始计时的最大新鲜时间，一般响应中还会出现age标明这个资源当前的新鲜程度。</p>
<p>no-cache 会让浏览器缓存这个文件到本地但是不用，Network中disable-cache勾中的话就会在请求时带上这个haader，会在下一次新鲜度验证通过后使用这个缓存。</p>
<p>no-store 会完全放弃缓存这个文件。</p>
<p>服务器响应时的Cache-Control略有不同，其中有两个需要注意下:</p>
<ul>
<li>public, public 表明这个请求可以被任何对象缓存，代理/CDN等中间商。</li>
<li>private，private 表明这个请求只能被终端缓存，不允许代理或者CDN等中间商缓存。</li>
</ul>
<p>Expires是一个具体的日期，到了那个日期就会让这个缓存失活，优先级较低，存在max-age的情况下会被忽略，和本地时间绑定，修改本地时间可以绕过。</p>
<p>另外，如果你的服务器的返回内容中不存在Expires，Cache-Control: max-age，或 Cache-Control:s-maxage但是存在Last-Modified时，那么浏览器默认会采用一个启发式的算法，即启发式缓存。通常会取响应头的Date_value - Last-Modified_value值的10%作为缓存时间，之后浏览器仍然会按强缓存来对待这个资源一段时间，如果你不想要缓存的话务必确保有no-cache或no-store在响应头中。</p>
<ol start="2">
<li>协商缓存</li>
</ol>
<p>协商缓存一般会在强缓存新鲜度过期后发起，向服务器确认是否需要更新本地的缓存文件，如果不需要更新，服务器会返回304否则会重新返回整个文件。</p>
<p>服务器响应中会携带ETag和Last-Modified，Last-Modified 表示本地文件最后修改日期，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p>
<p>但是如果在本地打开缓存文件，就会造成Last-Modified被修改，所以在HTTP / 1.1 出现了ETag。</p>
<p>Etag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的</p>
<p>If-None-Match的header会将上次返回的ETag发送给服务器，询问该资源的ETag是否有更新，有变动就会发送新的资源回来</p>
<p>ETag(If-None-Match)的优先级高于Last-Modified(If-Modified-Since)，优先使用ETag进行确认。</p>
<p>协商缓存比强缓存稍慢，因为还是会发送请求到服务器进行确认。</p>
<ul>
<li>CDN<br>CDN会把源站的资源缓存到CDN服务器，当用户访问的时候就会从最近的CDN服务器拿取资源而不是从源站拿取，这样做的好处是分散了压力，同时也会提升返回访问速度和稳定性。</li>
</ul>
<p><strong>压缩</strong><br>合理的压缩资源可以有效减少传输体积，减少传输体积的结果就是用户更快的拿到资源开始解析。</p>
<p>压缩在各个阶段都会出现，比如上面提到的HTTP2的首部压缩，进行到这一步的压缩是指对整个资源文件进行的压缩。</p>
<p>浏览器在发起请求时会在headers中携带accept-encoding: gzip, deflate, br，告知服务器客户端可以接受的压缩算法，之后响应资源会在响应头中携带content-encoding: gzip告知本文件的压缩算法。</p>
<ul>
<li>GZIP压缩</li>
</ul>
<p>GZIP是非常常用的压缩算法，现代客户端都会支持，你可以在上传文件时就上传一份压缩后的文件，也可以让Nginx动态压缩。</p>
<p><strong>进行页面渲染</strong></p>
<p><img src= "/img/loading.gif" data-src="./641.webp"></p>
<p>关键渲染路径是浏览器将HTML/CSS/JS转换为屏幕上看到的像素内容所经过的一系列步骤。</p>
<p>浏览器得到HTML后会开始解析DOM树，CSS资源的下载不会阻塞解析DOM，但是也要注意，如果CSS未下载解析完成是会阻塞最终渲染的。</p>
<p>得到HTML后首先会解析HTML，然后解析样式，计算样式，绘制图层等等操作，JS脚本运行，之后可能会重复这一步骤。</p>
<ul>
<li>预加载/预连接内容</li>
</ul>
<p>和前面说的DNS预查询一样，可以将即将要用到的资源或者即将要握手的地址提前告知浏览器让浏览器利用还在解析HTML计算样式的时间去提前准备好。</p>
<ol>
<li>preload</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;preload&quot;</span> href=<span class="string">&quot;style.css&quot;</span> <span class="keyword">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>as属性可以指定预加载的类型，除了style还支持很多类型，常用的一般是style和script，css和js。</p>
</blockquote>
<ol start="2">
<li>prefetch</li>
</ol>
<p>prefetch和preload差不多，prefetch是一个低优先级的获取，通常用在这个资源可能会在用户接下来访问的页面中出现的时候。</p>
<p>当然对当前页面的要用preload，不要用prefetch，可以用到的一个场景是在用户鼠标移入a标签时进行一个prefetch。</p>
<ol start="3">
<li>preconnect<br>preconnect和dns-prefetch做的事情类似，提前进行TCP，SSL握手，省去这一部分时间，基于HTTP1.1(keep-alive)和HTTP2(多路复用)的特性，都会在同一个TCP链接内完成接下来的传输任务。</li>
</ol>
<ul>
<li>script加标记</li>
</ul>
<ol>
<li>async标记</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;main.js&quot;</span> <span class="keyword">async</span>&gt;</span><br></pre></td></tr></table></figure>
<p>async标记告诉浏览器在等待js下载期间可以去干其他事，当js下载完成后会立即(尽快)执行，多条js可以并行下载。</p>
<p>async的好处是让多条js不会互相等待，下载期间浏览器会去干其他事(继续解析HTML等)，异步下载，异步执行。</p>
<ol start="2">
<li>defer标记</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;main.js&quot;</span> defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>与async一样，defer标记告诉浏览器在等待js下载期间可以去干其他事，多条js可以并行下载，不过当js下载完成之后不会立即执行，而是会等待解析完整个HTML之后在开始执行，而且多条defer标记的js会按照顺序执行，</p>
<p><a href="https://mp.weixin.qq.com/s/20aC5bZeJ0j6Mb8r5xZpDg">参考</a></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>代码重构之处理继承关系</title>
    <url>/2021/03/10/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E4%B9%8B%E5%A4%84%E7%90%86%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h4 id="函数上移"><a href="#函数上移" class="headerlink" title="函数上移"></a>函数上移</h4><blockquote>
<p>动机：如果某个函数在各个子类中的函数体都相同，则将函数上移</p>
</blockquote>
<ol>
<li>检查待上移的函数，确定完全一致</li>
<li>检查函数体内引用的所有函数调用和字段都能从超类中调用到</li>
<li>如果待上移的函数声明不同，则修改为将要在超类中使用的声明</li>
<li>超类中创建一个函数，将待上移函数代码复制其中</li>
<li>执行静态检查</li>
<li>移除一个待上移子类函数</li>
<li>测试</li>
<li>移除其余待上移子类函数</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">annualCost</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.monthlyCost * <span class="number">12</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">annualCost</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.monthlyCost * <span class="number">12</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">annualCost</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.monthlyCost * <span class="number">12</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">monthlyCost</span>() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SubclassResponsibilityError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字段上移"><a href="#字段上移" class="headerlink" title="字段上移"></a>字段上移</h4><blockquote>
<p>动机：观察函数如何使用字段来判断它们是否重复，如果它们被使用方式很相似，则可以将它们上移到超类中去</p>
</blockquote>
<ol>
<li>检查待上移的字段使用方式一致</li>
<li>如果在在类中名字不一致，则取相同的名字</li>
<li>超类中创建一个字段</li>
<li>移除子类字段</li>
<li>测试</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salesman</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salesman</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数本体上移"><a href="#构造函数本体上移" class="headerlink" title="构造函数本体上移"></a>构造函数本体上移</h4><blockquote>
<p>动机： 各个子类中构造函数有共同的行为</p>
</blockquote>
<ol>
<li>超类不存在构造函数，则创建一个，并确保子类调用</li>
<li>将子类构造函数中的公共语句移动到超类构造函数中</li>
<li>删除子类构造函数公共代码</li>
<li>测试</li>
<li>如存在无法简单上移至超类的公共代码，利用函数上移提升</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Party</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, id, monthlyCost</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>._id = id;</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">    <span class="built_in">this</span>._monthlyCost = monthlyCost;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, staff</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">    <span class="built_in">this</span>._staff = staff;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, id, monthlyCost</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">this</span>._id = id;</span><br><span class="line">    <span class="built_in">this</span>._monthlyCost = monthlyCost;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, staff</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">this</span>._staff = staff;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数下移"><a href="#函数下移" class="headerlink" title="函数下移"></a>函数下移</h4><blockquote>
<p>动机：如果超类中的某个函数只与一个子类有关，最好将其从超类中移除，放到正在关心它的子类中去</p>
</blockquote>
<ol>
<li>将超类中的函数本体复制到需要此函数的子类中</li>
<li>删除超类中的函数</li>
<li>测试</li>
<li>将该函数从所有不需要的子类中删除</li>
<li>测试</li>
</ol>
<h4 id="字段下移"><a href="#字段下移" class="headerlink" title="字段下移"></a>字段下移</h4><blockquote>
<p>动机：如果属性字段只被一个子类用到，则下移至该子类中</p>
</blockquote>
<ol>
<li>在子类中声明该字段</li>
<li>从超类中移除</li>
<li>测试</li>
<li>将该字段从不需要它的子类中删除</li>
<li>测试</li>
</ol>
<h4 id="以子类取代类型码"><a href="#以子类取代类型码" class="headerlink" title="以子类取代类型码"></a>以子类取代类型码</h4><blockquote>
<p>动机：继承可以用多态来处理条件逻辑，更能明确地表达数据和类型之间的关系</p>
</blockquote>
<ol>
<li>自封装类型码字段</li>
<li>任选一个类型码取值，为其创建一个子类</li>
<li>创建一个选择器逻辑，把类型码参数映射到新的子类</li>
<li>测试</li>
<li>针对每个类型码取值，重复 2</li>
<li>去除类型码字段</li>
<li>测试</li>
<li>处理原本访问类型码的函数</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, type</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.validateType(type);</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">    <span class="built_in">this</span>._type = type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">validateType</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="string">&quot;engineer&quot;</span>, <span class="string">&quot;manager&quot;</span>, <span class="string">&quot;salesman&quot;</span>].includes(arg))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Employee cannot be of type <span class="subst">$&#123;arg&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>._name&#125;</span> (<span class="subst">$&#123;<span class="built_in">this</span>._type&#125;</span>)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, type</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">type</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;engineer&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salesman</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">type</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;salesman&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">type</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;manager&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEmployee</span>(<span class="params">name, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;engineer&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Engineer(name);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;salesman&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Salesman(name);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;manager&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Manager(name);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Employee cannot be of type <span class="subst">$&#123;type&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移除子类"><a href="#移除子类" class="headerlink" title="移除子类"></a>移除子类</h4><blockquote>
<p>动机：如果子类的用处太少，最好移除子类，将其替换为超类的一个字段</p>
</blockquote>
<ol>
<li>把子类的构造函数包装到超类的工厂函数中</li>
<li>将类型检查逻辑包装起来搬移到超类</li>
<li>新建一个字段，代表子类类型</li>
<li>将判断子类类型的函数改为新建字段</li>
<li>删除子类</li>
<li>测试</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">genderCode</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">genderCode</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;M&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">genderCode</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;F&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">aRecord</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (aRecord.gender) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;M&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Person(aRecord.name, <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;F&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Person(aRecord.name, <span class="string">&quot;F&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Person(aRecord.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, genderCode</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">    <span class="built_in">this</span>._genderCode = genderCode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">genderCode</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._genderCode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提炼超类"><a href="#提炼超类" class="headerlink" title="提炼超类"></a>提炼超类</h4><blockquote>
<p>动机：如果两个类在做相似的事，可以利用继承把相似之处提炼到超类。</p>
</blockquote>
<ol>
<li>为原本类新建一个空的超类</li>
<li>测试</li>
<li>逐一将子类共同元素上移至超类</li>
<li>检查子类中的函数，看是否还有共同的成分，有则提炼并上移</li>
<li>检查所有原本的类，将其调整为使用超类接口</li>
</ol>
<h4 id="折叠继承体系"><a href="#折叠继承体系" class="headerlink" title="折叠继承体系"></a>折叠继承体系</h4><blockquote>
<p>动机：如果一个子类和超类已经没多大差别，则将子类和超类合并起来</p>
</blockquote>
<ol>
<li>选择移除超类还是子类？</li>
<li>将所有元素移动到同一个类中</li>
<li>修改将被移除类的所有引用点，改为合并后留下的类</li>
<li>移除类</li>
<li>测试</li>
</ol>
<h4 id="以委托取代子类"><a href="#以委托取代子类" class="headerlink" title="以委托取代子类"></a>以委托取代子类</h4><blockquote>
<p>动机：与继承相比使用委托关系时接口更清晰、耦合更少，对象组合常常优于类继承</p>
</blockquote>
<ol>
<li>如果构造函数有多个调用者，首先工厂函数把构造函数包装起来</li>
<li>创建一个空的委托类</li>
<li>在超类中添加一个字段，用于安放委托对象</li>
<li>修改子类创建逻辑，使其初始化委托字段，放入一个委托对象的实例中</li>
<li>选择一个子类的函数，将其移入委托类</li>
<li>搬移上述函数，不要删除类中的委托代码</li>
<li>如果原函数在子类之外被调用，则把委托代码上移至超类，如果子类外没有调用，则移除委托代码</li>
<li>测试</li>
<li>重复，直到子类中所有函数都搬到委托类</li>
<li>找到所有子类构造函数的地方，逐一改为使用超类的构造函数</li>
<li>测试</li>
<li>移除子类</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Booking</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">show, date</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._show = show;</span><br><span class="line">    <span class="built_in">this</span>._date = date;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">hasTalkback</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._show.hasOwnProperty(<span class="string">&quot;talkback&quot;</span>) &amp;&amp; !<span class="built_in">this</span>.isPeakDay;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">basePrice</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">this</span>._show.price;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isPeakDay) result += <span class="built_in">Math</span>.round(result * <span class="number">0.15</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PremiumBooking</span> <span class="keyword">extends</span> <span class="title">Booking</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">show, date, extras</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(show, date);</span><br><span class="line">    <span class="built_in">this</span>._extras = extras;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">hasTalkback</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._show.hasOwnProperty(<span class="string">&quot;talkback&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">basePrice</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.round(<span class="built_in">super</span>.basePrice + <span class="built_in">this</span>._extras.premiumFee);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">hasDinner</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._extras.hasOwnProperty(<span class="string">&quot;dinner&quot;</span>) &amp;&amp; !<span class="built_in">this</span>.isPeakDay;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Booking</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">show, date</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._show = show;</span><br><span class="line">    <span class="built_in">this</span>._date = date;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_bePremium</span>(<span class="params">extras</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._premiumDelegate = <span class="keyword">new</span> PremiumBookingDelegate(<span class="built_in">this</span>, extras);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">hasTalkback</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._premiumDelegate</span><br><span class="line">      ? <span class="built_in">this</span>._premiumDelegate.hasTalkback</span><br><span class="line">      : <span class="built_in">this</span>._show.hasOwnProperty(<span class="string">&quot;talkback&quot;</span>) &amp;&amp; !<span class="built_in">this</span>.isPeakDay;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">basePrice</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">this</span>._show.price;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isPeakDay) result += <span class="built_in">Math</span>.round(result * <span class="number">0.15</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._premiumDelegate</span><br><span class="line">      ? <span class="built_in">this</span>._premiumDelegate.extendBasePrice(result)</span><br><span class="line">      : result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">hasDinner</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._premiumDelegate ? <span class="built_in">this</span>._premiumDelegate.hasDinner : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBooking</span>(<span class="params">show, date</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Booking(show, date);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPremiumBooking</span>(<span class="params">show, date, extras</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> Booking(show, date);</span><br><span class="line">  result._bePremium(extras);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PremiumBookingDelegate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">hostBooking, extras</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._host = hostBooking;</span><br><span class="line">    <span class="built_in">this</span>._extras = extras;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">hasTalkback</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._host._show.hasOwnProperty(<span class="string">&quot;talkback&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">extendBasePrice</span>(<span class="params">base</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.round(base + <span class="built_in">this</span>._extras.premiumFee);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">hasDinner</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._extras.hasOwnProperty(<span class="string">&quot;dinner&quot;</span>) &amp;&amp; !<span class="built_in">this</span>._host.isPeakDay;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="以委托取代超类"><a href="#以委托取代超类" class="headerlink" title="以委托取代超类"></a>以委托取代超类</h4><blockquote>
<p>动机：如果超类的一些函数对子类并不适用，则以委托取代超类</p>
</blockquote>
<ol>
<li>在子类中新建一个字段，使其引用超类的一个对象，并将委托引用初始化为超类的新实例</li>
<li>针对超类的每个函数，在子类中创建一个转发函数，将调用请求转发委托引用</li>
<li>当所有超类函数都被转发函数覆写后，去掉继承关系</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CatalogItem</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id, title, tags</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._id = id;</span><br><span class="line">    <span class="built_in">this</span>._title = title;</span><br><span class="line">    <span class="built_in">this</span>._tags = tags;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">id</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">title</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._title;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">hasTag</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._tags.includes(arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scroll</span> <span class="keyword">extends</span> <span class="title">CatalogItem</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id, title, tags, dateLastCleaned</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(id, title, tags);</span><br><span class="line">    <span class="built_in">this</span>._lastCleaned = dateLastCleaned;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">needsCleaning</span>(<span class="params">targetDate</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> threshold = <span class="built_in">this</span>.hasTag(<span class="string">&quot;revered&quot;</span>) ? <span class="number">700</span> : <span class="number">1500</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.daysSinceLastCleaning(targetDate) &gt; threshold;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">daysSinceLastCleaning</span>(<span class="params">targetDate</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._lastCleaned.until(targetDate, ChronoUnit.DAYS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CatalogItem</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id, title, tags</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._id = id;</span><br><span class="line">    <span class="built_in">this</span>._title = title;</span><br><span class="line">    <span class="built_in">this</span>._tags = tags;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">id</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">title</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._title;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">hasTag</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._tags.includes(arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scroll</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id, dateLastCleaned, catalogID, catalog</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._id = id;</span><br><span class="line">    <span class="built_in">this</span>._catalogItem = catalog.get(catalogID);</span><br><span class="line">    <span class="built_in">this</span>._lastCleaned = dateLastCleaned;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">id</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">title</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._catalogItem.title;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">hasTag</span>(<span class="params">aString</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._catalogItem.hasTag(aString);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">needsCleaning</span>(<span class="params">targetDate</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> threshold = <span class="built_in">this</span>.hasTag(<span class="string">&quot;revered&quot;</span>) ? <span class="number">700</span> : <span class="number">1500</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.daysSinceLastCleaning(targetDate) &gt; threshold;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">daysSinceLastCleaning</span>(<span class="params">targetDate</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._lastCleaned.until(targetDate, ChronoUnit.DAYS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>代码重构之重构API</title>
    <url>/2021/03/10/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E4%B9%8B%E9%87%8D%E6%9E%84API/</url>
    <content><![CDATA[<h4 id="将查询函数和修改函数分离"><a href="#将查询函数和修改函数分离" class="headerlink" title="将查询函数和修改函数分离"></a>将查询函数和修改函数分离</h4><blockquote>
<p>动机：任何有返回值的函数，都不应该有看得到的副作用。</p>
</blockquote>
<p>一种常见的优化办法是：将查询所得记过缓存于某个字段中，后续重复查询可以大大加快速度。</p>
<ol>
<li>复制函数，以查询来命名</li>
<li>移除有副作用的代码</li>
<li>执行静态检查</li>
<li>查找所有调用原函数的地方，替换为新函数，并在下面调用一次原函数</li>
<li>从原函数中去掉返回值</li>
<li>测试</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Miscreant - 恶棍</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertForMiscreant</span>(<span class="params">people</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> people) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p === <span class="string">&quot;Don&quot;</span>) &#123;</span><br><span class="line">      setOffAlarms();</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Don&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p === <span class="string">&quot;John&quot;</span>) &#123;</span><br><span class="line">      setOffAlarms();</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;John&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> found = alertForMiscreant(people);</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMiscreant</span>(<span class="params">people</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> people) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p === <span class="string">&quot;Don&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Don&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p === <span class="string">&quot;John&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;John&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertForMiscreant</span>(<span class="params">people</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (findMiscreant(people) !== <span class="string">&quot;&quot;</span>) setOffAlarms(); <span class="comment">// 替换算法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> found = findMiscreant(people);</span><br><span class="line">alertForMiscreant(people);</span><br></pre></td></tr></table></figure>

<h4 id="函数参数化"><a href="#函数参数化" class="headerlink" title="函数参数化"></a>函数参数化</h4><blockquote>
<p>动机：两个函数逻辑非常相似，可以将其合并为一个函数，以参数形式传入不同值，从而消除重复。</p>
</blockquote>
<ol>
<li>从一组相似函数选则一个</li>
<li>把需要作为参数传入的字面量添加到参数列表</li>
<li>修改该函数所有调用地方</li>
<li>测试</li>
<li>修改函数体，令其使用新传入的参数</li>
<li>替换与其相似的函数，并测试</li>
</ol>
<p>Before：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCharge</span>(<span class="params">usage</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (usage &lt; <span class="number">0</span>) <span class="keyword">return</span> usd(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> amount =</span><br><span class="line">    bottomBand(usage) * <span class="number">0.03</span> + middleBand(usage) * <span class="number">0.05</span> + topBand(usage) * <span class="number">0.07</span>;</span><br><span class="line">  <span class="keyword">return</span> usd(amount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bottomBand</span>(<span class="params">usage</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.min(usage, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleBand</span>(<span class="params">usage</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> usage &gt; <span class="number">100</span> ? <span class="built_in">Math</span>.min(usage, <span class="number">200</span>) - <span class="number">100</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">topBand</span>(<span class="params">usage</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> usage &gt; <span class="number">200</span> ? usage - <span class="number">200</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withinBand</span>(<span class="params">usage, bottom, top</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> usage &gt; bottom ? <span class="built_in">Math</span>.min(usage, top) - bottom : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCharge</span>(<span class="params">usage</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (usage &lt; <span class="number">0</span>) <span class="keyword">return</span> usd(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> amount =</span><br><span class="line">    withinBand(usage, <span class="number">0</span>, <span class="number">100</span>) * <span class="number">0.03</span> +</span><br><span class="line">    withinBand(usage, <span class="number">100</span>, <span class="number">200</span>) * <span class="number">0.05</span> +</span><br><span class="line">    withinBand(usage, <span class="number">200</span>, <span class="literal">Infinity</span>) * <span class="number">0.07</span>;</span><br><span class="line">  <span class="keyword">return</span> usd(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移除标记参数"><a href="#移除标记参数" class="headerlink" title="移除标记参数"></a>移除标记参数</h4><blockquote>
<p>动机：用标记参数来指示被调函数应该执行哪一部分逻辑，影响了函数内部控制流。移除标记参数是代码更加整洁。</p>
</blockquote>
<ol>
<li>针对参数的每一种可能值，新建一个明确函数</li>
<li>修改调用函数的地方为新建明确函数</li>
</ol>
<p>Before：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deliveryDate</span>(<span class="params">anOrder, isRush</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRush) &#123;</span><br><span class="line">    <span class="keyword">let</span> deliveryTime;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="string">&quot;MA&quot;</span>, <span class="string">&quot;CT&quot;</span>].includes(anOrder.deliveryState)) deliveryTime = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="string">&quot;NY&quot;</span>, <span class="string">&quot;NH&quot;</span>].includes(anOrder.deliveryState)) deliveryTime = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> deliveryTime = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> anOrder.placedOn.plusDays(<span class="number">1</span> + deliveryTime);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> deliveryTime;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="string">&quot;MA&quot;</span>, <span class="string">&quot;CT&quot;</span>, <span class="string">&quot;NY&quot;</span>].includes(anOrder.deliveryState)) deliveryTime = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="string">&quot;ME&quot;</span>, <span class="string">&quot;NH&quot;</span>].includes(anOrder.deliveryState)) deliveryTime = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> deliveryTime = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> anOrder.placedOn.plusDays(<span class="number">2</span> + deliveryTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deliveryDate</span>(<span class="params">anOrder, isRush</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRush) <span class="keyword">return</span> rushDeliveryDate(anOrder);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> regularDeliveryDate(anOrder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rushDeliveryDate</span>(<span class="params">anOrder</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> deliveryTime;</span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">&quot;MA&quot;</span>, <span class="string">&quot;CT&quot;</span>].includes(anOrder.deliveryState)) deliveryTime = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="string">&quot;NY&quot;</span>, <span class="string">&quot;NH&quot;</span>].includes(anOrder.deliveryState)) deliveryTime = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">else</span> deliveryTime = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> anOrder.placedOn.plusDays(<span class="number">1</span> + deliveryTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">regularDeliveryDate</span>(<span class="params">anOrder</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> deliveryTime;</span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">&quot;MA&quot;</span>, <span class="string">&quot;CT&quot;</span>, <span class="string">&quot;NY&quot;</span>].includes(anOrder.deliveryState)) deliveryTime = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="string">&quot;ME&quot;</span>, <span class="string">&quot;NH&quot;</span>].includes(anOrder.deliveryState)) deliveryTime = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">else</span> deliveryTime = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> anOrder.placedOn.plusDays(<span class="number">2</span> + deliveryTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="保持对象完整"><a href="#保持对象完整" class="headerlink" title="保持对象完整"></a>保持对象完整</h4><blockquote>
<p>动机：如果一个函数需要传入一个对象的多个属性值，传递对象本身是更好地方式。</p>
</blockquote>
<ol>
<li>新建空函数，传入对象</li>
<li>新函数中调用旧函数，并把新参数映射到就的参数列表</li>
<li>执行静态检查</li>
<li>修改调用地方为新函数</li>
<li>把旧函数内联到新函数体内</li>
<li>修改函数名为旧函数名，并修改所有调用的地方</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> low = aRoom.daysTempRange.low;</span><br><span class="line"><span class="keyword">const</span> high = aRoom.daysTempRange.high;</span><br><span class="line"><span class="keyword">if</span> (!aPlan.withinRange(low, high))</span><br><span class="line">  alerts.push(<span class="string">&quot;room temperature went outside range&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeatingPlan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">withinRange</span>(<span class="params">bottom, top</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      bottom &gt;= <span class="built_in">this</span>._temperatureRange.low &amp;&amp; top &lt;= <span class="built_in">this</span>._temperatureRange.high</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!aPlan.withinRange(aRoom.daysTemRange))</span><br><span class="line">  alerts.push(<span class="string">&quot;room temperature went outside range&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeatingPlan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">withinRange</span>(<span class="params">aNumberRange</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      aNumberRange.low &gt;= <span class="built_in">this</span>._temperatureRange.low &amp;&amp;</span><br><span class="line">      aNumberRange.high &lt;= <span class="built_in">this</span>._temperatureRange.high</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="以查询取代参数"><a href="#以查询取代参数" class="headerlink" title="以查询取代参数"></a>以查询取代参数</h4><blockquote>
<p>动机：如果函数的一个参数只需要向另一个参数查询就能得到，则参数列表应避免重复。</p>
</blockquote>
<ol>
<li>如有必要使用提炼函数将参数的查询过程提炼到一个独立函数中</li>
<li>将函数体内参数饮用的地方改为调用新建的函数，并测试</li>
<li>将参数去掉</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">finalPrice</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> basePrice = <span class="built_in">this</span>.quantity * <span class="built_in">this</span>.itemPrice;</span><br><span class="line">    <span class="keyword">let</span> discountLevel;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.quantity &gt; <span class="number">100</span>) discountLevel = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> discountLevel = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.discountedPrice(basePrice, discountLevel);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">discountedPrice</span>(<span class="params">basePrice, discountLevel</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (discountLevel) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> basePrice * <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">finalPrice</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> basePrice = <span class="built_in">this</span>.quantity * <span class="built_in">this</span>.itemPrice;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.discountedPrice(basePrice);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">discountLevel</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.quantity &gt; <span class="number">100</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">discountedPrice</span>(<span class="params">basePrice</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (discountLevel) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> basePrice * <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="以参数取代查询"><a href="#以参数取代查询" class="headerlink" title="以参数取代查询"></a>以参数取代查询</h4><blockquote>
<p>动机：在负责逻辑处理的模块中只有纯函数，其外再包裹处理 I/O 和其他可变元素的逻辑代码，使其更容易测试及理解。JavaScript 的类模型无法强制要求类的不可变形——始终有办法修改对象的内部数据，以参数取代查询是达成让类保持不可变的利器。</p>
</blockquote>
<ol>
<li>对查询操作的代码提炼为变量，从函数体中分离出去</li>
<li>提炼函数体内代码为新函数</li>
<li>使用内联变量消除刚提炼出来的变量</li>
<li>对原函数使用内联函数</li>
<li>新函数该会原函数名字</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeatingPlan</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">targetTemperature</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (thermostat.selectedTemperature &gt; <span class="built_in">this</span>._max) <span class="keyword">return</span> <span class="built_in">this</span>._max;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (thermostat.selectedTemperature &lt; <span class="built_in">this</span>._min) <span class="keyword">return</span> <span class="built_in">this</span>._min;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> thermostat.selectedTemperature;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (thePlan.targetTemperature &gt; thermostat.currentTemperature) setToH;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (thePlan.targetTemperature &lt; thermostat.currentTemperature) setToC;</span><br><span class="line"><span class="keyword">else</span> setOff();</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeatingPlan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">targetTemperature</span>(<span class="params">selectedTemperature</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedTemperature &gt; <span class="built_in">this</span>._max) <span class="keyword">return</span> <span class="built_in">this</span>._max;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (selectedTemperature &lt; <span class="built_in">this</span>._min) <span class="keyword">return</span> <span class="built_in">this</span>._min;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> selectedTemperature;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  thePlan.targetTemperature(thermostat.selectedTemperature) &gt;</span><br><span class="line">  thermostat.currentTemperature</span><br><span class="line">)</span><br><span class="line">  setToHeat();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  thePlan.targetTemperature(thermostat.selectedTemperature) &lt;</span><br><span class="line">  thermostat.currentTemperature</span><br><span class="line">)</span><br><span class="line">  setToCool();</span><br><span class="line"><span class="keyword">else</span> setOff();</span><br></pre></td></tr></table></figure>

<h4 id="移除设值函数"><a href="#移除设值函数" class="headerlink" title="移除设值函数"></a>移除设值函数</h4><blockquote>
<p>动机：如果不希望在对象创建之后某个属性还有机会被改变，就不要为它提供 set 函数。</p>
</blockquote>
<ol>
<li>在构造函数中调用设值函数，对字段设值</li>
<li>移除所有在构造函数之外对设值函数的调用，改为使用新的构造函数，并测试</li>
<li>使用内联函数消去设置函数</li>
<li>测试</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = arg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">id</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">id</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._id = arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> martin = <span class="keyword">new</span> Person();</span><br><span class="line">martin.name = <span class="string">&quot;martin&quot;</span>;</span><br><span class="line">martin.id = <span class="string">&quot;1234&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = arg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">id</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> martin = <span class="keyword">new</span> Person(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">martin.name = <span class="string">&quot;martin&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="以工厂函数取代构造函数"><a href="#以工厂函数取代构造函数" class="headerlink" title="以工厂函数取代构造函数"></a>以工厂函数取代构造函数</h4><blockquote>
<p>动机：与一般函数相比，构造函数常有一些丑陋的局限性，只能返回当前所调用类的实例，构造函数名称是固定的类名，需要通过特殊操作符调用。工厂函数的实现内部可以调用构造函数，也可以换别的方式实现。</p>
</blockquote>
<ol>
<li>新建一个工厂函数，让它调用现有的构造函数</li>
<li>将调用构造函数的代码替换为工厂函数</li>
<li>每次修改，执行测试</li>
<li>尽量缩小构造函数可见范围</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, typeCode</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">    <span class="built_in">this</span>._typeCode = typeCode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">type</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> Employee.legalTypeCodes[<span class="built_in">this</span>._typeCode];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> <span class="title">legalTypeCodes</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">E</span>: <span class="string">&quot;Engineer&quot;</span>, <span class="attr">M</span>: <span class="string">&quot;Manager&quot;</span>, <span class="attr">S</span>: <span class="string">&quot;Salesman&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> candidate = <span class="keyword">new</span> Employee(<span class="built_in">document</span>.name, <span class="built_in">document</span>.empType);</span><br><span class="line"><span class="keyword">const</span> leadEngineer = <span class="keyword">new</span> Employee(<span class="built_in">document</span>.leadEngineer, <span class="string">&quot;E&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, typeCode</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">    <span class="built_in">this</span>._typeCode = typeCode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">type</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> Employee.legalTypeCodes[<span class="built_in">this</span>._typeCode];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> <span class="title">legalTypeCodes</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">E</span>: <span class="string">&quot;Engineer&quot;</span>, <span class="attr">M</span>: <span class="string">&quot;Manager&quot;</span>, <span class="attr">S</span>: <span class="string">&quot;Salesman&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEmployee</span>(<span class="params">name, typeCode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Employee(name, typeCode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> candidate = createEmployee(<span class="built_in">document</span>.name, <span class="built_in">document</span>.empType);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEngineer</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Employee(name, <span class="string">&quot;E&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> leadEngineer = createEngineer(<span class="built_in">document</span>.leadEngineer);</span><br></pre></td></tr></table></figure>

<h4 id="以命令取代函数"><a href="#以命令取代函数" class="headerlink" title="以命令取代函数"></a>以命令取代函数</h4><blockquote>
<p>动机：将函数封装成自己的对象，称为“命令对象”，简称“命令”，只服务于单一函数，获得对该函数的请求，执行函数。</p>
</blockquote>
<ol>
<li>为想要包装的函数创建一个空类，根据该函数名字命名</li>
<li>把函数移动到空类里</li>
<li>给每个参数创建一个字段，并在构造函数中添加对应的参数</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">score</span>(<span class="params">candidate, medicalExam, scoringGuide</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> healthLevel = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> highMedicalRiskFlag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (medicalExam.isSmoker) &#123;</span><br><span class="line">    healthLevel += <span class="number">10</span>;</span><br><span class="line">    highMedicalRiskFlag = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> certificationGrade = <span class="string">&quot;regular&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (scoringGuide.stateWithLowCertification(candidate.originState)) &#123;</span><br><span class="line">    certificationGrade = <span class="string">&quot;low&quot;</span>;</span><br><span class="line">    result -= <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// lots more code like this</span></span><br><span class="line">  result -= <span class="built_in">Math</span>.max(healthLevel - <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">score</span>(<span class="params">candidate, medicalExam, scoringGuide</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Scorer().execute(candidate, medicalExam, scoringGuide);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scorer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">candidate, medicalExam, scoringGuide</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._candidate = candidate;</span><br><span class="line">    <span class="built_in">this</span>._medicalExam = medicalExam;</span><br><span class="line">    <span class="built_in">this</span>._scoringGuide = scoringGuide;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">execute</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>._healthLevel = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>._highMedicalRiskFlag = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.this.scoreSmoking();</span><br><span class="line">    <span class="built_in">this</span>._certificationGrade = <span class="string">&quot;regular&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="built_in">this</span>._scoringGuide.stateWithLowCertification(<span class="built_in">this</span>._candidate.originState)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="built_in">this</span>._certificationGrade = <span class="string">&quot;low&quot;</span>;</span><br><span class="line">      <span class="built_in">this</span>._result -= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// lots more code like this</span></span><br><span class="line">    <span class="built_in">this</span>._result -= <span class="built_in">Math</span>.max(healthLevel - <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">scoreSmoking</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._medicalExam.isSmoker) &#123;</span><br><span class="line">      <span class="built_in">this</span>._healthLevel += <span class="number">10</span>;</span><br><span class="line">      <span class="built_in">this</span>._highMedicalRiskFlag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="以函数取代命令"><a href="#以函数取代命令" class="headerlink" title="以函数取代命令"></a>以函数取代命令</h4><blockquote>
<p>动机：借助命令对象可以轻松地将原本复杂的函数拆解为多个方法，彼此间通过字段共享状态，拆解后的方法分别调用，开始调用前的数据状态也可以逐步构建。但如果这个函数不太复杂，可以考虑将其变回普通函数</p>
</blockquote>
<ol>
<li>把“创建并执行命令对象”的代码单独提炼到一个函数中</li>
<li>对命令对象在执行阶段调用到的函数，逐一使用内联函数</li>
<li>把构造函数的参数转移到执行函数声明中</li>
<li>执行函数中引用的所有字段改为使用参数，并测试</li>
<li>把“调用构造函数”和“调用执行函数”都内联到调用方</li>
<li>测试</li>
<li>把命令类删除</li>
</ol>
<p>Before:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChargeCalculator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">customer, usage, provider</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._customer = customer;</span><br><span class="line">    <span class="built_in">this</span>._usage = usage;</span><br><span class="line">    <span class="built_in">this</span>._provider = provider;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">baseCharge</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._customer.baseRate * <span class="built_in">this</span>._usage;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">charge</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.baseCharge + <span class="built_in">this</span>._provider.connectionCharge;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">charge</span>(<span class="params">customer, usage, provider</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> baseCharge = customer.baseRate * usage;</span><br><span class="line">  <span class="keyword">return</span> baseCharge + provider.connectionCharge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>分析设计分类导航</title>
    <url>/2020/12/30/%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1%E5%88%86%E7%B1%BB%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<p>作为设计师，在拿到设计需求后，不要着急做需求，先分析需求，且在思考设计视觉时一定记得从业务本身的属性出发，多跟运营以及产品沟通，分析挖掘到更多的潜在需求，才能从根本上解决问题，设计出符合产品调性的页面。</p>
<p>一般说来，在电商购物类的app中，用户想要到达商品详情页的路径有以下3种：</p>
<ul>
<li>通过搜索直达商品列表；</li>
<li>通过分类导航页触达；</li>
<li>通过一些资源位（例如：banner、活动专区、坑位入口等）进入专区商品列表；</li>
</ul>
<p>这三种路径基本上就涵盖了用户购物的的3种心态：</p>
<ul>
<li>通过搜索直达商品列表：可以有效满足用户明确知道自己要买哪个具体商品的需求；</li>
<li>通过分类导航页直达商详页：可以有效满足用户明确自己要买哪类商品但不知道具体要买哪个商品的需求；</li>
<li>通过资源位直达商品列表：可以满足用户逛逛的心态。</li>
</ul>
<h3 id="分类导航入口"><a href="#分类导航入口" class="headerlink" title="分类导航入口"></a>分类导航入口</h3><p>产品用户群体不一样、业务属性不一样，分类导航页的入口也不同。京东的用户群体一般都目标明确，购买力强，所以京东的分类导航页入口在底部导航处，可随时切换触达目标商品。而淘宝和考拉的用户是属于闲逛型的，不知道自己想买哪些商品，所以它们分类导航页的入口设置在金刚区最后边；就我自己而言，京东的分类导航页我的使用率高于淘宝和考拉的。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/158630/9/757/406744/5fec48e1Ec1b3de72/01a2f2cb91954f2c.png" alt="购物电商的分类导航"></p>
<h3 id="为什么要做分类导航"><a href="#为什么要做分类导航" class="headerlink" title="为什么要做分类导航"></a>为什么要做分类导航</h3><p>分类是把商品按照固有属性、适用人群、使用场景等座位区分标准，把符合统一标准的商品归类，提高查找商品效率的一种手段。</p>
<p>按照分类查找商品是人类最常用到的一种思维方式和习惯，这种习惯主要来源于人们在线下购物的方式。线下商场的商品都是实体的，需要占用三维的物理空间，无法像在网上一样可以通过搜索把商品相关信息展现在用户的眼前，商品是不会动的，用户需要改变自己的地理位置去走到商品所在位置，才能拿到商品，为了能够让用户快速找到自己的商品，商场就会按照一定的标准给商品分类，符合同类标准的商品会放在同一片区域，百货商场里面1楼是化妆品、2楼是女装、3楼男装、4楼箱包、5楼文体用品等，在电商刚兴起的时候，PC端的网站就是很大程度上借鉴了线下楼层的这种概念。</p>
<p>由于线下购物习惯的存在，分类导航始终是用户查找商品的一个重要入口，如何更高效的利用分类导航带来更多的成交，这是在电商app设计中不可忽略的一个课题。经过一些用户调研发现，用户在明确自己要买的商品大类但不知道具体商品型号的时候，90%的用户会通过类目去查找商品。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>设想一个使用场景，用户想买一些水果，但不知道具体买哪一种。我们来看看各大app都是怎么做的？如果通过类目导航查找，在生鲜/水果的类目下会有多种水果的种类帮助用户做出选择，京东还在三级类目上增加一个活动小banner，这样用户又会多一种选择，达到引流效果。经过三级类目的引导，用户可以轻易选择买哪个品类的零食；假如用户通过搜索路径，在“水果”的搜索结果页，京东在顶部还增加了一个分类展示，企图通过分类引导的方式帮助用户快速完成任务。毕竟淘宝和京东这种全品类的大型电商app大品类很多，可能在细小分类上就没有那么详细，反观美团买菜这种专门的生鲜app在分类导航上有更多细小的分类，除了能快速触达，还能快速加购。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/162975/27/49/784639/5fec48e4Ec8d5780f/082f8f0873396d83.png" alt="水果的分类导航"></p>
<h3 id="页面设计"><a href="#页面设计" class="headerlink" title="页面设计"></a>页面设计</h3><p>在分类页面的设计样式上，基本上都采用了标签＋盒子的形式，只不过标签的样式采用了横式和竖式。一级类目数量不是很多的情况下，可以优先考虑横式标签样式，这样能够把更多的空间留给二级类目；在一级类目数量比较多的情况下，建议采用竖式标签的样式，这样方便用户快捷的进行一级类目的查找。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/164730/12/46/722041/5fec48e0E285f2235/6332b5d2cb3dd7f7.png" alt="分类页设计"></p>
<p>在一些商品数量还不是很庞大的购物app上，大部分的会在首页的顶部栏额外增加一个标签式的分类导航，提升分类导航的层级，更好的引导用户利用分类导航去找到自己想要的商品，由于每个二级分类的商品数量不是很多，可以把多个二级类目的商品全部排列在一级类目的标签页下面（仅通过滑动就可以切换到下一个类目），降低了用户的二级类目切换成本，提升用户逛的沉浸感，增加商品成交量。</p>
<h3 id="品牌因素"><a href="#品牌因素" class="headerlink" title="品牌因素"></a>品牌因素</h3><p>随着消费水平的提高，品牌因素对用户选购商品会占有越来越大的比重，按照品牌来分类也越来越多的出现在购物类的app中，如图中左边的例子，可以直接通过品牌列表来查找自己要找的品牌；右边的例子在一级类目下面集成了品牌推荐，这也是对用户思路的一种引导方式。但现在品牌种类太多了，我觉得反而左边的品牌列表在选择品牌上更便捷。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/160261/1/697/465264/5fec48e2E30cf8cce/3d4bfcee09619de8.png" alt="品牌列表"></p>
<p>经过上面的案例可以看出来：</p>
<ul>
<li>类目导航最高效的适用场景是：用户有购物欲望，但无法确定所要购买具体商品型号；</li>
<li>按照商品属性分类仅仅是类目导航的一个基本的维度，我们还可以尝试从使用场景、使用人群、品牌、个性推荐等维度进行更多的分类尝试，以便覆盖更多的用户场景；</li>
<li>在类目导航页增加类目运营活动是提高转化率的一个有效手段，值得尝试；</li>
<li>要考虑好上下文的关系，点击二级类目进入到商品列表以后，较为合理的筛选与排序操作就是必不可少的动作了。</li>
</ul>
<p>所以在做设计时一定记得从业务本身的属性出发，从根本上解决问题。</p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>前端动画详解</title>
    <url>/2020/04/30/%E5%89%8D%E7%AB%AF%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="动画的多种实现方式与性能对比"><a href="#动画的多种实现方式与性能对比" class="headerlink" title="动画的多种实现方式与性能对比"></a>动画的多种实现方式与性能对比</h2><p>首先我们来了解一下Web有哪些动画形式</p>
<ol>
<li><strong>CSS3动画</strong>  </li>
</ol>
<ul>
<li>Transform（变形）  </li>
<li>Transition（过渡）  </li>
<li>Animation（动画）  </li>
</ul>
<ol start="2">
<li><strong>JS动画（操作DOM、修改CSS属性值）</strong>  </li>
<li><strong>Canvas动画</strong>   </li>
<li><strong>SVG动画</strong>   </li>
<li><strong>以Three.js为首的3D动画</strong> </li>
</ol>
<p>以上各种动画形式都可以制作出一种类型的动画，那就是帧动画，帧动画的实现原理是不断切换视觉内图片内容，利用视觉滞留生理现象来实现连续播放的动画效果  </p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>帧动画一般用来实现稍微复杂一点的动画效果，同时希望动画更细腻，设计师更自由的发挥。他可以定义到每一个时间刻度上的展现内容，我们一般用帧动画来做页面的Loading，小人物，小物体元素的简单动画。我们想象中的帧动画应该有以下几个特点：<br>     1. 可以自由控制播放、暂停和停止<br>     2. 可以控制播放次数，播放速度<br>     3. 可以添加交互，在播放完成后添加事件<br>     4. 浏览器兼容性好  </p>
<h2 id="GIF图"><a href="#GIF图" class="headerlink" title="GIF图"></a>GIF图</h2><p>我们可以将上面制作的帧动画导出成GIF图，GIF图会连续播放，无法暂停，它往往用来实现小细节动画，成本较低、使用方便。但其缺点也是很明显的：</p>
<p>画质上，gif 支持颜色少(最大256色)、Alpha 透明度支持差，图像锯齿毛边比较严重； </p>
<p>交互上，不能直接控制播放、暂停、播放次数，灵活性差；</p>
<p>性能上，gif 会引起页面周期性的绘画，性能较差。 </p>
<p>兼容性，gif几乎所有浏览器都能够兼容</p>
<h2 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h2><p>CSS3动画是我们今天需要重点介绍的方案，最核心的是利用CSS3中Animation动画，确切的说是使用animation-timing-function 的阶梯函数 steps(number_of_steps, direction) 来实现逐帧动画的连续播放。</p>
<p>###（1）连续切换动画图片地址src（不推荐）</p>
<p>我们将图片放到元素的背景中（background-image），通过更改 background-image 的值实现帧的切换。但是这种方式会有以下几个缺点，所以该方案不推荐。</p>
<p>多张图片会带来多个 HTTP 请求<br>每张图片首次加载会造成图片切换时的闪烁<br>不利于文件的管理</p>
<h3 id="连续切换雪碧图位置（推荐）"><a href="#连续切换雪碧图位置（推荐）" class="headerlink" title="连续切换雪碧图位置（推荐）"></a>连续切换雪碧图位置（推荐）</h3><p>我们将所有的帧动画图片合并成一张雪碧图，通过改变 background-position 的值来实现动画帧切换。分两步进行：</p>
<p>写法一： 将动画帧合并为雪碧图，比如下面这张帧动画雪碧图，共20帧。</p>
<p>写法二： 使用steps阶梯函数切换雪碧图位置</p>
<p><strong>先看写法一：</strong></p>
<pre><code>&lt;div class=&quot;sprite&quot;&gt;&lt;/div&gt;

.sprite &#123;
    width: 300px;
    height: 300px;
    background-repeat: no-repeat;
    background-image: url(frame.png);
    animation: frame 333ms steps(1,end) both infinite;
&#125;
@keyframes frame &#123;
    0% &#123;background-position: 0 0;&#125;
    5% &#123;background-position: -300px 0;&#125;
    10% &#123;background-position: -600px 0;&#125;
    15% &#123;background-position: -900px 0;&#125;
    ...
    90% &#123;background-position: -5400px 0;&#125;
    95% &#123;background-position: -5700px 0;&#125;
    100% &#123;background-position: -6000px 0;&#125;
&#125;
</code></pre>
<p>问题一：既然都详细定义关键帧了，是不是可以不用steps函数了，直接定义linear变化不就好了吗？</p>
<p>animation: frame 10s linear both infinite;</p>
<p>如果我们定义成这样，动画是不会阶梯状，一步一步执行的，而是会连续的变化背景图位置，是移动的效果，而不是切换的效果。<br>查看效果：<a href="https://user-gold-cdn.xitu.io/2019/3/3/16943ad82d6f8f5d?w=333&amp;h=305&amp;f=gif&amp;s=446114">https://user-gold-cdn.xitu.io/2019/3/3/16943ad82d6f8f5d?w=333&amp;h=305&amp;f=gif&amp;s=446114</a></p>
<p>这里我们先来了解下animation-timing-function属性。</p>
<p>CSS animation-timing-function属性定义CSS动画在每一动画周期中执行的节奏。对于关键帧动画来说，timing function作用于一个关键帧周期而非整个动画周期，即从关键帧开始开始，到关键帧结束结束。</p>
<p>timing-function 作用于每两个关键帧之间，而不是整个动画。</p>
<p>接着我们来了解下steps() 函数：</p>
<p>steps 函数指定了一个阶跃函数，它接受两个参数。<br>第一个参数接受一个整数值，表示两个关键帧之间分几步完成。<br>第二个参数有两个值&lt; start &gt; or &lt; end &gt;。默认值为&lt; end &gt; 。<br>step-start 等同于 step(1, start)。step-end 等同于 step(1, end)。<br>综上我们可以知道，因为我们详细定义了一个关键帧周期，从开始到结束，每两个关键帧之间分 1 步展示完，也就是说0% ~ 5%之间变化一次，5% ~ 10%变化一次，所以我们这样写才能达到想要的效果。</p>
<p><strong>再看写法二：</strong></p>
<pre><code>&lt;div class=&quot;sprite&quot;&gt;&lt;/div&gt;

.sprite &#123;
    width: 300px;
    height: 300px;
    background-repeat: no-repeat;
    background-image: url(frame.png);
    animation: frame 333ms steps(20) both infinite;
&#125;
@keyframes frame &#123;
    0% &#123;background-position: 0 0;&#125;//可省略
    100% &#123;background-position: -6000px 0;&#125;
&#125;
</code></pre>
<p>这里我们定义了关键帧的开始和结束，也就是定义了一个关键帧周期，但因为我们没有详细的定义每一帧的展示，所以我们要将0%~100%这个区间分成20步来阶段性展示。</p>
<p>也可以换成关键字的写法，还可以只定义最后一帧，因为默认第一帧就是初始位置。</p>
<h3 id="连续移动雪碧图位置（移动端推荐）"><a href="#连续移动雪碧图位置（移动端推荐）" class="headerlink" title="连续移动雪碧图位置（移动端推荐）"></a>连续移动雪碧图位置（移动端推荐）</h3><p>跟第二种基本一致，只是切换雪碧图的位置过程换成了transform:translate3d()来实现，不过要加多一层overflow: hidden;的容器包裹，这里我们以只定义初始和结束帧为例，使用transform可以开启GPU加速，提高机器渲染效果，还能有效解决<a href="https://aotu.io/notes/2017/08/14/fix-sprite-anim/index.html">移动端帧动画抖动</a>问题。  </p>
<pre><code>&lt;div class=&quot;sprite-wp&quot;&gt;
    &lt;div class=&quot;sprite&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

.sprite-wp &#123;
    width: 300px;
    height: 300px;
    overflow: hidden;
&#125;
.sprite &#123;
    width: 6000px;
    height: 300px;
    will-change: transform;
    background: url(frame.png) no-repeat center;
    animation: frame 333ms steps(20) both infinite;
&#125;
@keyframes frame &#123;
    0% &#123;transform: translate3d(0,0,0);&#125;
    100% &#123;transform: translate3d(-6000px,0,0);&#125;
&#125;
</code></pre>
<h2 id="JS帧动画"><a href="#JS帧动画" class="headerlink" title="JS帧动画"></a>JS帧动画</h2><h3 id="通过JS来控制img的src属性切换（不推荐）"><a href="#通过JS来控制img的src属性切换（不推荐）" class="headerlink" title="通过JS来控制img的src属性切换（不推荐）"></a>通过JS来控制img的src属性切换（不推荐）</h3><p>和上面CSS3帧动画里面切换元素background-image属性一样，会存在多个请求等问题，所以该方案我们不推荐，但是这是一种解决思路。</p>
<h3 id="通过JS来控制Canvas图像绘制"><a href="#通过JS来控制Canvas图像绘制" class="headerlink" title="通过JS来控制Canvas图像绘制"></a>通过JS来控制Canvas图像绘制</h3><p>通过Canvas制作帧动画的原理是用drawImage方法将图片绘制到Canvas上，不断擦除和重绘就能得到我们想要的效果（Vue放大镜插件就是基于这个原理）。</p>
<pre><code>&lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;

(function () &#123;
    var timer = null,
    canvas = document.getElementById(&quot;canvas&quot;),
    context = canvas.getContext(&#39;2d&#39;),
    img = new Image(),
    width = 300,
    height = 300,
    k = 20,
    i = 0;
    img.src = &quot;frame.png&quot;;

    function drawImg() &#123;
        context.clearRect(0, 0, width, height);
        i++;
        if (i == k) &#123;
            i = 0;
        &#125;
        context.drawImage(img, i * width, 0, width, height, 0, 0, width, height);
        window.requestAnimationFrame(drawImg);
    &#125;
    img.onload = function () &#123;
        window.requestAnimationFrame(drawImg);
    &#125;
&#125;)();
</code></pre>
<p>上面是通过改变裁剪图像的X坐标位置来实现动画效果的，也可以通过改变画布上放置图像的坐标位置实现，如下：<br>context.drawImage(img, 0, 0, width<em>k, height,-i</em>width,0,width*k,height);。</p>
<h3 id="通过JS来控制CSS属性值变化"><a href="#通过JS来控制CSS属性值变化" class="headerlink" title="通过JS来控制CSS属性值变化"></a>通过JS来控制CSS属性值变化</h3><p>这种方式和前面CSS3帧动画一样，有三种方式，一种是通过JS切换元素背景图片地址background-image，一种是通过JS切换元素背景图片定位background-position，最后一种是通过JS移动元素transform:translate3d()，第一种不做介绍，因为同样会存在多个请求等问题，不推荐使用，这里实现后面两种。</p>
<p>切换元素背景图片位置 background-position</p>
<pre><code>    .sprite &#123;
width: 300px;
height: 300px;
background: url(frame.png) no-repeat 0 0;
&#125;

&lt;div class=&quot;sprite&quot; id=&quot;sprite&quot;&gt;&lt;/div&gt;

(function()&#123;
var sprite = document.getElementById(&quot;sprite&quot;),
    picWidth = 300,
    k = 20,
    i = 0,
    timer = null;
// 重置背景图片位置
sprite.style = &quot;background-position: 0 0&quot;;
// 改变背景图位置
function changePosition()&#123;
sprite.style = &quot;background-position: &quot;+(-picWidth*i)+&quot;px 0&quot;;
i++;
if(i == k)&#123;
i = 0;
&#125;
window.requestAnimationFrame(changePosition);
&#125;
window.requestAnimationFrame(changePosition);
&#125;)();
移动元素背景图片位置 transform:translate3d()
.sprite-wp &#123;
   width: 300px;
height: 300px;
overflow: hidden;
&#125;
.sprite &#123;
width: 6000px;
height: 300px;
will-change: transform;
background: url(frame.png) no-repeat center;
&#125;

&lt;div class=&quot;sprite-wp&quot;&gt;
&lt;div class=&quot;sprite&quot; id=&quot;sprite&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

(function () &#123;
var sprite = document.getElementById(&quot;sprite&quot;),
picWidth = 300,
k = 20,
i = 0,
timer = null;
// 重置背景图片位置
sprite.style = &quot;transform: translate3d(0,0,0)&quot;;
// 改变背景图移动
function changePosition() &#123;
sprite.style = &quot;transform: translate3d(&quot; + (-picWidth * i) + &quot;px,0,0)&quot;;
i++;
if (i == k) &#123;
i = 0;
&#125;
window.requestAnimationFrame(changePosition);
&#125;
window.requestAnimationFrame(changePosition);
&#125;)();
</code></pre>
<h2 id="方案总结"><a href="#方案总结" class="headerlink" title="方案总结"></a><strong>方案总结</strong></h2><p>总结以上几种方案，我们可以看到GIF图有一定的优点同时缺点和局限性也比较明显，所以这种方案看情况选择使用。</p>
<p>其他实现方案的性能如何呢，我们来比较一下，如果测试结果出现偏差，可能与测试环境变化有关。</p>
<p>通过分析以上数据我们可以得出以下几点：</p>
<p>除了css transform:translate3d() 方案，其他方案的FPS都能达到60FPS的流畅程度，但该方案的FPS也不是很低。</p>
<p>CPU占用率最低的方案是 css transform:translate3d() 方案。<br>GPU占用最低的方案是 JS Canvas 绘制方案。<br>CSS 方案没有脚本开销  </p>
<p>Rendering 最少的是 css transform:translate3d() 方案。<br>Painting 最少的是 css transform:translate3d() 方案。<br>各方案内存占用区别不大。 </p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>我们看到，在7个指标中，css transform:translate3d() 方案将其中的4个指标做到了最低，从这点看，我们完全有理由选择这种方案来实现CSS帧动画。 </p>
<p>至于其他方案的绝对比较暂时没法给出结论，看具体情况来选择，也看开发者对哪个性能指标的追求。</p>
<p>延伸来看我们的Web动画，每种形式的动画都有其各自的有点，比如大量的粒子效果用Canvas绘制方案肯定要比DOM+CSS实现要好的，大量的CSS属性值变换，使用 transform 实现性能是要更好的。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><p>1.素材：动画图片宽高最好是偶数，总帧数最好是偶数，图片拼接处最好有一定的留白。</p>
<p>2.适配：移动端适配最好不用rem，因为rem的计算会造成小数四舍五入，造成一定的抖动效果，建议直接用px作为单位，同时辅助以scale（zoom）媒体查询进行适配。如果使用rem适配，试试使用transform的方案，抖动问题可以得到优化解决。</p>
<p>对于帧与帧之间的盈亏互补现象导致动画抖动，想要了解更多，可以阅读《CSS技巧：逐帧动画抖动解决方案》。</p>
<p>tips：使用 will-change 可以在元素属性真正发生变化之前提前做好对应准备。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本文我们主要梳理了目前实现帧动画的几种方案，同时对各种方案进行效果实现，优劣讨论，性能对比，同时简单介绍了帧动画实现过程的注意事项，最后我们得出结论，css transform:translate3d() 方案在实现和性能上都明显优于其他方案。  </p>
<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a><strong>参考来源</strong></h2><p><a href="https://aotu.io/notes/2016/05/17/css3-animation-frame/index.html">《CSS3动画之逐帧动画》</a></p>
]]></content>
      <categories>
        <category>动画</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>前端图片水印的2种方式</title>
    <url>/2021/09/23/%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%E6%B0%B4%E5%8D%B0%E7%9A%842%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>为了防止信息泄露或知识产权被侵犯，在web的世界里，对于图片文档等增加水印处理是十分有必要的。水印的添加根据环境可以分为两大类，前端浏览器环境添加和后端服务环境添加。</p>
<p><strong>前端浏览器加水印：</strong></p>
<blockquote>
<p>减轻服务端的压力，快速反应<br>安全系数较低，对于掌握一定前端知识的人来说可以通过各种骚操作跳过水印获取到源文件<br>适用场景：资源不跟某一个单独的用户绑定，而是一份资源，多个用户查看，需要在每一个用户查看的时候添加用户特有的水印，多用于某些机密文档或者展示机密信息的页面，水印的目的在于文档外流的时候可以追究到责任人</p>
</blockquote>
<p><strong>后端服务器加水印：</strong></p>
<blockquote>
<p>当遇到大文件密集水印，或是复杂水印，占用服务器内存、运算量，请求时间过长<br>安全性高，无法获取到加水印前的源文件<br>适用场景：资源为某个用户独有，一份原始资源只需要做一次处理，将其存储之后就无需再次处理，水印的目的在于标示资源的归属人</p>
</blockquote>
<p>重点来看看前端加水印的方式：</p>
<h3 id="1、Canvas-生成水印"><a href="#1、Canvas-生成水印" class="headerlink" title="1、Canvas 生成水印"></a>1、Canvas 生成水印</h3><p>canvas 有着不错的兼容性，是一种比较可靠、成熟的可视化技术。但是它比较依赖分辨率，对文本的处理上也有着先天的不足。但是它可以很方便的将结果保存为图片，对于完成水印的需求也是非常合适的。</p>
<p>为了方便使用者上手，我将所有的实现坐标都设置为top/left，以方便对x、y的设置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CanvasWay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">watermark</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.watermark = watermark</span><br><span class="line">        <span class="keyword">const</span> &#123;width, height&#125; = watermark</span><br><span class="line">        <span class="built_in">this</span>.canvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.canvas.setAttribute(<span class="string">&#x27;width&#x27;</span>, width);</span><br><span class="line">        <span class="built_in">this</span>.canvas.setAttribute(<span class="string">&#x27;height&#x27;</span>, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;txt, x, y, width, height, font, color, fontSize, alpha, angle&#125; = <span class="built_in">this</span>.watermark</span><br><span class="line">        <span class="keyword">const</span> ctx = <span class="built_in">this</span>.canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">        ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        ctx.textBaseline = <span class="string">&#x27;top&#x27;</span>;</span><br><span class="line">        ctx.textAlign = <span class="string">&#x27;left&#x27;</span></span><br><span class="line">        ctx.fillStyle = color;</span><br><span class="line">        ctx.globalAlpha = alpha;</span><br><span class="line">        ctx.font = <span class="string">`<span class="subst">$&#123;fontSize&#125;</span>px <span class="subst">$&#123;font&#125;</span>`</span></span><br><span class="line">        ctx.translate(x, y)</span><br><span class="line">        ctx.rotate(<span class="built_in">Math</span>.PI / <span class="number">180</span> * angle);</span><br><span class="line">        ctx.translate(-x, -y - fontSize)</span><br><span class="line">        ctx.fillText(txt, x, y + fontSize);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.canvas.toDataURL();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、SVG-生成方式"><a href="#2、SVG-生成方式" class="headerlink" title="2、SVG 生成方式"></a>2、SVG 生成方式</h3><p>svg 与 canvas 相比浏览器兼容性几乎一致，除了几个早起的 Android 版本，这样的设备以及很难找到了，完全可以忽略。svg 使用的是 XML 的方式，不依赖分辨率，在做水印这件事上 svg 有着更好的优势。</p>
<p>svg 的 text 属性 x、y，是将文本左下位置定位到其坐标系的(x,y)位置，这可能和日常写 css 的定位不同，所有需要有一个 dy 值，设置其偏移量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SvgWay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">watermark</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.watermark = watermark</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;txt, x, y, width, height, color, font, fontSize, alpha, angle&#125; = <span class="built_in">this</span>.watermark</span><br><span class="line">        <span class="keyword">const</span> svgStr =</span><br><span class="line">            <span class="string">`&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;<span class="subst">$&#123;width&#125;</span>px&quot; height=&quot;<span class="subst">$&#123;height&#125;</span>px&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;text x=&quot;<span class="subst">$&#123;x&#125;</span>px&quot; y=&quot;<span class="subst">$&#123;y&#125;</span>px&quot; dy=&quot;<span class="subst">$&#123;fontSize&#125;</span>px&quot;</span></span><br><span class="line"><span class="string">                    text-anchor=&quot;start&quot;</span></span><br><span class="line"><span class="string">                    stroke=&quot;<span class="subst">$&#123;color&#125;</span>&quot;</span></span><br><span class="line"><span class="string">                    stroke-opacity=&quot;<span class="subst">$&#123;alpha&#125;</span>&quot;</span></span><br><span class="line"><span class="string">                    fill=&quot;none&quot;</span></span><br><span class="line"><span class="string">                    transform=&quot;rotate(<span class="subst">$&#123;angle&#125;</span>,<span class="subst">$&#123;x&#125;</span> <span class="subst">$&#123;y&#125;</span>)&quot;</span></span><br><span class="line"><span class="string">                    font-weight=&quot;100&quot;</span></span><br><span class="line"><span class="string">                    font-size=&quot;<span class="subst">$&#123;fontSize&#125;</span>&quot;</span></span><br><span class="line"><span class="string">                    font-family=&quot;<span class="subst">$&#123;font&#125;</span>&quot;</span></span><br><span class="line"><span class="string">                    &gt;</span></span><br><span class="line"><span class="string">                    <span class="subst">$&#123;txt&#125;</span></span></span><br><span class="line"><span class="string">                &lt;/text&gt;</span></span><br><span class="line"><span class="string">            &lt;/svg&gt;`</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`data:image/svg+xml;base64,<span class="subst">$&#123;<span class="built_in">window</span>.btoa(<span class="built_in">unescape</span>(<span class="built_in">encodeURIComponent</span>(svgStr)))&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>安全问题不能大意，对于一些比较敏感的内容，我们可以通过组合使用上述的水印方案，这样才能最大程度给浏览者警示的作用，减少泄密的情况，即使泄密了,也有可能追踪到泄密者。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>水印</tag>
      </tags>
  </entry>
  <entry>
    <title>图片根据容器的大小自适应</title>
    <url>/2020/11/01/%E5%9B%BE%E7%89%87%E6%A0%B9%E6%8D%AE%E5%AE%B9%E5%99%A8%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%87%AA%E9%80%82%E5%BA%94/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>开发中，经常会遇到让图片自适应容器大小的场景，有时候图片尺寸和比列是不确定的。若只是简单的把图片的长和高设置为100%，可能会出现图片失真的情况。以下几种方法可实现图片根据容器的大小自适应。</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/135432/8/14454/373974/5f9fae16Eca3526cf/bb8c5e3ebf211578.png" alt="图片1.png"></p>
<h3 id="第一种：通过max-width和max-height"><a href="#第一种：通过max-width和max-height" class="headerlink" title="第一种：通过max-width和max-height"></a>第一种：通过max-width和max-height</h3><p>将图片的 max-width 和 max-height 设置成100%</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.img-box__img1</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法最为简单，但有一个缺点是，当图片尺寸较小或容器过大时，图片的长边和短边都无法填满容器，如下图所示：</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/144921/16/12879/68199/5f9ea92eE290cda3e/df1f085a97fac5c0.png" alt="图片2.png"></p>
<h3 id="第二种：通过背景图的方式"><a href="#第二种：通过背景图的方式" class="headerlink" title="第二种：通过背景图的方式"></a>第二种：通过背景图的方式</h3><p>图片以背景图的形式展示，利用 background-size 属性，将其设置为 contain，在保持图片宽高比的前提下缩放图片，保证把图片扩展至最大尺寸，以使其宽度和高度完全适应内容区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.img-box__img2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;https://img11.360buyimg.com/da/s800x800_jfs/t1/114578/23/16885/259767/5f51b88eE470cb092/6edf1a51c836efc3.jpg&#x27;</span>) no-repeat center/contain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>backgrount-image 没有任何语义，导致搜索引擎不会识别背景图也不会抓取背景图，不利于搜索引擎优化；且背景图会在页面加载完成之后才开始加载。<br>_注：图片以背景图形式展示还是以 img 标签形式展示？  </p>
<ul>
<li>img标签有alt和title等属性，有利于搜索引擎识别图片；若图片想让搜索引擎抓取到，比如广告图、产品图或logo，建议使用img标签；</li>
<li>仅作为页面装饰效果的图片，比如小图标之类的，建议使用 backgrount-image</li>
</ul>
<h3 id="第三种：通过-padding-bottom-的方式"><a href="#第三种：通过-padding-bottom-的方式" class="headerlink" title="第三种：通过 padding-bottom 的方式"></a>第三种：通过 padding-bottom 的方式</h3><p>在css中，当padding-top、padding-bottom、margin-top 或 margin-bottom 取值为百分比的时候，参照的是父元素的宽度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-box__inner&quot;</span>&gt;</span></span><br><span class="line">      &lt;img</span><br><span class="line">        class=&quot;img-box__img3&quot;</span><br><span class="line">        src=&quot;https://img11.360buyimg.com/da/s800x800_jfs/t1/114578/23/16885/259767/5f51b88eE470cb092/6edf1a51c836efc3.jpg&quot; alt=&quot;京东房产&quot; /&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.img-box__inner</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.img-box__img3</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用 padding-bottom 的方式，当图片的高度过大时，若是容器的高度固定，且设置为 overflow: hidden，图片会被裁剪，如下图所示：</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/133035/34/14530/287657/5f9fbc63Ecc2b2a5b/ce79e9f93733905e.png" alt="图片3.png">  </p>
<p>想要实现的效果，其实是：  </p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/150799/1/5210/205530/5f9fbc63E8175b11e/8d322b2668452ce0.png" alt="图片3.png">  </p>
<p>_注：<br>对于图片等资源，加载是需要时间的，可以通过 padding-bottom 提前占位，避免图片被撑开的过程中，出现闪烁的现象。</p>
<h3 id="第四种：-利用css3属性-gt-object-fit"><a href="#第四种：-利用css3属性-gt-object-fit" class="headerlink" title="第四种： 利用css3属性 -&gt; object-fit"></a>第四种： 利用css3属性 -&gt; object-fit</h3><p>object-fit 属性指定元素的内容应该如何去适应指定容器的高度与宽度，可适用于img和video标签。设置object-fit: contain，可实现图片保持原有尺寸比例，内容被缩放。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.img-box__img4</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">object-fit</span>: contain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第五种：-通过-js-根据容器的大小重新设置图片的大小"><a href="#第五种：-通过-js-根据容器的大小重新设置图片的大小" class="headerlink" title="第五种： 通过 js 根据容器的大小重新设置图片的大小"></a>第五种： 通过 js 根据容器的大小重新设置图片的大小</h3><p>大概思路是，通过 js 分别获取容器与图片的宽和高，算出容器和图片的大小比例，根据比例值，重新设置图片的大小</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第五种： 通过 js 根据容器的大小重新设置图片的大小</span></span><br><span class="line"><span class="keyword">var</span> imgBox = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;imgBox&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> imgDom = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;img5&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> imgBoxWidth = imgBox.offsetWidth <span class="comment">// 获取容器的宽度</span></span><br><span class="line"><span class="keyword">var</span> imgBoxHeight = imgBox.offsetHeight <span class="comment">// 获取容器的高度</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = imgDom.src</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> imgWidth = <span class="built_in">this</span>.width</span><br><span class="line">    <span class="keyword">var</span> imgHeight = <span class="built_in">this</span>.height</span><br><span class="line">    <span class="keyword">var</span> wRatio = imgBoxWidth / imgWidth</span><br><span class="line">    <span class="keyword">var</span> hRatio = imgBoxHeight / imgHeight</span><br><span class="line">    <span class="keyword">var</span> fitRatio = hRatio &lt; wRatio ? hRatio : wRatio <span class="comment">// 得出容器的大小与图片大小的比例</span></span><br><span class="line">    <span class="keyword">var</span> w = <span class="built_in">Math</span>.round(imgWidth * fitRatio)</span><br><span class="line">    <span class="keyword">var</span> h = <span class="built_in">Math</span>.round(imgHeight * fitRatio)</span><br><span class="line">    imgDom.style.width = w + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    imgDom.style.height = h + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    imgDom.style.display = <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这五种方法的完整代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .img-box &#123;</span><br><span class="line"><span class="css">      <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">      <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">      <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#00a495</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="comment">/*第一种：通过max-width和max-height*/</span></span></span><br><span class="line">    .img-box__img1 &#123;</span><br><span class="line"><span class="css">      <span class="attribute">max-width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">max-height</span>: <span class="number">100%</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="comment">/*第二种：通过背景图的方式*/</span></span></span><br><span class="line">    .img-box__img2 &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;https://img11.360buyimg.com/da/s800x800_jfs/t1/114578/23/16885/259767/5f51b88eE470cb092/6edf1a51c836efc3.jpg&#x27;</span>) no-repeat center/contain;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="comment">/*第三种：通过 padding-bottom 的方式*/</span></span></span><br><span class="line">    .img-box__inner &#123;</span><br><span class="line"><span class="css">      <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding-bottom</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .img-box__img3 &#123;</span><br><span class="line"><span class="css">      <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="comment">/*第四种*/</span></span></span><br><span class="line">    .img-box__img4 &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">object-fit</span>: contain;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .img-box__img5 &#123;</span><br><span class="line"><span class="css">      <span class="attribute">display</span>: none;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-box&quot;</span>&gt;</span></span><br><span class="line">  &lt;img</span><br><span class="line">    class=&quot;img-box__img1&quot;</span><br><span class="line">    src=&quot;https://img11.360buyimg.com/da/s800x800_jfs/t1/114578/23/16885/259767/5f51b88eE470cb092/6edf1a51c836efc3.jpg&quot; alt=&quot;京东房产&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-box__img2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-box__inner&quot;</span>&gt;</span></span><br><span class="line">    &lt;img</span><br><span class="line">      class=&quot;img-box__img3&quot;</span><br><span class="line">      src=&quot;https://img11.360buyimg.com/da/s800x800_jfs/t1/114578/23/16885/259767/5f51b88eE470cb092/6edf1a51c836efc3.jpg&quot; alt=&quot;京东房产&quot; /&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-box&quot;</span>&gt;</span></span><br><span class="line">  &lt;img</span><br><span class="line">    class=&quot;img-box__img4&quot;</span><br><span class="line">    src=&quot;https://img11.360buyimg.com/da/s800x800_jfs/t1/114578/23/16885/259767/5f51b88eE470cb092/6edf1a51c836efc3.jpg&quot; alt=&quot;京东房产&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img-box&quot;</span> <span class="attr">id</span>=<span class="string">&quot;imgBox&quot;</span>&gt;</span></span><br><span class="line">  &lt;img</span><br><span class="line">    class=&quot;img-box__img5&quot;</span><br><span class="line">    id=&quot;img5&quot;</span><br><span class="line">    src=&quot;https://img11.360buyimg.com/da/s800x800_jfs/t1/114578/23/16885/259767/5f51b88eE470cb092/6edf1a51c836efc3.jpg&quot; alt=&quot;京东房产&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 第五种： 通过 js 根据容器的大小重新设置图片的大小</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> imgBox = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;imgBox&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> imgDom = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;img5&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> imgBoxWidth = imgBox.offsetWidth <span class="comment">// 获取容器的宽度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> imgBoxHeight = imgBox.offsetHeight <span class="comment">// 获取容器的高度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span></span><br><span class="line">    img.src = imgDom.src</span><br><span class="line"><span class="javascript">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> imgWidth = <span class="built_in">this</span>.width</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> imgHeight = <span class="built_in">this</span>.height</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> wRatio = imgBoxWidth / imgWidth</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> hRatio = imgBoxHeight / imgHeight</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> fitRatio = hRatio &lt; wRatio ? hRatio : wRatio <span class="comment">// 得出容器的大小与图片大小的比例</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> w = <span class="built_in">Math</span>.round(imgWidth * fitRatio)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> h = <span class="built_in">Math</span>.round(imgHeight * fitRatio)</span></span><br><span class="line"><span class="javascript">        imgDom.style.width = w + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="javascript">        imgDom.style.height = h + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="javascript">        imgDom.style.display = <span class="string">&#x27;block&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>样式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>奇妙的CSS shapes</title>
    <url>/2021/03/25/%E5%A5%87%E5%A6%99%E7%9A%84CSS%20shapes/</url>
    <content><![CDATA[<h3 id="传统的实现方式"><a href="#传统的实现方式" class="headerlink" title="传统的实现方式"></a>传统的实现方式</h3><p><strong>三角形</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">5px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">5px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">10px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用透明的border模拟出三角形</p>
</blockquote>
<p><strong>切角</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">135deg</span>, transparent <span class="number">15px</span>, red <span class="number">0</span>) top left;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过角度和透明配合，使用线性渐变实现切角。</p>
</blockquote>
<p><strong>梯形</strong></p>
<ul>
<li>利用伪元素加旋转透视实现梯形<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">20px</span>) <span class="built_in">scaleY</span>(<span class="number">1.3</span>) <span class="built_in">rotateX</span>(<span class="number">5deg</span>);</span><br><span class="line">    <span class="attribute">transform-origin</span>: bottom;</span><br><span class="line">    <span class="attribute">background</span>: yellowgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>perspective 属性设置镜头到元素平面的距离。<strong>perspective 一定要在 rotateY（或 rotateX）的前面</strong> <br><br>transform-origin 规定了镜头在平面上的位置。默认是放在元素的中心</p>
</blockquote>
<ul>
<li>利用border在矩形两侧构造两个透明的三角形<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">60px</span> solid red;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>五边形</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">60px</span> solid red;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">60px</span> solid black;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">70px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">70px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>五边形 = 梯形 + 三角形</p>
</blockquote>
<p><strong>六边形</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">60px</span> solid red;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">60px</span> solid black;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>六边形 = 梯形 + 梯形</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="./%E5%85%AD%E8%BE%B9%E5%BD%A2.png"></p>
<p><strong>八边形</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">30px</span> solid black;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">30px</span> solid red;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>八边形 = 梯形 + 矩形 + 梯形</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="./%E5%85%AB%E8%BE%B9%E5%BD%A2.png"></p>
<p><strong>五角星</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">70px</span> solid red;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">35deg</span>) <span class="built_in">scale</span>(.<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">80px</span> solid black;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">45px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">65px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">35deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">105px</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">70px</span> solid green;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">70deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3个三角形叠加旋转在一起实现</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="./%E4%BA%94%E8%A7%92%E6%98%9F.png"></p>
<p><strong>六角星</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">100px</span> solid black;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个向上的三角形 ▲，叠加上一个向下的三角形 ▼，就可以得到一个六边形</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="./asstes/%E5%85%AD%E8%A7%92%E6%98%9F.png"></p>
<p><strong>八角星</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;div&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用两个矩形进行旋转拼接</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="./%E5%85%AB%E8%A7%92%E6%98%9F.png"></p>
<p><strong>十二角星</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">100px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">60deg</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="'./%E5%8D%81%E4%BA%8C%E8%A7%92%E6%98%9F.png"></p>
<p><strong>椭圆</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">160px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span> <span class="number">50%</span> <span class="number">50%</span> <span class="number">50%</span> / <span class="number">60%</span> <span class="number">60%</span> <span class="number">40%</span> <span class="number">40%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="./%E6%A4%AD%E5%9C%86.png"></p>
<h3 id="CSS-Shapes"><a href="#CSS-Shapes" class="headerlink" title="CSS Shapes"></a>CSS Shapes</h3><h4 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a>clip-path</h4><blockquote>
<p>CSS 新属性 clip-path，意味裁剪路径的意思，让我们可以很便捷的生成各种几何图形。clip-path 通过定义特殊的路径，实现我们想要的图形。而这个路径，正是 SVG 中的 path 。看看它的 API：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Keyword values */</span></span><br><span class="line">    <span class="attribute">clip-path</span>: none;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Image values */</span> </span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">url</span>(<span class="string">resources.svg#c1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Box values</span></span><br><span class="line"><span class="comment">    clip-path: fill-box;</span></span><br><span class="line"><span class="comment">    clip-path: stroke-box;</span></span><br><span class="line"><span class="comment">    clip-path: view-box;</span></span><br><span class="line"><span class="comment">    clip-path: margin-box</span></span><br><span class="line"><span class="comment">    clip-path: border-box</span></span><br><span class="line"><span class="comment">    clip-path: padding-box</span></span><br><span class="line"><span class="comment">    clip-path: content-box</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    /* Geometry values */</span></span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">inset</span>(<span class="number">100px</span> <span class="number">50px</span>);</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">circle</span>(<span class="number">50px</span> at <span class="number">0</span> <span class="number">100px</span>);</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">50%</span> <span class="number">0%</span>, <span class="number">100%</span> <span class="number">50%</span>, <span class="number">50%</span> <span class="number">100%</span>, <span class="number">0%</span> <span class="number">50%</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Box and geometry values combined */</span></span><br><span class="line">    <span class="attribute">clip-path</span>: padding-box <span class="built_in">circle</span>(<span class="number">50px</span> at <span class="number">0</span> <span class="number">100px</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Global values */</span></span><br><span class="line">    <span class="attribute">clip-path</span>: inherit;</span><br><span class="line">    <span class="attribute">clip-path</span>: initial;</span><br><span class="line">    <span class="attribute">clip-path</span>: unset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>clip-path: circle(50px at 50px 50px) 表示在元素的 （50px, 50px）处，裁剪生成一个半径为 50px 的圆。</li>
</ul>
<blockquote>
<p>以元素的左上角为坐标起点</p>
</blockquote>
<p><strong>clip-path生成圆</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: royalblue;</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">circle</span>(<span class="number">50px</span> at <span class="number">50px</span> <span class="number">50px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>clip-path生成十边形</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: royalblue;</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">50%</span> <span class="number">0%</span>, <span class="number">80%</span> <span class="number">10%</span>, <span class="number">100%</span> <span class="number">35%</span>, <span class="number">100%</span> <span class="number">70%</span>, <span class="number">80%</span> <span class="number">90%</span>, <span class="number">50%</span> <span class="number">100%</span>, <span class="number">20%</span> <span class="number">90%</span>, <span class="number">0%</span> <span class="number">70%</span>, <span class="number">0%</span> <span class="number">35%</span>, <span class="number">20%</span> <span class="number">10%</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>整个 clip-path 属性，最为重要的当属 polygon，可以利用 polygon 生成任意多边形。本例中依次列出了10个坐标点，可以采用百分比，也可以是具体数值。</p>
</blockquote>
<h4 id="clip-path动画"><a href="#clip-path动画" class="headerlink" title="clip-path动画"></a>clip-path动画</h4><p>clip-path 另外一个强大之处在于可以进行 CSS transtion 与 CSS animation，也就是过渡和动画。</p>
<p>看一个多边形的过渡切换动画。</p>
<!-- ![](https://mmbiz.qpic.cn/mmbiz_gif/SMw0rcHsoNKx4Cz1QzFjDVdxgHG7lN03iclweBjarRiazbCPfbII7E7qica6E1X6kP9W4V7fKyFo7L2Mwia9toLbEw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1) -->

<p><a href="https://codepen.io/Chokcoco/pen/LLNWyZ">多边形过渡动画</a></p>
<h4 id="图形变换动画"><a href="#图形变换动画" class="headerlink" title="图形变换动画"></a>图形变换动画</h4><p>除此之外，我们还可以尝试，将一个完整的图形，分割成多个小图形，这也是 clip-path 的魅力所在，纯 CSS 的图形变换：</p>
<!-- ![](https://mmbiz.qpic.cn/mmbiz_gif/SMw0rcHsoNKx4Cz1QzFjDVdxgHG7lN03tXLng1lZbHedTcbOz5NQHbEsKuuYudPJoFhSPCkS4KGrfg3icy7EGhA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1) -->

<p><a href="https://codepen.io/Chokcoco/pen/yXOjZm">Clip-path triangle2rect</a></p>
<h4 id="clip-path-动画的局限"><a href="#clip-path-动画的局限" class="headerlink" title="clip-path 动画的局限"></a>clip-path 动画的局限</h4><p>clip-path 动画虽然美好，但是存在一定的局限性，那就是进行过渡的两个状态，坐标顶点的数量必须一致。</p>
<p>也就是如果我希望从三角形过渡到矩形。假设三角形和矩形的 clip-path 分别为：</p>
<ul>
<li>三角形：clip-path: polygon(50% 0, 0 100%, 100% 0)</li>
<li>矩形：clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%)</li>
</ul>
<p>进行过渡动画时候，直接从 polygon(50% 0, 0 100%, 100% 0) –&gt; polygon(0 0, 100% 0, 100% 100%, 0 100%) 是不行的，因为是从 3 个坐标点变换到 4 个坐标点。</p>
<p>因此这里需要使用一个讨巧的办法，在三角形的表示方法中，使用四个坐标点表示，其中两个坐标点进行重合即可。也就是：</p>
<ul>
<li>三角形：clip-path: polygon(50% 0, 0 100%, 100% 0) -&gt; clip-path: polygon(50% 0, 50% 0, 0 100%, 100% 0)</li>
</ul>
<h4 id="N边形过渡动画"><a href="#N边形过渡动画" class="headerlink" title="N边形过渡动画"></a>N边形过渡动画</h4><p>随机生成 N（N&gt;=1000）边形，进行变换，会是什么效果呢？</p>
<!-- ![](https://mmbiz.qpic.cn/mmbiz_gif/SMw0rcHsoNKx4Cz1QzFjDVdxgHG7lN03M4hdQL0rVKicwdOxhiatG4zXsSR2bhSao1enTMkWE5zSibUCJic5DxZgSg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1) -->

<p><a href="https://codepen.io/Chokcoco/pen/XgJRzO">2000边形过渡动画</a></p>
<p>变换的瞬间很有爆炸的感觉。不过这里有个很大的问题，只是随机生成了 2000 个坐标点，然后使用 clip-path 将这些坐标点连接起来，并不是符合要求的多边形。</p>
<p>在 <a href="https://vuefe.cn/v2/guide/transitioning-state.html#%E5%8A%A8%E6%80%81%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">VUE官网</a>，有下面这样一个例子，一个规则的多边形进行不断的过渡动画，非常酷炫：</p>
<!-- ![](https://mmbiz.qpic.cn/mmbiz_gif/SMw0rcHsoNKx4Cz1QzFjDVdxgHG7lN03LcKsAibKWfl4O1G0ssmZkeeAMa1IkZZN5WBCIakURiaSIF3Yg8sJQic6w/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1) -->


<p>使用 CSS clip-path 实现：<br><a href="https://codepen.io/Chokcoco/pen/NgqGOo">clip-path N polygon</a></p>
<h3 id="shape-outside"><a href="#shape-outside" class="headerlink" title="shape-outside"></a>shape-outside</h3><blockquote>
<p>只能和浮动 float 一起使用,它赋予了我们一种更为自由的图文混排的能力。</p>
</blockquote>
<p><strong>API</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Keyword values */</span></span><br><span class="line">    shape-outside: none;</span><br><span class="line">    shape-outside: margin-box;</span><br><span class="line">    shape-outside: content-box;</span><br><span class="line">    shape-outside: border-box;</span><br><span class="line">    shape-outside: padding-box;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Function values */</span></span><br><span class="line">    shape-outside: <span class="built_in">circle</span>();</span><br><span class="line">    shape-outside: <span class="built_in">ellipse</span>();</span><br><span class="line">    shape-outside: <span class="built_in">inset</span>(<span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span>);</span><br><span class="line">    shape-outside: <span class="built_in">polygon</span>(<span class="number">10px</span> <span class="number">10px</span>, <span class="number">20px</span> <span class="number">20px</span>, <span class="number">30px</span> <span class="number">30px</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;url&gt; value */</span></span><br><span class="line">    shape-outside: <span class="built_in">url</span>(<span class="string">image.png</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Gradient value */</span></span><br><span class="line">    shape-outside: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>) <span class="number">150px</span>, red <span class="number">150px</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Global values */</span></span><br><span class="line">    shape-outside: initial;</span><br><span class="line">    shape-outside: inherit;</span><br><span class="line">    shape-outside: unset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;shape-outside&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    xxxxxxxxxxx，文字描述，xxxxxxxxx</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.shape-outside</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">160px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">160px</span>;</span><br><span class="line">    shape-outside: <span class="built_in">circle</span>(<span class="number">80px</span> at <span class="number">80px</span> <span class="number">80px</span>);</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面 .shape-outside 使用了浮动，并且定义了 shape-outside: circle(80px at 80px 80px) ，表示在元素的 (80px, 80px) 坐标处，生成一个 80px 半径的圆。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNKx4Cz1QzFjDVdxgHG7lN03IOeMyoHdbhASMp2E6JXDZOslSaH2gT3tLLYnzibe7CcRd5icicVY408iag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p>嗯？好像没什么了不起啊？这不就是 float 的效果吗？</p>
<p>不，不是的，看看 float 和 加上shape-outside 后的对比：</p>
<p><img src= "/img/loading.gif" data-src="https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNKx4Cz1QzFjDVdxgHG7lN03rF3d6iaTQwTWLLgD5Dskwme36mQkEUaAl287mTC6iaQbNPW5vEWK1SjQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p><a href="https://codepen.io/Chokcoco/pen/owxedZ">图文混排 shape-outside</a></p>
<h3 id="shape-outside-的本质"><a href="#shape-outside-的本质" class="headerlink" title="shape-outside 的本质"></a>shape-outside 的本质</h3><p>所以，shape-outside 的本质其实是生成几何图形，并且<strong>裁剪掉其几何图形之外周围的区域，让文字能排列在这些被裁剪区域之内</strong>。</p>
<p><strong>平行四边形混排</strong></p>
<p><img src= "/img/loading.gif" data-src="https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNKx4Cz1QzFjDVdxgHG7lN03wCNXbArwtR20ojSRcm6NiavCu96JicAnwNcXUvAdTuzwMHRFlXYtFhNw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p><a href="https://codepen.io/Chokcoco/pen/NgqZqX">参考示例-平行四边形混排</a></p>
<p><strong>心形、菱形混排</strong></p>
<p><img src= "/img/loading.gif" data-src="https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNKx4Cz1QzFjDVdxgHG7lN03JkYIJRZ2T2HJoG4cdZs2zaceD2vC54PlUqEzpuowxiaos6ZiaLZ5oxAg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p><a href="https://codepen.io/Chokcoco/pen/ZyWRbQ">参考示例-心形、菱形混排</a></p>
<blockquote>
<p>截止到今天， clip-path 与 shape-outside 都有着非常不错的兼容支持。在移动端和非 IE 浏览器下都可以放心的使用</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s/2_fd1sbrNqUyq3GW8DQpiw">原文地址</a><br><a href="https://codepen.io/Chokcoco/pen/NgxNrq">CSS Shapes(CSS 几何图形)</a></p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何监听容器高度变化（二）</title>
    <url>/2021/06/18/%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%AE%B9%E5%99%A8%E9%AB%98%E5%BA%A6%E5%8F%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>在<a href="https://yolkpie.net/2021/06/17/%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%AE%B9%E5%99%A8%E9%AB%98%E5%BA%A6%E5%8F%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/">【如何监听容器高度变化（一）】</a> 中介绍了几种使用模拟（iframe/object/scroll）的方式获取容器实时高度的方法，这篇文章主要介绍可以监听变化的API。</p>
<h2 id="Mutation-Events"><a href="#Mutation-Events" class="headerlink" title="Mutation Events"></a>Mutation Events</h2><p>容器高度是由 dom 节点的操作（如插入、渲染、移除等）引起的，如果我们可以监听到 dom 节点的子节点、属性、文本节点等的变化，就可以获取到此时容器的高度，从而实现对于容器高度的监听。</p>
<p>Mutation Events 是 DOM3 中定义的针对 dom 节点更改的事件，支持的事件如下：</p>
<ul>
<li>DOMAttrModified：dom 属性变更</li>
<li>DOMAttributeNameChanged：dom 属性名修改</li>
<li>DOMCharacterDataModified：dom 文本数据发生修改</li>
<li>DOMElementNameChanged：dom 元素名发生变化</li>
<li>DOMNodeInserted：dom 节点插入</li>
<li>DOMNodeInsertedIntoDocument：dom 节点插入</li>
<li>DOMNodeRemoved：dom 节点删除</li>
<li>DOMNodeRemovedFromDocument：dom 节点删除</li>
<li>DOMSubtreeModified：dom 子元素修改</li>
</ul>
<p>备注：<a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-type-DOMNodeInsertedIntoDocument">W3C文档</a>上 DOMNodeInsertedIntoDocument 会先于 DOMNodeInserted 触发，但是测试过程中插入节点时 DOMNodeInsertedIntoDocument 没有被触发，DOMNodeInserted 有被触发。另外，和 DOMNodeInserted 相比，DOMNodeInsertedIntoDocument 兼容的浏览器更少。DOMNodeRemovedFromDocument 的情况也是一样的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;main&quot;</span>);</span></span><br><span class="line"><span class="javascript">  container.addEventListener(<span class="string">&quot;DOMSubtreeModified&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;DOMSubtreeModified&quot;</span>); <span class="comment">// 控制台输出 DOMSubtreeModified</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(container.clientHeight); <span class="comment">// 控制台输出 16</span></span></span><br><span class="line">  &#125;);</span><br><span class="line">  container.innerHTML =</span><br><span class="line"><span class="handlebars"><span class="xml">    &#x27;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img30.360buyimg.com/babel/s590x470_jfs/t1/175659/2/14809/204433/60c88e44Eb9ffa27a/1cc8a1d4d8a5205b.jpg.webp&quot;</span> /&gt;</span>&#x27;;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，监听了 DOMSubtreeModified 事件，修改 dom 内容的时候被触发，但是也可以看到，使用这种方式也并没有获取到 dom 的正确高度。其实很好理解，因为图片是异步加载的，当 img 标签插入到 dom 中的时候，图片并没有加载完成，高度没有撑开。因此，这种方式的适用情况依然是有限度的，对于需要异步加载的资源不适用。</p>
<p>Mutation Events 存在很多问题，在 DOM4 中已经被废弃：</p>
<ol>
<li>兼容性问题：<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/190118/2/8890/53322/60cc10dcE6b0339d0/3bb4d01d8c7cf762.png" alt="Mutation Events兼容"></li>
</ol>
<ul>
<li>上图标注1的浏览器不支持 DOMAttrModified</li>
<li>上图标注2的浏览器不支持 DOMNodeInsertedIntoDocument 和 DOMNodeRemovedFromDocument</li>
</ul>
<ol start="2">
<li>性能问题</li>
</ol>
<ul>
<li>Mutation Events 是同步执行的，每次调用都需要从事件队列中取出事件，执行，然后事件队列中移除。如果事件触发频繁，上述步骤会多次调用，会对浏览器性能造成影响。</li>
<li>Mutation Events 本身是事件，所以捕获是采用的是事件冒泡的形式，如果冒泡捕获期间又触发了其他的 Mutation Events，很有可能就会导致阻塞 Javascript 线程，甚至导致浏览器崩溃。</li>
</ul>
<h2 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h2><p>MutationObserver 接口是 Mutation Events 功能的替代品，同样用于监视 dom 节点的更改。概念上，MutationObserver 可以理解为 dom 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，dom 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，dom 的变动并不会马上触发，而是要等到当前所有 dom 操作都结束才触发。</p>
<p>MutationObserver 的特点如下：</p>
<ul>
<li>等待所有脚本任务完成后，才会运行（即异步触发方式）</li>
<li>把 dom 变动记录封装成一个数组进行处理，而不是一条条个别处理 dom 变动</li>
<li>既可以观察 dom 的所有类型变动，也可以指定只观察某一类变动</li>
</ul>
<p>MutationObserver的兼容性如下：<br><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/178582/35/9773/41975/60cc33c5Ebc03d8eb/f69fa11f951f98cf.png" alt="MutationObserver兼容性"></p>
<p>上图中，中间有-的黄色矩形表示需要加webkit前缀。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>MutationObserver()</p>
<p>使用时，首先使用 MutationObserver 构造函数，新建一个观察器实例，同时指定这个实例的回调函数。该回调函数接受两个参数，一个是变动的数组，另一个是观察器实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations, observer</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(observer)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mutations.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> mutation = mutations[i];</span><br><span class="line">        <span class="built_in">console</span>.log(mutation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li>observe()</li>
</ol>
<p>observe 方法用来启动监听，接受两个参数，一个是要监听的 dom 节点，一个是配置项 options。</p>
<p>options 中可以配置要监听的变动类型（必须有其中的一种或几种，否则会报错），如下：</p>
<ul>
<li>childList：布尔值，表示子节点的变动（指新增，删除或者更改）</li>
<li>attributes：布尔值，表示属性的变动</li>
<li>characterData：布尔值，表示节点内容或节点文本的变动（比如可以监听 input 值的变化）</li>
</ul>
<p>此外，还可以设置以下属性：</p>
<ul>
<li>subtree：布尔值，表示是否将该观察器应用于该节点的所有后代节点</li>
<li>attributeOldValue：布尔值，表示观察 attributes 变动时，是否需要记录变动前的属性值</li>
<li>characterDataOldValue：布尔值，表示观察 characterData 变动时，是否需要记录变动前的值</li>
<li>attributeFilter：数组，表示需要观察的特定属性（比如[‘class’,’src’]）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">observer.observe(container, &#123;</span><br><span class="line">attributes: <span class="literal">true</span>,</span><br><span class="line">characterData: <span class="literal">true</span>,</span><br><span class="line">childList: <span class="literal">true</span>,</span><br><span class="line">subtree: <span class="literal">true</span>,</span><br><span class="line">attributeOldValue: <span class="literal">true</span>,</span><br><span class="line">characterDataOldValue: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对一个节点添加观察器，就像使用 addEventListener 方法一样，多次添加同一个观察器是无效的，回调函数依然只会触发一次。但是，如果指定不同的 options 对象，就会被当作两个不同的观察器。</p>
<ol start="2">
<li>disconnect()</li>
</ol>
<p>disconnect 方法用来停止观察。调用该方法后，dom 再发生变动，也不会触发观察器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">observer.disconnect();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>takeRecords()</li>
</ol>
<p>takeRecords 方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> changes = observer.takeRecords(); <span class="comment">// 保存没有被处理的变动</span></span><br></pre></td></tr></table></figure>

<h3 id="MutationRecord"><a href="#MutationRecord" class="headerlink" title="MutationRecord"></a>MutationRecord</h3><p>MutationObserver() 构造函数回调中的 mutation 是 MutationRecord 的实例，包含的属性如下：</p>
<ul>
<li>type：观察的变动类型（attribute、characterData或者childList）</li>
<li>target：发生变动的 dom 节点</li>
<li>addedNodes：新增的 dom 节点</li>
<li>removedNodes：删除的 dom 节点</li>
<li>previousSibling：前一个同级节点，如果没有则返回 null</li>
<li>nextSibling：下一个同级节点，如果没有则返回 null</li>
<li>attributeName：发生变动的属性。如果设置了 attributeFilter，则只返回预先指定的属性</li>
<li>oldValue：变动前的值。这个属性只对 attribute 和 characterData 变动有效，如果发生 childList 变动，则返回 null</li>
</ul>
<p>对 MutationObserver 进行了简单的了解之后，我们回到监听容器高度的需求上来：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;main&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> currentHeight = container.clientHeight;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations, observer</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> newHeight = container.clientHeight;</span></span><br><span class="line">    if (currentHeight !== newHeight) &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;高度变化了：&quot;</span> + newHeight); <span class="comment">// 控制台输出 高度变化了：16</span></span></span><br><span class="line">      currentHeight = newHeight;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  observer.observe(container, &#123;</span><br><span class="line"><span class="javascript">    attributes: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">    characterData: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">    childList: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">    subtree: <span class="literal">true</span>,</span></span><br><span class="line">  &#125;);</span><br><span class="line">  container.innerHTML =</span><br><span class="line"><span class="handlebars"><span class="xml">    &#x27;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img30.360buyimg.com/babel/s590x470_jfs/t1/175659/2/14809/204433/60c88e44Eb9ffa27a/1cc8a1d4d8a5205b.jpg.webp&quot;</span> /&gt;</span>&#x27;;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MutationObserver 和 Mutation Event 一样都是监听 dom 节点的变化，同样不能监听到异步资源加载后高度的变化。另外，因为 MutationObserver 监听的范围不包含样式属性的变化，因此如果通过 CSS 动画改变容器高度的话是检测不到的。我们需要在动画（transitionend、animationend）停止事件触发时监听高宽变化。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="keyword">@keyframes</span> changeHeight &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">from</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-tag">to</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    50% &#123;</span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px; background: red; animation: changeHeight ease-in-out 5000ms&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;main&quot;</span>);</span></span><br><span class="line"><span class="javascript">  container.addEventListener(<span class="string">&quot;animationend&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(getComputedStyle(container).height); <span class="comment">// 控制台输出 100px</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>综上，MutationObserver 的事件处理是异步的，调用也比较简单，但仍有以下局限：</p>
<ol>
<li>IE10 及以下版本不兼容，需要和 Mutation Events 配合使用</li>
<li>不能监听异步资源加载完成后造成的高度变化，不能监听 flex 布局挤压造成的高度变化</li>
<li>CSS动画造成的高度变化需要使用 transitionend或animationend 方法监听停止后的高度，动画进行中的高度变化监听不到</li>
</ol>
<h2 id="ResizeObserver"><a href="#ResizeObserver" class="headerlink" title="ResizeObserver"></a>ResizeObserver</h2><p>ResizeObserver 是一个实验中的功能，可以监听到 Element 的内容区域或 SVGElement的边界框改变。内容区域则需要减去内边距padding。</p>
<blockquote>
<p>ResizeObserver 避免了在自身回调中调整大小，从而触发的无限回调和循环依赖。它仅通过在后续帧中处理 dom 中更深层次的元素来实现这一点。如果（浏览器）遵循规范，只会在绘制前或布局后触发调用。</p>
</blockquote>
<p>ResizeObserver 的兼容性如下：<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/176414/28/14602/46065/60cc45c8Ed316895e/3eaa3a1c156ac584.png" alt="ResizeObserver兼容性"></p>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>ResizeObserver()</p>
<p>首先使用 ResizeObserver 构造函数，新建一个观察器实例，同时指定这个实例的回调函数。该回调函数接受一个参数，一个是变动的数组，另一个是观察器实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> ResizeObserver(<span class="function"><span class="keyword">function</span>(<span class="params">entries, observer</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(observer)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; entries.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> entry = entries[i];</span><br><span class="line">        <span class="built_in">console</span>.log(entry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>构造函数回调中 entry 为 ResizeObserverEntry 对象的实例，包含属性如下：</p>
<ul>
<li>target：大小发生变化的 dom 节点</li>
<li>contentRect：dom 节点的 contentRect，包含 width/height/top/left/right/bottom/x/y</li>
<li>borderBoxSize：dom 含边框的尺寸大小，为数组，数组中对象包含 blockSize/inlineSize（为高度/宽度）</li>
<li>contentBoxSize：dom 内容区域大小（不含边框和 padding），（同上）</li>
<li>devicePixelContentBoxSize：contentBoxSize * window.devicePixelRatio的大小,（同上）</li>
</ul>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol>
<li>observe()</li>
</ol>
<p>observe 方法用来启动监听，接受一个参数，即要监听的 dom 节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">observer.observe(container);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>unobserve()</li>
</ol>
<p>observe 方法用来停止监听，接收一个参数，即要停止监听的 dom 节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">observer.observe(container);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>disconnect()</li>
</ol>
<p>disconnect 方法用来停止 observer 下所有的监听。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">observer.disconnect();</span><br></pre></td></tr></table></figure>

<p>用 ResizeObserver 监听容器高度变化的代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 10px solid red; padding: 40px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;main&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> currentHeight = container.clientHeight;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> observer = <span class="keyword">new</span> ResizeObserver(<span class="function"><span class="keyword">function</span> (<span class="params">entries, observer</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; entries.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> entry = entries[i];</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> newHeight = entry.borderBoxSize[<span class="number">0</span>].blockSize;</span></span><br><span class="line">      if (newHeight !== currentHeight) &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;高度变化了：&quot;</span> + newHeight);  <span class="comment">// 控制台输出 高度变化了：573</span></span></span><br><span class="line">        currentHeight = newHeight;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  observer.observe(container);</span><br><span class="line">  container.innerHTML =</span><br><span class="line"><span class="handlebars"><span class="xml">    &#x27;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img30.360buyimg.com/babel/s590x470_jfs/t1/175659/2/14809/204433/60c88e44Eb9ffa27a/1cc8a1d4d8a5205b.jpg.webp&quot;</span> /&gt;</span>&#x27;;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外，对 flex 挤压和 CSS 动画造成的高度变化进行了测试，ResizeObserver 都可以监听到。</p>
<p>注意：网上有人反馈 ResizeObserver 回调内如果涉及到会导致 reflow 的设置，在 chrome 中可能会报错： Error：ResizeObserver loop limit exceeded。解决办法是在回调中增加 requestAnimationFrame 来进行节流处理。<a href="https://www.zhangxinxu.com/wordpress/2020/03/dom-resize-api-resizeobserver/">【在这里的评论部分】</a></p>
<p>综上，ResizeObserver 可以实现动态监听元素高度的需求，美中不足的是不兼容 IE。这点可以使用 polyfill 来弥补：<a href="https://github.com/que-etc/resize-observer-polyfill">resize-observer-polyfill</a>，可以兼容到 IE9。（测试中发现 IE 浏览器中回调中 entry 参数中只有 target 和 contentRect 两个属性，不包含 borderBoxSize/contentBoxSize/devicePixelContentBoxSize。）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结合上一篇文章<a href="https://yolkpie.net/2021/06/17/%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%AE%B9%E5%99%A8%E9%AB%98%E5%BA%A6%E5%8F%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/">【如何监听容器高度变化（一）】</a> 的内容，如果要监听容器高度的实时变化，推荐以下三种：</p>
<ol>
<li>使用 object 模拟</li>
<li>监听 scroll 事件</li>
<li>使用 ResizeObserver + polyfill</li>
</ol>
<p>当然，如果只需要知道窗口的实时高度，使用 resize 方法就行，不过要记得使用节流函数。</p>
]]></content>
      <tags>
        <tag>Mutation Events, MutationObserver, ResizeObserver</tag>
      </tags>
  </entry>
  <entry>
    <title>安装证书</title>
    <url>/2020/12/22/%E5%AE%89%E8%A3%85%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>证书的安装不依赖于代理工具，Fiddler、Charles、Whistle都可以依照下面的步骤安装。(注意：证书的下载方式在不同代理工具中是不同的，这里默认已经下载了证书)</p>
<blockquote>
<p>安装证书的核心在<b>信任</b>证书的这步操作上，这两个字其实也是本文的核心。</p>
</blockquote>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><ol>
<li>双击下载好的证书文件，点击安装<br><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/156646/1/1360/31950/5fe08c03E16ab94c8/093f9c23c5030147.png" alt="双击安装"></li>
<li>选择存储位置为当前用户<br><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/151347/26/11830/32386/5fe08c03Ea91634e2/1a0e934cf9607b8c.png" alt="选择存储位置"></li>
<li>选择将所有的证书都放入下列存储<br><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/148989/23/19257/26999/5fe08c03E9306869d/5198463e9213d285.png" alt="指定证书存储位置"></li>
<li>这一步是关键的“信任”的步骤：点击浏览按钮，选择受信任的根证书颁发机构<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/152242/3/10881/34116/5fe08c03E8faf6f6d/08fb718ae8980a7f.png" alt="受信任的根证书颁发机构"></li>
<li>导入完成<br><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/156009/19/1351/24923/5fe08c03Eb5448a05/9e74fa3a66015d80.png" alt="导入完成"></li>
</ol>
<h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><ol>
<li>双击下载好的证书，系统会将证书添加到钥匙串并自动打开钥匙串的窗口，在钥匙串中找到wistle证书并选中，会发现页面提示该证书不受信任<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/140214/23/19534/558122/5fe15be5E6fe5c218/5b1347299597881c.jpg" alt="钥匙串"></li>
<li>右键该证书，选择简介 -&gt; 信任 -&gt; 使用此证书修改为始终信任<br><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/145084/17/19471/414745/5fe15c4bE14c0903d/5e2cb0436e61b9f7.jpg" alt="信任证书"></li>
<li>关闭窗口时系统会要求输入电脑密码，照做就行</li>
<li>回到钥匙串窗口，此时页面会提示此证书已标记为受账户信任<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/143587/12/19500/553727/5fe15c29E8d3c1aa9/8ae332a26633593c.jpg" alt="此证书已标记为受账户信任"></li>
</ol>
<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><ol>
<li>系统设置 -&gt; 通用 -&gt; 描述文件与设备管理<br><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/153496/23/10319/52081/5fdc5922Ee183d0e0/86ddce16d2a308bb.jpg" alt="描述文件与设备管理"></li>
<li>选择已经下载的证书<br><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/146189/7/18958/44348/5fdc5925E454049d7/3a9ee4b2484fd6c9.jpg" alt="选择证书"></li>
<li>点击安装<br><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/153162/21/10375/41967/5fdc5925Ebf5a2b6f/e0c179099bca7278.jpg" alt="安装证书"></li>
<li>输入密码，这个密码是手机的开机密码<br><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/141566/40/19047/38951/5fdc5925E470ec670/5c687269928aff3c.jpg" alt="输入密码"></li>
<li>继续点击安装<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/130565/20/20599/52481/5fdc5925Edae2a1d9/bded077f3e57dc42.jpg" alt="警告"></li>
<li>安装完成。别急，不要忘了核心的信任二字：iOS 10.3以下的版本会自动给安装的证书添加信任，如果你的iOS版本是<a href="https://support.apple.com/zh-cn/HT204477">10.3及以上</a>，还要手动给证书设置信任才行<br><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/150193/14/18800/37854/5fdc5922Eabd28996/b198eeceeb40b830.jpg" alt="安装完成"></li>
<li>回到 设置 -&gt; 通用 -&gt; 关于本机 -&gt; 证书信任设置<br><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/143797/4/19061/59581/5fdc5925E982c7de5/6b99488bfb0f6302.jpg" alt="证书信任设置"></li>
<li>第2步我们选择的证书名称为whistle.1560220575433369（你会发现这个名称和Mac安装时whistle的钥匙串名称是一样的），这里选择该证书，并打开信任开关。到这一步，iOS的证书就真的是安装完成了。<br><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/140144/16/18961/335450/5fdc5926E1f261a6e/2ca582daf46a390c.png" alt="选择已安装证书"></li>
</ol>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>在Android手机中，如果下载了证书，浏览器会自动提示要不要安装，但因为这样安装的证书经常不被系统信任，建议不要使用这种安装方式。</p>
<ol>
<li>设置 -&gt; 安全和隐私 -&gt; 更多安全设置 -&gt; 从SD卡安装（这里以华为mate 10 为例，不同Android机型的设置选项是不同的，总的来说都是要在设置的选项里先找到与“安全”相关的配置，再找到与“用户凭据”或者“从SD卡安装”相关的内容，之后选择已经下载好的证书安装即可）<br><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/155127/4/10869/138769/5fe090f3Ecdad6eff/33b27c69761a8567.jpg" alt="从SD卡安装"></li>
<li>选择刚才下载的证书文件（默认的文件夹里没有的话需要按照下载文件的实际路径选择）<br><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/144057/37/19303/96168/5fe090e6Ebc38a41d/5d9cdc8f6f3079cd.jpg" alt="选择证书文件"></li>
<li>输入锁屏密码</li>
<li>为证书命名，安装完成<br><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/141887/25/19384/143601/5fe090b7E39859168/89aa9d09a8dd7ff5.jpg" alt="为证书命名"></li>
</ol>
]]></content>
      <tags>
        <tag>代理</tag>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title>实时对话界面设计思考</title>
    <url>/2020/09/27/%E5%AE%9E%E6%97%B6%E5%AF%B9%E8%AF%9D%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>日常生活中，我们经常会用到即时通讯软件，对聊天对话界面已经很熟悉了。打开聊天界面，最主要的三个UI元素有：头像、文字气泡、和对话缩略图。那我们有没有想过，为什么有的头像是圆形的，有的是方形的？气泡的极限值应该怎么定义？对话中的缩略图又有什么样的展示比例？</p>
<p>本次我们就从聊天界面中常见的头像、文字气泡、图片展示来分析总结一下，在设计即时聊天界面时应该注意哪些细节。</p>
<h2 id="头像部分"><a href="#头像部分" class="headerlink" title="头像部分"></a>头像部分</h2><p>最近正好在做一个项目是有关消息列表和聊天对话的页面，那关于界面中的头像我们该如何定义呢？是用方形头像还是圆形头像？这两种形状在产品设计中都非常普遍，那到底应该根据什么因素来做抉择依据呢？交互设计包含五要素：用户、行为、目标、场景、媒介。本文我们主要从用户、媒介维度和场景来作分析。</p>
<h3 id="媒介维度"><a href="#媒介维度" class="headerlink" title="媒介维度"></a>媒介维度</h3><p>媒介维度这里主要是展示形态的差异，要决定媒介的展示形态，我们需要对媒介本身的用户、行为、目标、产品调性(包括用户目标、行为和场景)进行分析。</p>
<ol>
<li><p><strong>方形</strong></p>
<p>通常来讲方形均衡的四边、凸显的棱角给人一种敦实、稳重、可靠、有原则的信赖感。因为棱角的关系，人的视觉会相对分散，出了视觉中心，注意力也会像四个角转移，棱角越尖锐，视线扩散越明显。</p>
<p><strong>方形的扩散性让图形内的注意力分布更为均衡，同时可以保持与人合适的距离感，让人的情绪相对冷静与克制。</strong></p>
</li>
<li><p><strong>圆形</strong></p>
<p>圆形在方形的对比下就显得柔软、亲切、温和了。从感知上来讲，圆形具有收缩性更容易视觉聚焦，因为它只有1个中心点，而方形有更多分散的焦点，不容易聚焦。此外国外的视觉实验也明确指出：人的视网膜对于正圆形的处理速度要显著高于对边角的处理速度。所以，圆形相对其他图形而言，在聚焦效果上可以说又快又好，可以快速拉升人的情绪兴趣。</p>
<p>所以圆形头像更多的运用在具有娱乐属性的社交产品上。</p>
<p><img src= "/img/loading.gif" data-src="%E8%A7%86%E8%A7%89%E8%81%9A%E7%84%A6.png" alt="视觉聚焦"></p>
</li>
</ol>
<h3 id="产品调性"><a href="#产品调性" class="headerlink" title="产品调性"></a>产品调性</h3><p>设计页面时，要考虑头像与周围信息的关系，它在页面中的信息层级是怎样的？是否是要凸显的要素？是否希望它抓取用户的视觉注意力？同时也需要根据产品调性来选择媒介的展示形态，要考虑头像所处的周围环境，以及头像与周围信息的关系（目标）和互动（行为）。看产品是偏活泼型或者陌生人社交性质的，还是偏严肃性的，或者熟人社交性的。</p>
<ul>
<li>对于活泼型或者陌生人社交性的产品来说，圆形的动感，更符合活泼的产品调性，圆形的聚焦性，可以快速帮助用户识别陌生人的关键特征信息（人脸），激发社交的兴趣；</li>
<li>对于严肃性或者熟人社交产品来说，方形的稳重，与严肃的气质更加的贴合；</li>
</ul>
<p><img src= "/img/loading.gif" data-src="%E8%81%8A%E5%A4%A9%E7%95%8C%E9%9D%A2.png" alt="聊天界面"></p>
<p>所以：</p>
<ul>
<li><p><strong>对于产品调性是娱乐互动型的（如游戏、教育、陌生人社交等），推荐使用圆形头像，可以更好的凸显用户的特征，激发他人的互动兴趣。</strong></p>
</li>
<li><p><strong>对于产品调性是专业严肃稳重型的（（如金融、政务，熟人社交等），推荐使用方形头像，可以更好的传达冷静、专业的用户气质，并传递更多的环境信息，赢得他人的信赖感。</strong></p>
</li>
</ul>
<h2 id="文字气泡部分"><a href="#文字气泡部分" class="headerlink" title="文字气泡部分"></a>文字气泡部分</h2><p>文字气泡框我们很容易看出来有两个变量：a(气泡距左侧的边距)和b（气泡的宽度），当页面中有两个变量时我们就不能用常规的方法：固定其宽度，而是需要采用百分比的形式才较为合理。这样气泡在不同尺寸的手机上展示才是相对合适的。</p>
<p><strong>那这个比例是多少呢？我的结论是：b/屏幕宽度=70%最为适宜</strong></p>
<p>为什么是70%的比例呢？根据对齐原则，在750尺寸下，减去头像、安全间距和空白间距，我们需要让气泡在宽度最大时展示是整齐工整的。该比例是不是适用于所有的产品？当然不适用。因为每个产品的调性不一样，有的对话需要有头像，有的对话不需要头像 (比如一些app的人工智助手，对话过程中需要弱化头像信息，模拟真实的对话场景，就会取消智能助手的头像展示)。70%的比例只适合有头像的对话界面。这个比例不是固定的，是灵活可变的，我们只需要在不同的业务场景下最大限度展示更明确的信息即可。</p>
<p><img src= "/img/loading.gif" data-src="%E8%81%8A%E5%A4%A9%E6%B0%94%E6%B3%A1@2x.png" alt="聊天气泡@2x"></p>
<p>文字气泡的宽度适不适合用黄金比例展示呢，其实是不适合的。黄金比例公式如下：</p>
<p><img src= "/img/loading.gif" data-src="%E9%BB%84%E9%87%91%E6%AF%94%E4%BE%8B@2x.png" alt="黄金比例@2x"></p>
<p>根据计算，在长度750px的时候，根据黄金比例：长边/短边=1/0.618计算，除去安全间距和空白间距，文字气泡的最大宽度约为464px；展示效果如下：</p>
<p>会造成错落不整齐的视觉效果。所以根据对齐性原则，我们需要让对话两方在气泡最大时展示是工整的。此时的气泡宽度占屏幕比恰好是70%；</p>
<p><img src= "/img/loading.gif" data-src="%E9%BB%84%E9%87%91%E6%AF%94%E4%BE%8B%E6%B0%94%E6%B3%A1@2x.png" alt="黄金比例气泡@2x"></p>
<h2 id="图片部分"><a href="#图片部分" class="headerlink" title="图片部分"></a>图片部分</h2><p>关于图片部分，本次主要分享一下聊天页面中，缩略图的展示规则。</p>
<p>聊天过程中用户发送的图片各种各样大小不一，缩略图通常是将用户这些大小不一的图片进行缩小或者裁剪展示；一是为了节省屏幕空间，二是用缩略图展示图片内容，页面文字信息更加清晰整齐美观。如何设计一个合理的缩略图展示规则能最大可能的满足展示需求，又让整个聊天信息整齐美观呢？</p>
<p>如果我们希望尽可能保留图片的长宽比样式，在聊天列表中错落有致地展示，则我们需要对横向和纵向图片的长和宽都做相应的阈值限制。</p>
<p>以微博微信为例，我们分别像微博和微信发测试图片：</p>
<h3 id="正方形图："><a href="#正方形图：" class="headerlink" title="正方形图："></a>正方形图：</h3><p><img src= "/img/loading.gif" data-src="%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%9B%BE.png" alt="正方形图"></p>
<p>分别向微博和微信发送一组不同尺寸的正方形，分别是：100x100 px    300x300px   600x600px  900x900px 大小不同的正方形：如下图，通过对缩略图测量，发现：</p>
<ul>
<li><p><strong>微信的处理方式：</strong></p>
<p>微信的正方形缩略图大小完全一样，所以不论图片尺寸大小，只要是是正方形的图，微信统一展示限定的的宽高；</p>
</li>
<li><p><strong>微博的处理方式：</strong></p>
<p>微博的展示规则则比微信细致一些，在图片大小小于阈值时，不满足我们限定的宽高，则原尺寸展示；在图片大小大于阈值时，则统一展示限定的宽高。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="%E6%AD%A3%E6%96%B9%E5%BD%A2%E6%AF%94%E4%BE%8B.png" alt="正方形比例"></p>
<h3 id="横向-长方形图："><a href="#横向-长方形图：" class="headerlink" title="横向-长方形图："></a>横向-长方形图：</h3><p><img src= "/img/loading.gif" data-src="%E6%A8%AA%E5%90%91-%E9%95%BF%E6%96%B9%E5%BD%A2.png" alt="横向-长方形"></p>
<p>当我们分别向微博和微信发送一组不同尺寸的横向-长方形，分别是：2:1    3:1    4:3    16:9      21:9     超宽图的尺寸，发现：</p>
<ul>
<li><p><strong>微信的处理方式：</strong></p>
<p>21:9  3:1 的图片的缩略图都未被裁减，除了超宽的图片，其他尺寸的图片都能都完整的被缩放；</p>
</li>
<li><p><strong>微博的处理方式：</strong></p>
<p>微博同微信一样，21:9  3:1的图片也能被完整缩放；</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="%E6%A8%AA%E5%90%91-%E9%95%BF%E6%96%B9%E5%BD%A2%E7%A4%BA%E4%BE%8B.png" alt="横向-长方形示例"></p>
<h3 id="竖向-长方形图："><a href="#竖向-长方形图：" class="headerlink" title="竖向-长方形图："></a>竖向-长方形图：</h3><p><img src= "/img/loading.gif" data-src="%E7%AB%96%E5%90%91-%E9%95%BF%E6%96%B9%E5%BD%A2.png" alt="竖向-长方形"></p>
<p>当我们分别向微博和微信发送一组不同尺寸的竖向-长方形，分别是：3:4    9:16    1:2    9:16   1:3    和 超长图的尺寸，发现：</p>
<ul>
<li><p><strong>微信的处理方式：</strong></p>
<p>9:21  1:3 的图片的缩略图都未被裁减，除了超高的图片，其他尺寸的图片都能都完整的被缩放；</p>
</li>
<li><p><strong>微博的处理方式：</strong></p>
<p>微博同微信一样，9:21   1:3的图片也能被完整缩放；</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="%E7%AB%96%E5%90%91-%E9%95%BF%E6%96%B9%E5%BD%A2%E7%A4%BA%E4%BE%8B.png" alt="竖向-长方形示例"></p>
<p><strong>对于横向-长方形 和 竖向-长方形的缩略图，微博和微信设定的展示规则是一样的，微博和微信对于阈值设定，都是以正方形作为基准，去限定的高度和宽度</strong>，意思就是： 比例较大的边等于正方形的边，这意味着在聊天过程中能产生最大显示面积的是正方形的图片，并且无需为正方形做特殊判断，缺点是，正方形的图片面积是聊天界面中最大的缩略图，其他比例的缩略图相对正方形都较小，似乎「有失公平」。但是这种方式设定的高度和宽度在一屏幕中可以展示更多的图片缩略图；</p>
<p>但是对于正方形图片二者是有差别的：</p>
<ul>
<li><p>微信的正方形缩略图大小完全一样，所以不论图片尺寸大小，只要是是正方形的图，微信统一展示限定的的宽高；</p>
</li>
<li><p>微博的展示规则则比微信细致一些，在图片大小小于我们限定的宽高时，则原尺寸展示；在图片大小大于阈值时，则统一展示限定的宽高。</p>
</li>
</ul>
<h3 id="缩略图小结"><a href="#缩略图小结" class="headerlink" title="缩略图小结"></a>缩略图小结</h3><p>设定多大的宽度阈值取决于我们的业务属性和使用场景。为了更好的兼顾用户不同大小的图片尽可能被完全展示，在阈值设定时，我们需要宽松一点，简化一个维度，用户多次发送图片时，也能尽可能整齐展示。</p>
<p><strong>缩略图展示规则如下：</strong></p>
<ul>
<li>正方形图：固定宽高 x；小于固定宽高原尺寸展示；</li>
<li>横向-长方形：固定宽度x；高度根据图片动态变化；最高x;</li>
<li>竖向-长方形：固定高度 ；宽度根据文字动态变化；最宽x；</li>
</ul>
<p>参考文档：<a href="http://www.woshipm.com/pd/597974.html">http://www.woshipm.com/pd/597974.html</a></p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>对话</tag>
      </tags>
  </entry>
  <entry>
    <title>导出GIF图的4种方式</title>
    <url>/2021/03/25/%E5%AF%BC%E5%87%BAGIF%E5%9B%BE%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当下UI设计师工作中多多少少都会涉及到动效的制作，如交互动效，icon动效，运营类的微动效等，从设计制动效到交付开发的过程中，总有一个不起眼的环节会占用我大量时间，这个环节就是将完成的动效导出gif，在自己查阅了大量资料，咨询了很多人以及自己实践了n多次后，得到了很多种解决办法，在此，提炼了一些常用到，效果较好的方法分享出来。本篇文章只分享GIF图的导出方法，不包含动效转Lottie。</p>
<h3 id="方式一：视频导入PS再导出GIF图"><a href="#方式一：视频导入PS再导出GIF图" class="headerlink" title="方式一：视频导入PS再导出GIF图"></a>方式一：视频导入PS再导出GIF图</h3><ol>
<li><p>在AE中选择合成-添加到渲染队列渲染视频，选择“QuickTime”格式（渲染速度快），得到一个.mov的视频文件；</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/170379/23/14658/1619026/605c5268E05630612/4898cb5299553724.png" alt="导出视频"></p>
</li>
<li><p>接着我们将该视频导入到ps中，将视频转换成帧动画，再选择文件-导出为web所用格式，选择GIF格式就可以成功导出GIF图了。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/158695/38/15344/2220493/605c526cE7854235f/d5a8a6ead06d9f9b.png" alt="帧动画"></p>
</li>
</ol>
<h3 id="方法二：png序列导出GIF图"><a href="#方法二：png序列导出GIF图" class="headerlink" title="方法二：png序列导出GIF图"></a>方法二：png序列导出GIF图</h3><ol>
<li><p>在AE中Ctrl+M打开渲染队列，点“输出模块”打开设置，将“格式”改为[Png序列]，“通道”改为“RGB+Alpha”，设置完成后点击“渲染”，得到一套完整的png序列图；</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/166009/32/14226/890152/605c526fE8773c642/4672808b6ef1adad.png" alt="png序列"></p>
</li>
<li><p>加载序列图：打开PS，点“文件-脚本-将文件载入堆栈”，浏览并选择全部序列图点击“确定”；</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/174507/16/364/1113540/605c5269Ead842a66/0af78cb8688c093b.png" alt="导入png序列图"></p>
</li>
<li><p>然后创建时间轴：待所有序列图加载完成后，打开窗口-时间轴，点“创建时间轴”。以下步骤就同视频导出GIF图一样；</p>
</li>
<li><p>点击时间轴右上角展开菜单，选择“设置时间轴帧速率”，将帧速率和AE合成的速率保持一致（在ae中Ctrl+K打开合成设置可查看帧速率）；</p>
</li>
<li><p>选择“转换帧-从剪辑建立帧”；</p>
</li>
<li><p>点击时间轴左下角，生成帧动画；</p>
</li>
<li><p>修改动画顺序：此时动画是倒放，所以点击右上角展开菜单，点击“选择全部帧”，然后点击“反向帧”，将动画正序；</p>
</li>
<li><p>导出动画：此时动图已设置好，Ctrl+shift+alt+s导出为web所用格式，将杂边颜色修改为图案所应用的界面的背景图层一致或改成“无”，即可导出；</p>
</li>
</ol>
<h3 id="方式三：GifGun导出GIF图"><a href="#方式三：GifGun导出GIF图" class="headerlink" title="方式三：GifGun导出GIF图"></a>方式三：GifGun导出GIF图</h3><h4 id="GifGun安装方法"><a href="#GifGun安装方法" class="headerlink" title="GifGun安装方法"></a>GifGun安装方法</h4><p>先介绍一下GifGun安装方法，下载链接：<a href="http://www.gfxcamp.com/gifgun-v1715/">http://www.gfxcamp.com/gifgun-v1715/</a></p>
<p>目前GifGun的版本是：v1.7.15</p>
<p>先安装插件程序GifGunInstaller1.7.7signed.pkg；</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/163510/37/14413/59081/605c5267E71fed68d/b04c884bb17f05db.png" alt="安装方法"></p>
<p>然后复制gifGun.jsxbin文件到AE脚本目录：Mac路径：应用程序\Adobe After Effects CC\Scripts\ScriptUI Panels\；</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/163261/29/14604/994451/605c5269E3f39cc98/da2b8c42f096680c.png" alt="复制路径"></p>
<p>安装成功以后打开AE软件设置，勾选上允许脚本读写和访问网络；接下来我们就可以使用插件导出GIF啦～</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/162719/15/14710/567003/605c526aE02083989/e700d5189a6d2130.png" alt="勾选允许脚本写入"></p>
<h4 id="GifGun使用方法"><a href="#GifGun使用方法" class="headerlink" title="GifGun使用方法"></a>GifGun使用方法</h4><p>先从AE窗口最下边把GifGun插件打开，图片右侧就是GifGun插件。</p>
<p>接着就可以导出需要GIF图了，先设置下需要导出图片尺寸，比如这里我需要导出1125*926尺寸，设置宽度1125px，高度会自动换算的，设置导出位置，先把AE图层选中，也可以在导出之前，先把所有图层进行预合成，然后选中预合成文件，直接点击MaKe GIF动效就导出来了。</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/159615/15/14718/454946/605c526aE310d637d/0a9967b647ceaf08.png" alt="设置插件"></p>
<h3 id="方式四：Adobe-Media-Encoder导出GIF图"><a href="#方式四：Adobe-Media-Encoder导出GIF图" class="headerlink" title="方式四：Adobe Media Encoder导出GIF图"></a>方式四：Adobe Media Encoder导出GIF图</h3><p>1.启动Adobe Media Encoder：先选中合成文件，然后选择合成-添加到Adobe Media Encoder渲染队列，启动启动Adobe Media Encoder；</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/162087/32/14797/1739901/605c526dE5fbe7529/11a733bd25b1e1c8.png" alt="Adobe Media Encoder"></p>
<p>2.选择合成下边的下拉三角，找到我们想输出的动画GIF图格式，然后在预设中对GIF图的输出进行设置：输出路径、图片尺寸、输出质量、透明通道等进行设置，然后就可以导出GIF图了。但是一般导出的GIF图质量高体积大，需要我们再次进行GIF体积的瘦身。</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/173571/25/352/1187978/605c526bE48f3bc20/7bc2a868b6c9056d.png" alt="预设"></p>
<h3 id="影响GIF体积的因素"><a href="#影响GIF体积的因素" class="headerlink" title="影响GIF体积的因素"></a>影响GIF体积的因素</h3><p>影响GIF体积主要有三个因素：<strong>尺寸、动画复杂度、动画时长</strong></p>
<p>尺寸、动画时长越小，输出GIF的体积也就越小，动画复杂度越低，体积也就越小。影响动画复杂度的因素主要是：<strong>颜色和运动方式</strong>。相同条件下，色彩越丰富，运动方式越复杂，GIF体积越大。</p>
<h3 id="降低GIF体积的方法"><a href="#降低GIF体积的方法" class="headerlink" title="降低GIF体积的方法"></a>降低GIF体积的方法</h3><p>有时候好不容易导出了GIF图，但却因为动图文件太大，导致上传受到限制，或研发说文件太大加载太慢拒绝接受文件，这时候是不是心里有一万只草泥马🦙在奔腾～hahh～</p>
<p>我发现了一个特别好用的网站分享给大家：免费GIF编辑：<a href="https://ezgif.com/optimize%EF%BC%9B%E6%94%B6%E8%B4%B9GIF%E7%BC%96%E8%BE%91%EF%BC%9Ahttps://www.soogif.com/compress%EF%BC%9B">https://ezgif.com/optimize；收费GIF编辑：https://www.soogif.com/compress；</a></p>
<h4 id="减小GIF大小的原理"><a href="#减小GIF大小的原理" class="headerlink" title="减小GIF大小的原理"></a>减小GIF大小的原理</h4><p>编辑GIF之前，我们要先知道怎样操作才可以降低图片大小。降低GIF大小原理有三个：减少图片帧数、减少图片颜色数量、减少图片大小（宽高像素），接下来我们根据以下步骤完成GIF的编辑。以ezgif网站步骤为例：</p>
<h4 id="减小GIF大小的操作步骤"><a href="#减小GIF大小的操作步骤" class="headerlink" title="减小GIF大小的操作步骤"></a>减小GIF大小的操作步骤</h4><h5 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h5><p>先选择需要压缩的GIF图，点击上传；</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/156989/35/18066/71279/605c526aE06990430/4ad51f75b92d096b.png" alt="上传GIF"></p>
<h5 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h5><p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/155918/13/17959/753855/605c526bE4dc68d64/432b7081ec905be1.png" alt="优化gif"></p>
<p>如上图，上传了GIF后，在图片下方我们可以选择优化方法，这里的优化方法就是降低GIF图大小的三个原理；减色、使用单色：就是减少图片的颜色数量，删除重复的帧、删除第二帧、删除每三帧，、每隔4帧删除一次：就是减少GIF的帧数；有损GIF：降低GIF的质量，清晰度；</p>
<p>原图3M，经过优化后图片的质量为500k；</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/171737/21/343/510522/605c526aE4b05879d/65c60449899b9100.gif" alt="优化后图片"></p>
<p>此外，在这个宝藏网站上，我们还可以调整GIF图的动画速度和给GIF增加效果；</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/158383/36/15444/243419/605c5267Ead1122c5/c2d0cf6ef165a8cb.png" alt="变速"></p>
<p>以上就是GIF导出的几种方法，GIF格式拥有非常强的兼容性，可以在大部分智能设备上直接预览，在各个平台上的兼容性也都很强。所以GIF成为设计师做概念展示时最受欢迎的格式。</p>
<p>但GIF的缺点也是显而易见的，首先GIF对设备的性能占用很大，有时候满屏的GIF就会让页面卡顿；其次GIF作为一种有损格式，多少会对画面的色彩、质感有些影响；第三，GIF对于透明通道的支持有限，导出会出现白边。 </p>
<p>所以，下篇文章我们来分享如何将动效转换成Lottlie，实现动效展示。</p>
]]></content>
  </entry>
  <entry>
    <title>小程序实用扩展工具类库总结</title>
    <url>/2020/12/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%94%A8%E6%89%A9%E5%B1%95%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>介绍一些小程序的扩展的工具类库。</p>
</blockquote>
<h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><h3 id="1、瘦身工具"><a href="#1、瘦身工具" class="headerlink" title="1、瘦身工具"></a>1、瘦身工具</h3><blockquote>
<p>通过剔除无用文件、压缩图片、复用代码等方式减少小程序代码包体积。</p>
</blockquote>
<h4 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g miniprogram-slim</span><br></pre></td></tr></table></figure>

<h4 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Usage: miniprogram-slim &lt;command&gt;</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -v, --version                  output the version number</span><br><span class="line">  -h, --help                     output usage information</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  <span class="comment">//分析miniprogram的依赖关系，找出未使用的文件</span></span><br><span class="line">  analyzer [options]             Analyze dependencies <span class="keyword">of</span> miniprogram, find out unused files</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检测源代码中的重复</span></span><br><span class="line">  cpd [options] &lt;dir&gt;            Detect duplications <span class="keyword">in</span> source code </span><br><span class="line"></span><br><span class="line">  <span class="comment">//将图像转换为css精灵</span></span><br><span class="line">  sprite [options] &lt;input...&gt;    Covert images into css sprites </span><br><span class="line"></span><br><span class="line">  <span class="comment">//无缝缩小图像</span></span><br><span class="line">  imagemin [options] &lt;input...&gt;  Minify images seamlessly </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  $ miniprogram-slim analyzer -t</span><br><span class="line">  $ miniprogram-slim cpd src</span><br><span class="line">  $ miniprogram-slim imagemin images<span class="comment">/**/</span>*.png</span><br><span class="line">  $ miniprogram-slim sprite -f emoji images<span class="comment">/**/</span>*.png</span><br></pre></td></tr></table></figure>


<h4 id="1-2-1-依赖分析，查找无用文件（-analyzer-options-）"><a href="#1-2-1-依赖分析，查找无用文件（-analyzer-options-）" class="headerlink" title="1.2.1 依赖分析，查找无用文件（ analyzer [options] ）"></a>1.2.1 依赖分析，查找无用文件（ analyzer [options] ）</h4><blockquote>
<p>对小程序的页面和组件进行依赖分析，找出未被引用的文件，生成packOptions项，在开发者工具上传代码时忽略无用文件。</p>
<p>支持小程序/插件，仅对 wxml、wxss、wxs、js、json 以及组件进行分析，不包括组件内的图片等资源。</p>
<p>需要注意的是，js 文件的依赖，支持 import 和 require 导入的模块，但运行时计算的路径如 require(a + b) 将无法识别。</p>
</blockquote>
<p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Usage: miniprogram-slim analyzer [options]</span><br><span class="line"></span><br><span class="line">Analyze dependencies <span class="keyword">of</span> miniprogram, find out unused files</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  <span class="comment">//输出[dir]结果的目录路径（默认值：“./analyzer”）</span></span><br><span class="line">  -o, --output [dir]   path to directory <span class="keyword">for</span> result (<span class="keyword">default</span>: <span class="string">&quot;./analyzer&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//忽略应该从未使用的文件中排除的文件的glob模式</span></span><br><span class="line">  -i, --ignore &lt;glob&gt;  glob pattern <span class="keyword">for</span> files what should be excluded <span class="keyword">from</span> unused files</span><br><span class="line"></span><br><span class="line">  <span class="comment">//写覆盖旧project.config.json项目</span></span><br><span class="line">  -w, --write          overwrite old project.config.json</span><br><span class="line"></span><br><span class="line">  <span class="comment">//表打印微型程序文件大小数据</span></span><br><span class="line">  -t, --table          print miniprogram file size data</span><br><span class="line"></span><br><span class="line">  <span class="comment">//帮助输出使用信息</span></span><br><span class="line">  -h, --help           output usage information</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入包含 project.config.json 的项目根目录，执行 miniprogram-slim analyzer，默认会生成 ./analyzer/result.json 文件，记录生成的数据结果。</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//字段记录着在开发者工具打包上传时可以被忽略的文件，拷贝该部分至 project.config.json 即可，执行 miniprogram-slim analyzer -w 将自动进行同步。</span></span><br><span class="line">  <span class="string">&quot;packOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;ignore&quot;</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//字段记录着文件间的依赖关系，按页面维护分割，包括与页面相关的 wxml、wxss、js、wxs 以及组件的引用。</span></span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;app&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;esDeps&quot;</span>: [],</span><br><span class="line">      <span class="string">&quot;wxmlDeps&quot;</span>: [],</span><br><span class="line">      <span class="string">&quot;wxssDeps&quot;</span>: [],</span><br><span class="line">      <span class="string">&quot;compDeps&quot;</span>: [],</span><br><span class="line">      <span class="string">&quot;wxsDeps&quot;</span>: [],</span><br><span class="line">      <span class="string">&quot;jsonDeps&quot;</span>: [],</span><br><span class="line">      <span class="string">&quot;files&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;pages&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">&quot;subpackages&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//为未引用的文件数组</span></span><br><span class="line">  <span class="string">&quot;unusedFiles&quot;</span>: [],</span><br><span class="line">  <span class="comment">//为保持依赖关系的文件大小的集合，test/minicode 项目测试部分结果如下，其中后缀为 .json 的表示一个组件</span></span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-2-2-代码相似度比较-cpd-options"><a href="#1-2-2-代码相似度比较-cpd-options" class="headerlink" title="1.2.2 代码相似度比较 ( cpd [options] )"></a>1.2.2 代码相似度比较 ( cpd [options] )</h4><blockquote>
<p>对 jscpd 模块的简单封装，默认会在执行的目录下生成一份 .jscpd.json 配置文件，report 目录保存生成的代码对比报告。</p>
</blockquote>
<p>用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sage: miniprogram-slim cpd [options] &lt;dir&gt;</span><br><span class="line"></span><br><span class="line">Detect duplications <span class="keyword">in</span> source code</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  <span class="comment">//配置[文件]配置文件的路径</span></span><br><span class="line">  -c, --config [file]  path to config file (<span class="keyword">default</span>: <span class="string">&quot;.jscpd.json&quot;</span>)  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出[dir]报告的目录路径（默认值：“./report/”）</span></span><br><span class="line">  -o, --output [dir]   path to directory <span class="keyword">for</span> reports (<span class="keyword">default</span>: <span class="string">&quot;./report/&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//忽略应该从重复检测中排除的文件的glob模式</span></span><br><span class="line">  -i, --ignore &lt;glob&gt;  glob pattern <span class="keyword">for</span> files what should be excluded <span class="keyword">from</span> duplication detection  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//帮助输出使用信息</span></span><br><span class="line">  -h, --help           output usage information </span><br></pre></td></tr></table></figure>


<h4 id="1-2-3-图片压缩-imagemin-options"><a href="#1-2-3-图片压缩-imagemin-options" class="headerlink" title="1.2.3 图片压缩 ( imagemin [options] )"></a>1.2.3 图片压缩 ( imagemin [options] )</h4><blockquote>
<p>对 imagemin 模块的简单封装。</p>
</blockquote>
<p>用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// miniprogram-slim imagemin -h</span></span><br><span class="line">Usage: miniprogram-slim imagemin [options] &lt;input...&gt;</span><br><span class="line"></span><br><span class="line">Minify images seamlessly</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  <span class="comment">//输出目录</span></span><br><span class="line">  -o, --output &lt;dir&gt;      output directory </span><br><span class="line"></span><br><span class="line">  <span class="comment">//指示pngquant使用最少的颜色（默认值为：“0.65分,0.8分&quot;)</span></span><br><span class="line">  --png-quality &lt;string&gt;  instructs pngquant to use the least amount <span class="keyword">of</span> colors (<span class="keyword">default</span>: <span class="string">&quot;0.65,0.8&quot;</span>) </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无渐进式创建基准JPEG文件</span></span><br><span class="line">  --no-progressive        creates baseline JPEG file</span><br><span class="line"></span><br><span class="line">  <span class="comment">//帮助输出使用信息</span></span><br><span class="line">  -h, --help              output usage information </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="1-2-4-生成雪碧图代码-（sprite-f-emoji-images-png）"><a href="#1-2-4-生成雪碧图代码-（sprite-f-emoji-images-png）" class="headerlink" title="1.2.4 生成雪碧图代码 （sprite -f emoji images/*/.png）"></a>1.2.4 生成雪碧图代码 （sprite -f emoji images/*<em>/</em>.png）</h4><blockquote>
<p>对 spritesmith 模块的简单封装，能够自动生成雪碧图和对应的 css 代码。</p>
</blockquote>
<p>用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// miniprogram-slim sprite -h</span></span><br><span class="line">Usage: miniprogram-slim sprite [options] &lt;input...&gt;</span><br><span class="line"></span><br><span class="line">Covert images into css sprites</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  <span class="comment">//输出[目录]输出目录（默认值：“../”）</span></span><br><span class="line">  -o, --output [dir]       output directory (<span class="keyword">default</span>: <span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//filename[string]spritesheet的文件名（默认值：“sprite”）</span></span><br><span class="line">  -f, --filename [string]  filename <span class="keyword">of</span> spritesheet (<span class="keyword">default</span>: <span class="string">&quot;sprite&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// --要在图像之间使用的填充[数字]填充（默认值：2）</span></span><br><span class="line">  -p, --padding [number]   padding to use between images (<span class="keyword">default</span>: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//帮助输出使用信息</span></span><br><span class="line">  -h, --help               output usage information</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="2、微信小程序定义文件"><a href="#2、微信小程序定义文件" class="headerlink" title="2、微信小程序定义文件"></a>2、微信小程序定义文件</h3><blockquote>
<p>微信小程序 API 的 TypeScript 类型定义文件</p>
</blockquote>
<h4 id="1-1-安装-1"><a href="#1-1-安装-1" class="headerlink" title="1.1 安装"></a>1.1 安装</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 安装对应最新基础库的定义文件</span><br><span class="line">npm install miniprogram-api-typings</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line"># 安装对应基础库版本 2.4.1 的定义文件</span><br><span class="line">npm install miniprogram-api-typings@<span class="number">2.4</span><span class="number">.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、扩展微信小程序api支持promise"><a href="#3、扩展微信小程序api支持promise" class="headerlink" title="3、扩展微信小程序api支持promise"></a>3、扩展微信小程序api支持promise</h3><blockquote>
<p>微信小程序 API 的 TypeScript 类型定义文件</p>
</blockquote>
<h4 id="1-1-安装-2"><a href="#1-1-安装-2" class="headerlink" title="1.1 安装"></a>1.1 安装</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save miniprogram-api-promise</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-2-使用-1"><a href="#1-2-使用-1" class="headerlink" title="1.2 使用"></a>1.2 使用</h4><blockquote>
<p>在小程序入口（app.js）调用一次promisifyAll，只需要调用一次。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="keyword">import</span> &#123; promisifyAll, promisify &#125; <span class="keyword">from</span> <span class="string">&#x27;miniprogram-api-promise&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wxp = &#123;&#125;</span><br><span class="line"><span class="comment">// promisify all wx&#x27;s api</span></span><br><span class="line">promisifyAll(wx, wxp)</span><br><span class="line"><span class="built_in">console</span>.log(wxp.getSystemInfoSync())</span><br><span class="line">wxp.getSystemInfo().then(<span class="built_in">console</span>.log)</span><br><span class="line">wxp.showModal().then(wxp.openSetting())</span><br><span class="line"></span><br><span class="line"><span class="comment">// compatible usage</span></span><br><span class="line">wxp.getSystemInfo(&#123;<span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;<span class="built_in">console</span>.log(res)&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// promisify single api</span></span><br><span class="line">promisify(wx.getSystemInfo)().then(<span class="built_in">console</span>.log)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="4、threejs-miniprogram"><a href="#4、threejs-miniprogram" class="headerlink" title="4、threejs-miniprogram"></a>4、threejs-miniprogram</h3><blockquote>
<p>Three.js 小程序 WebGL 的适配版本</p>
<p>WebGL（Web图形库）是一个JavaScript API，可在任何兼容的Web浏览器中渲染高性能的交互式3D和2D图形，而无需使用插件。该API可以在HTML5 canvas元素中使用。 这种一致性使API可以利用用户设备提供的硬件图形加速</p>
</blockquote>
<h4 id="1-1-安装-3"><a href="#1-1-安装-3" class="headerlink" title="1.1 安装"></a>1.1 安装</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子可参考： https://github.com/wechat-miniprogram/threejs-miniprogram/tree/master/example</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过 npm 安装  =》 安装完成之后在微信开发者工具中点击构建 npm。</span></span><br><span class="line">npm install --save threejs-miniprogram</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、导入小程序适配版本的 Three.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;createScopedThreejs&#125; <span class="keyword">from</span> <span class="string">&#x27;threejs-miniprogram&#x27;</span></span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  <span class="function"><span class="title">onReady</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    wx.createSelectorQuery()</span><br><span class="line">      .select(<span class="string">&#x27;#webgl&#x27;</span>)</span><br><span class="line">      .node()</span><br><span class="line">      .exec(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> canvas = res[<span class="number">0</span>].node</span><br><span class="line">        <span class="comment">// 创建一个与 canvas 绑定的 three.js</span></span><br><span class="line">        <span class="keyword">const</span> THREE = createScopedThreejs(canvas)</span><br><span class="line">        <span class="comment">// 传递并使用 THREE 变量</span></span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ul>
<li>本项目当前使用的 Three.js 版本号为 0.108.0，如要更新 threejs 版本可发 PR 修改或 fork 后自行修改。</li>
<li>该适配版本的 THREE 不在全局环境中，如使用 Three.js 的其他配套类库，需要自行传入 THREE 到类库中。</li>
</ul>
<h3 id="5、lottie-miniprogram"><a href="#5、lottie-miniprogram" class="headerlink" title="5、lottie-miniprogram"></a>5、lottie-miniprogram</h3><blockquote>
<p>lottie 动画库适配小程序的版本</p>
<p>Lottie是一个用于Android，iOS，Web和Windows的库，用于解析使用Bodymovin导出为json的Adobe After Effects动画，并在移动设备和网络上呈现它们</p>
</blockquote>
<h4 id="1-1-安装-4"><a href="#1-1-安装-4" class="headerlink" title="1.1 安装"></a>1.1 安装</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可参考该代码片段：https://developers.weixin.qq.com/s/2TYvm9mJ75bF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过 npm 安装  =》 安装完成之后在微信开发者工具中点击构建 npm。</span></span><br><span class="line">npm install --save lottie-miniprogram</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、传入 canvas 对象用于适配</span></span><br><span class="line">&lt;canvas id=<span class="string">&quot;canvas&quot;</span> type=<span class="string">&quot;2d&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lottie <span class="keyword">from</span> <span class="string">&#x27;lottie-miniprogram&#x27;</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  <span class="function"><span class="title">onReady</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    wx.createSelectorQuery().select(<span class="string">&#x27;#canvas&#x27;</span>).node(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> canvas = res.node</span><br><span class="line">      lottie.setup(canvas)</span><br><span class="line">    &#125;).exec()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、使用 lottie 接口</span></span><br><span class="line">lottie.setup(canvas)</span><br><span class="line">lottie.loadAnimation(&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-2-接口"><a href="#1-2-接口" class="headerlink" title="1.2 接口"></a>1.2 接口</h4><p>目前提供两个接口：</p>
<ul>
<li>lottie.setup(canvas)</li>
</ul>
<p>需要在任何 lottie 接口调用之前调用，传入 canvas 对象</p>
<ul>
<li>lottie.loadAnimation(options)</li>
</ul>
<p>与原来的 loadAnimation 有些不同，支持的参数有：</p>
<ul>
<li>loop</li>
<li>autoplay</li>
<li>animationData</li>
<li>path （只支持网络地址）</li>
<li>rendererSettings.context （必填）</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>本项目是以 npm 的方式依赖原 lottie-web 项目，若原项目有新版本，可直接改变依赖的版本号。</li>
<li>本项目依赖小程序基础库 2.8.0 里性能更好的 canvas 实现，由于还有些小问题没有正式开放，但目前用在此处暂无发现问题。</li>
<li>由于小程序本身不支持动态执行脚本，因此 lottie 的 expression 功能也是不支持的。</li>
</ul>
<h3 id="6、参考文档"><a href="#6、参考文档" class="headerlink" title="6、参考文档"></a>6、参考文档</h3><ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/extended/utils/miniprogram-slim.html">小程序文档</a></li>
<li><a href="https://github.com/wechat-miniprogram">小程序文档源代码</a></li>
<li><a href="https://github.com/airbnb/lottie-web">web-lottie源代码</a></li>
<li><a href="https://www.yuque.com/lottie/document/web">web-lottie中文网</a></li>
<li><a href="https://github.com/mrdoob/three.js">three.js源代码</a></li>
<li><a href="http://www.webgl3d.cn/">threejs中文网</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>微信小程序canvas(二)：绘制顶部或底部有凹凸弧度的矩形或图片</title>
    <url>/2020/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fcanvas(%E4%B8%80)%EF%BC%9A%E7%BB%98%E5%88%B6%E9%A1%B6%E9%83%A8%E6%88%96%E5%BA%95%E9%83%A8%E6%9C%89%E5%87%B9%E5%87%B8%E5%BC%A7%E5%BA%A6%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%88%96%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>要实现顶部或底部有凹凸弧度的矩形或图片，实现的效果如下：<br><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/90092/12/12709/105215/5e4e2a2aE8c55ded3/5caeb3c5a8aa1cf0.png" alt="图片 1.png"></p>
<h3 id="第一步：需要定义生成顶部或底部有弧度的矩形的函数"><a href="#第一步：需要定义生成顶部或底部有弧度的矩形的函数" class="headerlink" title="第一步：需要定义生成顶部或底部有弧度的矩形的函数"></a>第一步：需要定义生成顶部或底部有弧度的矩形的函数</h3><ul>
<li>参数定义：topRadianHeight： 顶部弧度的高度，大于0为顶部凸，小于0为顶部凹；bottomRadianHeight：底部弧度高度，大于0为底部凸，小于0为底部凹<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 画顶部或底部有弧度的矩形或图片需要用到的方法</span><br><span class="line"> * @param params</span><br><span class="line"> * @param topRadianHeight 顶部弧度，大于0为顶部凸，小于0为顶部凹</span><br><span class="line"> * @param bottomRadianHeight 底部弧度，大于0为底部凸，小于0为底部凹</span><br><span class="line"> * @param ctx</span><br><span class="line"> *&#x2F;</span><br><span class="line">const toDrawArcRect &#x3D; (params, ctx) &#x3D;&gt; &#123; &#x2F;&#x2F; 画上下左右方向有弧度的矩形</span><br><span class="line">  const &#123;</span><br><span class="line">    left, top, width, height,</span><br><span class="line">    topRadianHeight, bottomRadianHeight</span><br><span class="line">  &#125; &#x3D; params</span><br><span class="line"> </span><br><span class="line">  const halfWidth &#x3D; width &#x2F; 2</span><br><span class="line">  const radianHeight &#x3D; topRadianHeight || bottomRadianHeight || 0</span><br><span class="line">  const r &#x3D; (halfWidth * halfWidth + radianHeight * radianHeight) &#x2F; (2 * Math.abs(radianHeight))</span><br><span class="line">  const radiusX &#x3D; left + halfWidth &#x2F;&#x2F; 圆心X的坐标</span><br><span class="line">  const radianValue &#x3D; Math.acos(halfWidth &#x2F; r) &#x2F;&#x2F; 弧度</span><br><span class="line">  ctx.beginPath()</span><br><span class="line">  if (bottomRadianHeight) &#123; &#x2F;&#x2F; 底部凸</span><br><span class="line">    if (bottomRadianHeight &gt; 0) &#123;</span><br><span class="line">      ctx.arc(radiusX, top + height - r, r, radianValue, -radianValue + Math.PI)</span><br><span class="line">      ctx.lineTo(left, top)</span><br><span class="line">      ctx.lineTo(left + width, top)</span><br><span class="line">      ctx.lineTo(left + width, top - radianHeight + height)</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 底部凹</span><br><span class="line">      ctx.arc(radiusX, top + height + r + radianHeight, r, radianValue - Math.PI, -radianValue)</span><br><span class="line">      ctx.lineTo(left + width, top)</span><br><span class="line">      ctx.lineTo(left, top)</span><br><span class="line">      ctx.lineTo(left, top + height)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  if (topRadianHeight) &#123;</span><br><span class="line">    if (topRadianHeight &gt; 0) &#123; &#x2F;&#x2F; 顶部凸</span><br><span class="line">      ctx.arc(radiusX, top + r, r, radianValue - Math.PI, -radianValue)</span><br><span class="line">      ctx.lineTo(left + width, top + height)</span><br><span class="line">      ctx.lineTo(left, top + height)</span><br><span class="line">      ctx.lineTo(left, top + radianHeight)</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 顶部凹</span><br><span class="line">      ctx.arc(radiusX, top - r - topRadianHeight, r, radianValue, -radianValue + Math.PI)</span><br><span class="line">      ctx.lineTo(left, top + height)</span><br><span class="line">      ctx.lineTo(left + width, top + height)</span><br><span class="line">      ctx.lineTo(left + width, top)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="第二步：绘制顶部或底部有凹凸弧度的线框、矩形或图片"><a href="#第二步：绘制顶部或底部有凹凸弧度的线框、矩形或图片" class="headerlink" title="第二步：绘制顶部或底部有凹凸弧度的线框、矩形或图片"></a>第二步：绘制顶部或底部有凹凸弧度的线框、矩形或图片</h3><ul>
<li>画线框<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toDrawArcRect(***)</span><br><span class="line">this.ctx.stroke()</span><br></pre></td></tr></table></figure></li>
<li>画矩形<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toDrawArcRect(***)</span><br><span class="line">this.ctx.fill()</span><br></pre></td></tr></table></figure></li>
<li>画图片<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.ctx.save()</span><br><span class="line">toDrawArcRect(***)</span><br><span class="line">ctx.strokeStyle &#x3D; &#39;rgba(255,255,255,0)&#39;</span><br><span class="line">ctx.stroke()</span><br><span class="line">this.ctx.clip()</span><br><span class="line">this.ctx.drawImage(***)</span><br><span class="line">this.ctx.restore()</span><br></pre></td></tr></table></figure>
_注：原理是，clip() 方法会在原始画布上剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。可以在使用 clip() 方法前通过使用 save() 方法对当前画布区域进行保存，并在以后的任意时间通过 restore() 方法对其进行恢复。</li>
</ul>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序canvas(一)：绘制圆角矩形或图片</title>
    <url>/2020/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fcanvas(%E4%BA%8C)%EF%BC%9A%E7%BB%98%E5%88%B6%E5%9C%86%E8%A7%92%E7%9F%A9%E5%BD%A2%E6%88%96%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>参考了大牛文章的方案，链接如下：<a href="https://juejin.im/post/5b7e48566fb9a01a1059543f">https://juejin.im/post/5b7e48566fb9a01a1059543f</a><br>他的方案只能同时设置四个角的圆角值，在这里优化了大牛的方案，可根据需要给四个圆角设置不同的值。</p>
<h3 id="需要定义生成圆角矩形的函数"><a href="#需要定义生成圆角矩形的函数" class="headerlink" title="需要定义生成圆角矩形的函数"></a>需要定义生成圆角矩形的函数</h3><ul>
<li>参数定义：可以通过设置borderRadius或borderTopLeftRadius、borderTopRightRadius、 borderBottomRightRadius和borderBottomLeftRadius来生成四个方向的圆角矩形或图片<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 画圆角矩形、圆角边框和圆角图片所用到的方法</span><br><span class="line"> * @param params</span><br><span class="line"> * @param ctx</span><br><span class="line"> *&#x2F;</span><br><span class="line">const toDrawRadiusRect &#x3D; (params, ctx) &#x3D;&gt; &#123;</span><br><span class="line">  const &#123;</span><br><span class="line">    left, top, width, height, borderRadius,</span><br><span class="line">    borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius</span><br><span class="line">  &#125; &#x3D; params</span><br><span class="line">  ctx.beginPath()</span><br><span class="line">  if (borderRadius) &#123;</span><br><span class="line">    &#x2F;&#x2F; 全部有弧度</span><br><span class="line">    const br &#x3D; borderRadius &#x2F; 2</span><br><span class="line">    ctx.moveTo(left + br, top) &#x2F;&#x2F; 移动到左上角的点</span><br><span class="line">    ctx.lineTo(left + width - br, top) &#x2F;&#x2F; 画上边的线</span><br><span class="line">    ctx.arcTo(left + width, top, left + width, top + br, br) &#x2F;&#x2F; 画右上角的弧</span><br><span class="line">    ctx.lineTo(left + width, top + height - br) &#x2F;&#x2F; 画右边的线</span><br><span class="line">    ctx.arcTo(left + width, top + height, left + width - br, top + height, br) &#x2F;&#x2F; 画右下角的弧</span><br><span class="line">    ctx.lineTo(left + br, top + height) &#x2F;&#x2F; 画下边的线</span><br><span class="line">    ctx.arcTo(left, top + height, left, top + height - br, br) &#x2F;&#x2F; 画左下角的弧</span><br><span class="line">    ctx.lineTo(left, top + br) &#x2F;&#x2F; 画左边的线</span><br><span class="line">    ctx.arcTo(left, top, left + br, top, br) &#x2F;&#x2F; 画左上角的弧</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const topLeftBr &#x3D; borderTopLeftRadius ? borderTopLeftRadius &#x2F; 2 : 0</span><br><span class="line">    const topRightBr &#x3D; borderTopRightRadius ? borderTopRightRadius &#x2F; 2 : 0</span><br><span class="line">    const bottomRightBr &#x3D; borderBottomRightRadius ? borderBottomRightRadius &#x2F; 2 : 0</span><br><span class="line">    const bottomLeftBr &#x3D; borderBottomLeftRadius ? borderBottomLeftRadius &#x2F; 2 : 0</span><br><span class="line">    ctx.moveTo(left + topLeftBr, top)</span><br><span class="line">    ctx.lineTo(left + width - topRightBr, top)</span><br><span class="line">    if (topRightBr) &#123; &#x2F;&#x2F; 画右上角的弧度</span><br><span class="line">      ctx.arcTo(left + width, top, left + width, top + topRightBr, topRightBr)</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.lineTo(left + width, top + height - bottomRightBr) &#x2F;&#x2F; 画右边的线</span><br><span class="line">    if (bottomRightBr) &#123; &#x2F;&#x2F; 画右下角的弧度</span><br><span class="line">      ctx.arcTo(left + width, top + height,</span><br><span class="line">        left + width - bottomRightBr, top + height, bottomRightBr)</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.lineTo(left + bottomLeftBr, top + height)</span><br><span class="line">    if (bottomLeftBr) &#123;</span><br><span class="line">      ctx.arcTo(left, top + height, left, top + height - bottomLeftBr, bottomLeftBr)</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.lineTo(left, top + topLeftBr)</span><br><span class="line">    if (topLeftBr) &#123;</span><br><span class="line">      ctx.arcTo(left, top, left + topLeftBr, top, topLeftBr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="绘制顶部或底部有凹凸弧度的线框、矩形或图片"><a href="#绘制顶部或底部有凹凸弧度的线框、矩形或图片" class="headerlink" title="绘制顶部或底部有凹凸弧度的线框、矩形或图片"></a>绘制顶部或底部有凹凸弧度的线框、矩形或图片</h3><ul>
<li>画线框<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toDrawRadiusRect(***)</span><br><span class="line">this.ctx.stroke()</span><br></pre></td></tr></table></figure></li>
<li>画矩形<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toDrawRadiusRect(***)</span><br><span class="line">this.ctx.fill()</span><br></pre></td></tr></table></figure></li>
<li>画图片<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.ctx.save()</span><br><span class="line">toDrawRadiusRect(***) </span><br><span class="line">ctx.strokeStyle &#x3D; &#39;rgba(255,255,255,0)&#39;</span><br><span class="line">ctx.stroke()</span><br><span class="line">this.ctx.clip()</span><br><span class="line">this.ctx.drawImage(***)</span><br><span class="line">this.ctx.restore()</span><br></pre></td></tr></table></figure>
_注：原理是，clip() 方法会在原始画布上剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。可以在使用 clip() 方法前通过使用 save() 方法对当前画布区域进行保存，并在以后的任意时间通过 restore() 方法对其进行恢复。</li>
</ul>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序暗黑模式</title>
    <url>/2020/11/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。</p>
<p>WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。</p>
<p>增强 wxml 标签的表达能力</p>
<p>WXS 对性能的贡献就只有一点：与 WXML 是在同一个线程运行的，避免了跨线程通信的开销。</p>
<p>号称 『wxs 目前在 iOS 设备的效率，会比JS快 2~20倍。在 Android 则无差异</p>
</blockquote>
<h1 id="WXS模块"><a href="#WXS模块" class="headerlink" title="WXS模块"></a>WXS模块</h1><p>每一个 .wxs 文件和 <code>&lt;wxs&gt;</code> 标签都是一个单独的模块。</p>
<p>每个模块都有自己独立的作用域。即在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见。</p>
<p>一个模块要想对外暴露其内部的私有变量与函数，只能通过 module.exports 实现。</p>
<h2 id="module-对象"><a href="#module-对象" class="headerlink" title="module 对象"></a>module 对象</h2><p>eg:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /page/tools.wxs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;&#x27;hello world&#x27; from tools.wxs&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象形式导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  FOO: foo,</span><br><span class="line">  bar: bar,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 单独导出某一个</span></span><br><span class="line"><span class="built_in">module</span>.exports.msg = <span class="string">&quot;some msg&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><p>在 wxs 中引用其它 wxs 文件文件模块，可以使用 require 函数，引用的时候需要注意以下几点问题：</p>
<ol>
<li>只能引用 .wxs 文件模块，且必须使用相对路径。</li>
<li>wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。</li>
<li>如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tools = <span class="built_in">require</span>(<span class="string">&quot;./cat.wxs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tools.tip);</span><br><span class="line"><span class="built_in">console</span>.log(tools.msg);</span><br></pre></td></tr></table></figure>

<h2 id="标签"><a href="#标签" class="headerlink" title=" 标签"></a><wxs> 标签</h2><p><code>&lt;wxs&gt;</code> 标签有两个属性，一个是 module，一个是 src.</p>
<p>此标签可以使用单标签闭合的写法</p>
<h3 id="module-属性"><a href="#module-属性" class="headerlink" title="module 属性"></a>module 属性</h3><p>当前 <code>&lt;wxs&gt;</code> 标签的模块名。必填字段。</p>
<p>在单个 wxml 文件内，建议其值唯一。有重复模块名则按照先后顺序覆盖（后者覆盖前者）。不同文件之间的 wxs 模块名不会相互覆盖。</p>
<p>module 属性值的命名必须符合下面两个规则：</p>
<ol>
<li>首字符必须是：字母（a-zA-Z），下划线（_）</li>
<li>剩余字符可以是：字母（a-zA-Z），下划线（_）， 数字（0-9）</li>
</ol>
<h3 id="src-属性"><a href="#src-属性" class="headerlink" title="src 属性"></a>src 属性</h3><p>引用 .wxs 文件的相对路径。仅当本标签为单闭合标签或标签的内容为空时有效</p>
<p>src 属性可以用来引用其他的 wxs 文件模块。</p>
<p>引用的时候，要注意如下几点：</p>
<ol>
<li>只能引用 .wxs 文件模块，且必须使用相对路径。</li>
<li>wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。</li>
<li>如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。</li>
</ol>
<p>这里的规则同 require 函数。</p>
<p><code>&lt;wxs&gt;</code> 模块只能在定义模块的 WXML 文件中被访问到。使用 <code>&lt;include&gt;</code> 或 <code>&lt;import&gt;</code> 时，<code>&lt;wxs&gt;</code> 模块不会被引入到对应的 WXML 文件中。</p>
<p><code>&lt;template&gt;</code> 标签中，只能使用定义该 <code>&lt;template&gt;</code> 的 WXML 文件中定义的 <code>&lt;wxs&gt;</code> 模块.</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol>
<li>WXS 中的变量均为值的引用。</li>
<li>没有声明的变量直接赋值使用，会被定义为全局变量。</li>
<li>如果只声明变量而不赋值，则默认值为 undefined。</li>
<li>var表现与javascript一致，会有变量提升</li>
</ol>
<p>…<br>其余的都与JavaScript相差不大，不再赘述。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li><code>&lt;wxs&gt;</code> 模块只能在定义模块的 WXML 文件中被访问到。使用 <code>&lt;include&gt;</code> 或 <code>&lt;import&gt;</code> 时，<code>&lt;wxs&gt;</code> 模块不会被引入到对应的 WXML 文件中。</li>
<li>&lt;<code>template&gt;</code> 标签中，只能使用定义该 <code>&lt;template&gt;</code> 的 WXML 文件中定义的 <code>&lt;wxs&gt;</code> 模块。</li>
<li><em>不支持es6语法</em></li>
</ol>
<h1 id="小程序暗黑模式"><a href="#小程序暗黑模式" class="headerlink" title="小程序暗黑模式"></a>小程序暗黑模式</h1><p>当app.json中配置darkmode为true时，小程序部分配置项可通过变量的形式配置，在变量配置文件中定义不同主题下的颜色或图标，方法如下：</p>
<ol>
<li>在app.json中配置 themeLocation，指定变量配置文件 theme.json 路径，例如：在根目录下新增theme.json，需要配置”themeLocation”:”theme.json”</li>
<li>在theme.json中定义相关变量；</li>
<li>在app.json中以@开头引用变量。</li>
</ol>
<p>支持通过变量配置的属性：</p>
<p>全局配置的 window 属性与页面配置下的属性</p>
<ol>
<li>navigationBarBackgroundColor</li>
<li>navigationBarTextStyle</li>
<li>backgroundColor</li>
<li>backgroundTextStyle</li>
<li>backgroundColorTop</li>
<li>backgroundColorBottom</li>
</ol>
<p>全局配置 window.tabBar 的属性</p>
<ol>
<li>color</li>
<li>selectedColor</li>
<li>backgroundColor</li>
<li>borderStyle</li>
<li>list</li>
<li>iconPath</li>
<li>selectedIconPat</li>
</ol>
<p>相关配置：</p>
<p>app.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;themeLocation&quot;: &quot;theme.json&quot;,</span><br><span class="line">&quot;darkmode&quot;: true,</span><br><span class="line">&quot;window&quot;: &#123;</span><br><span class="line">  &quot;navigationBarBackgroundColor&quot;: &quot;@navBgColor&quot;,</span><br><span class="line">  &quot;navigationBarTextStyle&quot;: &quot;@navTxtStyle&quot;,</span><br><span class="line">  &quot;backgroundColor&quot;: &quot;@bgColor&quot;,</span><br><span class="line">  &quot;backgroundTextStyle&quot;: &quot;@bgTxtStyle&quot;,</span><br><span class="line">  &quot;backgroundColorTop&quot;: &quot;@bgColorTop&quot;,</span><br><span class="line">  &quot;backgroundColorBottom&quot;: &quot;@bgColorBottom&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>theme.json</p>
<p>必须包含 light、dark 属性</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;light&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;navBgColor&quot;</span>: <span class="string">&quot;#f6f6f6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;navTxtStyle&quot;</span>: <span class="string">&quot;black&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;bgColor&quot;</span>: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;bgTxtStyle&quot;</span>: <span class="string">&quot;light&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;bgColorTop&quot;</span>: <span class="string">&quot;#eeeeee&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;bgColorBottom&quot;</span>: <span class="string">&quot;#efefef&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dark&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;navBgColor&quot;</span>: <span class="string">&quot;#191919&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;navTxtStyle&quot;</span>: <span class="string">&quot;white&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;bgColor&quot;</span>: <span class="string">&quot;#1f1f1f&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;bgTxtStyle&quot;</span>: <span class="string">&quot;dark&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;bgColorTop&quot;</span>: <span class="string">&quot;#191919&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;bgColorBottom&quot;</span>: <span class="string">&quot;#1f1f1f&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Attention：</p>
<ol>
<li>在小程序中，若使用编译打包的形式，直接在app.js中写入时，如果打包出来的 theme.json 引入报错，可采用在 config 中 copy theme.json 文件 的方式</li>
<li>必须配置darkmode和themeLocation才会生效</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>微前端实践一</title>
    <url>/2021/06/08/%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80/</url>
    <content><![CDATA[<h2 id="微前端起源"><a href="#微前端起源" class="headerlink" title="微前端起源"></a>微前端起源</h2><p>微前端的概念最早由 thoughtworks 在 2016 年提出。其核心思路是借鉴后端微服务架构理念，将一个单体的庞大的前端应用拆分为多个简单独立的前端工程。每个前端工程可以独立开发、测试、部署。最终再由一个容器应用，将拆分后的微前端工程组合为一个整体，面向用户提供服务<br><img src= "/img/loading.gif" data-src="%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.jpg" alt="整体架构"></p>
<h2 id="微前端的价值"><a href="#微前端的价值" class="headerlink" title="微前端的价值"></a>微前端的价值</h2><ul>
<li>技术栈无关<br>主框架不限制接入应用的技术栈，子应用具备完全自主权</li>
<li>独立开发、独立部署<br>子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</li>
<li>独立运行时<br>每个子应用之间状态隔离，运行时状态不共享</li>
</ul>
<p>微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。</p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>MPA: 多页面应用(Multi page web application)<br>SPA: 单页面应用(Single page web appliction)</p>
<p>MPA:</p>
<ul>
<li>优点:  部署简单、各应用之间硬隔离，天生具备技术栈无关、独立开发、独立部署的特性。</li>
<li>缺点则也很明显，应用之间切换会造成浏览器重刷，由于产品域名之间相互跳转，流程体验上会存在断点。</li>
</ul>
<p>SPA </p>
<ul>
<li>优点: 则天生具备体验上的优势，应用直接无刷新切换，能极大的保证多产品之间流程操作串联时的流程性。</li>
<li>缺点则在于各应用技术栈之间是强耦合的。</li>
</ul>
<h2 id="常见的实现方式"><a href="#常见的实现方式" class="headerlink" title="常见的实现方式"></a>常见的实现方式</h2><ul>
<li>路由分发式。通过 HTTP 服务器的反向代理功能，来将请求路由到对应的应用上。</li>
<li>前端微服务化。在不同的框架之上设计通讯、加载机制，以在一个页面内加载对应的应用。</li>
<li>微应用。通过软件工程的方式，在部署构建环境中，组合多个独立应用成一个单体应用。</li>
<li>微件化。开发一个新的构建系统，将部分业务功能构建成一个独立的 chunk 代码，使用时只需要远程加载即可。</li>
<li>前端容器化。通过将 iFrame 作为容器，来容纳其它前端应用。</li>
<li>应用组件化。借助于 Web Components 技术，来构建跨框架的前端应用。<h3 id="路由分发式"><a href="#路由分发式" class="headerlink" title="路由分发式"></a>路由分发式</h3>路由分发式微前端，即通过路由将不同的业务分发到不同的、独立前端应用上。其通常可以通过 HTTP 服务器的反向代理来实现，又或者是应用框架自带的路由来解决。<br><img src= "/img/loading.gif" data-src="%E8%B7%AF%E7%94%B1%E5%88%86%E5%8F%91.jpg" alt="路由分发式"></li>
</ul>
<h3 id="前端微服务化"><a href="#前端微服务化" class="headerlink" title="前端微服务化"></a>前端微服务化</h3><p>前端微服务化，是微服务架构在前端的实施，每个前端应用都是完全独立（技术栈、开发、部署、构建独立）、自主运行的，最后通过模块化的方式组合出完整的前端应用。其<br><img src= "/img/loading.gif" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96.jpeg" alt="微服务化"></p>
<h3 id="组合式集成：微应用化"><a href="#组合式集成：微应用化" class="headerlink" title="组合式集成：微应用化"></a>组合式集成：微应用化</h3><p>微应用化，即在开发时，应用都是以单一、微小应用的形式存在，而在运行时，则通过构建系统合并这些应用，组合成一个新的应用。<br><img src= "/img/loading.gif" data-src="%E5%BE%AE%E5%BA%94%E7%94%A8%E5%8C%96.jpeg" alt="微应用化"></p>
<h3 id="微件化"><a href="#微件化" class="headerlink" title="微件化"></a>微件化</h3><p>微件（widget），指的是一段可以直接嵌入在应用上运行的代码，它由开发人员预先编译好，在加载时不需要再做任何修改或者编译。<br><img src= "/img/loading.gif" data-src="%E5%BE%AE%E4%BB%B6%E5%8C%96.jpeg" alt="微件化"></p>
<h3 id="前端容器化"><a href="#前端容器化" class="headerlink" title="前端容器化"></a>前端容器化</h3><p>前端容器 iframe 或 web components</p>
<h3 id="几种实现方式对比"><a href="#几种实现方式对比" class="headerlink" title="几种实现方式对比"></a>几种实现方式对比</h3><p><img src= "/img/loading.gif" data-src="%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94.jpg" alt="微前端实现方式对比"></p>
<p>Systemjs模块化解决方案<br><a href="https://github.com/systemjs/systemjs">https://github.com/systemjs/systemjs</a></p>
<p>systemjs 是一个最小系统加载工具，用来创建插件来处理可替代的场景加载过程，包括加载 CSS 场景和图片，主要运行在浏览器和 NodeJS 中。它是 ES6 浏览器加载程序的的扩展，将应用在本地浏览器中。通常创建的插件名称是模块本身，要是没有特意指定用途，则默认插件名是模块的扩展名称。</p>
<p>通常它支持创建的插件种类有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CSS </span></span><br><span class="line">System.import(<span class="string">&#x27;my/file.css!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Image </span></span><br><span class="line">System.import(<span class="string">&#x27;some/image.png!image&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON </span></span><br><span class="line">System.import(<span class="string">&#x27;some/data.json!&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Markdown </span></span><br><span class="line">System.import(<span class="string">&#x27;app/some/project/README.md!&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Text </span></span><br><span class="line">System.import(<span class="string">&#x27;some/text.txt!text&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WebFont </span></span><br><span class="line">System.import(<span class="string">&#x27;google Port Lligat Slab, Droid Sans !font&#x27;</span>)</span><br><span class="line"></span><br><span class="line">System.register(<span class="string">&#x27;name&#x27;</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;system.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;systemjs-importmap&quot;</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="javascript">  <span class="string">&quot;imports&quot;</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="string">&quot;lodash&quot;</span>: <span class="string">&quot;https://unpkg.com/lodash@4.17.10/lodash.js&quot;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;systemjs-module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="webpack5-Module-Federation"><a href="#webpack5-Module-Federation" class="headerlink" title="webpack5 Module Federation"></a>webpack5 Module Federation</h2><p><a href="https://indepth.dev/posts/1173/webpack-5-module-federation-a-game-changer-in-javascript-architecture">https://indepth.dev/posts/1173/webpack-5-module-federation-a-game-changer-in-javascript-architecture</a></p>
<p>1、模块联邦是什么<br>简单来说就是允许运行时动态决定代码的引入和加载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app1</span><br><span class="line">---index.js 入口文件</span><br><span class="line">---bootstrap.js 启动文件 <span class="comment">// 特殊处理</span></span><br><span class="line">---App.js react组件</span><br><span class="line"></span><br><span class="line">app2</span><br><span class="line">---index.js 入口文件</span><br><span class="line">---bootstrap.js 启动文件 <span class="comment">// 特殊处理</span></span><br><span class="line">---App.js react组件</span><br><span class="line">---User.js react组件</span><br><span class="line">---News.js react组件</span><br></pre></td></tr></table></figure>

<p>2、代码结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** app1 **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * index.js</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * App.js</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;app2/User&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _onbind = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onBind&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;App1 Content&lt;/h2&gt;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    &lt;React.Suspense fallback=<span class="string">&quot;Loading app2&quot;</span>&gt;</span><br><span class="line">      &lt;User name=&#123;<span class="string">&#x27;app1 named&#x27;</span>&#125; onbind=&#123; _onbind&#125;/&gt;</span><br><span class="line">    &lt;/React.Suspense&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>
<p>暂时不用关心app2的代码，问题关键是： app1是如何引入app2的代码的？</p>
<p>3、Module federation的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * app1/webpack.config.js</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.join(__dirname, <span class="string">&#x27;public/index.html&#x27;</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> Mfp(&#123;</span><br><span class="line">      filename:<span class="string">&#x27;app1.js&#x27;</span>,<span class="comment">// 对外提供打包后的文件名，导入时会使用</span></span><br><span class="line">      name:<span class="string">&#x27;app1&#x27;</span>,<span class="comment">// 微应用的名字</span></span><br><span class="line">      remotes: &#123;  <span class="comment">// 引用外部的组件</span></span><br><span class="line">        app2: <span class="string">&quot;app2@http://localhost:3001/app2.js&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// shared: [&quot;react&quot;, &quot;react-dom&quot;],</span></span><br><span class="line">      shared: &#123;</span><br><span class="line">        react: &#123; <span class="attr">singleton</span>: <span class="literal">true</span> &#125;, <span class="comment">// singleton 只实例化一次</span></span><br><span class="line">        <span class="string">&quot;react-dom&quot;</span>: &#123; <span class="attr">singleton</span>: <span class="literal">true</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置：exposes/remotes<br>app1项目引入 app2 的 News组件 User组件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * app2/webpack.config.js</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">new</span> Mfp(&#123;</span><br><span class="line">  filename:<span class="string">&#x27;app2.js&#x27;</span>,<span class="comment">// 对外提供打包后的文件名，导入时会使用</span></span><br><span class="line">  name:<span class="string">&#x27;app2&#x27;</span>,<span class="comment">// 微应用的名字</span></span><br><span class="line">  exposes:&#123; <span class="comment">// 暴露外部的组件</span></span><br><span class="line">    <span class="string">&#x27;./News&#x27;</span>:<span class="string">&#x27;./src/News.js&#x27;</span>, <span class="comment">// 名字：具体那个一个组件</span></span><br><span class="line">    <span class="string">&#x27;./User&#x27;</span>:<span class="string">&#x27;./src/User.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * app1/webpack.config.js</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">new</span> Mfp(&#123;</span><br><span class="line">  filename:<span class="string">&#x27;app1.js&#x27;</span>,<span class="comment">// 对外提供打包后的文件名，导入时会使用</span></span><br><span class="line">  name:<span class="string">&#x27;app1&#x27;</span>,<span class="comment">// 微应用的名字</span></span><br><span class="line">  remotes: &#123; <span class="comment">// 引用外部的组件</span></span><br><span class="line">    app2: <span class="string">&quot;app2@http://localhost:3001/app2.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
我们重点关注 <code>exposes/remotes</code>：</li>
</ul>
<ul>
<li>提供了 <code>exposes</code> 选项的表示当前应用是一个 <code>Remote</code>，<code>exposes</code> 内的模块可以被其他的 <code>Host</code> 引用，引用方式为 <code>import($&#123;name&#125;/$&#123;expose&#125;)</code>。</li>
<li>提供了 <code>remotes</code> 选项的表示当前应用是一个 <code>Host</code>，可以引用 <code>remote</code> 中 <code>expose</code> 的模块。</li>
</ul>
<p>项目中如何使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * app1/App.js中通过 React.lazy 引用</span></span><br><span class="line"><span class="comment"> * 使用 &lt;React.Suspense&gt;&lt;/React.Suspense&gt;包括</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> User = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;app2/User&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;App1 Content&lt;/h2&gt;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;React.Suspense fallback=<span class="string">&quot;Loading app&quot;</span>&gt;</span><br><span class="line">      &lt;User/&gt;</span><br><span class="line">    &lt;/React.Suspense&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>

<ul>
<li>配置：shared<br>除了前面提到的模块引入和模块暴露相关的配置外，还有个 <code>shared</code> 配置，主要是用来避免项目出现多个公共依赖。<br>例如，我们当前的项目 app1，已经引入了一个 <code>react/react-dom</code>，而项目 app2 暴露的User组件也依赖了 <code>react/react-dom</code>。如果不解决这个问题，项目 app1 就会加载两个 <code>react</code> 库。</li>
</ul>
<ul>
<li><ol>
<li>remotes的代码自己不打包，类似external，例如app2/button就是加载app2打包的代码</li>
</ol>
</li>
<li><ol start="2">
<li>shared的代码自己是有打包的</li>
</ol>
</li>
</ul>
<ul>
<li>问题及解决方案<br>1、配置shared后报错： Shared module is not available for eager consumption<br><img src= "/img/loading.gif" data-src="shared_error.png" alt="shared报错"></li>
</ul>
<p>解决方案：<br>增加<code>bootstrap.js</code> 通过 <code>index.js</code> 异步加载页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * webpack.config.js</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/bootstrap\.js$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;bundle-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          lazy: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * index.js</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">import</span> bootstrap <span class="keyword">from</span> <span class="string">&#x27;./bootstrap&#x27;</span></span><br><span class="line">bootstrap()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bootstrap.js</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主要原因是 <code>remote</code> 暴露的 js 文件需要优先加载，如果 <code>bootstrap.js</code> 不是一个异步逻辑，在 <code>import User</code> 的时候，会依赖 <code>app2</code> 的 <code>app2.js</code>，如果直接在 <code>index.js</code> 执行，<code>app2</code> 的 <code>app2.js</code> 根本没有加载，所以会有问题。</p>
<ul>
<li><p>双向共享</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * app1/webpack.config.js</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">new</span> Mfp(&#123;</span><br><span class="line">  filename:<span class="string">&#x27;app1.js&#x27;</span>,</span><br><span class="line">  name:<span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">  exposes:&#123;</span><br><span class="line">    <span class="comment">// 名字：具体那个一个组件</span></span><br><span class="line">    <span class="string">&#x27;./Button&#x27;</span>:<span class="string">&#x27;./src/Button.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * app2/webpack.config.js</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> <span class="keyword">new</span> Mfp(&#123;</span><br><span class="line">  filename:<span class="string">&#x27;app2.js&#x27;</span>,</span><br><span class="line">  name:<span class="string">&#x27;app2&#x27;</span>,</span><br><span class="line">  <span class="comment">// 引用外部的组件</span></span><br><span class="line">  remotes: &#123;</span><br><span class="line">    app1: <span class="string">&quot;app1@http://localhost:3000/app1.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * app2/News.js</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> <span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;app1/Button&quot;</span>))</span><br><span class="line"><span class="keyword">const</span> News = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    App2 News组件</span><br><span class="line">    &lt;React.Suspense fallback=<span class="string">&quot;loading app1&quot;</span>&gt;</span><br><span class="line">      &lt;Button /&gt;</span><br><span class="line">    &lt;/React.Suspense&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> News</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载逻辑<br><img src= "/img/loading.gif" data-src="load_order.jpg" alt="加载顺序"></p>
</li>
</ul>
<p>这里有一个点需要特别注意，就是入口文件 index.js 本身没有什么逻辑，反而将逻辑放在了 bootstrap.js 中，index.js 去动态加载 bootstrap.js。</p>
<p>参考文档：<br><a href="https://micro-frontends.org/">https://micro-frontends.org/</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>微前端</tag>
      </tags>
  </entry>
  <entry>
    <title>微前端实践三（Micro-App落地）</title>
    <url>/2021/09/09/%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%89/</url>
    <content><![CDATA[<h2 id="微前端架构之Micro-App"><a href="#微前端架构之Micro-App" class="headerlink" title="微前端架构之Micro-App"></a>微前端架构之Micro-App</h2><p>经过前面一系列调研，最终决定使用京东出品的微前端框架Micro-App来落地我们的新项目</p>
<h3 id="关于Micro-App"><a href="#关于Micro-App" class="headerlink" title="关于Micro-App"></a>关于Micro-App</h3><p><code>single-spa</code>是通过监听 <code>url change</code> 事件，在路由变化时匹配到渲染的子应用并进行渲染，这个思路也是目前实现微前端的主流方式。同时<code>single-spa</code>要求子应用修改渲染逻辑并暴露出三个方法：<code>bootstrap</code>、<code>mount</code>、<code>unmount</code>，分别对应初始化、渲染和卸载，这也导致子应用需要对入口文件进行修改。因为<code>qiankun</code>是基于<code>single-spa</code>进行封装，所以这些特点也被<code>qiankun</code>继承下来，并且需要对<code>webpack</code>配置进行一些修改。</p>
<p><code>micro-app</code>并没有沿袭<code>single-spa</code>的思路，而是借鉴了<code>WebComponent</code>的思想，通过<code>CustomElement</code>结合自定义的<code>ShadowDom</code>，将微前端封装成一个类<code>WebComponent</code>组件，从而实现微前端的组件化渲染。并且由于自定义<code>ShadowDom</code>的隔离特性，<code>micro-app</code>不需要像<code>single-spa</code>和<code>qiankun</code>一样要求子应用修改渲染逻辑并暴露出方法，也不需要修改<code>webpack</code>配置，相对接入微前端成本最低的方案。</p>
<p>Micro-App 概念图<br><img src= "/img/loading.gif" data-src="%E6%A6%82%E5%BF%B5%E5%9B%BE.png" alt="概念图"></p>
<h3 id="Micro-App的优势"><a href="#Micro-App的优势" class="headerlink" title="Micro-App的优势"></a>Micro-App的优势</h3><ol>
<li><p>使用简单<br>它将所有功能都封装到一个类<code>WebComponent</code>组件中，从而实现在基座应用中嵌入一行代码即可渲染一个微前端应用，使用类似：<code>iframe</code>。<br>同时<code>Micro-App</code>还提供了<code>js沙箱</code>、<code>样式隔离</code>、<code>元素隔离</code>、<code>预加载</code>、<code>数据通信</code>、<code>静态资源补全</code>等一系列完善的功能。</p>
</li>
<li><p>零依赖<br><code>Micro-App</code>没有任何依赖，这赋予它小巧的体积和更高的扩展性。</p>
</li>
<li><p>兼容所有框架<br>为了保证各个业务之间独立开发、独立部署的能力，<code>Micro-App</code>做了诸多兼容，在任何技术框架中都可以正常运行。</p>
</li>
</ol>
<h3 id="开始实战"><a href="#开始实战" class="headerlink" title="开始实战"></a>开始实战</h3><p><a href="https://zeroing.jd.com/micro-app/docs.html#/">Micro-App官网</a><br>Micro-App的官网写的太理想的，单看里面的一些介绍根本无从下手。<br>那我们再来一个官网的Demo: <a href="https://github.com/micro-zoe/micro-app.git">GitHub: Micro-App</a></p>
<p>很不幸，你从GitHub上下载下来的demo可以无法在本地顺利的运行，可能会遇到各种各样的问题，但是：你要把问题解决了，项目是可以运行起来的，而且效果还不错。具体遇到啥问题，咨询官方吧！不在本次分享范畴里。</p>
<blockquote>
<p>项目背景<br>需求：做一个客户管理系统，简单描述功能模块：<br>  1、首页 工作台：统计客户昨日新增量，活跃度，发布消息数等<br>  2、客户信息管理：客户列表，基本信息维护，给客户发短信等<br>  3、系统日志：记录每个用户登录系统后的所有操作<br>  4、权限控制：用户权限不同，能访问的菜单也不同，页面内展示的模块，操作按钮等也不同</p>
</blockquote>
<h4 id="一、安装依赖"><a href="#一、安装依赖" class="headerlink" title="一、安装依赖"></a>一、安装依赖</h4><p><strong>基座应用</strong><br>1、安装依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i @micro-zoe/micro-app --save</span><br></pre></td></tr></table></figure>
<p>2、引入依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> microApp <span class="keyword">from</span> <span class="string">&#x27;@micro-zoe/micro-app&#x27;</span></span><br><span class="line"></span><br><span class="line">microApp.start()</span><br></pre></td></tr></table></figure>
<p>3、给子应用分配路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Customer <span class="keyword">from</span> <span class="string">&#x27;./customer.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 非严格匹配，/customer/* 都将匹配到 Customer 组件</span></span><br><span class="line">    path: <span class="string">&#x27;/customer/*&#x27;</span>, </span><br><span class="line">    name: <span class="string">&#x27;customer&#x27;</span>,</span><br><span class="line">    component: Customer,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> routes</span><br></pre></td></tr></table></figure>
<p>4、在 customer.vue 页面中使用组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- customer.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>客户管理<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- url为html地址 (url只是html地址，子应用的路由还是基于浏览器地址) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">micro-app</span> <span class="attr">name</span>=<span class="string">&#x27;customer&#x27;</span> <span class="attr">url</span>=<span class="string">&#x27;http://localhost:3001/&#x27;</span> <span class="attr">baseurl</span>=<span class="string">&#x27;/customer&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">micro-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>子应用</strong><br>1、添加路由前缀<code>(如果基座应用是history路由，子应用是hash路由，不需要设置路由前缀，这一步可以省略)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mian.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  options: &#123;</span><br><span class="line">    <span class="comment">// 添加路由前缀，子应用可以通过window.__MICRO_APP_BASE_URL__获取基座下发的baseurl</span></span><br><span class="line">    base: <span class="built_in">window</span>.__MICRO_APP_BASE_URL__ || <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>2、在webpack-dev-server的headers中设置跨域支持。<code>为什么要支持跨域访问？</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>完成以上步骤微前端即可正常渲染。</p>
<blockquote>
<p>注意：<br>1、name必传，name值不可以重复，它是区分子应用的标识<br>2、url必传，与子应用路由没任何关系，它只是子应用资源的访问地址，是html页面的地址哦<br>3、baseurl是基座应用分配给子应用的路由前缀，非必传，默认值为空字符串。<br>4、子应用必须支持跨域访问。</p>
</blockquote>
<h4 id="二、主要功能"><a href="#二、主要功能" class="headerlink" title="二、主要功能"></a>二、主要功能</h4><p><strong>1、配置项</strong><br><strong>name</strong>: 必须， 子应用标识，全局唯一, <code>name</code> 值变化时，会卸载当前应用并重新渲染<br><strong>url</strong>: 必须， 子应用访问地址：页面的访问地址：<a href="http://xxx.jd.com/appname/index.html">http://xxx.jd.com/appname/index.html</a>; 基座会解析出页面中依赖的js、css 之后下载资源,并执行<br><strong>baseurl</strong>:非必须 用于设置子应用的路由前缀，类似react-router中的 basename</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;BrowserRouter basename=&#123;<span class="built_in">window</span>.proxyWindow.__MICRO_APP_BASE_URL__ || <span class="string">&#x27;/&#x27;</span>&gt;</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &lt;/Switch&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure>
<p>其他配置，参考官方文档</p>
<p><strong>2、环境变量</strong><br>在子应用中通过 <code>window.proxyWindow.__MICRO_APP_ENVIRONMENT__</code> 变量判断是否在<code>micro-app</code>环境中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.proxyWindow.__MICRO_APP_ENVIRONMENT__) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我在 micro-app 环境中渲染&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// window.proxyWindow 属性上，有基座注入到window上的全局变量，如：baseurl, public_path, appname,environment(是否Micro-app环境)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>3、数据通信</strong></p>
<ul>
<li><ol>
<li>基座应用和子应用之间的通信</li>
</ol>
</li>
<li><ol start="2">
<li>全局通信</li>
</ol>
</li>
</ul>
<p><strong>基座应用和子应用之间的通信</strong></p>
<ul>
<li>基座主动给子应用发送数据，基座主动问子应用要数据</li>
<li>子应用主动给基座发送数据，子应用主动问基座要数据</li>
</ul>
<p><strong>1）基座应用 –<code>发送Data</code>–&gt; 子应用</strong></p>
<ul>
<li>方法一: 属性绑定<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;micro-app</span><br><span class="line">  name=<span class="string">&quot;my-app&quot;</span></span><br><span class="line">  url=<span class="string">&quot;xx&quot;</span></span><br><span class="line">  :data=<span class="string">&quot;data&quot;</span> <span class="comment">// data只接受对象类型，数据变化时会重新发送</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li>
<li>方法二：调用setData方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> microApp <span class="keyword">from</span> <span class="string">&#x27;@micro-zoe/micro-app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据给子应用 appName</span></span><br><span class="line">microApp.setData(<span class="string">&#x27;appName&#x27;</span>, &#123;<span class="attr">type</span>: <span class="string">&#x27;数据&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2）基座应用 –<code>获取Data</code>–&gt; 子应用</strong></p>
<ul>
<li>方法一：监听事件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;micro-app</span><br><span class="line">  name=<span class="string">&#x27;appName&#x27;</span></span><br><span class="line">  url=<span class="string">&#x27;xxxxx&#x27;</span></span><br><span class="line">  :data=<span class="string">&#x27;data&#x27;</span></span><br><span class="line">  <span class="comment">// 数据在事件对象的detail.data字段中，子应用每次发送数据都会重新触发事件</span></span><br><span class="line">  @datachange=<span class="string">&#x27;handleDataChange&#x27;</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">methods:&#123;</span><br><span class="line">  <span class="function"><span class="title">handleDataChange</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 处理子应用发送的数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure></li>
<li>方法二：手动绑定监听函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> microApp <span class="keyword">from</span> <span class="string">&#x27;@micro-zoe/micro-app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataListener</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;来自子应用appName的数据&#x27;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绑定监听函数</span></span><br><span class="line"><span class="comment"> * appName: 应用名称</span></span><br><span class="line"><span class="comment"> * dataListener: 绑定函数</span></span><br><span class="line"><span class="comment"> * autoTrigger: 在初次绑定监听函数时有缓存数据，是否需要主动触发一次，默认为false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">microApp.addDataListener(appName: string, <span class="attr">dataListener</span>: <span class="built_in">Function</span>, autoTrigger?: boolean)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑监听my-app子应用的函数</span></span><br><span class="line">microApp.removeDataListener(appName: string, <span class="attr">dataListener</span>: <span class="built_in">Function</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空所有监听appName子应用的函数</span></span><br><span class="line">microApp.clearDataListener(appName: string)</span><br></pre></td></tr></table></figure></li>
<li>方法三：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">microApp.getData(appName) <span class="comment">// 返回子应用发送的data数据</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>3）子应用 –<code>发送Data</code>–&gt; 基座应用</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据是对象&#123;&#125;</span></span><br><span class="line"><span class="built_in">window</span>.microApp.dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;子应用发送的数据&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>


<p><strong>4）子应用 –<code>拉取Data</code>–&gt; 基座应用</strong></p>
<ul>
<li>方法一：监听函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataListener</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;来自基座应用的数据&#x27;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绑定监听函数</span></span><br><span class="line"><span class="comment"> * dataListener: 绑定函数</span></span><br><span class="line"><span class="comment"> * autoTrigger: 在初次绑定监听函数时有缓存数据，是否需要主动触发一次，默认为false</span></span><br><span class="line"><span class="comment"> * 补充: autoTrigger主要是为子应用提供的，因为子应用是异步渲染的，如果在子应用还没渲染时基座应用发送数据，子应用在初始化后不会触发绑定函数，但这个数据会放入缓存中，此时可以设置autoTrigger为true主动触发一次监听函数来获取数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">window</span>.microApp.addDataListener(dataListener: <span class="built_in">Function</span>, autoTrigger?: boolean)</span><br><span class="line"><span class="comment">// 对应基座的的</span></span><br><span class="line"><span class="comment">// microApp.setData(&#x27;appName&#x27;, &#123;type: &#x27;数据&#x27;&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除绑定</span></span><br><span class="line"><span class="built_in">window</span>.microApp.removeDataListener(dataListener)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空所有当前应用的绑定函数</span></span><br><span class="line"><span class="built_in">window</span>.microApp.clearDataListener()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：主动获取<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.microApp.getData() <span class="comment">// 返回data数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>全局数据通信</strong><br>全局数据通信会向基座应用和所有子应用发送数据，在跨应用通信的场景中适用</p>
<p><strong>1）数据监听与解绑</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基座中</span></span><br><span class="line"><span class="keyword">import</span> microApp <span class="keyword">from</span> <span class="string">&#x27;@micro-zoe/micro-app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataListener</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;全局数据&#x27;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绑定监听函数</span></span><br><span class="line"><span class="comment"> * dataListener: 绑定函数</span></span><br><span class="line"><span class="comment"> * autoTrigger: 在初次绑定监听函数时有缓存数据，是否需要主动触发一次，默认为false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">microApp.addGlobalDataListener(dataListener: <span class="built_in">Function</span>, autoTrigger?: boolean)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除绑定</span></span><br><span class="line">microApp.removeGlobalDataListener(dataListener)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空所有全局数据的绑定函数</span></span><br><span class="line">microApp.clearGlobalDataListener()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子应用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataListener</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;全局数据&#x27;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绑定监听函数</span></span><br><span class="line"><span class="comment"> * dataListener: 绑定函数</span></span><br><span class="line"><span class="comment"> * autoTrigger: 在初次绑定监听函数时有缓存数据，是否需要主动触发一次，默认为false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">window</span>.microApp?.addGlobalDataListener(dataListener: <span class="built_in">Function</span>, autoTrigger?: boolean)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除绑定</span></span><br><span class="line"><span class="built_in">window</span>.microApp?.removeGlobalDataListener(dataListener)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空所有全局数据绑定函数</span></span><br><span class="line"><span class="built_in">window</span>.microApp?.clearGlobalDataListener()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: window.microApp 的判空操作</span></span><br></pre></td></tr></table></figure>
<p><strong>2）发送数据</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基座</span></span><br><span class="line"><span class="keyword">import</span> microApp <span class="keyword">from</span> <span class="string">&#x27;@micro-zoe/micro-app&#x27;</span></span><br><span class="line"></span><br><span class="line">microApp.setGlobalData(&#123;<span class="attr">type</span>: <span class="string">&#x27;全局数据&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子应用</span></span><br><span class="line"><span class="built_in">window</span>.microApp?.setGlobalData(&#123;<span class="attr">type</span>: <span class="string">&#x27;全局数据&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：window.microApp 判空</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<br>1、clearGlobalDataListener会清空所有应用的绑定，不仅限于自身<br>2、在子应用卸载时，需要调用removeGlobalDataListener主动解绑函数。</p>
</blockquote>
<p><strong>4、路由</strong><br><strong>url属性与子应用路由的关系</strong>  <code>答：没关系</code><br><code>micro-app</code>不是<code>iframe</code>，不会重开一个<code>window</code>窗口，基座应用和子应用本质是在同一个页面渲染，所以影响到子应用路由的是浏览器地址。<code>micro-app</code>的<code>url</code>属性只是<code>html</code>的地址，它只是用来获取<code>html</code>。</p>
<p>基座应用：根据浏览器地址决定访问哪个子应用<br>子应用：根据浏览器地址，决定渲染哪个页面</p>
<p>例如：浏览器访问：<a href="http://localhost/customer/list">http://localhost/customer/list</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基座路由配置</span></span><br><span class="line">&#123; <span class="attr">title</span>:<span class="string">&#x27;客户管理&#x27;</span>, <span class="attr">name</span>:<span class="string">&#x27;customer&#x27;</span>, <span class="attr">path</span>:<span class="string">&#x27;/customer/*&#x27;</span>, <span class="attr">view</span>:<span class="string">&#x27;/customer.vue&#x27;</span>&#125;,</span><br><span class="line"><span class="comment">// customer.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;micro-app</span><br><span class="line">    name=<span class="string">&#x27;customer&#x27;</span></span><br><span class="line">    url=<span class="string">&#x27;http://localhost:8001/&#x27;</span>&gt;</span><br><span class="line">  &lt;/micro-app&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子应用路由配置</span></span><br><span class="line">&#123; <span class="attr">title</span>:<span class="string">&#x27;&#x27;</span>, <span class="attr">name</span>:<span class="string">&#x27;customerList&#x27;</span>, <span class="attr">path</span>:<span class="string">&#x27;/customer/list&#x27;</span>, <span class="attr">view</span>:<span class="string">&#x27;/customer/List.vue&#x27;</span>&#125;,</span><br><span class="line"><span class="comment">// customer/List.vue</span></span><br><span class="line"><span class="comment">// 正常页面排版，js逻辑</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>页面访问及解析流程：<br><img src= "/img/loading.gif" data-src="%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程图"></p>
<p><strong>几个例子</strong></p>
<ul>
<li><ol>
<li>基座，子应用都是history模式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 浏览器地址为：http://localhost/page1/，此时路由地址为page1。</span></span><br><span class="line"><span class="comment">//    基座匹配路由 page1 渲染组件； 子应用 page1匹配 并渲染组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基座micr-app配置, url 不包含page1, 路由还在浏览器地址栏取</span></span><br><span class="line"><span class="comment">// http://localhost:8001/ 会兜底到 http://localhost:8001/index.html</span></span><br><span class="line">&lt;micro-app url=<span class="string">&#x27;http://localhost:8001/&#x27;</span>&gt;&lt;/micro-app&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>基座 history 子应用 hash<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- // 浏览器地址： http://localhost/appName#/page1 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- // 这里的#/page1是无效的，应该添加到浏览器地址上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">micro-app</span> <span class="attr">url</span>=<span class="string">&#x27;http://localhost:8001/#/page1&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">micro-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- // 这个url才是正确的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">micro-app</span> <span class="attr">url</span>=<span class="string">&#x27;http://localhost:8001/&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">micro-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="3">
<li>基座 history 子应用 history<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子应用通过baseurl设置路由前缀，路由 /page1 就变为 /appNmae/page1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">micro-app</span> <span class="attr">url</span>=<span class="string">&#x27;http://localhost:8001/&#x27;</span> <span class="attr">baseurl</span>=<span class="string">&#x27;/appNmae&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">micro-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>1）基座是hash路由，子应用也必须是hash路由</li>
<li>2）基座是history路由，子应用可以是hash或history路由</li>
</ul>
<p><strong>5、应用之间如何跳转</strong><br>因为每个应用的路由实例都是不同的，路由实例只能控制自身，无法影响其它应用，要实现应用之间的跳转有两种方式：</p>
<ul>
<li><p><strong>方法一：history.pushState(replaceState)</strong><br><code>history.pushState</code>和<code>history.replaceState</code>可以直接修改浏览器地址，但是它们无法触发<code>popstate</code>事件，所以在跳转后需要主动触发一次<code>popstate</code>事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// history 模式</span></span><br><span class="line">history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&#x27;page2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主动触发一次popstate事件</span></span><br><span class="line"><span class="built_in">window</span>.dispatchEvent(<span class="keyword">new</span> PopStateEvent(<span class="string">&#x27;popstate&#x27;</span>, &#123; <span class="attr">state</span>: <span class="literal">null</span> &#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hash模式</span></span><br><span class="line">history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&#x27;#/page2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主动触发一次popstate事件</span></span><br><span class="line"><span class="built_in">window</span>.dispatchEvent(<span class="keyword">new</span> PopStateEvent(<span class="string">&#x27;popstate&#x27;</span>, &#123; <span class="attr">state</span>: <span class="literal">null</span> &#125;))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法二：利用数据通信机制，让基座跳转路由</strong><br>如基座下发指令控制子应用进行跳转，或者子应用向基座应用上传一个可以控制自身路由的函数。</p>
</li>
</ul>
<h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><ul>
<li><p><strong>1、子应用一定要支持跨域吗？</strong><br><code>是的！</code><br>开发环境配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack-devserver 中配置， 或 vue.config.js中</span></span><br><span class="line">devServer: &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>线上环境，通过nginx配置解决</p>
</li>
<li><p><strong>2、兼容性如何</strong><br>micro-app依赖于CustomElements和Proxy两个较新的API。</p>
</li>
</ul>
<p>对于不支持CustomElements的浏览器，可以通过引入polyfill进行兼容，详情可参考：webcomponents/polyfills。</p>
<p>但是Proxy暂时没有做兼容，所以对于不支持Proxy的浏览器无法运行micro-app。</p>
<p>浏览器兼容性可以查看：<a href="https://caniuse.com/?search=Proxy">Can I Use</a></p>
<p>总体如下：</p>
<ul>
<li>PC端：除了IE浏览器，其它浏览器基本兼容。</li>
<li>移动端：ios10+、android5+</li>
</ul>
<p><a href="https://zeroing.jd.com/micro-app/docs.html#/zh-cn/questions">官网问答</a></p>
<p>参考文档<br><a href="https://zeroing.jd.com/micro-app/docs.html">https://zeroing.jd.com/micro-app/docs.html</a><br><a href="https://github.com/micro-zoe/micro-app.git">https://github.com/micro-zoe/micro-app.git</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>微前端</tag>
      </tags>
  </entry>
  <entry>
    <title>情绪版的应用</title>
    <url>/2021/06/28/%E6%83%85%E7%BB%AA%E7%89%88%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>在很多项目总结中，我们几乎都能看到情绪板的运用，精美的图片搭配符合主题的关键词，可以向需求方和产品侧准确地表达出页面的设计方向和风格。那什么是情绪版呢，我们又该怎么建立情绪版呢，以下是我写的一点点总结。</p>
<h3 id="什么是情绪板？"><a href="#什么是情绪板？" class="headerlink" title="什么是情绪板？"></a><strong>什么是情绪板？</strong></h3><p>情绪板定义</p>
<p>情绪板（Mood Board），主要是对设计的产品和相关主题方向的色彩、图片、影像或其他材料的收集，从而引起某些情绪反应，以此作为设计方向或者形式的参考，是常用的表达设计定义和方向的设计方法论。帮助设计师明确视觉设计需求，用于提取配色方案、视觉风格、质感材质，以指导视觉设计，为设计师提供灵感。</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/194598/6/10655/1045228/60d93285E801ddbeb/2ce4c81f06300fa3.png" alt="情绪版@1x"></p>
<h3 id="情绪板的作用"><a href="#情绪板的作用" class="headerlink" title="情绪板的作用"></a>情绪板的作用</h3><p>情绪板首先能组织整个项目的灵感，保持风格和美学的一致性，并与客户的目标和期望保持一致。</p>
<p>情绪板是在开始实际设计前确定和完善产品风格的好方法。在资源和时间方面，情绪版比模型或原型的成本要低得多，并且能直接传达出关于最终设计风格的信息。</p>
<p>对设计师来说：情绪板是定义视觉风格和指导设计方向的依据；对团队：在团队之间传递设计灵感与设计思路，从而使想法充分融合，深化设计。情绪板能够巧妙地向客户传达设计理念。例如当设计师在说扁平化或极简等设计风格时，客户或者我们的产品可能并不知道这些风格是怎样的。这个时候我们就需要建立情绪版向客户和产品传达我们的想法。</p>
<h3 id="情绪板的组成"><a href="#情绪板的组成" class="headerlink" title="情绪板的组成"></a>情绪板的组成</h3><p>每个情绪板都是不同的，包含的内容会根据项目需要而有所不同。</p>
<p>重要的是要包含尽可能多的元素，让想表现的设计思路更清晰。情绪板中包含的内容包括以下几种。</p>
<h4 id="（1）图片"><a href="#（1）图片" class="headerlink" title="（1）图片"></a>（1）图片</h4><p>主要包括品牌图片、图库上的摄影/产品图片、插画、logo等。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/172489/16/17137/803628/60d93288Ec8047ade/954179ae0c9be644.png" alt="图片"></p>
<h4 id="（2）颜色"><a href="#（2）颜色" class="headerlink" title="（2）颜色"></a>（2）颜色</h4><p>色板是情绪板的重要组成部分，根据搜集的素材我们能确定哪种色系跟整体需求更相近，再通过吸色来获得配色信息。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/175197/22/17008/771196/60d93285E622aff07/8ef9f31d2045ddd3.png" alt="色彩情绪版"></p>
<h4 id="（3）文字"><a href="#（3）文字" class="headerlink" title="（3）文字"></a>（3）文字</h4><p>搜集与品牌或主题相关的文案，或者展示选用的某种特定的字体。</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/188821/18/10548/470121/60d93288E5f4b4ed0/6ef9e81859df59e9.png" alt="文字"></p>
<h4 id="（4）纹理"><a href="#（4）纹理" class="headerlink" title="（4）纹理"></a>（4）纹理</h4><p>设计中涉及到的纹理或图案都应该包含在情绪板上。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/196488/8/10487/568483/60d93288Eaec17d82/54e2fbb0288dea97.png" alt="纹理"></p>
<h3 id="建立情绪板的步骤"><a href="#建立情绪板的步骤" class="headerlink" title="建立情绪板的步骤"></a>建立情绪板的步骤</h3><p>当我们接到一个界面改版需求时，会考虑哪些点呢？大部分人都会重点关注美观度，但是这往往是不够的，我们既要把界面做得好看，也要做得科学。这次要说的情绪板，就可以帮助我们做出一个更加有理有据的界面设计。 </p>
<p>那么情绪板到底如何使用呢？我们先来看看整体的操作流程: </p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/188256/31/10563/26036/60d93284Ec8460dec/d90aa10d9581cd12.png" alt="流程"></p>
<h4 id="（1）确定原生关键词"><a href="#（1）确定原生关键词" class="headerlink" title="（1）确定原生关键词"></a>（1）确定原生关键词</h4><p>通过产品定位、涉众访谈和以往的用户研究数据，可以获得大量的关键词，而这些关键词并不是都能用得上，我们需要筛选出既符合产品定位又能达到用户心理预期的。比如我们要做一个金融产品，最终可以提取3个基础关键词：收益、安全、灵活。</p>
<p>注意要点：基础关键词一般在3-5个之间，同时原生关键词，一定要抽象化，不能过于具体。（例如：咖啡就是个具体名次，脑海中一下子就能联想出该物体） </p>
<p>﻿<img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/196817/29/10379/199885/60d93289Eb5cbf094/5d5359accaf48bf1.png" alt="原生关键词"></p>
<h4 id="（2）确定衍生关键词"><a href="#（2）确定衍生关键词" class="headerlink" title="（2）确定衍生关键词"></a>（2）确定衍生关键词</h4><p>由于第一步的原生关键词大多都比较抽象，因此需要对其进行发散和联想。从而需要更多具体关键词，这样我们后面才能更容易找到相应的图片，具体关键词一般都是具体的物体。为了更科学地找图，第一步确定3-5个原生关键词，第二步在每个原生关键词下拓展3个衍生关键词。﻿</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/180228/16/10911/232102/60d93289Eb37fb6aa/556ac43dee29ec4f.png" alt="衍生关键词"></p>
<h4 id="（3）搜集图片素材"><a href="#（3）搜集图片素材" class="headerlink" title="（3）搜集图片素材"></a>（3）搜集图片素材</h4><p>关键词确定好后，我们终于可以在图库中，使用关键词进行图片的搜集了。这时候如果图片太多，不但会增加我们搜图的工作量，后期也不方便用户进行筛选，如果图片太多，则可能搜到的图片重复率太高，导致得出的结论不够准确。所以一般来说1个关键词对应搜3－5张图片就足够了。﻿</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/193167/33/10669/3161906/60d93287E954c990f/c6c801d94de61159.png" alt="收益"></p>
<h4 id="（4）创建图片库式的情绪板"><a href="#（4）创建图片库式的情绪板" class="headerlink" title="（4）创建图片库式的情绪板"></a>（4）创建图片库式的情绪板</h4><p>搜集好图片后，可以先在部门内部筛选一次，再将挑选出来的图片打乱并依次排列，邀请目标用户进行再次挑选，下图为一部分图片： </p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/175413/37/17190/402505/60d93286E88d0c987/0c3e151963d2a9d3.png" alt="收集图片"></p>
<p>在挑选图片的过程中，我们需要问产品或者客户2个问题：</p>
<ol>
<li><p>分别选择最能代表“投资收益”、“资金安全”、“周转灵活”的几张图片。</p>
</li>
<li><p>为什么选择了这张图片？图片的哪个元素让你觉得有安全的感觉？</p>
</li>
</ol>
<p>问题1：是为了挑选出最终能代表关键词的图片；</p>
<p>问题2：是为了能让我们了解用户选择图片的原因，挖掘出用户的心理情绪，从而了解到用户的视觉偏好，而这2个点都可以为我们后面做视觉设计做好铺垫，如下图：</p>
<p>经过这样一轮分析，我们选择的任何一个颜色，都将会有理有据，具备科学度。</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/194200/26/10572/320604/60d93287Ec4002ba8/27964263f4b3cd9d.png" alt="收益产品图"></p>
<h3 id="情绪板的应用"><a href="#情绪板的应用" class="headerlink" title="情绪板的应用"></a>情绪板的应用</h3><h4 id="（1）情绪板在彩色化卡片的运用"><a href="#（1）情绪板在彩色化卡片的运用" class="headerlink" title="（1）情绪板在彩色化卡片的运用"></a>（1）情绪板在彩色化卡片的运用</h4><p>彩色化卡片，是一个非常常见的功能入口，拥有各类颜色，但问题是：我们如何行之有效地提升细节感？</p>
<p>经过之前情绪板的铺垫，彩色化版块在设计时应该做到了色彩属性与业务属性相连接，才能与用户的认知匹配。比如稳健投资的业务属性是稳定，而蓝色的色彩属性也有安全、稳定的意思，那么就做到了图标色彩的选取连接业务属性。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/175034/34/16902/63151/60d93284E2319b4fa/9333a1282e09620a.png" alt="彩色卡片"></p>
<h4 id="（2）情绪板在图标风格上的运用"><a href="#（2）情绪板在图标风格上的运用" class="headerlink" title="（2）情绪板在图标风格上的运用"></a>（2）情绪板在图标风格上的运用</h4><p>根据用户画像可以发现用户在投资过程中容易出现紧张不安的心理情绪，大多数用户都倾向寻求一个“靠谱”的平台。</p>
<p>且通过之前情绪板的调研发现，用户觉得一个图片能给他安全感，除了颜色之外，坚固圆润的造型，同样也能传递安全的感受。因此在图标设计中采用圆角而非直角的设计细节也是为了缓和用户情绪，表达一种稳重和安全感。如Tab栏图标和列表流图标，都采用较为圆胖的圆角设计。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/192417/3/10515/130451/60d93288Ed559e587/f5b01f1ddc0a315e.png" alt="图标"></p>
<h4 id="（3）情绪板在界面呼吸感的运用"><a href="#（3）情绪板在界面呼吸感的运用" class="headerlink" title="（3）情绪板在界面呼吸感的运用"></a>（3）情绪板在界面呼吸感的运用</h4><p>同样的，界面风格采用大留白的设计来增加页面的呼吸感，也是了缓解用户紧张不安的心理情绪。</p>
<p>什么样的图片能给用户带来安全？探索图片本质，我们同样能运用至界面设计，这就是情绪板的多样性。</p>
<p>﻿﻿<img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/172256/31/17126/159621/60d93284Ed1cf4c45/3bd167c63255260f.png" alt="界面"></p>
<p>以上就是我所理解的情绪版的应用。</p>
]]></content>
  </entry>
  <entry>
    <title>我如何解决Android上字体不能垂直居中的问题</title>
    <url>/2021/07/23/%E6%88%91%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Android%E4%B8%8A%E5%AD%97%E4%BD%93%E4%B8%8D%E8%83%BD%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="我如何解决Android上字体不能垂直居中的问题"><a href="#我如何解决Android上字体不能垂直居中的问题" class="headerlink" title="我如何解决Android上字体不能垂直居中的问题"></a>我如何解决Android上字体不能垂直居中的问题</h1><p>某个风和日丽（coding）的下午，老大突然发给我一个截图，[单品页标签文字不居中.png]</p>
<p><img src= "/img/loading.gif" data-src="./unnamed.jpeg"></p>
<p>拿出iPhone测试机检查 ？？？ 是居中的呀。。。。。。</p>
<p>看来事情并不简单，基本是Android手机兼容性的问题</p>
<p>换了两个Android手机测试，果然都有不同程度的偏移</p>
<p>而且发现同一页面上，有的会偏移有的却能正常垂直居中</p>
<p>通过测试，发现字体小于12px会产生很明显的偏移</p>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>Android手机上当字体小于12px通过lineheight或padding撑开无法做到垂直居中</p>
<h3 id="听他们说"><a href="#听他们说" class="headerlink" title="听他们说"></a>听他们说</h3><p><a href="https://blog.csdn.net/yangxiqian/article/details/80204072">字体原因及解决办法</a></p>
<blockquote>
<p>字体基本不可取，UI已经指定字体</p>
</blockquote>
<h3 id="实践出真知"><a href="#实践出真知" class="headerlink" title="实践出真知"></a>实践出真知</h3><ul>
<li>table布局</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;solution&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: table; height: 16px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot; display: table-cell; font-size: 10px; vertical-align: middle;&quot;</span>&gt;</span>table 布局<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>文本偏上</p>
</blockquote>
<ul>
<li>flex 布局</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;solution&quot; style&#x3D;&quot;display: inline-flex; align-items: center; height: 16px; line-height: 1; font-size: 10px;&quot;&gt;</span><br><span class="line">  &lt;span&gt;flex 布局&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>文本偏上</p>
</blockquote>
<ul>
<li>zoom 缩放</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;solution&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 32px; line-height: 32px; font-size: 20px; zoom: 0.5;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>zoom 缩放<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>文本偏上</p>
</blockquote>
<ul>
<li>固定高度+内边距+行高设定为字体大小</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;solution&quot;</span> <span class="attr">style</span>=<span class="string">&quot;box-sizing: border-box; height: 16px; padding: 3px 0; line-height: 10px; font-size: 10px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>固定高度+内边距+行高设定为字体大小<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>文本偏上</p>
</blockquote>
<ul>
<li>固定高度+内边距+行高设为 normal</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;solution&quot;</span> <span class="attr">style</span>=<span class="string">&quot;box-sizing: border-box; height: 16px; padding: 3px; line-height: normal; font-size: 10px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>固定高度+内边距+行高设为 normal<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>文本偏上</p>
</blockquote>
<ul>
<li>内边距+行高设为 normal</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;solution&quot;</span> <span class="attr">style</span>=<span class="string">&quot;box-sizing: border-box; padding: 2px; line-height: normal; font-size: 10px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>内边距+行高设为 normal<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>文本居中，但在部分客户端上不居中</p>
</blockquote>
<ul>
<li>行高+字体大小设为 initial</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;solution&quot;</span> <span class="attr">style</span>=<span class="string">&quot;line-height: 16px; font-size: initial;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 10px;&quot;</span>&gt;</span>行高+字体大小设为 initial<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>文本居中，在最新的 Chrome 浏览器上不居中</p>
</blockquote>
<ul>
<li>transform 缩放</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;solution&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 32px; line-height: 32px; font-size: 20px; transform: scale(0.5, 0.5); transform-origin: left top;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>transform 缩放<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>文本居中了，但是 transform 不能还原元素在 dom 上的占用区域大小</p>
</blockquote>
<h3 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h3><p>只有transform缩放能完全解决居中问题，同时带来的问题是，transform不会引起重排，所以会有大面积占用空间</p>
<p>那我们只有能解决多余的占用空间问题不就能做到完全居中了么</p>
<p>那怎么解决多余的空间占用问题？</p>
<p>众所周知<a href="https://zhuanlan.zhihu.com/p/25892372">margin是可以设置为负值的</a> 并且有一些应用margin设置为负值实现的布局</p>
<p>那么我们是否可以通过设置margin，来解决多余空间的占用问题？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;solution&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 32px; line-height: 32px; margin: -8px -8%; font-size: 20px; transform: scale(0.5, 0.5); transform-origin: center center;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>transform 缩放<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果出奇的好，基本实现了相同的占用空间</p>
<p>现在为止，基本方向已经确定了，但是这种固定数值还是有些死板，同时随着dom宽度的改变 margin的值并不完全准确</p>
<p>此时我想到可以借助js来确定margin 的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;span</span><br><span class="line">    class&#x3D;&quot;tag-view&quot;</span><br><span class="line">    :class&#x3D;&quot;&#123; &#39;tag-view_android&#39;: isAndroid &#125;&quot;</span><br><span class="line">    :style&#x3D;&quot;&#96;margin: -0.16rem -$&#123;widthMeth - 4&#125;px -0.16rem -$&#123;widthMeth&#125;px&#96;&quot;</span><br><span class="line">    v-show&#x3D;&quot;message&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isAndroid: this.isAndroid(),</span><br><span class="line">      widthMeth: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    message: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &quot;&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    isAndroid() &#123;</span><br><span class="line">      const u &#x3D; navigator.userAgent</span><br><span class="line">      return u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Adr&#39;) &gt; -1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  watch: &#123;</span><br><span class="line">    message: &#123;</span><br><span class="line">      handler() &#123;</span><br><span class="line">        this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">          this.widthMeth &#x3D; this.$el.offsetWidth &#x2F; 4;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      immediate: true,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line">.tag-view &#123;</span><br><span class="line">  background: rgba(240, 242, 245, 1);</span><br><span class="line">  border-radius: 0.04rem;</span><br><span class="line">  padding: 0 0.15rem;</span><br><span class="line">  height: 0.32rem;</span><br><span class="line">  line-height: 0.32rem;</span><br><span class="line">  font-size: 0.22rem;</span><br><span class="line">  color: rgba(66, 72, 84, 1);</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin-right: 0.1rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.tag-view_android &#123;</span><br><span class="line">  font-family: miui;</span><br><span class="line">  padding: 0 0.3rem;</span><br><span class="line">  height: 0.64rem;</span><br><span class="line">  line-height: 0.64rem;</span><br><span class="line">  font-size: 0.44rem;</span><br><span class="line">  transform: scale(0.5, 0.5);</span><br><span class="line">  transform-origin: center center;</span><br><span class="line">  margin: -0.16rem -9%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>至此，margin的准确性解决了</p>
<p>但是如果想应用到项目里，一个样式就要封装一个组件未免也太麻烦了吧，而且对于已经存在的样式，改动也蛮多的</p>
<p>那能不能像 v-bind 一样 通过自定义指令来实现呢？</p>
<p>说干就干！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;tag&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">inserted</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!isAndroid()) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> needBook = [</span><br><span class="line">      <span class="string">&#x27;fontSize&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;height&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;paddingTop&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;paddingLeft&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;paddingBottom&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;paddingRight&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    needBook.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> value = getComputedStyle(el)[item]</span><br><span class="line">      <span class="keyword">if</span> (getValue(value)) &#123;</span><br><span class="line">        el.style[item] = getValue(value) * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">        <span class="keyword">if</span>(item === <span class="string">&#x27;height&#x27;</span>) &#123;</span><br><span class="line">          el.style.lineHeight = getValue(value) * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    el.style.transform = <span class="string">&#x27;scale(0.5, 0.5)&#x27;</span></span><br><span class="line">    el.style.transformOrigin = <span class="string">&#x27;center center&#x27;</span></span><br><span class="line">    el.style.margin = <span class="string">`-<span class="subst">$&#123;el.offsetHeight <span class="regexp">/ 4&#125;px -$&#123;el.offsetWidth /</span> <span class="number">4</span> - <span class="number">4</span>&#125;</span>px -<span class="subst">$&#123;el.offsetHeight <span class="regexp">/ 4&#125;px -$&#123;el.offsetWidth /</span> <span class="number">4</span>&#125;</span>px`</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!params) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="keyword">const</span> arr = params.split(<span class="string">&#x27;px&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> arr &amp;&amp; arr[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isAndroid</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> u = navigator.userAgent</span><br><span class="line">      <span class="keyword">return</span> u.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Adr&#x27;</span>) &gt; -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>一顿操作，终于实现了效果，迫不及待去真机上验证一番</p>
<p>居然不居中了。。。。。</p>
<p><img src= "/img/loading.gif" data-src="./unnamed.jpeg"></p>
<p>百思不解，只能去再问问度娘了～</p>
<p>原来，字号为奇数也会导致字体偏移，再看加上v-tag后的样式，height居然还有小数点</p>
<p>对代码进行再一次改造</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">needBook.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value = getComputedStyle(el)[item]</span><br><span class="line">  <span class="keyword">if</span> (getValue(value)) &#123;</span><br><span class="line">    - el.style[item] = getValue(value) * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    - <span class="keyword">if</span>(item === <span class="string">&#x27;height&#x27;</span>) &#123;</span><br><span class="line">    -   el.style.lineHeight = getValue(value) * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    - &#125;</span><br><span class="line">    + <span class="keyword">if</span>(item === <span class="string">&#x27;height&#x27;</span>) &#123;</span><br><span class="line">    +   <span class="keyword">const</span> num = <span class="built_in">Math</span>.ceil(getValue(value))</span><br><span class="line">    +   el.style[item] = (num - <span class="number">1</span>) * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    +   el.style.lineHeight = num * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    +   <span class="keyword">return</span></span><br><span class="line">    + &#125;</span><br><span class="line">    + el.style[item] = getValue(value) * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对获取到的高度进行向上取整，同时减少1容错误差</p>
</blockquote>
<p>至此，实现了本次逻辑 </p>
<p>最后，分享大家一个自定义指令自用的文件结构</p>
<ol>
<li>新建directives文件夹</li>
<li>在directives文件夹下，新建tag.js copy代码</li>
<li>在directives文件夹下，新建index.js<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tag <span class="keyword">from</span> <span class="string">&#x27;./tag&#x27;</span></span><br><span class="line"><span class="comment">// 自定义指令</span></span><br><span class="line"><span class="keyword">const</span> directives = &#123;</span><br><span class="line">  tag,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">install</span>(<span class="params">Vue</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(directives).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      Vue.directive(key, directives[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在main.js中挂载<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Directives <span class="keyword">from</span> <span class="string">&#x27;./directives&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Directives)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>THE END 感谢你看到最后！</p>
]]></content>
      <tags>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title>按钮权限控制实现方案</title>
    <url>/2021/03/31/%E6%8C%89%E9%92%AE%E6%9D%83%E9%99%90%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="按钮权限控制实现方案"><a href="#按钮权限控制实现方案" class="headerlink" title="按钮权限控制实现方案"></a>按钮权限控制实现方案</h1><p>背景：某些管理系统需增加 ”按钮权限控制“ 功能，对权限的控制粒度要普及到按钮层级</p>
<h2 id="预期"><a href="#预期" class="headerlink" title="预期"></a>预期</h2><p>按钮权限控制的交互方式无非两种：”不可见” 和 “可见不可点”。</p>
<h3 id="不可见"><a href="#不可见" class="headerlink" title="不可见"></a>不可见</h3><p>不可见的交互方式相对简单，我们可使用 v-if 控制其是否显示。使用 v-show 也行，但不够保险，毕竟 v-show 只是把样式改成 display: none，在真实的 DOM 渲染还是存在的，所以更推荐 v-if 来控制不可见。</p>
<h3 id="可见不可点"><a href="#可见不可点" class="headerlink" title="可见不可点"></a>可见不可点</h3><p>“看是能看了，但你不行了”。</p>
<ul>
<li>样式控制（得加个禁用样式），什么 cursor: not-allowed ，置灰之类的云云；</li>
<li>不可点击，即要禁用或屏蔽点击事件，好像有 preventDefault/stopProgration 可实现；</li>
</ul>
<p>最终产品需求选择了 “可见不可点”，原因可能就觉得不可见太简单了。(¬_¬)</p>
<h2 id="思路探索"><a href="#思路探索" class="headerlink" title="思路探索"></a>思路探索</h2><ul>
<li>给按钮点击事件的回调函数，加个包装函数，对其权限控制，进行事件拦截与触发。相当是做了个代理，有点高阶组件那意思（但对现有业务改动太大，得对每个@click绑定函数逐个修改，遂放弃该方案）；</li>
<li>阻止按钮点击事件冒泡与触发，貌似能用上 preventDefautl/stopProgration, 感觉能用指令的方式对 DOM 元素进行事件监听，允许的话则让事件正常执行，不允许则拦截屏蔽；</li>
</ul>
<h2 id="实践方案"><a href="#实践方案" class="headerlink" title="实践方案"></a>实践方案</h2><p>最终选择了指令的方式，最小成本扩展，避免改动现有业务代码逻辑。<br>针对权限控制需做点击劫持的元素：</p>
<ul>
<li>el-button</li>
<li>btn-wrapper（自封装组件）</li>
<li>div/span/a 等标签</li>
</ul>
<p>具体实现：</p>
<h3 id="权限入口：Vuex-控制，全局使用"><a href="#权限入口：Vuex-控制，全局使用" class="headerlink" title="权限入口：Vuex 控制，全局使用"></a>权限入口：Vuex 控制，全局使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户登陆后，获取该用户权限 CODE 码，并存储至 store</span></span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;SET_AUTH_CODE&#x27;</span>, authCodeList);</span><br><span class="line"></span><br><span class="line">SET_AUTH_CODE: <span class="function">(<span class="params">state, acthCode</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (acthCode) &#123;</span><br><span class="line">      state.autoCodeList = acthCode;</span><br><span class="line">  &#125;</span><br><span class="line">  setStore(&#123;</span><br><span class="line">    name: <span class="string">&#x27;autoCodeList&#x27;</span>,</span><br><span class="line">    content: state.autoCodeList || [],</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义权限指令"><a href="#定义权限指令" class="headerlink" title="定义权限指令"></a>定义权限指令</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> disableClickFn = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event &amp;&amp; event.stopImmediatePropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hasPermission = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    Vue.directive(<span class="string">&#x27;permission&#x27;</span>, &#123;</span><br><span class="line">        <span class="function"><span class="title">bind</span>(<span class="params">el, binding</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> disalbe = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (autoCodeList.length &amp;&amp; autoCodeList.includes(binding.value)) &#123;</span><br><span class="line">                disable = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (disable) &#123;</span><br><span class="line">                el.classList.add(<span class="string">&#x27;permission-disabled&#x27;</span>);</span><br><span class="line">                el.setAttribute(<span class="string">&#x27;disabled&#x27;</span>, <span class="string">&#x27;disabled&#x27;</span>);</span><br><span class="line">                el.addEventListener(<span class="string">&#x27;click&#x27;</span>, disableClickFn, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">unbind</span>(<span class="params">el</span>)</span> &#123;</span><br><span class="line">            el.removeEventListener(<span class="string">&#x27;click&#x27;</span>, disableClickFn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先 addEventListener 第三个参数我们使用 useCapture 为 true 让其在捕获阶段触发，因此这里的事件监听器会优先 @click 触发回调；</li>
<li>其次使用了 stopImmediatePropagation 阻止事件冒泡和其它相同事件监听器的触发；</li>
</ul>
<blockquote>
<p>如果多个事件监听器被附加到相同元素的相同事件类型上，当此事件触发时，它们会按其被添加的顺序被调用。如果在其中一个事件监听器中执行 stopImmediatePropagation() ，那么剩下的事件监听器都不会被调用。</p>
</blockquote>
<h3 id="增加禁用的-CSS-样式"><a href="#增加禁用的-CSS-样式" class="headerlink" title="增加禁用的 CSS 样式"></a>增加禁用的 CSS 样式</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.permission-disabled</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">cursor</span>: not-allowed <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">pointer-events</span>: none;  // 阻止元素成为鼠标事件</span><br><span class="line">    <span class="attribute">border</span>:none;</span><br><span class="line">    <span class="attribute">background-image</span>: none;</span><br><span class="line">    &amp;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">        <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">z-index</span>: <span class="number">9</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CSS3 的 pointer-events 属性指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target。 </p>
</blockquote>
<p>这里使用 pointer-events 只是一个辅助功能，并不一定意味着元素上的事件监听器永远不会触发，如果后代元素有指定 pointer-events 并允许成为事件目标的话，是可以触发父元素事件，而且单纯依靠 CSS 属性来控制不点击，还是有风险，因此这里仅作辅助作用。</p>
<h3 id="全局-“权限判断”-工具函数"><a href="#全局-“权限判断”-工具函数" class="headerlink" title="全局 “权限判断” 工具函数"></a>全局 “权限判断” 工具函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@/util/store&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> autoCodeList = getStore(&#123; <span class="attr">name</span>: <span class="string">&#x27;autoCodeList&#x27;</span>, &#125;) || [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hasPermission</span>(<span class="params">authName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(autoCodeList.length &gt; <span class="number">0</span> &amp;&amp; autoCodeList.includes(authName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指令方式（这里的 sys/auth/save 就是对应用户登陆时 CODE 权限码）</span></span><br><span class="line">&lt;el-button v-permission=<span class="string">&quot;&#x27;sys:auth:save&#x27;&quot;</span>&gt;保存&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数方式</span></span><br><span class="line">&lt;el-button :disabled=<span class="string">&quot;hasPermission(&#x27;sys:auth:save&#x27;)&quot;</span>&gt;&lt;/el-button&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库中的锁</title>
    <url>/2020/02/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<h2 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h2><p>两段锁协议是指每个事务的执行可以分为两个阶段：生长阶段（加锁阶段）和衰退阶段（解锁阶段）。<br><strong>加锁阶段：</strong> 在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁，在进行写操作之前要申请并获得X锁。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。<br><strong>解锁阶段：</strong> 当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。  </p>
<a id="more"></a>
<p>两段封锁法可以这样来实现：事务开始后就处于加锁阶段，一直到执行ROLLBACK和COMMIT之前都是加锁阶段。ROLLBACK和COMMIT使事务进入解锁阶段，即在ROLLBACK和COMMIT模块中DBMS释放所有封锁。   </p>
<p>通俗来讲：就是说一个事务中必需先完成所有的加锁，然后才可以进行锁的释放。</p>
<p>可以证明，若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。<br><em>如果事务是良构的且是两阶段的，那么任何一个合法的调度都是隔离的。</em><br><em>具体的数学推到过程可以参照</em> <strong>《事务处理:概念与技术》</strong> <em>这本书的 <a href="http://img20.360buyimg.com/uba/jfs/t1/29007/31/6774/115290/5c6275d0E681a259e/9437a68ca64b5073.jpg">7.5.8.2节</a>.</em>   </p>
<p><em>另外要注意两段锁协议和防止死锁的一次封锁法的异同之处。一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议；但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。</em></p>
<hr>
<h2 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h2><p><strong>表锁（table lock）</strong><br>表锁是mysql最基本的锁策略，也是开销最小的锁，它会锁定整个表。<br><em>尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如：服务器会为注入ALTER TBALE 之类的语句使用表锁，而忽略存储引擎的锁机制</em><br><strong>行锁（row lock）</strong><br>行锁可以最大限度的支持并发处理，当然也带来了最大开销。众所周知，在InnoDB和XtraDB,以及其他一切存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而MySQL服务器层没有实现，所有的存储引擎都以自己的方式显现了行级锁。   </p>
<hr>
<h2 id="行锁的模式"><a href="#行锁的模式" class="headerlink" title="行锁的模式"></a>行锁的模式</h2><p><strong>1.共享锁(S锁)：</strong><br>对同一行数据都可以共享一把锁,但是没有获得锁的事务只可以读,不可以修改<br><strong>2.排它锁(X锁)：</strong><br>对同一行数据,获得该锁的事务可读可写,未获得锁的事务不可读也不可写.  </p>
<p><em>(另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。)</em><br><strong>3.意向共享锁（IS）：</strong><br>事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。<br><strong>4.意向排他锁（IX）：</strong><br>事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p>
<p><img src= "/img/loading.gif" data-src="1.png"></p>
<p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；</p>
<h2 id="加锁方法"><a href="#加锁方法" class="headerlink" title="加锁方法"></a>加锁方法</h2><p><strong>MVCC中:</strong> </p>
<blockquote>
<p>select语句默认不会加任何锁类型<br> update,delete,insert都会自动给涉及到的数据加上排他锁   </p>
</blockquote>
<p><strong>共享锁</strong>   </p>
<blockquote>
<p>SELECT … LOCK IN SHARE MODE  </p>
</blockquote>
<p><strong>排它锁</strong>   </p>
<blockquote>
<p>SELECT … LOCK FOR UPDATE  </p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="2.png"></p>
<hr>
<h2 id="InnoDB中行锁的实现"><a href="#InnoDB中行锁的实现" class="headerlink" title="InnoDB中行锁的实现"></a>InnoDB中行锁的实现</h2><p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的， InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong> </p>
<p><strong>在不通过索引条件查询的时候，InnoDB使用的是表锁，而不是行锁</strong><br><img src= "/img/loading.gif" data-src="3.png"></p>
<p><strong>在通过索引的where条件下，使用了行锁</strong><br><img src= "/img/loading.gif" data-src="4.jpg"></p>
<p><em>即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</em><br>InnoDB只有在访问行的时候才会对其加锁，而索引能减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层以后，MySQL服务器才能应用WHERE子句。这时已经无法避免锁定行了：InnoDB已经锁定了这些行，到适当的时候才释放。<em>（在MySQL 5.1和更新的版本中，InnoDB可以在服务器端过滤掉行后就释放锁，但在早期的版本中只有在事务提交后才能释放锁。）</em></p>
<p><strong>间隙锁</strong><br>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。  </p>
<p>举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p>
<blockquote>
<p>Select * from  emp where empid &gt; 100 for update;</p>
</blockquote>
<p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。  </p>
<p>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对锁机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况，在后续的会做进一步介绍。 </p>
<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
<p>还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**innodb_lock_wait_timeout 锁等待超时参数**</span><br><span class="line"></span><br><span class="line">**SHOW INNODB STATUS 可以查看数据库中的锁状态** </span><br><span class="line"></span><br><span class="line">**SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS 可以查看锁等待信息**</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>本地缓存 Guava Cache + Caffeine Cache</title>
    <url>/2020/02/04/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>为什么我们要使用本地缓存？</p>
<ol>
<li>空间换时间-消耗内存空间提升速度</li>
<li>某些热key重复hit到很多次</li>
<li>缓存的总容量不会超过内存的总量</li>
</ol>
<a id="more"></a>

<h2 id="GuavaCache"><a href="#GuavaCache" class="headerlink" title="GuavaCache"></a>GuavaCache</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LoadingCache&lt;String, String&gt; build = CacheBuilder.newBuilder()</span><br><span class="line"><span class="comment">// key的最大数量</span></span><br><span class="line">.maximumSize(<span class="number">1000L</span>)</span><br><span class="line"><span class="comment">// 并发最大线程数</span></span><br><span class="line">.concurrencyLevel(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 基于写过期时间</span></span><br><span class="line">.expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line"><span class="comment">// 基于访问过期</span></span><br><span class="line">.expireAfterAccess(<span class="number">15</span>, TimeUnit.MINUTES)</span><br><span class="line"><span class="comment">// 记录命中数 未命中数等</span></span><br><span class="line">.recordStats()</span><br><span class="line"><span class="comment">// 从缓存移除数据的监听器</span></span><br><span class="line">.removalListener(<span class="keyword">new</span> RemovalListener&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;String, String&gt; removalNotification)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// log do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="comment">// 使用CacheLoader来动态加载数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// invoke method</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="全部队列"><a href="#全部队列" class="headerlink" title="全部队列"></a>全部队列</h3><p><img src= "/img/loading.gif" data-src="img1.png"></p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>1.结构大体和concurrentHashMap一致，但是concurrentHashMap只能显示地去移除因素，而Guava Cache能自动去回收元素<br>2.当缓存数据超过预先设定的最大值时，利用LRU算法去移除数据，关于LRU算法的实现：<a href="https://blog.csdn.net/caoshangpa/article/details/78783749">https://blog.csdn.net/caoshangpa/article/details/78783749</a><br>3.设置recordStats能统计缓存的命中率，未命中率和异常率<br>4.不同引用级别的key value</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src= "/img/loading.gif" data-src="img2.jpg"></p>
<h3 id="数据的加载"><a href="#数据的加载" class="headerlink" title="数据的加载"></a>数据的加载</h3><p>1.初始化时使用CacheLoader来加载数据<br>2.利用回调函数，实现callable接口，在get时再去指定，这样比较第一条稍微灵活一些</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loadingCache.get(key, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// invoke method</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="软引用和弱引用"><a href="#软引用和弱引用" class="headerlink" title="软引用和弱引用"></a>软引用和弱引用</h3><p>1.强引用指的是Object object = new Object(); 只有有引用 垃圾回收不会回收对象<br>2.软引用：CacheBuilder.newBuilder().softValues() 当要发生内存溢出时，会回收该value<br>3.弱引用：CacheBuilder.newBuilder().weakKeys() 当gc时就会直接回收</p>
<h3 id="其他使用注意点"><a href="#其他使用注意点" class="headerlink" title="其他使用注意点"></a>其他使用注意点</h3><p>1.使用CacheLoader来加载数据，返回null的情况会抛异常，解决办法可以为对cache.get()加trycatch处理<br>2.cache的超时机制是不准确的，设定存活60秒，可能为61秒或者62秒<br>3.如果不用load去动态加载数据，直接用cache.getIfPresent就可以了，有值则返回，无值则返回null<br>4.调用invalid和invalidAll来删除缓存，也可以手动用cleanUp来回收缓存<br>5.maximumWeight用改值可以设定缓存的最大权重，超过后采用淘汰策略LRU<br>6.cache.asMap将缓存转化为ConccurentHashmap</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>1.先根据当前时间用preWriteCleanup来清理无效的数据<br>2.不能找到entry的情况下，直接创建新的entry，储存数据，更新ccessQueue和WriteQueue<br>3.找到entry的情况下，如果为空，直接更新新值，更新ccessQueue和WriteQueue<br>4.找到entry的情况下，如果不为空，根据onlyIfAbsent来判断，true的情况直接读旧的数据，更新accessQueue，false的情况直接更新新值，更新ccessQueue和WriteQueue，然后直接返回旧数据<br>5.用postWriteCleanup处理被移除的数据</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> now = <span class="keyword">this</span>.map.ticker.read();</span><br><span class="line">    <span class="keyword">this</span>.preWriteCleanup(now);</span><br><span class="line">    <span class="keyword">int</span> newCount = <span class="keyword">this</span>.count + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(newCount &gt; <span class="keyword">this</span>.threshold) &#123;</span><br><span class="line">        <span class="keyword">this</span>.expand();</span><br><span class="line">        newCount = <span class="keyword">this</span>.count + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = <span class="keyword">this</span>.table;</span><br><span class="line">    <span class="keyword">int</span> index = hash &amp; table.length() - <span class="number">1</span>;</span><br><span class="line">    ReferenceEntry&lt;K, V&gt; first = (ReferenceEntry)table.get(index);</span><br><span class="line"></span><br><span class="line">    ReferenceEntry e;</span><br><span class="line">    Object entryKey;</span><br><span class="line">    <span class="keyword">for</span>(e = first; e != <span class="keyword">null</span>; e = e.getNext()) &#123;</span><br><span class="line">        entryKey = e.getKey();</span><br><span class="line">        <span class="keyword">if</span>(e.getHash() == hash &amp;&amp; entryKey != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.map.keyEquivalence.equivalent(key, entryKey)) &#123;</span><br><span class="line">            LocalCache.ValueReference&lt;K, V&gt; valueReference = e.getValueReference();</span><br><span class="line">            V entryValue = valueReference.get();</span><br><span class="line">            Object var15;</span><br><span class="line">            <span class="keyword">if</span>(entryValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(onlyIfAbsent) &#123; </span><br><span class="line">                    <span class="comment">// 如果是true的情况 那么直接读数据返回 读只需要更新accessQueue队列即可</span></span><br><span class="line">                    <span class="keyword">this</span>.recordLockedRead(e, now);</span><br><span class="line">                    var15 = entryValue;</span><br><span class="line">                    <span class="keyword">return</span> var15;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 直接替换旧值</span></span><br><span class="line">                ++<span class="keyword">this</span>.modCount;</span><br><span class="line">                <span class="comment">// 放入移除提醒队列 随后统一交给LocalCache注册的RemovalListener </span></span><br><span class="line">                <span class="keyword">this</span>.enqueueNotification(key, hash, entryValue, valueReference.getWeight(), RemovalCause.REPLACED);</span><br><span class="line">                <span class="comment">// 存入值 并且放入accessQueue和WriteQueue                    </span></span><br><span class="line">                <span class="keyword">this</span>.setValue(e, key, value, now);</span><br><span class="line">                <span class="comment">// 淘汰策略</span></span><br><span class="line">                <span class="keyword">this</span>.evictEntries(e);</span><br><span class="line">                var15 = entryValue;</span><br><span class="line">                <span class="keyword">return</span> var15;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取的值为空的话 则直接替换 </span></span><br><span class="line">            ++<span class="keyword">this</span>.modCount;</span><br><span class="line">            <span class="keyword">if</span>(valueReference.isActive()) &#123;</span><br><span class="line">                <span class="comment">// 放入移除提醒队列，随后统一交给LocalCache注册的RemovalListener </span></span><br><span class="line">                <span class="keyword">this</span>.enqueueNotification(key, hash, entryValue, valueReference.getWeight(), RemovalCause.COLLECTED);</span><br><span class="line">                <span class="comment">// 存入值 并且放入accessQueue和WriteQueue                                        </span></span><br><span class="line">                <span class="keyword">this</span>.setValue(e, key, value, now);</span><br><span class="line">                newCount = <span class="keyword">this</span>.count;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 可能会被load后的值覆盖掉这样count减1</span></span><br><span class="line">                <span class="keyword">this</span>.setValue(e, key, value, now);</span><br><span class="line">                newCount = <span class="keyword">this</span>.count + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.count = newCount;</span><br><span class="line">            <span class="keyword">this</span>.evictEntries(e);</span><br><span class="line">            var15 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> var15;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新entry 放入table</span></span><br><span class="line">    ++<span class="keyword">this</span>.modCount;</span><br><span class="line">    e = <span class="keyword">this</span>.newEntry(key, hash, first);</span><br><span class="line">    <span class="comment">// 存入值 放入accessQueue和WriteQueue                    </span></span><br><span class="line">    <span class="keyword">this</span>.setValue(e, key, value, now);</span><br><span class="line">    <span class="comment">// table也存入entry</span></span><br><span class="line">    table.set(index, e);</span><br><span class="line">    newCount = <span class="keyword">this</span>.count + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.count = newCount;</span><br><span class="line">    <span class="keyword">this</span>.evictEntries(e);</span><br><span class="line">    entryKey = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> entryKey;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.unlock();</span><br><span class="line">    <span class="comment">// 处理刚才放入移除提醒队列的元素</span></span><br><span class="line">    <span class="keyword">this</span>.postWriteCleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>1.进入segment，进入table，如果直接命中调用scheduleRefresh返回结果<br>2.如果没有命中，进入后发现正在loading（其他线程加载数据状态），则线程阻塞，等待加载的结果<br>3.前两条都不符合，那就是说这个entry为null，还没有拿到数据调用lockedGetOrLoad方法获取数据<br>4.进入lockedGetOrLoad后，首先对segment加锁，如果没有找不到这个entry，创建新的entry，同步加载Vlaue到entry中<br>5.进入lockedGetOrLoad后，如果找到了这个entry，如果正在loading了，那就等待结果<br>6.进入lockedGetOrLoad后，如果找到了这个entry，否则如果value为null，证明被gc，或者是过期了的数据，那么这两种移入移除提醒队列，并且在writeQueue和accessQueue中remove掉,然后创建新的entry，同步加载Vlaue到entry中<br>7.剩下的最后一种情况为，命中数据，直接返回</p>
<p><img src= "/img/loading.gif" data-src="img3.png"></p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.count != <span class="number">0</span>) &#123;</span><br><span class="line">    ReferenceEntry&lt;K, V&gt; e = <span class="keyword">this</span>.getEntry(key, hash);</span><br><span class="line">    <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> now = <span class="keyword">this</span>.map.ticker.read();</span><br><span class="line">        V value = <span class="keyword">this</span>.getLiveValue(e, now);</span><br><span class="line">        <span class="keyword">if</span>(value != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 直接击中</span></span><br><span class="line">            <span class="keyword">this</span>.recordRead(e, now);</span><br><span class="line">            <span class="keyword">this</span>.statsCounter.recordHits(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 刷新机制获取value</span></span><br><span class="line">            Object var17 = <span class="keyword">this</span>.scheduleRefresh(e, key, hash, value, now, loader);</span><br><span class="line">            <span class="keyword">return</span> var17;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LocalCache.ValueReference&lt;K, V&gt; valueReference = e.getValueReference();</span><br><span class="line">        <span class="keyword">if</span>(valueReference.isLoading()) &#123; </span><br><span class="line">            <span class="comment">// loading 状态 线程阻塞等待 等值</span></span><br><span class="line">            Object var9 = <span class="keyword">this</span>.waitForLoadingValue(e, key, valueReference);</span><br><span class="line">            <span class="keyword">return</span> var9;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var15 = <span class="keyword">this</span>.lockedGetOrLoad(key, hash, loader);</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">V <span class="title">lockedGetOrLoad</span><span class="params">(K key, <span class="keyword">int</span> hash, CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; loader)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    LocalCache.ValueReference&lt;K, V&gt; valueReference = <span class="keyword">null</span>;</span><br><span class="line">    LocalCache.LoadingValueReference&lt;K, V&gt; loadingValueReference = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> createNewEntry = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 首先对segment加锁            </span></span><br><span class="line">    <span class="keyword">this</span>.lock();</span><br><span class="line"></span><br><span class="line">    ReferenceEntry e;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 记录时间</span></span><br><span class="line">        <span class="keyword">long</span> now = <span class="keyword">this</span>.map.ticker.read();</span><br><span class="line">        <span class="comment">// 加锁清理遗留的数据</span></span><br><span class="line">        <span class="keyword">this</span>.preWriteCleanup(now);</span><br><span class="line">        <span class="keyword">int</span> newCount = <span class="keyword">this</span>.count - <span class="number">1</span>;</span><br><span class="line">        AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = <span class="keyword">this</span>.table;</span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; table.length() - <span class="number">1</span>;</span><br><span class="line">        ReferenceEntry&lt;K, V&gt; first = (ReferenceEntry)table.get(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(e = first; e != <span class="keyword">null</span>; e = e.getNext()) &#123;</span><br><span class="line">            K entryKey = e.getKey();</span><br><span class="line">            <span class="keyword">if</span>(e.getHash() == hash &amp;&amp; entryKey != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.map.keyEquivalence.equivalent(key, entryKey)) &#123;</span><br><span class="line">                valueReference = e.getValueReference();</span><br><span class="line">                <span class="keyword">if</span>(valueReference.isLoading()) &#123;</span><br><span class="line">                    <span class="comment">// 如果数据正在loading 阻塞等待结果</span></span><br><span class="line">                    createNewEntry = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    V value = valueReference.get();</span><br><span class="line">                    <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 放入移除提醒队列 随后统一交给LocalCache注册的RemovalListener </span></span><br><span class="line">                        <span class="keyword">this</span>.enqueueNotification(entryKey, hash, value, valueReference.getWeight(), RemovalCause.COLLECTED);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!<span class="keyword">this</span>.map.isExpired(e, now)) &#123; </span><br><span class="line">                            <span class="comment">// entry没有过期 命中 直接返回</span></span><br><span class="line">                            <span class="keyword">this</span>.recordLockedRead(e, now);</span><br><span class="line">                            <span class="keyword">this</span>.statsCounter.recordHits(<span class="number">1</span>);</span><br><span class="line">                            Object var16 = value;</span><br><span class="line">                            <span class="keyword">return</span> var16;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 过期数据 cause是expired 放入移除提醒队列</span></span><br><span class="line">                        <span class="keyword">this</span>.enqueueNotification(entryKey, hash, value, valueReference.getWeight(), RemovalCause.EXPIRED);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 从writeQueue和accessQueue 移除过期无用的数据</span></span><br><span class="line">                    <span class="keyword">this</span>.writeQueue.remove(e);</span><br><span class="line">                    <span class="keyword">this</span>.accessQueue.remove(e);</span><br><span class="line">                    <span class="keyword">this</span>.count = newCount;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(createNewEntry) &#123;</span><br><span class="line">            loadingValueReference = <span class="keyword">new</span> LocalCache.LoadingValueReference();</span><br><span class="line">            <span class="keyword">if</span>(e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 新建一个entry的数据 将ValueReference设置为loadingValueReference 并不是完全的状态 还要调用下面的方法</span></span><br><span class="line">                e = <span class="keyword">this</span>.newEntry(key, hash, first);</span><br><span class="line">                e.setValueReference(loadingValueReference);</span><br><span class="line">                table.set(index, e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                e.setValueReference(loadingValueReference);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.unlock();</span><br><span class="line">        <span class="keyword">this</span>.postWriteCleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将值加载到entry上</span></span><br><span class="line">    <span class="keyword">if</span>(createNewEntry) &#123;</span><br><span class="line">        Object var9;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 只需要锁entry 不需要锁segment</span></span><br><span class="line">            <span class="keyword">synchronized</span>(e) &#123; </span><br><span class="line">                var9 = <span class="keyword">this</span>.loadSync(key, hash, loadingValueReference, loader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.statsCounter.recordMisses(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var9;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.waitForLoadingValue(e, key, valueReference);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CaffeineCache"><a href="#CaffeineCache" class="headerlink" title="CaffeineCache"></a>CaffeineCache</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>封装的API和Guava Cache基本上相同<br>在spring5.0以后使用了Caffeine代替了Guava Cache，因为Caffeine的性能比Guava Cache强很多，并且它的理想命中率也比Guava Cache高很多，这要得益于他的W-TinyLFU算法，那么W-TinyLFU又是什么呢，首先我们知道LRU是淘汰最久的数据，那么对于突发的的访问量旧的数据就被冲掉，LFU是代表访问频率最小的被淘汰掉，但是有些数据只是一段时间会访问到，所以在垃圾数据会被挤压太久，所以两者都有缺陷，这样W-TinyLFU可以说是LFU和LRU的完美结合，具体如下图所示</p>
<ul>
<li>新数据进来首先进入Eden区，那么就算有突发的访问频率，也不会把这些数据给冲掉</li>
<li>被访问过一次以上数据会从Eden进入Probation，Probation称为缓刑区，一旦没有晋升到Protected，那么这个区的数据最有可能先死</li>
<li>从Probation的数据再被访问时会进入Protected区，在这个区称为保护区，这里的数据相对安全，但是一旦Protected区数据满了，被淘汰的数据，又会回到Probation区</li>
</ul>
<p><img src= "/img/loading.gif" data-src="img4.png" alt="1"><br><img src= "/img/loading.gif" data-src="img5.jpg" alt="1"></p>
<hr>
<h3 id="图片来源"><a href="#图片来源" class="headerlink" title="图片来源"></a>图片来源</h3><pre><code>https://juejin.im/post/5b8df63c6fb9a019e04ebaf4
https://www.jianshu.com/p/38bd5f1cf2f2
</code></pre>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><pre><code>https://juejin.im/post/5b8df63c6fb9a019e04ebaf4
https://www.jianshu.com/p/38bd5f1cf2f2
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>模块机制</title>
    <url>/2020/02/04/%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>程序员最怕两件事，第一件事是产品改需求，第二件事是接手的代码乱七八糟结果最后发现是自己以前写的。<br>很不幸，我正在经历第二件事。<br>本文旨在让你对模块机制有简单了解以及对require js的核心原理的介绍。</p>
<a id="more"></a>
<h2 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h2><p>模块的实质就是业务逻辑的低耦合高内聚，一个模块独立实现一个功能不依赖其他模块，这就是低耦合高内聚。而不是所有功能代码堆叠在一起，牵一发而动全身。模块最重要的是你使用它时仅导入导出你所需要的绑定。</p>
<p>引入模块和引入脚本是有区别的，模块可以理解为按需加载，后者更多是一次性引入全部不管你有没有用，例如引入JQuery。</p>
<h2 id="模块编程的几种方式"><a href="#模块编程的几种方式" class="headerlink" title="模块编程的几种方式"></a>模块编程的几种方式</h2><h3 id="原始写法"><a href="#原始写法" class="headerlink" title="原始写法"></a>原始写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p>
</blockquote>
<h3 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">   num:<span class="number">0</span>,</span><br><span class="line">   fn1 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">   &#125;,</span><br><span class="line">   fn2 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.num = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p> 这种方法会有一个明显的缺点，就是内部的变量会被外部改变。举个栗子，你定义了一个a=10,但我在我的代码中把a改成了100，但其实模块里的a应该一直是10，不应该被外部所改变。</p>
</blockquote>
<h3 id="立即执行函数写法"><a href="#立即执行函数写法" class="headerlink" title="立即执行函数写法"></a>立即执行函数写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> immediately = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">var</span> func2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     func1 : func1,</span><br><span class="line">     func2 : func2</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(immediately.num)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种特点也很明显，就是外部无法读取内部的变量,虽然模块不应该被改变变量，但好歹获取得让我获取一下啊。</p>
</blockquote>
<h3 id="输入全局变量写法"><a href="#输入全局变量写法" class="headerlink" title="输入全局变量写法"></a>输入全局变量写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  globalVariable= (<span class="function"><span class="keyword">function</span> (<span class="params">$,y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;)(JQuery,yhooh);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输入全局变量写法,为了在模块内部调用全局变量，必须将其他变量输入模块,就把这两个库（也是两个模块）当作参数.这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>
</blockquote>
<h2 id="Common-js的require和AMD的require"><a href="#Common-js的require和AMD的require" class="headerlink" title="Common js的require和AMD的require"></a>Common js的require和AMD的require</h2><ul>
<li>Commonjs是同步加载，在服务器端并不是问题，因为服务器端的文件都是存在本地硬盘里可以同步加载，等待时间就是硬盘读取时间，但是浏览器端不同，时间取决于网速，很可能造成浏览器假死。</li>
<li>AMD规范下的require接受两个参数，异步加载所需模块，不阻塞进程，只有依赖模块加载完毕后才会执行回调方法。</li>
</ul>
<h2 id="require-js优点"><a href="#require-js优点" class="headerlink" title="require js优点"></a>require js优点</h2><ul>
<li>实现js文件的异步加载，避免网页失去响应</li>
<li>管理模块之间的依赖性</li>
</ul>
<h2 id="Require的原理"><a href="#Require的原理" class="headerlink" title="Require的原理"></a>Require的原理</h2><ul>
<li>Require作为程序的入口，调度javascript资源，加载到各个defined模块时，各个模块就悄无声息的动态创建script标签加载文件，加载结束后往require队列里报告自己结束了，require中所有以来的模块都结束了，就执行回调函数。</li>
<li>举个栗子：马上开学了，小明的寒假作业还有很多没写（需要依赖的模块很多），如果让他自己写（按照顺序加载），可能会写不完（等待时间过长造成浏览器卡死），小明找了几个自己的好朋友帮自己一起写（异步执行加载模块操作），每个小伙伴领了自己的任务开始写作业（创建script标签放到html的head头里），每一个人写完小明给他们的作业了就告诉小明，我写完了（每一个模块向队列报告加载完成），小明把作业都放进自己的书包里（记录模块加载完成的个数长度），当所有人的任务都完成，小明就开开心心上学了（所有模块依赖完成后，执行回调代码）</li>
</ul>
<p>一起来看看我写的一个require源码中核心思想，源码太多了，就讲讲原理吧</p>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myRequire.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">require</span>([<span class="string">&#x27;defined1.js&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">def</span>) </span>&#123;</span></span><br><span class="line">        def.define.sayHello();</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>   这里require就是myRequire.js里的方法，require接受两个参数，第一个参数是个数组，也就是所有依赖的模块名，第二个参数是加载完这些模块后执行的回调函数.def1和def2是这两个模块定义的时候导出的对象</p>
</blockquote>
<p>defined1.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.define = &#123;</span><br><span class="line">    topic: <span class="string">&#x27;老王&#x27;</span>,</span><br><span class="line">    desc: <span class="string">&#x27;说了声Hello&#x27;</span>,</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="built_in">this</span>.topic + <span class="built_in">this</span>.desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   这其实就是一个简单的模块—defined1模块,exports.define包裹的部分也就是导出的内容，也就是之前提到过的def1</p>
</blockquote>
<p>myRequire.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标记已经加载成功的个数</span></span><br><span class="line"><span class="keyword">let</span> successNum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//模块导出</span></span><br><span class="line"><span class="built_in">window</span>.exports = &#123;&#125;;</span><br><span class="line"><span class="comment">//记录各个模块的顺序</span></span><br><span class="line"><span class="keyword">let</span> moduleOrder = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> param <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//require 真正实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">arr, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> req_list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化成数组。（arr就是小明的朋友们）</span></span><br><span class="line">    <span class="keyword">if</span>(isArray(arr)) &#123;</span><br><span class="line">        req_list = arr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        req_list = [arr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> req_len = req_list.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模块逐个加载（小明的朋友们都到齐了）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;req_len;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> req_item = req_list[i];</span><br><span class="line">        <span class="comment">// 每一个都创建script标签（每一个小伙伴都领了一部分要帮小明写的作业）</span></span><br><span class="line">        <span class="keyword">let</span> $script = createScript(req_item, i);</span><br><span class="line">        <span class="comment">//html里的head节点</span></span><br><span class="line">        <span class="keyword">let</span> $node = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;head&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">$script</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//将每个script标签加入扫head头里（每个小伙伴正在写作业）</span></span><br><span class="line">            $node.appendChild($script);</span><br><span class="line">            <span class="comment">//检测script 的onload事件(判断小明的朋友们是否写完作业)</span></span><br><span class="line">            $script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将加载完成后的模块按照顺序塞到一个数组里（写完作业的朋友们将作业给了小明，小明记录了已经写完的作业数量）</span></span><br><span class="line">                successNum++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> script_index = $script.getAttribute(<span class="string">&#x27;index&#x27;</span>);</span><br><span class="line">                <span class="comment">//这是模块加载完成顺序数组（小明按照顺序将写好的作业排好）</span></span><br><span class="line">                moduleOrder[script_index] = <span class="built_in">exports</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">window</span>.exports = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//所有的模块都加载成功后，执行callback（所有的小伙伴都写完了作业，小明收好了所有的作业，去上学了）</span></span><br><span class="line">                <span class="keyword">if</span>(successNum == req_len) &#123;</span><br><span class="line"></span><br><span class="line">                    callback &amp;&amp; callback.apply(<span class="built_in">exports</span>, moduleOrder);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;)($script);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个script标签（小伙伴们领到任务开始写作业）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createScript</span>(<span class="params">src, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> $script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    $script.setAttribute(<span class="string">&#x27;src&#x27;</span>, src);</span><br><span class="line">    $script.setAttribute(<span class="string">&#x27;index&#x27;</span>, index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $script;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   回想上面提过的require原理</p>
</blockquote>
<h2 id="Es6模块化export和import"><a href="#Es6模块化export和import" class="headerlink" title="Es6模块化export和import"></a>Es6模块化export和import</h2><h3 id="Es6模块化的基本特点："><a href="#Es6模块化的基本特点：" class="headerlink" title="Es6模块化的基本特点："></a>Es6模块化的基本特点：</h3><ul>
<li> 基于文件的模块化，通俗的说就是一个文件一个模块</li>
<li> 模块的API是静态的，需要在模块公开API中静态定义所有最高层导出，后期无法补充</li>
<li> 单例模式，模块只有一个实例，其中维护了他的状态，每次被导入时，是对单个中心实例的引用，如果想要多个模块实例，模块需要提供某种工厂方法来实现这一点。</li>
<li> 模块公开的API中暴露的属性和方法并不仅仅是普通的值或者引用赋值，他们是到内部模块定义中的标识符的实际绑定，几乎类似于指针。每一个模块内声明的变量都是局部变量，不会污染全局作用域。</li>
</ul>
<h3 id="Export和export-default"><a href="#Export和export-default" class="headerlink" title="Export和export default"></a>Export和export default</h3><ul>
<li> 都可以用来导出常量，函数，模块，文件等等</li>
<li> 都可以通过import引入</li>
<li> Export可以有很多，但export default只有一个</li>
<li> Export导出后面要用{ },export default不用</li>
<li> Import export default 输出的模块时，可以随便起名，但Import export输出的模块时，只能用export导出时定义的名字</li>
</ul>
<p>以上就是所有的内容啦，BIU～</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝vs深拷贝</title>
    <url>/2021/03/10/%E6%B5%85%E6%8B%B7%E8%B4%9Dvs%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>本文主要讲一下javascript的基本数据类型以及一些堆和栈的知识和什么是深拷贝、浅拷贝，深拷贝与浅拷贝的区别，以及怎么进行深拷贝和怎么进行浅拷贝。</p>
<h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p>深拷贝和浅拷贝的主要区别在内存中的存储类型不同。堆和栈都是内存中划分出来用来存储的区域。栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。</p>
<h2 id="ECMAScript的数据类型"><a href="#ECMAScript的数据类型" class="headerlink" title="ECMAScript的数据类型"></a>ECMAScript的数据类型</h2><p>首先先说一下ECMAScript的数据类型。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li><p>undefined</p>
</li>
<li><p>boolean</p>
</li>
<li><p>number</p>
</li>
<li><p>string</p>
</li>
<li><p>null</p>
<p>基本数据类型存放在栈中。存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。</p>
</li>
</ul>
<h4 id="基本数据类型值不可变"><a href="#基本数据类型值不可变" class="headerlink" title="基本数据类型值不可变"></a>基本数据类型值不可变</h4><p>js中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本区别。原始值是不可更改的。</p>
<p>基本数据类型的值是不可变的，动态修改了基本数据类型的值，它的原始值也是不会改变的，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &quot;abc&quot;;</span><br><span class="line">console.log(str[1]&#x3D;&quot;f&quot;);    &#x2F;&#x2F; f</span><br><span class="line">console.log(str);           &#x2F;&#x2F; abc</span><br></pre></td></tr></table></figure>

<h4 id="基本类型的比较是值的比较"><a href="#基本类型的比较是值的比较" class="headerlink" title="基本类型的比较是值的比较"></a>基本类型的比较是值的比较</h4><p>基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 1, b &#x3D; 1;</span><br><span class="line">console.log(a &#x3D;&#x3D;&#x3D; b);  &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="引用类型存放在堆中"><a href="#引用类型存放在堆中" class="headerlink" title="引用类型存放在堆中"></a>引用类型存放在堆中</h4><p>引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let person1 &#x3D; &#123;name:&#39;jozo&#39;&#125;;</span><br><span class="line">let person2 &#x3D; &#123;name:&#39;xiaom&#39;&#125;;</span><br><span class="line">let person3 &#x3D; &#123;name:&#39;xiaoq&#39;&#125;;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/166090/31/5915/69760/601fd463E65160a6e/6f84d4dbcd475154.jpg"></p>
<h4 id="引用类型值可变"><a href="#引用类型值可变" class="headerlink" title="引用类型值可变"></a>引用类型值可变</h4><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; [1,2,3];</span><br><span class="line">a[1] &#x3D; 5;</span><br><span class="line">console.log(a[1]); &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>
<h4 id="引用类型的比较是引用的比较"><a href="#引用类型的比较是引用的比较" class="headerlink" title="引用类型的比较是引用的比较"></a>引用类型的比较是引用的比较</h4><p>所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; [1,2,3], b &#x3D; [1,2,3];</span><br><span class="line">console.log(a &#x3D;&#x3D;&#x3D; b);  &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/153245/23/18034/51108/601fd528E492b7b56/6d14b845e7c8f7e4.jpg"></p>
<h3 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h3><p>了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。在进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 10, b &#x3D; a;</span><br><span class="line">a ++ ;</span><br><span class="line">console.log(a); &#x2F;&#x2F; 11</span><br><span class="line">console.log(b); &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/161856/11/5971/48056/601fd5d5Eefd12f79/bcdf1d5896d925f0.jpg"></p>
<p>而引用类型的赋值是传址。只是改变指针的指向，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; &#123;&#125;; &#x2F;&#x2F; a保存了一个空对象的实例</span><br><span class="line">var b &#x3D; a;  &#x2F;&#x2F; a和b都指向了这个空对象</span><br><span class="line"></span><br><span class="line">a.name &#x3D; &#39;jozo&#39;;</span><br><span class="line">console.log(a.name); &#x2F;&#x2F; &#39;jozo&#39;</span><br><span class="line">console.log(b.name); &#x2F;&#x2F; &#39;jozo&#39;</span><br><span class="line"></span><br><span class="line">b.age &#x3D; 22;</span><br><span class="line">console.log(b.age);&#x2F;&#x2F; 22</span><br><span class="line">console.log(a.age);&#x2F;&#x2F; 22</span><br><span class="line"></span><br><span class="line">console.log(a &#x3D;&#x3D; b);&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/166818/18/5850/88832/601fd6a6E0e87f529/4bcaa52d018dd200.jpg"></p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h4 id="赋值（-）和浅拷贝的区别"><a href="#赋值（-）和浅拷贝的区别" class="headerlink" title="赋值（=）和浅拷贝的区别"></a>赋值（=）和浅拷贝的区别</h4><p>以下例说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">    &#39;name&#39; : &#39;zhangsan&#39;,</span><br><span class="line">    &#39;age&#39; :  &#39;18&#39;,</span><br><span class="line">    &#39;language&#39; : [1,[2,3],[4,5]],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; obj1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var obj3 &#x3D; shallowCopy(obj1);</span><br><span class="line">function shallowCopy(src) &#123;</span><br><span class="line">    var dst &#x3D; &#123;&#125;;</span><br><span class="line">    for (var prop in src) &#123;</span><br><span class="line">        if (src.hasOwnProperty(prop)) &#123;</span><br><span class="line">            dst[prop] &#x3D; src[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj2.name &#x3D; &quot;lisi&quot;;</span><br><span class="line">obj3.age &#x3D; &quot;20&quot;;</span><br><span class="line"></span><br><span class="line">obj2.language[1] &#x3D; [&quot;二&quot;,&quot;三&quot;];</span><br><span class="line">obj3.language[2] &#x3D; [&quot;四&quot;,&quot;五&quot;];</span><br><span class="line"></span><br><span class="line">console.log(obj1);  </span><br><span class="line">&#x2F;&#x2F;obj1 &#x3D; &#123;</span><br><span class="line">&#x2F;&#x2F;    &#39;name&#39; : &#39;lisi&#39;,</span><br><span class="line">&#x2F;&#x2F;    &#39;age&#39; :  &#39;18&#39;,</span><br><span class="line">&#x2F;&#x2F;    &#39;language&#39; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],</span><br><span class="line">&#x2F;&#x2F;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj2);</span><br><span class="line">&#x2F;&#x2F;obj2 &#x3D; &#123;</span><br><span class="line">&#x2F;&#x2F;    &#39;name&#39; : &#39;lisi&#39;,</span><br><span class="line">&#x2F;&#x2F;    &#39;age&#39; :  &#39;18&#39;,</span><br><span class="line">&#x2F;&#x2F;    &#39;language&#39; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],</span><br><span class="line">&#x2F;&#x2F;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj3);</span><br><span class="line">&#x2F;&#x2F;obj3 &#x3D; &#123;</span><br><span class="line">&#x2F;&#x2F;    &#39;name&#39; : &#39;zhangsan&#39;,</span><br><span class="line">&#x2F;&#x2F;    &#39;age&#39; :  &#39;20&#39;,</span><br><span class="line">&#x2F;&#x2F;    &#39;language&#39; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],</span><br><span class="line">&#x2F;&#x2F;&#125;;</span><br></pre></td></tr></table></figure>

<p>先定义个一个原始的对象 obj1，然后使用赋值得到第二个对象 obj2，然后通过浅拷贝，将 obj1 里面的属性都赋值到 obj3 中。也就是说：</p>
<p>obj1：原始数据<br>obj2：赋值操作得到<br>obj3：浅拷贝得到</p>
<p>然后我们改变 obj2 的 name 属性和 obj3 的 name 属性，可以看到，改变赋值得到的对象 obj2 同时也会改变原始值 obj1，而改变浅拷贝得到的的 obj3 则不会改变原始对象 obj1。这就可以说明赋值得到的对象 obj2 只是将指针改变，其引用的仍然是同一个对象，而浅拷贝得到的的 obj3 则是重新创建了新对象。<br>然而，我们接下来来看一下改变引用类型会是什么情况呢，我又改变了赋值得到的对象 obj2 和浅拷贝得到的 obj3 中的 language 属性的第二个值和第三个值（language 是一个数组，也就是引用类型）。结果见输出，可以看出来，无论是修改赋值得到的对象 obj2 和浅拷贝得到的 obj3 都会改变原始数据。<br>这是因为浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据。所以就会出现改变浅拷贝得到的 obj3 中的引用类型时，会使原始数据得到改变。</p>
<p>深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象，</p>
<p>浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象<br><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/153006/4/18335/127130/601fd8aaE7f1845aa/d855d9ba0b486d45.jpg"></p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>深拷贝就是对对象以及对象的所有子对象进行拷贝。<br>怎么进行深拷贝呢？<br>思路就是递归调用刚刚的浅拷贝，把所有属于对象的属性类型都遍历赋给另一个对象即可。</p>
<h4 id="扩展运算符是深拷贝还是浅拷贝"><a href="#扩展运算符是深拷贝还是浅拷贝" class="headerlink" title="扩展运算符是深拷贝还是浅拷贝"></a>扩展运算符是深拷贝还是浅拷贝</h4><p>以下例说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3, 4, 5, 6];</span><br><span class="line">let arr1 &#x3D; [...arr];</span><br><span class="line">arr1.push(7);</span><br><span class="line">console.log(arr); &#x2F;&#x2F;[1, 2, 3, 4, 5, 6]</span><br><span class="line">console.log(arr1); &#x2F;&#x2F;[1, 2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure>
<p>当数组是一维数组时，扩展运算符可以进行完全深拷贝，改变拷贝后数组的值并不会影响拷贝源的值。但是，当数组为多维时：例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3, 4, 5, 6, [1, 2, 3]];</span><br><span class="line">let arr1 &#x3D; [...arr];</span><br><span class="line">arr1.push(7);</span><br><span class="line">arr1[arr1.length - 2][0] &#x3D; 100;</span><br><span class="line">console.log(arr); &#x2F;&#x2F;[1, 2, 3, 4, 5, 6,[100, 2, 3]]</span><br><span class="line">console.log(arr1); &#x2F;&#x2F;[1, 2, 3, 4, 5, 6, [100, 2, 3],7]</span><br></pre></td></tr></table></figure>
<p>由此可见，不难发现当改变拷贝后数组中第二层数组的值时，则拷贝前数组第二层数组的值也跟着改变了。</p>
<p>结论：扩展运算符，如果只是一层数组或是对象，其元素只是简单类型的元素，那么属于深拷贝（就是一层拷贝，可以理解为深拷贝吧！）<br>如果数组或对象中的元素是引用类型的元素，那么就是浅拷贝。</p>
<h4 id="JSON-parse-JSON-stringfy-xxx-来实现深拷贝"><a href="#JSON-parse-JSON-stringfy-xxx-来实现深拷贝" class="headerlink" title="JSON.parse(JSON.stringfy(xxx))来实现深拷贝"></a>JSON.parse(JSON.stringfy(xxx))来实现深拷贝</h4><p>利用JSON.parse(JSON.stringfy(xxx))也可实现深拷贝<br><code>注意：JSON.parse(JSON.stringfy(xxx))的方法，如果变量中含有Promise对象，则不可以使用该方法。</code></p>
]]></content>
  </entry>
  <entry>
    <title>浏览器缓存</title>
    <url>/2021/02/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 说到浏览器缓存，一些前端同学可能会先联想localStorage和sessionStorage，但它们是完全不同的概念。localStorage或sessionStorage是浏览器本地存储技术，是用来存储客户端临时信息的；浏览器缓存是，浏览器将通过HTTP获取的网路资源保存到本地，下次再请求相同的url时，根据当前的缓存机制，来决定是使用本地缓存的资源还是向服务器发送网络请求。</p>
<p> 浏览器缓存的好处：</p>
<ul>
<li><p>减少了重复数据的传输；</p>
</li>
<li><p>减少服务器端的网络请求</p>
</li>
<li><p>加快客户端页面加载速度，提升用户体验</p>
<h3 id="浏览器缓存的流程"><a href="#浏览器缓存的流程" class="headerlink" title="浏览器缓存的流程"></a>浏览器缓存的流程</h3><p>浏览器缓存的具体流程是：</p>
</li>
</ul>
<ol>
<li>浏览器发送请求时，首先判断是否采用缓存（强缓存或协商缓存），若未使用缓存，向服务器端请求资源；</li>
<li>若使用缓存，先判断是否使用强缓存且强缓存为过期，若是的话，直接使用本地缓存的资源；</li>
<li>若未使用强缓存或者强缓存已过期，浏览器向服务端发起请求，服务端根据请求头的信息判断是否使用协商缓存，若使用协商缓存且协商缓存的资源未发生变化，则返回304和空的响应体，直接从客户端缓存中读取资源；否则返回200和新的资源<br><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/165592/32/7462/60812/6034fa6dE8d773898/4fd4fb53ba00e91e.png" alt="浏览器缓存的流程.png"></li>
</ol>
<p>下面详细介绍缓存资源的存放位置、强缓存和协商缓存~</p>
<h3 id="缓存资源位置"><a href="#缓存资源位置" class="headerlink" title="缓存资源位置"></a>缓存资源位置</h3><p><strong>memory cache</strong><br>是将资源缓存到内存中，等下次再访问时直接从内存中读取缓存资源。浏览器关闭后，缓存的资源就被释放掉了，下次再打开相同的页面时，不会出现memory cache的资源。  </p>
<p><strong>disk cache</strong><br>是将资源缓存到磁盘中，等再次访问时，直接从磁盘中读取。跟memory cache不同的是，关闭浏览器后，缓存的资源依旧存在。  </p>
<p>访问缓存资源的优先级是先从内存中查找，内存中没有，再从硬盘中查找，若是两者都没有的话，就向服务器发送网络请求。</p>
<p>已加载的资源是存到磁盘中还是存到内存中，取决于资源的大小和内存空闲情况。磁盘的容量远大于内存容量。当内存空闲时，优先将资源放入内存，否则存入磁盘中。</p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存是，浏览器加载资源时，不会像服务器发送请求，而是直接从本地缓存中读取资源。强缓存的实现方式有两种，Expires 和 Cache-Control，它们都是通过设置HTTP请求头来实现的。</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires用来指定资源的到期时间，是服务器的绝对时间，是GMT时间格式。当服务器时间和浏览器本地时间偏差较大时，会导致缓存混乱。</p>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>Cache-Control是一个相对时间，通过设置max-age的值来实现，单位是秒。比如，Cache-Control:max-age=200，表示缓存的资源200s后过期。</p>
<p>Cache-Control的设置值：</p>
<ul>
<li>max-age=xxx：xxx秒后，缓存的资源到期；</li>
<li>no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存；</li>
<li>no-store：禁止使用缓存，每一次都要重新请求数据；</li>
<li>public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器；</li>
<li>private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。</li>
</ul>
<p>若Expires和Cache-Control在服务端同时启用，Cache-Control的优先级更高。那么若本地客户端请求头和服务器响应头都设置了Cache-Control，它们的优先级是怎么样的呢？<br>这里，我们通过代码实验一下。chrome浏览器默认设置Cache-Control:no-cache，所以需要将Disable cache取消勾选。</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/161197/2/7873/76825/6035e22cE18d858b3/e6fc95a141400e0f.png" alt="关闭Disable cache.png"></p>
<p>第一种：客户端和服务端都不设置Cache-Control</p>
<ul>
<li>客户端<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    url: <span class="string">&#x27;http://localhost:3000/cacheDemo&#x27;</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;请求的资源&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>服务端<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">&#x27;/cacheDemo&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行了&#x27;</span>)</span><br><span class="line">    res.end(<span class="string">`cacheDemo`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/165028/13/7441/137566/6035eb5fE5b597e41/a058eaf095c81830.png" alt="场景1.png"></li>
</ul>
<p>默认情况下，第二次请求相同的资源，是不会走缓存逻辑的  </p>
<p>第二种：客户端设置Cache-Control，服务端不设置Cache-Control</p>
<ul>
<li>客户端<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    url: <span class="string">&#x27;http://localhost:3000/cacheDemo&#x27;</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=10&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;请求的资源&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/155234/40/19141/125236/6035eb5fE1f8c773d/2f2ad352131fe81f.png" alt="场景2.png"></li>
</ul>
<p>第二次请求相同的资源，缓存同样没有生效。  </p>
<p>第三种：客户端不设置Cache-Control，服务端设置Cache-Control</p>
<ul>
<li>客户端<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    url: <span class="string">&#x27;http://localhost:3000/cacheDemo&#x27;</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;请求的资源&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>服务端<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>)</span><br><span class="line">    res.header(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;max-age=300&quot;</span>)</span><br><span class="line">    res.header(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;X-Requested-With, cache-control&quot;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">&#x27;/cacheDemo&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行了&#x27;</span>)</span><br><span class="line">    res.end(<span class="string">`cacheDemo`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/162049/14/7678/116715/6035eb5fE2207302f/71b4aae2f370bc7a.png" alt="场景3.png"> </li>
</ul>
<p>第二次请求相同的资源，命中强缓存，不再进行网络请求，直接从缓存中读取资源。  </p>
<p>第四种，客户端和服务端都设置Cache-Control，但max-age是不同的值  </p>
<ul>
<li>客户端<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    url: <span class="string">&#x27;http://localhost:3000/cacheDemo&#x27;</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=10&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;请求的资源&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>服务端<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>)</span><br><span class="line">    res.header(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;max-age=300&quot;</span>)</span><br><span class="line">    res.header(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;X-Requested-With, cache-control&quot;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">&#x27;/cacheDemo&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;    </span><br><span class="line">    res.end(<span class="string">`cacheDemo`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/170106/19/7773/121716/6035eb5fEda2e11bd/1e75b7033dddb0b5.png" alt="场景4.png"></li>
</ul>
<p>10s之后，缓存并未失效，30s后才生效，缓存的失效时间是由服务端决定的  </p>
<p>第五种，客户端设置关闭缓存，服务端都设置Cache-Control  </p>
<ul>
<li>客户端<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    url: <span class="string">&#x27;http://localhost:3000/cacheDemo&#x27;</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;请求的资源&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>服务端<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>)</span><br><span class="line">    res.header(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;max-age=300&quot;</span>)</span><br><span class="line">    res.header(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;X-Requested-With, cache-control&quot;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">&#x27;/cacheDemo&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;    </span><br><span class="line">    res.end(<span class="string">`cacheDemo`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/152904/22/19259/145673/6035eb5fEa9a1e989/a51e4fade6b418e7.png" alt="场景5.png"></li>
</ul>
<p>第二次载入资源，不再走强缓存，而晒向服务器端发送资源请求</p>
<p>所以，结论是，服务器端才能开启强缓存，且决定缓存的失效时间；客户端无法开启强缓存，但可以通过设置Cache-Control为max-age=0、no-store或no-cache，来关闭缓存</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当没有强缓存或者强缓存过期时，浏览器会向服务端发起请求，服务端根据请求头信息判断是否使用协商缓存且协商缓存的资源未发生变化，若是的话，返回304和空的响应体，告诉浏览器资源未更新，直接从本地缓存中读取资源；否则返回200和新的资源。协商缓存的实现方式有两种， Last-Modified/If-Modify-Since 和 ETag/If-None-Match。</p>
<h4 id="Last-Modified-If-Modify-Since"><a href="#Last-Modified-If-Modify-Since" class="headerlink" title="Last-Modified/If-Modify-Since"></a>Last-Modified/If-Modify-Since</h4><p>浏览器在第一次访问资源时，服务器返回资源的同时，在响应头中添加 Last-Modified字段（绝对时间，GMT格式），其值是这个资源在服务器上的最后修改时间；浏览器再次向服务端请求相同的资源时，请求头中会包含If-Modify-Since，其值是之前响应头Last-Modified的值。服务端收到资源请求后，如果If-Modify-Since的值等于服务器中这个资源的最后修改时间，表示资源未发生变化，则返回304和空的响应体；如果If-Modify-Since的值小于资源最后修改时间，说明资源发生变化，返回200和新资源。</p>
<p>缺点：</p>
<ul>
<li>Last-Modified检查的粒度是秒级，是无法检测到1s内资源的N次变化</li>
<li>有些资源只是文件的修改时间变了，但其内容被未发生改变，结果还是会命中协商缓存</li>
</ul>
<h3 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h3><p>与Last-Modified/If-Modify-Since不同的是，服务器返回资源的响应头中添加ETag字段，其值是当前资源文件的唯一标识符，资源变化，Etag的值会发生变化；浏览器再次向服务端请求相同的资源时，Etag的值放到请求头的If-None-Match中，服务端会根据If-None-Match的值跟服务器中该资源的Etag作对比，若是值相等，表示资源未发生变化，则返回304和空的响应体；如果Etag不一致，说明资源发生变化，返回200和新资源。</p>
<p>ETag/If-None-Match 的优先级高于 ETag/If-None-Match</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>浏览器缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>用javaScript原生的方式实现设计模式</title>
    <url>/2021/05/23/%E7%94%A8javaScript%E5%8E%9F%E7%94%9F%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="用javaScript原生的方式实现设计模式"><a href="#用javaScript原生的方式实现设计模式" class="headerlink" title="用javaScript原生的方式实现设计模式"></a>用javaScript原生的方式实现设计模式</h1><p><strong>应该在JavaScript中使用Class么</strong></p>
<blockquote>
<p>大部分场景下不鼓励使用JavaScript class</p>
</blockquote>
<p>不使用 class 的情况下，JavaScript 开发中还能使用设计模式吗？—— 毕竟这是几十年来许许多多程序员先驱们总结出来的 精髓！</p>
<p>答案是 —— 当然可以！只不过是用 JavaScript 原生的方式（functional way）来实现。</p>
<p><strong>单例模式</strong></p>
<p>单例模式的目标是在整个程序中，某个类有且只有一个实例。</p>
<ol>
<li>方案一：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance;  <span class="comment">// 闭包形成私有变量</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;call createInstance&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> object = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&quot;I am the instance&quot;</span>);  <span class="comment">// 可以替换成更复杂的对象构建过程</span></span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getInstance: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!instance) &#123;  <span class="comment">//  惰性创建实例</span></span><br><span class="line">                instance = createInstance();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(); <span class="comment">// 自执行函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = Singleton.getInstance();</span><br><span class="line"><span class="keyword">const</span> instance2 = Singleton.getInstance();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Same instance? &quot;</span> + (instance1 === instance2));  <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>没有用 class 而是 函数和闭包</p>
</blockquote>
<ol start="2">
<li>方案二：</li>
</ol>
<p>ES6 module 的静态import中有以下规范,在一次程序运行中，一个 module 只会被初始化一次，无论被 import 几次， 拿到的都是同一个module实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singleton.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;initialize singletonInstance module&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> singletonInstance = &#123;</span><br><span class="line">  increase: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter++;</span><br><span class="line">  &#125;,</span><br><span class="line">  getCounter: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> singletonInstance;</span><br></pre></td></tr></table></figure>

<p> 编写几个内容相同的 js 文件，分别命名为 SingletonUser1.js 、SingletonUser2.js 、SingletonUser3.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> singletonInstance <span class="keyword">from</span> <span class="string">&quot;./Singleton.js&quot;</span></span><br><span class="line"></span><br><span class="line">singletonInstance.increase();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写一个测试文件 index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SingletonUser1 <span class="keyword">from</span> <span class="string">&#x27;./SingletonUser1.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> SingletonUser2 <span class="keyword">from</span> <span class="string">&#x27;./SingletonUser2.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> SingletonUser3 <span class="keyword">from</span> <span class="string">&#x27;./SingletonUser3.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> singletonInstance <span class="keyword">from</span> <span class="string">&quot;./Singleton.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;counter value: &quot;</span> + singletonInstance.getCounter());</span><br><span class="line">singletonInstance.increase();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;counter value: &quot;</span> + singletonInstance.getCounter());</span><br></pre></td></tr></table></figure>

<p>编写index.html</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;./index.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>运行会得到以下结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">initialize singletonInstance <span class="built_in">module</span></span><br><span class="line">counter value: <span class="number">3</span></span><br><span class="line">counter value: <span class="number">4</span></span><br></pre></td></tr></table></figure>


<p>结果分析：</p>
<ol>
<li><p>Singleton.mjs 就算被import了4次，也只会初始化一次</p>
</li>
<li><p>每个 SingletonUser 都会调用一次 increase 方法，所以第一次输出的 counter 值是 3；</p>
</li>
<li><p>index.js 又执行了一次 increase 方法，counter 值最后变成了 4 —— 可见它们是调用同一个 singletonInstance 实例</p>
</li>
</ol>
<p><strong>装饰者模式</strong></p>
<blockquote>
<p>装饰者模式用于 动态的给目标添加一些额外的属性或行为 —— 在JavaScript 里，目标既可以是对象，也可以是function，甚至可以是 Promise。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeNormalPicture</span>(<span class="params">landscape</span>) </span>&#123; <span class="comment">// 拍一张普通照片</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;take a picture of the landsacpe - &quot;</span> + landscape);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: landscape</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> picture1 = takeNormalPicture(<span class="string">&quot;The Great Wall&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(picture1, <span class="literal">null</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">meituEnhance</span>(<span class="params">takePicture</span>)</span>&#123;   <span class="comment">// 增强函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">landscape</span>)=&gt;</span> &#123; <span class="comment">// 返回一个装饰者 </span></span><br><span class="line">    <span class="keyword">const</span> res = takePicture(landscape);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;enhance the picture with meitu&quot;</span>); <span class="comment">// 可以美化图片</span></span><br><span class="line">    res.quality = <span class="string">&#x27;high&#x27;</span>; <span class="comment">// 给图片添加额外属性</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强后的相机，即装饰者</span></span><br><span class="line"><span class="keyword">const</span> takeBetterPicture = meituEnhance(takeNormalPicture); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰者的使用 跟原本的函数没有区别</span></span><br><span class="line"><span class="keyword">const</span> picture2 = takeBetterPicture(<span class="string">&quot;The Great Wall&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(picture2, <span class="literal">null</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>输出的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">take a picture <span class="keyword">of</span> the landsacpe - The Great Wall</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;The Great Wall&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">take a picture <span class="keyword">of</span> the landsacpe - The Great Wall</span><br><span class="line">enhance the picture <span class="keyword">with</span> meitu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;The Great Wall&quot;</span>,</span><br><span class="line">    <span class="string">&quot;quality&quot;</span>: <span class="string">&quot;high&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>装饰者模式的精髓在于</p>
<ol>
<li>动态地给目标添加一些额外的属性或行为 —— 装饰者模式可以对原目标（以function为例）的参数、过程、结果进行增强、修改、删除。</li>
<li>同时，调用者无感知 —— 装饰者的API跟原目标的API一模一样。</li>
</ol>
<p><strong>代理模式</strong></p>
<blockquote>
<p>代理模式跟装饰者模式实现上有几分相像，但是目的有些差异 —— 给目标（对象、function）创建一个代理，而代理内部通常有额外的逻辑（与原目标无关的逻辑）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadGifImage</span>(<span class="params">path</span>) </span>&#123;  <span class="comment">// 加载 gif 图片</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;loading GIF image from path : &quot;</span> + path);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    path: path,</span><br><span class="line">    image: <span class="string">&#x27;mock-image&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadOtherImage</span>(<span class="params">path</span>) </span>&#123; <span class="comment">// 加载 其他 图片</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;loading normal image from path : &quot;</span> + path);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    path: path,</span><br><span class="line">    image: <span class="string">&#x27;mock-image&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">imageProxy</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;;  <span class="comment">// 闭包特性</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123; <span class="comment">// 图片加载代理</span></span><br><span class="line">    <span class="keyword">if</span> (path <span class="keyword">in</span> map) &#123;  <span class="comment">// 新增了缓存功能</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;No need to load from fs for : &quot;</span> + path);</span><br><span class="line">      <span class="keyword">return</span> map[path];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据图片的格式，使用不同的方式加载图片</span></span><br><span class="line">    <span class="keyword">const</span> image = path.endsWith(<span class="string">&#x27;gif&#x27;</span>) ? loadGifImage(path) : loadOtherImage(path);</span><br><span class="line">    map[path] = image;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = imageProxy(); <span class="comment">// 代理</span></span><br><span class="line">proxy(<span class="string">&#x27;img1.gif&#x27;</span>);</span><br><span class="line">proxy(<span class="string">&#x27;img2.jpg&#x27;</span>);</span><br><span class="line">proxy(<span class="string">&#x27;img3.png&#x27;</span>);</span><br><span class="line">proxy(<span class="string">&#x27;img1.gif&#x27;</span>);</span><br><span class="line">proxy(<span class="string">&#x27;img2.jpg&#x27;</span>);</span><br><span class="line">proxy(<span class="string">&#x27;img4.gif&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">loading GIF image <span class="keyword">from</span> path : img1.gif   <span class="comment">// -&gt; 加载 GIF</span></span><br><span class="line">loading normal image <span class="keyword">from</span> path : img2.jpg  <span class="comment">// -&gt; 加载普通图片</span></span><br><span class="line">loading normal image <span class="keyword">from</span> path : img3.png</span><br><span class="line">No need to load <span class="keyword">from</span> fs <span class="keyword">for</span> : img1.gif   <span class="comment">// -&gt; 缓存了</span></span><br><span class="line">No need to load <span class="keyword">from</span> fs <span class="keyword">for</span> : img2.jpg   <span class="comment">// -&gt; 缓存了</span></span><br><span class="line">loading GIF image <span class="keyword">from</span> path : img4.gif</span><br></pre></td></tr></table></figure>

<p>实现上，imageProxy也是个高阶函数，同时内部用到了闭包的特性，放置了一个缓存 map。</p>
<p>同 装饰者模式一样，代理的 API 也尽量与原目标保持一致，让外部调用者无感知。</p>
<p>代理模式引入的额外逻辑通常有3类：</p>
<ol>
<li>对外部调用者隐藏真实的执行者（如：上面的调用者可能根本不知道有 loadGifImage 这个函数）</li>
<li>优化执行过程 （如：上面加入了缓存，不必每次都去加载图片）</li>
<li>增加了额外的”内务工作”（house-keeping) ( 如：上面的图片缓存过多时，可能要释放掉一部分；清理过期资源等）</li>
</ol>
<p><strong>适配器模式</strong></p>
<p>适配器模式通常用来适配新、老接口，让它们能和谐工作 —— 这里的接口不必是OOP中的接口，你可以理解为广义的接口 即 暴露给外部调用的 API 协议。</p>
<p>让我们看看鼎鼎大名的JavaScript http 客户端库 axios 的源代码里如何使用 适配器模式的。</p>
<p>axios 即可以在前端开发中使用，也可以在 Node 环境下使用 —— 它是怎么做到的呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adapter/http.js  给 Node 环境使用的适配器</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">httpAdapter</span>(<span class="params">config</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">dispatchHttpRequest</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// adapter/xhr.js  给 浏览器环境使用的适配器</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">xhrAdapter</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">dispatchXhrRequest</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDefaultAdapter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> adapter;  <span class="comment">// 判断环境，选择合适的适配器</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// For browsers use XHR adapter  </span></span><br><span class="line">    adapter = <span class="built_in">require</span>(<span class="string">&#x27;./adapters/xhr&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> process !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// For node use HTTP adapter</span></span><br><span class="line">    adapter = <span class="built_in">require</span>(<span class="string">&#x27;./adapters/http&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// axios.js  直接使用适配器开始工作</span></span><br><span class="line">adapter(config).then(<span class="function"><span class="keyword">function</span> <span class="title">onAdapterResolution</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>适配器的核心在于</p>
<ol>
<li>定义一个统一的接口；</li>
<li>写一层额外的代码调用、封装下层的 API ，让这层代码暴露出定义好的接口。</li>
</ol>
<p>axios 源码中，写了两段代码分别调用且封装了 Node 下的 http.js 和 浏览器下的 XMLHttpRequest，这两段代码就是适配器，它们暴露出来的接口是一样的 —— 接收一个 config 对象，返回一个 Promise</p>
<p><strong>命令模式</strong><br>把命令（请求、操作）封装成对象发送给执行端执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> light = &#123;</span><br><span class="line">  turnOn: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;turn on the light&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  turnOff: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;turn off the light&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SwitchOnCommand = &#123;  <span class="comment">// 开灯指令</span></span><br><span class="line">  name: <span class="string">&#x27;SwitchOnCommand&#x27;</span>,</span><br><span class="line">  execute: light.turnOn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SwitchOffCommand = &#123;  <span class="comment">// 关灯指令</span></span><br><span class="line">  name: <span class="string">&#x27;SwitchOffCommand&#x27;</span>,</span><br><span class="line">  execute: light.turnOff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lightSwitchFactory</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 工厂函数</span></span><br><span class="line">  <span class="keyword">let</span> lastCommand = <span class="literal">null</span>;  <span class="comment">// 存放上一个指令</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> receiveCommand =  <span class="function">(<span class="params">command</span>) =&gt;</span> &#123; <span class="comment">// 接收指令</span></span><br><span class="line">    lastCommand = command;</span><br><span class="line">    command.execute();  <span class="comment">// 执行指令</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    receiveCommand: receiveCommand,</span><br><span class="line">    undo: <span class="function">() =&gt;</span> &#123;  <span class="comment">// 提供撤销功能</span></span><br><span class="line">      <span class="keyword">if</span>(!lastCommand) <span class="keyword">return</span> ;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;undo the last command&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (lastCommand.name === <span class="string">&#x27;SwitchOnCommand&#x27;</span>) &#123;</span><br><span class="line">        receiveCommand(SwitchOffCommand);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        receiveCommand(SwitchOnCommand);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lightSwitch = lightSwitchFactory();</span><br><span class="line"></span><br><span class="line">lightSwitch.receiveCommand(SwitchOnCommand);</span><br><span class="line">lightSwitch.receiveCommand(SwitchOffCommand);</span><br><span class="line">lightSwitch.undo();</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">turn on the light</span><br><span class="line">turn off the light</span><br><span class="line">undo the last command <span class="comment">// 撤销上一次操作，上次是关灯，所以现在开灯</span></span><br><span class="line">turn on the light</span><br></pre></td></tr></table></figure>

<p>命令模式的精髓在于</p>
<ol>
<li>把执行命令从一个动词变成名词 即 封装成对象，方便传递；</li>
<li>可以在命令对象里添加更多属性（如上面代码中的 name ），可以作为标志或其他功能；</li>
<li>命令可以被存储起来，方便实现撤销、重做等功能</li>
</ol>
<p>其实 Redux 的 action 机制也有点像 命令模式，不过 redux 更进一步，把命令的执行函数拆分到了 actionCreator 、reducer 和 middleware 里。</p>
<p><strong>责任链模式</strong></p>
<blockquote>
<p>责任链模式为请求创建一条接收者链，每当有请求发出，这条链上的接收者依次检查是否该由自己处理，如果是就（拦截）处理，否则就继续传递给下一个接收者。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> LOGGER_LEVELS = &#123;</span><br><span class="line">  INFO: <span class="number">0</span>,</span><br><span class="line">  DEBUG: <span class="number">1</span>,</span><br><span class="line">  WARNING: <span class="number">2</span>,</span><br><span class="line">  ERROR: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLogger</span>(<span class="params">level, logFunc</span>) </span>&#123;  <span class="comment">// 工厂函数</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    accept: <span class="function">(<span class="params">paraLevel</span>) =&gt;</span> paraLevel &gt;= level, <span class="comment">// 只有在消息等级不低于 level 时，这个 logger 才会执行</span></span><br><span class="line">    log: logFunc</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> emailLogger = createLogger(LOGGER_LEVELS.ERROR, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;send the log to admin email : &quot;</span> + message);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fileLogger = createLogger(LOGGER_LEVELS.WARNING, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;send the log to file : &quot;</span> + message);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> consoleLogger = createLogger(LOGGER_LEVELS.INFO, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;send the log to console : &quot;</span> + message);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建一个责任链</span></span><br><span class="line"><span class="keyword">const</span> loggers = [emailLogger, fileLogger, consoleLogger];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部调用接口</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">messageObj</span>) </span>&#123;</span><br><span class="line">  loggers.forEach(<span class="function"><span class="params">logger</span> =&gt;</span> &#123; <span class="comment">// 接收者依次过目请求</span></span><br><span class="line">    <span class="keyword">if</span> (logger.accept(messageObj.level)) &#123;  </span><br><span class="line">      logger.log(messageObj.message) <span class="comment">// 这个场景中，请求不会被拦截，而是继续让后面的接收者处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&#123;<span class="attr">level</span>: LOGGER_LEVELS.INFO, <span class="attr">message</span>: <span class="string">&quot;an info message&quot;</span>&#125;)</span><br><span class="line">log(&#123;<span class="attr">level</span>: LOGGER_LEVELS.DEBUG, <span class="attr">message</span>: <span class="string">&quot;a debug message&quot;</span>&#125;)</span><br><span class="line">log(&#123;<span class="attr">level</span>: LOGGER_LEVELS.WARNING, <span class="attr">message</span>: <span class="string">&quot;a warning message&quot;</span>&#125;)</span><br><span class="line">log(&#123;<span class="attr">level</span>: LOGGER_LEVELS.ERROR, <span class="attr">message</span>: <span class="string">&quot;an error message&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">send the log to <span class="built_in">console</span> : an info message  <span class="comment">// info 和 debug 信息只需要在console输出</span></span><br><span class="line">send the log to <span class="built_in">console</span> : a debug message</span><br><span class="line">send the log to file : a warning message  <span class="comment">// warning 消息被 file 和 console 都处理了</span></span><br><span class="line">send the log to <span class="built_in">console</span> : a warning message</span><br><span class="line">send the log to admin email : an error message <span class="comment">// error 消息被所有logger接收处理</span></span><br><span class="line">send the log to file : an error message</span><br><span class="line">send the log to <span class="built_in">console</span> : an error message</span><br></pre></td></tr></table></figure>



<p>责任链模式的精髓——提供了简洁的代码结构，省却了大量的if else （想象一下如果不使用责任链模式实现上面的需求，代码会变成什么样）</p>
<p>注意事项：</p>
<ol>
<li>拦截请求是可选的，即一个接收者处理结束之后是否需要让后续的接收者继续处理；</li>
<li>如果决定拦截请求，就要格外小心责任链的顺序。</li>
</ol>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>用户行为监控（轨迹追踪）</title>
    <url>/2021/09/10/%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E7%9B%91%E6%8E%A7%EF%BC%88%E8%BD%A8%E8%BF%B9%E8%BF%BD%E8%B8%AA%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一名前端，最头疼的问题莫过于用户反馈了线上问题但是却复现不了。有些复现不了的问题跟操作步骤有关，但是用户描述问题常常不够准确，需要通过客服再进行多次沟通。还有一种情况就是用户明明进行了某项操作（比如出价）却硬说自己没有任何点击行为。因此，对用户行为进行监控，对于定位线上问题和减少客诉来说很重要。</p>
<p>如果要监控用户的操作行为，我们采用的是埋点上报的形式，这样做的好处是上报准确，而且依托于我们现有的埋点搜集系统，使用起来也比较方便。缺点也比较明显，那就是对代码的耦合度比较高，如果新增操作或者改变交互，上报的方法也要随之变动，如果操作过程的上报有所遗漏，整个用户行为其实是不完整的。本文尝试采用通用的一种上报方式，可以追踪用户的所有轨迹，希望能够在不侵入业务代码的情况下，对用户轨迹进行上报。</p>
<h2 id="用户行为"><a href="#用户行为" class="headerlink" title="用户行为"></a>用户行为</h2><p>要监控用户行为，不仅仅要监控用户的操作，比如打开页面、点击等，还需要监控这些行为产生的的数据请求以及js报错问题。当然还有更复杂的用户行为，这里我们不做探讨。</p>
<p>我们可以用枚举定义上面的四类用户行为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    jsError: &#123;</span><br><span class="line">        value: <span class="number">0</span>,</span><br><span class="line">        text: <span class="string">&#x27;js报错&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    network: &#123;</span><br><span class="line">        value: <span class="number">1</span>,</span><br><span class="line">        text: <span class="string">&#x27;网络请求&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    navigation: &#123;</span><br><span class="line">        value: <span class="number">2</span>,</span><br><span class="line">        text: <span class="string">&#x27;打开页面&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    clickEvent: &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        text: <span class="string">&#x27;用户点击&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上报数据的格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    base: &#123;</span><br><span class="line">        traceId: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 用户轨迹Id</span></span><br><span class="line">        ua: <span class="string">&#x27;&#x27;</span>, <span class="comment">// ua信息</span></span><br><span class="line">        url: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 页面地址</span></span><br><span class="line">        refer: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 页面refer</span></span><br><span class="line">        ... <span class="comment">// 其他信息</span></span><br><span class="line">    &#125;,</span><br><span class="line">    logs: [&#123;</span><br><span class="line">        type: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 轨迹名称</span></span><br><span class="line">        value: <span class="number">0</span>, <span class="comment">// 轨迹value</span></span><br><span class="line">        data: &#123;&#125; <span class="comment">// 轨迹上报data</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户行为的监控"><a href="#用户行为的监控" class="headerlink" title="用户行为的监控"></a>用户行为的监控</h2><h3 id="打开页面"><a href="#打开页面" class="headerlink" title="打开页面"></a>打开页面</h3><p>对于多页面应用来说，可以通过监听浏览器的 onload 事件来实现。但是在单页面应用中，因为只有在第一次进入页面才会触发 onload 事件，还需要监听路由的变化。单页面应用有两种路由模式：hash 模式和 history 模式，两者的处理方式有所差异：</p>
<ul>
<li>hash 模式：hash 模式是通过改变 url 的 hash 值来实现无页面刷新的，hash 的变化会触发浏览器的 hashchange 事件，因此需要监听 hashchange 事件。</li>
<li>history 模式：history 模式是通过操纵浏览器原生的 history 对象实现的，方法如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.go()</span><br><span class="line">history.forward()</span><br><span class="line">history.back()</span><br><span class="line">history.pushState()</span><br><span class="line">history.replaceState()</span><br></pre></td></tr></table></figure>
<p>history.go、history.forward 和 history.back 3个方法会触发浏览器的 popstate 事件，但是 history.pushState 和 history.replaceState 这两个方法不会。如果要监听 history.pushState 和 history.replaceState，我们需要在 history.pushState 和 history.replaceState 方法中添加自定义事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addHistoryEvent</span>(<span class="params">eventName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (history[eventName]) &#123;</span><br><span class="line">        <span class="keyword">const</span> oFunc = history[eventName]</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res = oFunc.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            <span class="keyword">var</span> event = <span class="keyword">new</span> Event(eventName)</span><br><span class="line">            event.arguments = <span class="built_in">arguments</span></span><br><span class="line">            <span class="built_in">window</span>.dispatchEvent(event)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们给 window 增加监听事件来监控页面的打开：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNavigationListener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    addEvent(<span class="built_in">window</span>, <span class="string">&#x27;load&#x27;</span>, addNavigationLog)</span><br><span class="line">    addEvent(<span class="built_in">window</span>, <span class="string">&#x27;hashchange&#x27;</span>, addNavigationLog)</span><br><span class="line">    addEvent(<span class="built_in">window</span>, <span class="string">&#x27;popstate&#x27;</span>, addNavigationLog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="js报错"><a href="#js报错" class="headerlink" title="js报错"></a>js报错</h3><p>我之前在<a href="https://yolkpie.net/2021/01/28/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">前端异常处理</a>中总结过，如果要捕获全局的异常，需要监听 onerror 和 onunhandledrejection 事件，这里就不再重复了。</p>
<p>如果浏览器在页面加载之前向注入的 js 发生了错误（比如离线应用）是没有办法捕获到的，这时候我们需要重写下 console.error。如果 js（非浏览器注入）加载完成，需要停止 console.error 的错误上报，由 onerror 和 onunhandledrejection 来接管。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.error = handleConsoleError</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> errorMsg = <span class="built_in">arguments</span>[<span class="number">0</span>] &amp;&amp; <span class="built_in">arguments</span>[<span class="number">0</span>].message</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">window</span>.location.href</span><br><span class="line"><span class="keyword">const</span> lineNumber = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> columnNumber = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> errorObj = <span class="built_in">arguments</span>[<span class="number">0</span>] &amp;&amp; <span class="built_in">arguments</span>[<span class="number">0</span>].stack</span><br><span class="line"><span class="keyword">if</span> (!errorObj) errorObj = <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> (jsErrorReported) &#123;</span><br><span class="line">    <span class="comment">// onerror和onunhandledrejection开始处理报错后，停止console.error的上报</span></span><br><span class="line">    handleError(errorMsg, url, lineNumber, columnNumber, errorObj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户点击"><a href="#用户点击" class="headerlink" title="用户点击"></a>用户点击</h3><p>监控用户的点击行为，就是重写下 document.onclick 方法，然后获取元素的文本内容、属性信息等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> attributes = event.target.attributes</span><br><span class="line">    <span class="keyword">const</span> tag = event.target.tagName.toLowerCase()</span><br><span class="line">    <span class="keyword">const</span> attributesObj = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> ignoreTag = [<span class="string">&#x27;html&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> (ignoreTag.includes(tag)) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> attributes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (attributes[key][<span class="string">&#x27;value&#x27;</span>] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">            attributesObj[attributes[key][<span class="string">&#x27;name&#x27;</span>]] = attributes[key][<span class="string">&#x27;value&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> innerText = event.target.innerText.replace(<span class="regexp">/\s*/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    addClickEventLog(&#123;</span><br><span class="line">        attributes: attributesObj,</span><br><span class="line">        innerText</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>对于网络请求的监控可以通过监听 XMLHttpRequest 和 fetch 请求来实现。</p>
<ul>
<li>监听 XMLHttpRequest 请求</li>
</ul>
<p>XMLHttpRequest 请求支持的事件如下：<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/110720/23/16103/238966/613af5d4E2a5e4c02/eab15c215acfe3f9.png" alt="XMLHttpRequest请求支持的事件如下："></p>
<p>我们在 XMLHttpRequest 的事件中增加自定义事件来触发相应的上报操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听XMLHttpRequest事件中增加自定义事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxEventTrigger</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ajaxEvent = <span class="keyword">new</span> CustomEvent(event, &#123;</span><br><span class="line">        detail: <span class="built_in">this</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">window</span>.dispatchEvent(ajaxEvent)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> oldXHR = <span class="built_in">window</span>.XMLHttpRequest</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newXHR</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> realXHR = <span class="keyword">new</span> oldXHR()</span><br><span class="line">    realXHR.addEventListener(<span class="string">&#x27;abort&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="built_in">this</span>, <span class="string">&#x27;ajaxAbort&#x27;</span>); &#125;, <span class="literal">false</span>)</span><br><span class="line">    realXHR.addEventListener(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="built_in">this</span>, <span class="string">&#x27;ajaxError&#x27;</span>); &#125;, <span class="literal">false</span>)</span><br><span class="line">    realXHR.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="built_in">this</span>, <span class="string">&#x27;ajaxLoad&#x27;</span>); &#125;, <span class="literal">false</span>)</span><br><span class="line">    realXHR.addEventListener(<span class="string">&#x27;loadstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="built_in">this</span>, <span class="string">&#x27;ajaxLoadStart&#x27;</span>) &#125;, <span class="literal">false</span>)</span><br><span class="line">    realXHR.addEventListener(<span class="string">&#x27;progress&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="built_in">this</span>, <span class="string">&#x27;ajaxProgress&#x27;</span>); &#125;, <span class="literal">false</span>)</span><br><span class="line">    realXHR.addEventListener(<span class="string">&#x27;timeout&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="built_in">this</span>, <span class="string">&#x27;ajaxTimeout&#x27;</span>); &#125;, <span class="literal">false</span>)</span><br><span class="line">    realXHR.addEventListener(<span class="string">&#x27;loadend&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="built_in">this</span>, <span class="string">&#x27;ajaxLoadEnd&#x27;</span>); &#125;, <span class="literal">false</span>)</span><br><span class="line">    realXHR.addEventListener(<span class="string">&#x27;readystatechange&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="built_in">this</span>, <span class="string">&#x27;ajaxReadyStateChange&#x27;</span>) &#125;, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">return</span> realXHR</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.XMLHttpRequest = newXHR</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听自定义事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;ajaxAbort&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    addNetworkEventLog(event)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;ajaxError&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    addNetworkEventLog(event)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;ajaxLoad&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    addNetworkEventLog(event)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因为 CustomEvent 在 IE 等浏览器中有兼容问题（如下），需要使用 document.createEvent(‘CustomEvent’) 来创建：</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/61807/16/16787/755169/613b1a9eEf9f182e7/d9ae910b4f6ec941.jpg" alt="CustomEvent兼容问题"></p>
<blockquote>
<p>While a window.CustomEvent object exists, it cannot be called as a constructor. Instead of new CustomEvent(…), you must use e = document.createEvent(‘CustomEvent’) and then e.initCustomEvent(…)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">window</span>.CustomEvent === <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomEvent</span> (<span class="params"> event, params </span>) </span>&#123;</span><br><span class="line">    params = params || &#123; <span class="attr">bubbles</span>: <span class="literal">false</span>, <span class="attr">cancelable</span>: <span class="literal">false</span>, <span class="attr">detail</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">    <span class="keyword">const</span> evt = <span class="built_in">document</span>.createEvent( <span class="string">&#x27;CustomEvent&#x27;</span> )</span><br><span class="line">    evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail )</span><br><span class="line">    <span class="keyword">return</span> evt</span><br><span class="line">&#125;</span><br><span class="line">CustomEvent.prototype = <span class="built_in">window</span>.Event.prototype</span><br><span class="line"><span class="built_in">window</span>.CustomEvent = CustomEvent</span><br></pre></td></tr></table></figure>

<ul>
<li>监听fetch请求</li>
</ul>
<p>fetch 没有提供可供监听的事件，因此我们需要在 fetch 返回的 Promise 中进行处理（当然你也可以参考 vue 数据劫持的思路，使用 defineProperty 或者 proxy）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rewriteFetcnEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> oldFetch = <span class="built_in">window</span>.fetch</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">newFetch</span>(<span class="params">url, options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            oldFetch(url, options).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                addFecthEventLog(res)</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                addFecthEventLog(err)</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.fetch = newFetch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>我在页面上模拟了点击和发送请求的操作，最终上报的数据如下：<br><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/62199/4/16976/825298/613b286dE946e3acc/6d52993d9fe167be.jpg" alt="上报数据"></p>
<p>这个demo只是简单梳理了一下监控用户轨迹的基本思路，还存在很多很多的问题，下面举的例子只是这众多问题的一小部分，是在写 demo 的时候想到的：</p>
<ul>
<li>页面的hash值改变时，会同时触发 pushState 和 hashChange 事件，造成事件的重复上报</li>
<li>监控用户点击事件时需要对一些无效的事件进行过滤，过滤规则需要全盘考虑下，另外，表单元素 value 值的获取也需要单独处理</li>
<li>网络请求上报的数据需要按照实际场景进行更细化的处理，XMLHttpRequest 和 fetch 的上报数据格式需要合并</li>
</ul>
<p>总之，这只是一个小小的开始，希望我能坚持完善下去。</p>
]]></content>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端表单校验参考</title>
    <url>/2021/04/27/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近做过不少的移动端表单提交的项目，跳了一些坑，也学习了一些技巧，总结了一下，等以后再做类似项目的时候拿来借鉴。同时也与大家分享。</p>
<h3 id="常见的移动端表单校验问题"><a href="#常见的移动端表单校验问题" class="headerlink" title="常见的移动端表单校验问题"></a>常见的移动端表单校验问题</h3><ul>
<li><ol>
<li>电话格式校验</li>
</ol>
</li>
<li><ol start="2">
<li>邮箱格式校验</li>
</ol>
</li>
<li><ol start="3">
<li>汉字VS字母输入</li>
</ol>
</li>
<li><ol start="4">
<li>value绑定与防抖</li>
</ol>
</li>
<li><ol start="5">
<li>input框折行展示</li>
</ol>
</li>
<li><ol start="6">
<li>数字键盘的唤起</li>
</ol>
</li>
<li><ol start="7">
<li>提交按钮联动校验</li>
</ol>
</li>
<li><ol start="8">
<li>错误提示批量处理</li>
</ol>
</li>
</ul>
<h3 id="电话格式校验"><a href="#电话格式校验" class="headerlink" title="电话格式校验"></a>电话格式校验</h3><ol>
<li><p><strong>手机号码</strong>：网上有很多校验手机的正则，但是随着手机号码格式的增多，严格的校验可能导致在不久的将来，你的代码就需要重新上线，以适应更多的号码区段。如果再考虑到国际长途，可能不仅仅是11位。所以建议只使用纯数字校验，关于位数因需求而异。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^\d&#123;0,11&#125;$/</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>400电话</strong>：只做数字和位数的校验</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[400]\d&#123;0,n&#125;$/</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>座机号码</strong>：做数字和位数的校验</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^\d&#123;4,n&#125;$/</span>;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="邮箱格式校验"><a href="#邮箱格式校验" class="headerlink" title="邮箱格式校验"></a>邮箱格式校验</h3><ol>
<li><p>首来看几个合法邮箱的例子：</p>
<p> 1234@qq.com（纯数字）<br> wang@126.com（纯字母）<br> wang123@126.com（数字、字母混合）<br> wang123@vip.163.com（多级域名）<br> wang_email@outlook.com（含下划线 _）<br> wang.email@jd.com（含英语句号 .）</p>
</li>
<li><p>根据对以上邮箱的观察，可将邮箱分为两部分（“@”左边和右边部分）来进行分析：</p>
<p> 左边部分可以有数字、字母、下划线（_）和英语句号（.），因此可以表示成：[A-Za-z0-9]+([_.][A-Za-z0-9]+)*<br> 右边部分是域名，按照域名的规则，可以有数字、字母、短横线（-）和英语句号（.），另外顶级域名一般为 2 ~ 6 个英文字母（比如“cn”、“com”、“site”、“group”、“online”），故可表示为：([A-Za-z0-9-]+.)+[A-Za-z]{2,6}</p>
<p> 要注意两点：</p>
<p> 考虑到匹配邮箱时字符串的一头一尾不能有其它字符，故要加上开始标志元字符 ^ 和结束标志元字符 $。<br> 英语句号（.）是正则表达式的元字符，因此要进行转义（.）。</p>
</li>
<li><p>用于邮箱验证的函数及测试用例如下：</p>
<p> 考虑可能扩展的邮箱后缀，关于位数可以放开</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[A-Za-z0-9]+([_\.][A-Za-z0-9]+)*@([A-Za-z0-9\-]+\.)+[A-Za-z]&#123;2,n&#125;$/</span>;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="React中-汉字VS字母输入"><a href="#React中-汉字VS字母输入" class="headerlink" title="React中-汉字VS字母输入"></a>React中-汉字VS字母输入</h3><p>Vue中的v-model已经做了对于输入中文的处理，这里我们不多说，感兴趣的同学，可以查看相关文档中。</p>
<p>  在React输入汉字的文本框中，有时候我们会遇到书写‘我们’，直接输入了‘women’;这样的情况，可以考虑使用‘compositionend’<br>  首先了解三个事件</p>
<ul>
<li><p>要开始输入中文<br>compositionstart</p>
</li>
<li><p>插入新字符<br>compositionupdate</p>
</li>
<li><p>输入完成<br>compositionend</p>
<p>这样就可以做到在普通情况下监听 input 事件，而当监听到 compositionstart 事件时，移除对 input 事件的监听或不处理监听到的 input 事件，而监听 compositionend 事件并处理。<br><strong>此处注意的是compositionend是在onChange方法之后触发的，所以需要如下：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isOnComposition = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">setInvoiceTitle = <span class="function">(<span class="params">&#123;target&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = target.value</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if (!isOnComposition) &#123;//解决compositionend不触发问题</span></span><br><span class="line"><span class="comment">      this.setState(&#123;</span></span><br><span class="line"><span class="comment">        invoiceTitle: value </span></span><br><span class="line"><span class="comment">      &#125;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        invoiceTitle: value </span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br><span class="line">handleComposition = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.type === <span class="string">&#x27;compositionend&#x27;</span>) &#123;</span><br><span class="line">        isOnComposition = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isOnComposition = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;detail__item&quot;</span> &gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;detail__lable&quot;</span> &gt;抬头名称&lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;detail__value_box&quot;</span> &gt;</span><br><span class="line">            &lt;input className=<span class="string">&quot;detail__input&quot;</span>  onChange=&#123;<span class="built_in">this</span>.setInvoiceTitle&#125; onCompositionStart=&#123;<span class="built_in">this</span>.handleComposition&#125;</span><br><span class="line">            onCompositionEnd=&#123;<span class="built_in">this</span>.handleComposition&#125; type=<span class="string">&quot;text&quot;</span> placeholder=&#123;<span class="string">&quot;请填写单位名称&quot;</span>&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="value绑定与防抖"><a href="#value绑定与防抖" class="headerlink" title="value绑定与防抖"></a>value绑定与防抖</h3><p>  考虑移动端的校验经常是边输入边校验，我们就有必要做一些性能优化，比如常见的防抖</p>
<ol>
<li><p>减少value绑定；一些情况下，我们是没有必要将input框的value值与我们所需要的值进行绑定的。这样的情况下我们就不要做绑定，可以减少性能消耗。</p>
<p><strong>减少value绑定</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//减少value绑定</span></span><br><span class="line"></span><br><span class="line">setInvoiceTitle = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = e.target.value</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        invoiceTitle: value </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">handleComposition = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.type === <span class="string">&#x27;compositionend&#x27;</span>) &#123;</span><br><span class="line">        isOnComposition = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isOnComposition = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; invoiceTitle &#125; = <span class="built_in">this</span>.state</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;detail__item&quot;</span> &gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;detail__lable&quot;</span> &gt;抬头名称&lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;detail__value_box&quot;</span> &gt;</span><br><span class="line">            &lt;input className=<span class="string">&quot;detail__input&quot;</span>  value=&#123;invoiceTitle&#125; onChange=&#123;<span class="built_in">this</span>.setInvoiceTitle&#125; onCompositionStart=&#123;<span class="built_in">this</span>.handleComposition&#125;</span><br><span class="line">            onCompositionEnd=&#123;<span class="built_in">this</span>.handleComposition&#125; type=<span class="string">&quot;text&quot;</span> placeholder=&#123;<span class="string">&quot;请填写单位名称&quot;</span>&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在一些输入框中做校验，为了节约性能，不做不必要的频繁校验，需要使用防抖。</p>
<p><strong>防抖</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//防抖</span></span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">debounce = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      callback &amp;&amp; callback()</span><br><span class="line">    &#125;, <span class="number">600</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInvoiceTitle = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = e.target.value</span><br><span class="line">    <span class="keyword">let</span> setTitle = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">          invoiceTitle: value </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.debounce(setTitle)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="input框折行展示"><a href="#input框折行展示" class="headerlink" title="input框折行展示"></a>input框折行展示</h3><p>表单常见的输入还有一种情况是折行，如图：</p>
<p><img src= "/img/loading.gif" data-src="1.jpg" alt="示例"><img src= "/img/loading.gif" data-src="4.jpg" alt="示例"><img src= "/img/loading.gif" data-src="5.jpg" alt="示例"></p>
<p>这样的效果，我考虑到的方法有3种：</p>
<ul>
<li><ol>
<li>放一个textarea框，可以支持多行输入和展示；<br><img src= "/img/loading.gif" data-src="2.jpg" alt="示例"></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//HTML</span></span><br><span class="line">&lt;textarea className=&#123;TextareaMore?<span class="string">&#x27;detail__textarea_more&#x27;</span>:<span class="string">&quot;detail__textarea&quot;</span>&#125; onCompositionStart=&#123;<span class="built_in">this</span>.handleComposition&#125; onCompositionEnd=&#123;<span class="built_in">this</span>.handleComposition&#125; onChange=&#123;<span class="built_in">this</span>.setAddressText&#125; placeholder=<span class="string">&quot;请输入详细地址&quot;</span>&gt;&lt;/textarea&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>优点</strong><br>可以设置placeholder属性值；多行展示；多行输入；</p>
<p><strong>缺点</strong><br>高度不能自适应，如果高度写死，输入一行和两行不同情况的时候，文字上下会不居中</p>
<p><strong>解决</strong><br>默认一行的高度，这样可以保证placeholder垂直居中。然后动态判断输入文字高度，动态设置文本框的高度。</p>
</li>
</ul>
<ul>
<li><ol start="2">
<li>放一个input框和一个div，等到失焦的时候显示div,聚焦的时候隐藏div;<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//JS</span></span><br><span class="line">  showInputClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">          showInput: <span class="literal">true</span></span><br><span class="line">      &#125;) </span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.refs.input.focus()</span><br><span class="line">      &#125;, <span class="number">60</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  onInput = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> value = e.target.value</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">          addressText: value</span><br><span class="line">      &#125;) </span><br><span class="line">  &#125;</span><br><span class="line">  onBlur = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">          showInput: <span class="literal">false</span></span><br><span class="line">      &#125;) </span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//HTML</span></span><br><span class="line">&lt;input className=&#123;showInput?<span class="string">&#x27;showDom&#x27;</span>:<span class="string">&quot;hideDom&quot;</span>&#125; ref=<span class="string">&#x27;input&#x27;</span> onInput=&#123;<span class="built_in">this</span>.onInput&#125; onBlur=&#123;<span class="built_in">this</span>.onBlur&#125; type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;请输入详细地址&quot;</span> value=&#123;addressText&#125; /&gt;</span><br><span class="line">&lt;div className=&#123;showInput?<span class="string">&#x27;hideDom&#x27;</span>:<span class="string">&quot;showDom&quot;</span>&#125; onClick=&#123;<span class="built_in">this</span>.showInputClick&#125;&gt;&#123;addressText&#125;&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优点</strong><br>  相对于textarea不需要动态设置高度。</p>
<p><strong>缺点</strong><br>  在失焦和聚焦的时候。动态隐藏和显示input框。安卓和ios有兼容问题。在点击div的时候显示input框并且使其聚焦，聚焦这个动作有的不能实现。</p>
<p><strong>解决</strong><br>  加上延时后，可能会有改善的情况，需测试</p>
</li>
<li><ol start="3">
<li>放一个div给它一个<strong>contentEditable</strong>属性；</li>
</ol>
<p><strong>优点</strong><br>  没有动态设置的属性和操作</p>
<p><strong>缺点</strong><br>  安全性不好；<br>  不能设置placeholder；</p>
<p><strong>解决</strong><br>可以手动放placeholder；毕竟前端黑科技很多。目前我没有使用，因为查找有很多坑，就没敢用，感兴趣的小伙伴可以试试。</p>
</li>
</ul>
<h3 id="数字键盘的唤起"><a href="#数字键盘的唤起" class="headerlink" title="数字键盘的唤起"></a>数字键盘的唤起</h3><p>在部分要求只输入数字的input框中，要求唤起数字键盘；</p>
<p><img src= "/img/loading.gif" data-src="6.jpg" alt="示例"><br><img src= "/img/loading.gif" data-src="7.jpg" alt="示例"></p>
<ul>
<li><ol>
<li>使用 <strong>type=”number”</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input className=<span class="string">&quot;detail__input&quot;</span> type=<span class="string">&quot;number&quot;</span> pattern=<span class="string">&quot;\d*&quot;</span> value=&#123;zip&#125;  onChange=&#123;<span class="built_in">this</span>.setZip&#125; placeholder=<span class="string">&quot;请输入邮政编码&quot;</span>/&gt;</span><br><span class="line">&lt;input className=<span class="string">&quot;detail__input&quot;</span> type=<span class="string">&quot;number&quot;</span> pattern=<span class="string">&quot;[0-9]*&quot;</span> value=&#123;zip&#125; onChange=&#123;<span class="built_in">this</span>.setZip&#125; placeholder=<span class="string">&quot;请输入邮政编码&quot;</span>/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>iOS中，只有[0-9]* 才可以调起九宫格数字键盘，\d 无效</p>
<p>Android 4.4以下(包括X5内核)，两者都调起数字键盘；</p>
<p>Android 4.4.4以上，只认 type 属性，也就是说，如果上面的代码将 type=“number” 改为 type=“text” ，将调起全键盘而不会是九宫格数字键盘。<br><strong>缺点</strong><br>  键盘调用显示有兼容性，即有的有小数点和加减号，有的没有。对于只要求数字的需求，使用**type=”number”**并不友好</p>
</li>
<li><ol start="2">
<li>使用 <strong>type=”tel”</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input className=<span class="string">&quot;detail__input&quot;</span> type=<span class="string">&quot;tel&quot;</span> value=&#123;phone&#125; maxLength=&#123;<span class="number">11</span>&#125; onChange=&#123;<span class="built_in">this</span>.setPhone&#125; placeholder=<span class="string">&quot;请输入收票人手机&quot;</span>/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
可调用（有英文字母的大概）键盘，能获取到输入的数字以及各种符号 ，能用正则表达式限制输入内容！！！一般情况下可用这个</li>
</ol>
</li>
</ul>
<h3 id="提交按钮联动校验"><a href="#提交按钮联动校验" class="headerlink" title="提交按钮联动校验"></a>提交按钮联动校验</h3><p>随着移动端用户体验不断优化，有些场景要求表单按钮的提交状态呈现动态提示。即要求用户每一次动作都和按钮的高亮和置灰联动。<br>这要求每一步操作都有全局的校验。如果处理不好，不仅代码看起来重复冗长，对性能也有较大影响。所以需要注意以下几点：</p>
<ol>
<li>全局的优先级较高的校验，放在前面，如果信息未填写完整的情况下，在输入某个文本框的自身校验时不再进行全局校验。</li>
<li>封装方法，校验统一的check方法，不重复书写校验代码。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">checkoutAllItemTrue () &#123;</span><br><span class="line">  <span class="keyword">if</span>( <span class="built_in">this</span>.valueComp &amp;&amp; <span class="built_in">this</span>.addrFId  &amp;&amp; <span class="built_in">this</span>.addrSId  &amp;&amp; <span class="built_in">this</span>.addrTId &amp;&amp; <span class="built_in">this</span>.valueAddrD)&#123;</span><br><span class="line">    <span class="built_in">this</span>.canotSubmit = <span class="literal">false</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.canotSubmit = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="错误提示批量处理"><a href="#错误提示批量处理" class="headerlink" title="错误提示批量处理"></a>错误提示批量处理</h3><ol>
<li>如果表单提交项交多，有相似的输入结构放在同一个方法处理。</li>
<li>封装一个全局统一的提示方法，通过传入不同的value值，调用统一的提示方法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">checkoutAllItem () &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.valueComp) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$toast(<span class="string">&#x27;请填写机构名称&#x27;</span>, &#123;</span><br><span class="line">          type: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.addrFId != <span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="built_in">this</span>.addrSId != <span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="built_in">this</span>.addrTId != <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$toast(<span class="string">&#x27;请选择机构所在地&#x27;</span>, &#123;</span><br><span class="line">          type: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.valueAddrD) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$toast(<span class="string">&#x27;请填写详细地址&#x27;</span>, &#123;</span><br><span class="line">          type: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.valueName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$toast(<span class="string">&#x27;请填写姓名&#x27;</span>, &#123;</span><br><span class="line">          type: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.valueTel) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$toast(<span class="string">&#x27;请填写电话&#x27;</span>, &#123;</span><br><span class="line">          type: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> codeId = <span class="built_in">this</span>.$refs.codeId.value</span><br><span class="line">      <span class="keyword">if</span> (!codeId) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$toast(<span class="string">&#x27;请填写验证码&#x27;</span>, &#123;</span><br><span class="line">          type: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.valueMail) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$toast(<span class="string">&#x27;请填写邮箱&#x27;</span>, &#123;</span><br><span class="line">          type: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.fileList.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$toast(<span class="string">&#x27;请选择文件&#x27;</span>, &#123;</span><br><span class="line">          type: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>







</li>
</ol>
]]></content>
      <categories>
        <category>表单 校验</category>
      </categories>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义webpack插件</title>
    <url>/2021/03/17/%E8%87%AA%E5%AE%9A%E4%B9%89webpack%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>webpack 自身会提供一些基础插件，比如压缩、生成 html 文件、预加载等。有时，我们需要利用 webpack 提供的不同阶段钩子来做一些定制化功能的插件，以满足我们的业务需求，比如代码检查、打包后的文件处理(添加、删除、更改)。下面介绍如何自定义 webpack 插件。</p>
<h3 id="插件基本结构"><a href="#插件基本结构" class="headerlink" title="插件基本结构"></a>插件基本结构</h3><p>自定义插件大概包含以下几个步骤：</p>
<ul>
<li>webpack 插件其实就是一个构造函数，所以要先定义一个类函数；<br><code>function TestPlugin() &#123;&#125;</code></li>
<li>在构造函数的原型上定义 apply 方法，在安装插件时，apply 方法会被 Webpack compiler 调用。apply 方法可以接收一个 Webpack compiler 对象的引用；<br><code>TestPlugin.prototype.apply = function(compiler) &#123;&#125;</code></li>
<li>通过 compiler 对象，可以插入指定的事件钩子；</li>
<li>在钩子回调中，可以拿到 compilation 对象，使用 compilation 操纵修改 webpack 内部实例数据，其也提供了事件回调钩子；</li>
<li>实现功能后，调用 Webpack 提供的 callback  </li>
</ul>
<p>那 compiler 对象和 compilation 对象是什么呢？</p>
<ul>
<li>compiler 对象，包含了 webpack 的所有配置信息（webpack.config.js），包括 options，loader 和 plugin。该对象在启动 Webpac时被创建</li>
<li>compilation 对象，代表一次资源版本的构建，包含了当前的模块资源、编译生成的资源、变化的文件以及依赖等信息。文件发生变化时，都会创建一个新的 compilation 对象，从而生成一组新的编译资源。compilation 对象也提供了许多事件回调钩子</li>
</ul>
<h4 id="compiler-钩子"><a href="#compiler-钩子" class="headerlink" title="compiler 钩子"></a>compiler 钩子</h4><h5 id="钩子的用法"><a href="#钩子的用法" class="headerlink" title="钩子的用法"></a>钩子的用法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someHook 钩子名称</span></span><br><span class="line"><span class="comment">// webpack 4</span></span><br><span class="line">compiler.hooks.someHook.tap(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// webpack 2/3</span></span><br><span class="line">compiler.plugin(someHook, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="常用钩子介绍"><a href="#常用钩子介绍" class="headerlink" title="常用钩子介绍"></a>常用钩子介绍</h5><ul>
<li><strong>entryOption</strong>：在 webpack 选项中的 entry 被处理过之后调用</li>
<li><strong>afterPlugins</strong>：在初始化内部插件集合完成设置之后调用，回调参数 context 和 entry</li>
<li><strong>compilation</strong>：compilation 创建之后，输出 asset 之前执行。回调参数：compilation</li>
<li><strong>emit</strong>：输出 asset 到 output 目录之前执行。回调参数：compilation</li>
<li><strong>afterEmit</strong>：输出 asset 到 output 目录之后执行。回调参数：compilation</li>
<li><strong>done</strong>：在 compilation 完成时执行。回调参数：stats</li>
</ul>
<p>全部 compiler 钩子用法请见 <a href="https://webpack.docschina.org/api/compiler-hooks/">compiler 钩子</a></p>
<h4 id="compilation-钩子"><a href="#compilation-钩子" class="headerlink" title="compilation 钩子"></a>compilation 钩子</h4><h5 id="钩子的用法-1"><a href="#钩子的用法-1" class="headerlink" title="钩子的用法"></a>钩子的用法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// someHook 钩子名称</span></span><br><span class="line"><span class="comment">// webpack 4</span></span><br><span class="line">compilation.hooks.someHook.tap(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// webpack 2/3</span></span><br><span class="line">compilation.plugin(someHook, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="常用钩子介绍-1"><a href="#常用钩子介绍-1" class="headerlink" title="常用钩子介绍"></a>常用钩子介绍</h5><ul>
<li>buildModule：在模块构建开始之前触发，可以用来修改模块。</li>
<li>rebuildModule：在重新构建一个模块之前触发。</li>
<li>finishModules：所有模块都完成构建并且没有错误时执行。</li>
<li>seal：compilation 对象停止接收新的模块时触发，不再接收任何模块，进入编译封闭阶段</li>
<li>additionalAssets：为 compilation 创建额外 asset，可以加入一些自定义资源</li>
</ul>
<p>全部 compilation 钩子用法请见 <a href="https://webpack.docschina.org/api/compilation-hooks/">compilation 钩子</a></p>
<h3 id="如何写插件"><a href="#如何写插件" class="headerlink" title="如何写插件"></a>如何写插件</h3><p><strong>插件代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyWebpackPlugin &#123;</span><br><span class="line">  constructor(options) &#123;&#125;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    &#x2F;&#x2F; 插入钩子函数，里面加入</span><br><span class="line">    compiler.hooks.emit.tap(&#39;MyWebpackPlugin&#39;, (compilation) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;Hello World!&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; MyWebpackPlugin;</span><br></pre></td></tr></table></figure>
<p><strong>使用插件</strong>  </p>
<p>在 webpack.config.js 中引入插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="comment">// 传入插件实例</span></span><br><span class="line">    <span class="keyword">new</span> MyWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插件示例"><a href="#插件示例" class="headerlink" title="插件示例"></a>插件示例</h3><p>下面介绍的自定义的TestBuildPlugin插件，该插件是代码打包检查工具，通过一些简单的配置，在打包的过程中检查，检查webpack的配置项是否正确，打包后的代码是否符合要求。</p>
<h4 id="TestBuildPlugin-插件代码"><a href="#TestBuildPlugin-插件代码" class="headerlink" title="TestBuildPlugin 插件代码"></a>TestBuildPlugin 插件代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> resolvePath = <span class="function"><span class="params">dir</span> =&gt;</span> path.join(path.resolve(<span class="string">&#x27;./&#x27;</span>), dir)</span><br><span class="line"><span class="keyword">const</span> testBuildConfig = <span class="built_in">require</span>(resolvePath(<span class="string">&#x27;.testBuildConfig.js&#x27;</span>)) || &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBuildPlugin</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">args</span>) &#123;&#125;</span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; testBuild &#125; = process.env || &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (testBuild === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断webpack打包的配置项是否正确</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.testConfigValCorrect(compiler.options, testBuildConfig.options)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;options config err!&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// webpack4的写法</span></span><br><span class="line">      <span class="keyword">if</span> (compiler.hooks) &#123;</span><br><span class="line">        <span class="comment">// 生成资源到output目录之前</span></span><br><span class="line">        compiler.hooks.emit.tapAsync(<span class="string">&#x27;TestBuildPlugin&#x27;</span>, <span class="built_in">this</span>.emitFn.bind(<span class="built_in">this</span>))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 版本适配</span></span><br><span class="line">        compiler.plugin(<span class="string">&#x27;emit&#x27;</span>, <span class="built_in">this</span>.emitFn.bind(<span class="built_in">this</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compiler.hooks) &#123;</span><br><span class="line">        <span class="comment">// 生成资源到output目录之后</span></span><br><span class="line">        compiler.hooks.done.tap(<span class="string">&#x27;TestBuildPlugin&#x27;</span>, <span class="built_in">this</span>.doneFn.bind(<span class="built_in">this</span>))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 版本适配</span></span><br><span class="line">        compiler.plugin(<span class="string">&#x27;done&#x27;</span>, <span class="built_in">this</span>.doneFn.bind(<span class="built_in">this</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// emit 钩子的回调函数</span></span><br><span class="line">  <span class="function"><span class="title">emitFn</span>(<span class="params">compilation, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> assets = compilation.assets || &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> assetsArr = <span class="built_in">Object</span>.keys(assets)</span><br><span class="line">    <span class="keyword">if</span> (assets &amp;&amp; assetsArr &amp;&amp; assetsArr.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; mustHave, mustForbidden &#125; = testBuildConfig.codeRules</span><br><span class="line">      assetsArr.forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> asset = assets[key]</span><br><span class="line">        <span class="keyword">const</span> source = asset.source()</span><br><span class="line">        <span class="keyword">const</span> pathName = key</span><br><span class="line">        <span class="comment">// 判断必须禁止的代码</span></span><br><span class="line">        <span class="keyword">const</span> mustForbiddenRes = <span class="built_in">this</span>.testCodeCorrect(&#123;</span><br><span class="line">          codeRule: mustForbidden,</span><br><span class="line">          type: <span class="number">1</span>,  <span class="comment">// type为1，表示必须禁止的；type为2，表示必须包括的</span></span><br><span class="line">          name: pathName, <span class="comment">// 文件名</span></span><br><span class="line">          source</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> (!mustForbiddenRes.isCorrect) &#123;</span><br><span class="line">          callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;mustForbiddenRes.errItem&#125;</span> must be forbidden\nError detail: <span class="subst">$&#123;mustForbiddenRes.errItem&#125;</span> occurred in <span class="subst">$&#123;pathName&#125;</span> `</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断必须包含的代码</span></span><br><span class="line">        <span class="keyword">const</span> mustHaveRes = <span class="built_in">this</span>.testCodeCorrect(&#123;</span><br><span class="line">          codeRule: mustHave,</span><br><span class="line">          type: <span class="number">2</span>,  <span class="comment">// type为1，表示必须禁止的；type为2，表示必须包括的</span></span><br><span class="line">          name: pathName, <span class="comment">// 文件名</span></span><br><span class="line">          source</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> (!mustHaveRes.isCorrect) &#123;</span><br><span class="line">          callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;mustHaveRes.errItem&#125;</span> must be have\nError detail: err occurred in <span class="subst">$&#123;pathName&#125;</span> `</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`build err!`</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// done 钩子的回调函数</span></span><br><span class="line">  <span class="function"><span class="title">doneFn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test build passed!!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断配置是有一样</span></span><br><span class="line">  testConfigValCorrect (buildVal, configVal) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!configVal) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!buildVal) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> correct = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.getValType(configVal) === <span class="string">&#x27;[object Array]&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.getValType(buildVal) !== <span class="string">&#x27;[object Array]&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      configVal.every(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> correct = <span class="built_in">this</span>.testConfigValCorrect(buildVal[index], configVal[index])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.getValType(configVal) === <span class="string">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.getValType(buildVal) !== <span class="string">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Object</span>.keys(configVal)</span><br><span class="line">        .every(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> correct = <span class="built_in">this</span>.testConfigValCorrect(buildVal[key], configVal[key])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> buildVal === configVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !!correct</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断代码是否正确</span></span><br><span class="line">  testCodeCorrect (&#123;</span><br><span class="line">    codeRule,</span><br><span class="line">    type,  <span class="comment">// type为1，表示必须禁止的；type为2，表示必须包括的</span></span><br><span class="line">    name, <span class="comment">// 文件名</span></span><br><span class="line">    source <span class="comment">// 文件路径</span></span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> errItem = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> result = &#123;</span><br><span class="line">      isCorrect: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (codeRule &amp;&amp; codeRule.length) &#123;</span><br><span class="line">      codeRule.every(<span class="function">(<span class="params">codeRuleItem</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (codeRuleItem) &#123;</span><br><span class="line">          <span class="keyword">let</span> &#123; test, val &#125; = codeRuleItem</span><br><span class="line">          test = test ? <span class="built_in">this</span>.getRegExpTypeVal(test) : <span class="regexp">/\.(js|html)$/</span></span><br><span class="line">          val = val ? <span class="built_in">this</span>.getArrayTypeVal(val) : <span class="literal">null</span></span><br><span class="line">          <span class="keyword">if</span> (test.test(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &amp;&amp; val.length) &#123;</span><br><span class="line">              val.every(<span class="function"><span class="params">valItem</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> itemRegExp = <span class="built_in">this</span>.getRegExpTypeVal(valItem)</span><br><span class="line">                <span class="keyword">if</span> (itemRegExp) &#123;</span><br><span class="line">                  <span class="keyword">if</span> ((itemRegExp.test(source) &amp;&amp; type === <span class="number">1</span>)</span><br><span class="line">                    || (!itemRegExp.test(source) &amp;&amp; type === <span class="number">2</span>)</span><br><span class="line">                  ) &#123;</span><br><span class="line">                    errItem = valItem</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !errItem</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errItem) &#123;</span><br><span class="line">      result = &#123;</span><br><span class="line">        isCorrect: <span class="literal">false</span>,</span><br><span class="line">        errItem</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取类型</span></span><br><span class="line">  getValType (val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!val) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(val)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取RegExp类型的值</span></span><br><span class="line">  getRegExpTypeVal (val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.getValType(val) !== <span class="string">&#x27;[object RegExp]&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取数组类型的值</span></span><br><span class="line">  getArrayTypeVal (val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getValType(val) === <span class="string">&#x27;[object Array]&#x27;</span> ? val : [val]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = TestBuildPlugin</span><br></pre></td></tr></table></figure>
<h4 id="TestBuildPlugin-插件的使用"><a href="#TestBuildPlugin-插件的使用" class="headerlink" title="TestBuildPlugin 插件的使用"></a>TestBuildPlugin 插件的使用</h4><p><strong>安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev test-build-plugin</span><br></pre></td></tr></table></figure>
<p><strong>使用</strong><br>1）在项目的根目录中建立.testBuildConfig.js<br>2）在.testBuildConfig.js配置打包时的检查项</p>
<ul>
<li>options：webpack 打包配置项，用来检查打包的入口和出口等配置正确；</li>
<li>codeRules.mustHave：用来配置必须有的代码，test: 检测的范围；val: 代码；</li>
<li>用来配置必须禁止的代码，test: 检测的范围；val: 代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> resolvePath = <span class="function"><span class="params">dir</span> =&gt;</span> path.join(__dirname, dir)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// webpack 打包配置项</span></span><br><span class="line">  options: &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      app: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: resolvePath(<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">      publicPath: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  codeRules: &#123;</span><br><span class="line">    <span class="comment">// 用来配置必须有的代码，test: 检测的范围；val: 代码</span></span><br><span class="line">    mustHave: [&#123;</span><br><span class="line">      test: <span class="regexp">/index\.html$/</span>,</span><br><span class="line">      val: [<span class="string">&#x27;必须有的代码&#x27;</span>]</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="comment">// 用来配置必须禁止的代码，test: 检测的范围；val: 代码</span></span><br><span class="line">    mustForbidden: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.(js|html)$/</span>,</span><br><span class="line">      val: [<span class="string">&#x27;beta-api.m.jd.com&#x27;</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）项目中引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TestBuildPlugin = <span class="built_in">require</span>(<span class="string">&#x27;test-build-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">config.plugins.push(</span><br><span class="line">  <span class="keyword">new</span> TestBuildPlugin()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>4）在打包指令中添加testBuild=1，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;build:testBuild&quot;: &quot;testBuild&#x3D;1 node build&#x2F;build.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>辅助图形的设计解析</title>
    <url>/2021/06/29/%E8%BE%85%E5%8A%A9%E5%9B%BE%E5%BD%A2%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="什么是辅助图形？"><a href="#什么是辅助图形？" class="headerlink" title="什么是辅助图形？"></a>什么是辅助图形？</h3><p>辅助图形也称为辅助图案，是VI系统中不可或缺的一部分。它可以弥补品牌宣传过程中基本要素的设计运用不足，尤其在当今线上线下多端的传播媒介中既可以丰富整体内容又能强化企业形象。</p>
<p>品牌辅助图形犹如公司的第二张脸，它能强化企业识别系统的诉求力，抓住受众的视线，引起人们的兴趣，能增加设计要素的适应性，使所有的设计要素更加具有设计表现力，更明确地传递企业特征。</p>
<p>辅助图形不是纯装饰的图案，辅助图形的出发点就是要处理好其它要素的组合形式与应用环境的关系，进一步深化品牌传播核心要素的含义。</p>
<p>品牌辅助图形能够更好地配合企业标志，当标志不方便突出展示的时候，由辅助图形加强展示，能起到对比、陪衬企业标志的作用，使标志、标准字体的意义更具完整性，易于识别，同时可增加其它要素在应用中的柔软度与适应性，增加韵律，强化视觉冲击力和美感，最大限度地创造视觉诱导效果，增强审美趣味。</p>
<p>在这个信息迅猛爆炸的年代，每一个企业都意识到辅助图形牵引出的形象力量，它在标志的基础部分与标志的地位几乎是相等的，甚至有些时候，比起logo，简单和抽象的辅助图形可以更快更好地与人建立关系，并让视觉效果充满感染力。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/182490/17/11723/114957/60dadd3dE14dcfe5a/4c0d76675c0acb1c.jpg" alt="配图"></p>
<h3 id="辅助图形的作用"><a href="#辅助图形的作用" class="headerlink" title="辅助图形的作用"></a>辅助图形的作用</h3><ul>
<li><p>可以增强视觉识别系统，创造较强的视觉诱导效果，更能引起用户的关注；</p>
</li>
<li><p>增加设计要素的适应性，使所有的设计要素更加具有设计表现力；当某些情况，logo本身无法很好地去表现，就能通过辅助图形来传递企业特征，深化品牌传播核心要素的含义；</p>
</li>
<li><p>具有较强的适应性、灵活性和视觉冲击力，使画面效果富有感染力，最大限度地创造视觉诱导效果。</p>
</li>
<li><p>提高了品牌系统的视觉美感。辅助图形与品牌色彩系统的组合、变化，产生了次序节奏、增加韵律，强化了视觉冲击力和美感，增强了审美趣味。辅助图形不是纯装饰的图案，而与品牌基视觉要素，尤其是品牌标志有着紧密联系。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/181981/19/11804/130098/60dadd3dE30a03d8d/6973ee0d7fa20add.png" alt="辅助图形示例"></p>
<h3 id="辅助图形在平面中的应用"><a href="#辅助图形在平面中的应用" class="headerlink" title="辅助图形在平面中的应用"></a>辅助图形在平面中的应用</h3><h4 id="（1）直接运用完整的品牌标志logo本身"><a href="#（1）直接运用完整的品牌标志logo本身" class="headerlink" title="（1）直接运用完整的品牌标志logo本身"></a><strong>（1）直接运用完整的品牌标志logo本身</strong></h4><p>这种方法是将品牌图形标志或文字标志直接放大而成为品牌辅助图形，将logo“图案化”，延展了品牌标志应用受限制的情况，进一步强化了标志的视觉识别。以下是贝壳找房的品牌形象设计，将品牌logo融合在不同的节气中，既有意境，又强化了品牌。</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/186400/29/10846/1352569/60dadd3eE7d6e16ce/9499fe7860f23c64.png" alt="品牌案例-贝壳"></p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/179264/32/11730/1448392/60dadd3dE143ec59c/027f0202c8ee4210.png" alt="贝壳找房"></p>
<h4 id="（2）将logo或品牌元素重复排列"><a href="#（2）将logo或品牌元素重复排列" class="headerlink" title="（2）将logo或品牌元素重复排列"></a>（2）<strong>将logo或品牌元素重复排列</strong></h4><p>采用标志或标志的某一个具有特点的元素部分或者全部重复排列组合的方式，使标志图案退化为一种具有装饰意义的“背景”，同时也强化了标志的认知。比如奢侈品牌：LV，GUCCI，FENDI、迪奥等奢侈品牌利用“标志”崇拜心理，将品牌标志图形直接连续反复组合为有节奏和韵律的图案作为产品的外观装饰。</p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/193007/36/10778/769823/60dadd3fE129dcdef/4fd8c4496463ba62.png" alt="奢侈品图案"></p>
<h4 id="（3）提取logo的部分元素"><a href="#（3）提取logo的部分元素" class="headerlink" title="（3）提取logo的部分元素"></a><strong>（3）提取logo的部分元素</strong></h4><p>通过填充颜色或其他视觉手法（例如放大、重复排列、局部视觉等）利用“完形心理”让人联想到完成的品牌标注LOGO。同时截取的部分图形也让人注意到标志的独特和美感。比如京东的微笑符号、天猫的猫头轮廓视觉；</p>
<p>完形心理：指人有一种将他看到、听到、感知到的形象复合成他已知的完整形象心里倾向；</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/183722/2/11754/25030/60dadd3fE40507e4c/e6b22d3bb3c17403.jpg" alt="提取logo部分"></p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/194740/40/10915/52962/60dadd3dE7b859f53/50c97392f7c0f69c.png" alt="猫头"></p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/175824/38/17449/808319/60dadd3fE7a216f12/6b5fcb2f680080ca.png" alt="天猫案例"></p>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/174975/10/17301/796357/60dadd40E8fe218a0/b100d67d1a08f033.png" alt="天猫双十一视觉"></p>
<h4 id="（4）重新设计与现有标志有较强关联的辅助图形"><a href="#（4）重新设计与现有标志有较强关联的辅助图形" class="headerlink" title="（4）重新设计与现有标志有较强关联的辅助图形"></a><strong>（4）重新设计与现有标志有较强关联的辅助图形</strong></h4><p>原有图形标志在变成辅助图案时，美感和生动性会有不足，这时可以额外关联的方式丰富品牌联想，比如在原有标志外形上增加几何图形做辅助图案；</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/181367/37/11808/588639/60dadd40Eac80e6db/0b44ed151a700150.png" alt="VI"></p>
<h4 id="（5）重新设计与标志不相关的辅助图形"><a href="#（5）重新设计与标志不相关的辅助图形" class="headerlink" title="（5）重新设计与标志不相关的辅助图形"></a><strong>（5）重新设计与标志不相关的辅助图形</strong></h4><p>此种情形多数适合仅有文字标志的品牌。辅助图形在一定程度上发挥了图形标志的识别作用，但又比图形标志在运用上拥有更多灵活性。</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/184112/15/11159/160187/60dadd3fEb86119a8/d9017602912baf12.jpg" alt="随手记"></p>
<h3 id="辅助图形或标志在UI中的应用"><a href="#辅助图形或标志在UI中的应用" class="headerlink" title="辅助图形或标志在UI中的应用"></a>辅助图形或标志在UI中的应用</h3><p>越来越多的设计师也将品牌的辅助图形或者logo运用到UI界面中，既可以强化品牌，又可以丰富页面视觉；</p>
<h4 id="（1）辅助图形应用在底部导航上；"><a href="#（1）辅助图形应用在底部导航上；" class="headerlink" title="（1）辅助图形应用在底部导航上；"></a>（1）辅助图形应用在底部导航上；</h4><p>现在APP越来越多，用户每天使用无数个app，目前APP设计同质化十分严重，为了能让用户快速识别自家的产品，各家设计师都在设计上添加一些小心思，比如底部导航，如果都用默认的“小房子”做首页图标，用户可能没法儿一眼知道打开的是哪个app，所以大部分APP在底部导航的设计上，开始融合自己品牌的辅助元素或logo；</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/177141/3/11899/932795/60dadd3eE49f1f328/5433f2b3c4fefc49.png" alt="品牌在UI 中的应用"></p>
<h4 id="（2）辅助图形应用在卡片上，作为叠加纹理使用；"><a href="#（2）辅助图形应用在卡片上，作为叠加纹理使用；" class="headerlink" title="（2）辅助图形应用在卡片上，作为叠加纹理使用；"></a>（2）辅助图形应用在卡片上，作为叠加纹理使用；</h4><p>京东1号店的个人中心，用户信息卡片上，叠加1号店的logo图标；强化品牌logo，丰富页面视觉；</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/173877/26/17298/97472/60dadd3cEca8991c5/e5d8e591c7824666.jpg" alt="1号店"></p>
<h4 id="（3）辅助图形在弹窗上的应用；"><a href="#（3）辅助图形在弹窗上的应用；" class="headerlink" title="（3）辅助图形在弹窗上的应用；"></a>（3）辅助图形在弹窗上的应用；</h4><p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/196520/4/10841/256670/60dadd3dE58e644da/d81e7868ec1e912c.png" alt="弹窗配图"></p>
<h3 id="辅助图形设计的注意事项："><a href="#辅助图形设计的注意事项：" class="headerlink" title="辅助图形设计的注意事项："></a><strong>辅助图形设计的注意事项：</strong></h3><p>辅助图形是为了配合基本要素在各种媒体上广泛应用而设计的，在内涵上要体现企业精神，起到衬托和强化企业形象的作用。通过象征图案的丰富造型来补充标志符号建立的企业形象，使其意义更完整、更易识别、更具表现力。在具体设计辅助图形时，从品牌特性和实际应用的适合性角度出发，需注意以下事项：</p>
<ol>
<li><p>无论是提取标志中某一核心元素的构成样式，还是重新提炼、变化几何造型为辅助视觉图形，辅助图形的意义和作为符号的独立性都不能超过标志。</p>
</li>
<li><p>辅助图形的设计不应该只是一种纯粹的装饰符号而应当具有一定的意义内涵，以丰富整个基本设计要素的文化底蕴与美学价值。</p>
</li>
<li><p>辅助图形的设计需要从适用的角度出发，考虑实际使用情况中出现的问题。</p>
</li>
<li><p>不是所有的企业形象识别系统都能开发出理想的辅助图形。有的标志、标准字体本身已具备了画面的效果，则象征图案就失去了积极的意义，在这种情况下使用标准色丰富视觉形象更理想。</p>
</li>
<li><p>辅助图形是为了适应各种宣传媒体的需要而设计的，但是应用设计项目种类繁多，形式千差万别，画面大小变化无常。这就需要象征图案的造型设计是一个富有弹性的符号，能随着媒介物的不同或者版面面积的大小变化作适度的调整和变化，而不是一成不变的定型图案，要灵活运用。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>色彩</tag>
      </tags>
  </entry>
  <entry>
    <title>通过发布订阅模式实现组件间的通信</title>
    <url>/2020/11/26/%E9%80%9A%E8%BF%87%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>各种技术框架，比如 vue、react 和小程序，实现父子组件和兄弟组件通信的方案有很多，大多方案都强依赖于框架本身。这里介绍一种通过发布和订阅的方式来实现组件通信的方案，纯 JavaScript 实现，可以适用于各种框架。</p>
<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>发布订阅模式包含三部分内容，发布者、订阅者和数据处理中心。订阅者把自己想监听的事件和回调函数信息写入到数据处理中心去；当事件触发时，发布者发布该事件到数据处理中心，由数据处理中心统一执行订阅者写入到数据处理中心对应事件的回调函数。</p>
<p>比如A组件需要向B组件传递数据，通过发布订阅模式来实现的思路是：  </p>
<ul>
<li>在B组件里添加（on，事件监听）一个事件订阅，监听的事件名称和回调函数；  </li>
<li>当A组件需要给B组件传递数据时，可发布（emit）对应的事件名称并携带相应的数据,数据处理中心根据相应的事件执行回调函数并传递数据给B组件  </li>
</ul>
<h3 id="定义数据处理中心"><a href="#定义数据处理中心" class="headerlink" title="定义数据处理中心"></a>定义数据处理中心</h3><p>用来存储事件和回调函数信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 数据处理中心，用来存储事件和回调函数信息</span></span><br><span class="line">        <span class="built_in">this</span>.handlers = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现订阅功能"><a href="#实现订阅功能" class="headerlink" title="实现订阅功能"></a>实现订阅功能</h3><p>需要传入两个参数，订阅的事件名称和事件触发时的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅</span></span><br><span class="line"><span class="function"><span class="title">on</span>(<span class="params">eventName, fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123; <span class="built_in">console</span>.error(<span class="string">&#x27;fn must be a function&#x27;</span>) &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.handlers[eventName]) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handlers[eventName] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.handlers[eventName].push(fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现发布功能"><a href="#实现发布功能" class="headerlink" title="实现发布功能"></a>实现发布功能</h3><p>遍历数据处理中心的数据，找到并执行对应事件名称的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布</span></span><br><span class="line"><span class="function"><span class="title">emit</span>(<span class="params">eventName</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fns = <span class="built_in">this</span>.handlers[eventName]</span><br><span class="line">    <span class="keyword">if</span> (fns &amp;&amp; fns.length) &#123;</span><br><span class="line">        <span class="comment">// arguments，携带一些数据信息；将arguments函数参数列表（类数组对象）转为数组</span></span><br><span class="line">        <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        args.shift() <span class="comment">// 参数去掉事件名称</span></span><br><span class="line">        fns.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 给回调方法传参</span></span><br><span class="line">            fn.apply(<span class="literal">null</span>, args)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><p>删除数据处理中心数组中对应事件的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注销订阅</span></span><br><span class="line"><span class="function"><span class="title">off</span>(<span class="params">eventName, fn</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 若是没有传参，注销所有的订阅</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handlers = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> fns = <span class="built_in">this</span>.handlers[eventName]</span><br><span class="line">    <span class="keyword">if</span> (!fns) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 若是只传eventName，不传fn，删除对应事件名称下的所有回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">this</span>.handlers[eventName]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fns &amp;&amp; fns.includes(fn))&#123;</span><br><span class="line">        fns.splice(fns.indexOf(fn), <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 数据处理中心，用来存储事件和回调函数信息</span></span><br><span class="line">        <span class="built_in">this</span>.handlers = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 订阅</span></span><br><span class="line">    <span class="function"><span class="title">on</span>(<span class="params">eventName, fn</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123; <span class="built_in">console</span>.error(<span class="string">&#x27;fn must be a function&#x27;</span>) &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.handlers[eventName]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handlers[eventName] = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.handlers[eventName].push(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发布</span></span><br><span class="line">    <span class="function"><span class="title">emit</span>(<span class="params">eventName</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fns = <span class="built_in">this</span>.handlers[eventName]</span><br><span class="line">        <span class="keyword">if</span> (fns &amp;&amp; fns.length) &#123;</span><br><span class="line">            <span class="comment">// arguments，携带一些数据信息；将arguments函数参数列表（类数组对象）转为数组</span></span><br><span class="line">            <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">            args.shift() <span class="comment">// 参数去掉事件名称</span></span><br><span class="line">            fns.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 给回调方法传参</span></span><br><span class="line">                fn.apply(<span class="literal">null</span>, args)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注销订阅</span></span><br><span class="line">    <span class="function"><span class="title">off</span>(<span class="params">eventName, fn</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 若是没有传参，注销所有的订阅</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handlers = &#123;&#125;;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> fns = <span class="built_in">this</span>.handlers[eventName]</span><br><span class="line">        <span class="keyword">if</span> (!fns) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 若是只传eventName，不传fn，删除对应事件名称下的所有回调函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">delete</span> <span class="built_in">this</span>.handlers[eventName]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fns &amp;&amp; fns.includes(fn))&#123;</span><br><span class="line">            fns.splice(fns.indexOf(fn), <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Emitter()</span><br></pre></td></tr></table></figure>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>A组件需要向B组件传递数据</p>
<ul>
<li>B组件<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// B组件</span></span><br><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&#x27;emitter&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      pageIndex: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加&#x27;getAdata&#x27;事件订阅</span></span><br><span class="line">    emitter.on(<span class="string">&#x27;getAData&#x27;</span> + <span class="built_in">this</span>.pageIndex, <span class="built_in">this</span>.getAData.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 路由页面销毁</span></span><br><span class="line">  <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    emitter.on(<span class="string">&#x27;off&#x27;</span> + <span class="built_in">this</span>.pageIndex)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">getAData</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data.info, <span class="string">&#x27;获取到A组件传给B组件的数据&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>A组件<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A组件</span></span><br><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&#x27;emitter&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      pageIndex: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 发布&#x27;getAdata&#x27;事件并携带数据</span></span><br><span class="line">      emitter.eimit(<span class="string">&#x27;getAData&#x27;</span> + <span class="built_in">this</span>.pageIndex, &#123;</span><br><span class="line">        info: <span class="string">&#x27;A组件发送给B组件的数据&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>组件</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest单元测试（上）</title>
    <url>/2020/06/19/Jest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id="为什么要进行单元测试"><a href="#为什么要进行单元测试" class="headerlink" title="为什么要进行单元测试"></a>为什么要进行单元测试</h2><p>测试是开发工作的一个重要环节，但是往往由于编写和维护测试代码的成本问题，编写测试代码这个环节往往是被忽略的。首先说说前端单元测试为什么是重要的。  </p>
<p>仔细想一下，在我们的工作中是否经常遇到过下面的问题：</p>
<ul>
<li>修改某个模块的功能，引起了其他模块的问题；</li>
<li>代码难以维护，新增需求时难以评估在整个项目的影响范围；</li>
<li>多人开发的代码难以维护，往往是新增加一份代码来替代原有功能；</li>
<li>由于测试资源和测试对项目熟悉程度的问题，代码无法重构；</li>
<li>代码质量差，每次更新都像在打补丁；</li>
<li>项目需要频繁更改上线，但因为某些模块的复杂扭曲的逻辑，实在快不起来；</li>
<li>等等等等。。。</li>
</ul>
<p>如果你对这些问题感同身受，那么就有必要考虑是不是要使用单元测试了。增加自动化测试后，可以达到下面的目的：</p>
<ol>
<li>为核心功能编写测试后，可以保障项目的可靠性；</li>
<li>强迫开发者编写更容易被测试的代码，提高代码质量；</li>
<li>编写的测试有文档的作用，方便维护。</li>
</ol>
<p>总的来说，如果你想保证代码质量，那么你需要写单元测试；如果你想随时整理重构代码，那么你需要写单元测试；如果你想有自动化的测试套件来帮你快速验证提交的完整性，那么你需要写单元测试。当然，如果你的项目不需要频繁上线，一旦变更可能就是要改版了，那可以抛开编写测试代码的环节，毕竟这个投入产出是不平衡的。</p>
<h2 id="为什么选择Jest"><a href="#为什么选择Jest" class="headerlink" title="为什么选择Jest"></a>为什么选择Jest</h2><ol>
<li>Jest 是 Facebook 出品的一个测试框架，相对其他测试框架，其一大特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用；</li>
<li>Jest 可以利用其特有的快照测试功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试；</li>
<li>Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度；</li>
<li>React 内置了Jest，Vue CLI 也拥有开箱即用的通过 Jest 进行单元测试的内置选项</li>
</ol>
<h2 id="Jest用法"><a href="#Jest用法" class="headerlink" title="Jest用法"></a>Jest用法</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install jest</span><br><span class="line">or</span><br><span class="line">yarn add jest</span><br></pre></td></tr></table></figure>

<h3 id="创建一个-Jest-测试的demo"><a href="#创建一个-Jest-测试的demo" class="headerlink" title="创建一个 Jest 测试的demo"></a>创建一个 Jest 测试的demo</h3><ol>
<li>创建 math.js 文件，添加 math 方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        sum</span><br><span class="line">    &#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. 创建一个 math.test.js 文件，来测试 math.js 中定义的函数 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> js</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        sum</span><br><span class="line">    &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./math.js&#x27;</span>)</span><br><span class="line">    describe(<span class="string">&#x27;Test Math Module&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        test(<span class="string">&#x27;should return sum value when one plus another&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> one = <span class="number">1</span></span><br><span class="line">            <span class="keyword">const</span> another = <span class="number">2</span></span><br><span class="line">            <span class="keyword">const</span> result = sum(one, another)</span><br><span class="line">            expect(result).toBe(<span class="number">3</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 package.json 添加 scripts 命令 “test”: “jest”, 执行 npm run test 或者 yarn test， Jest 会自动搜索 <strong>tests</strong> 文件夹下的文件、以 .test.js 或者 .spec.js 结尾的文件，运行后效果如下:</li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/121993/40/3077/234476/5eccef57E5269112c/9b1dae76a08f6027.jpg" alt="ccccc"></p>
<p>是不是看起来很简单，下面我们就来看看用 Jest 写测试代码的套路吧。 </p>
<h3 id="Given-When-Then-的套路"><a href="#Given-When-Then-的套路" class="headerlink" title="Given/When/Then 的套路"></a>Given/When/Then 的套路</h3><p>首先我们看到的是一个由 test 包裹的测试主体最小单元，采用了 Given When Then 的经典格式，我们常常称之为测试三部曲，也可以解释为 3A 即：</p>
<table>
<thead>
<tr>
<th>GWT</th>
<th>3A</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Given</td>
<td>Arrange</td>
<td>准备测试条件，如要测试的数据或者要渲染的组件</td>
</tr>
<tr>
<td>When</td>
<td>Act</td>
<td>采取行动，一般来说就是调用相应的模块执行对应的函数或方法</td>
</tr>
<tr>
<td>Then</td>
<td>Assert</td>
<td>断言，这时需要借助的就是 Matchers 的能力，Jest 还可以扩展自己的 Matcher</td>
</tr>
</tbody></table>
<p>在 expect 后面的 toBe称之为 Matcher，是断言时的判断语句以验证正确性。插入下断言的概念：</p>
<blockquote>
<p>在程序设计中，断言（assertion）是一种放在程序中的一阶逻辑（如一个结果为真或是假的逻辑判断式），目的是为了标示与验证程序开发者预期的结果－当程序运行到断言的位置时，对应的断言应该为真。若断言不为真时，程序会中止运行，并给出错误消息.</p>
</blockquote>
<p>我们刚才创建的 demo 用 Given/When/Then 套路区分的话是这个样子的，当然实际编写测试用例的时候情况要复杂的多。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    sum</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./math.js&#x27;</span>)</span><br><span class="line">describe(<span class="string">&#x27;Test Math Module&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    test(<span class="string">&#x27;should return sum value when one plus another&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// Given</span></span><br><span class="line">        <span class="keyword">const</span> one = <span class="number">1</span></span><br><span class="line">        <span class="keyword">const</span> another = <span class="number">2</span></span><br><span class="line">        <span class="comment">// When</span></span><br><span class="line">        <span class="keyword">const</span> result = sum(one, another)</span><br><span class="line">        <span class="comment">// Then</span></span><br><span class="line">        expect(result).toBe(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Matcher（匹配器）"><a href="#Matcher（匹配器）" class="headerlink" title="Matcher（匹配器）"></a>Matcher（匹配器）</h3><ol>
<li>通用匹配</li>
</ol>
<ul>
<li>toBe 精确匹配</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;two plus two is four&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(<span class="number">2</span> + <span class="number">2</span>).toBe(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>toEqual 会递归检查对象或数组的每一个字段</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;object assignment&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">        one: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    data[<span class="string">&#x27;two&#x27;</span>] = <span class="number">2</span></span><br><span class="line">    expect(data).toEqual(&#123;</span><br><span class="line">        one: <span class="number">1</span>,</span><br><span class="line">        two: <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>真假值</li>
</ol>
<ul>
<li>toBeNull 仅匹配 null</li>
<li>toBeUndefined 仅匹配 undefined</li>
<li>toBeDefined 与 toBeUndefined 相对</li>
<li>toBeTruthy 匹配真值</li>
<li>toBeFalsy 匹配假值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;null&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="literal">null</span></span><br><span class="line">    expect(n).toBeNull()</span><br><span class="line">    expect(n).toBeDefined()</span><br><span class="line">    expect(n).not.toBeUndefined()</span><br><span class="line">    expect(n).not.toBeTruthy()</span><br><span class="line">    expect(n).toBeFalsy()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;zero&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> z = <span class="number">0</span></span><br><span class="line">    expect(z).not.toBeNull()</span><br><span class="line">    expect(z).toBeDefined()</span><br><span class="line">    expect(z).not.toBeUndefined()</span><br><span class="line">    expect(z).not.toBeTruthy()</span><br><span class="line">    expect(z).toBeFalsy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>数字</li>
</ol>
<ul>
<li>toBeGreaterThan 大于</li>
<li>toBeGreaterThanOrEqual 大于等于</li>
<li>toBeLessThan 小于</li>
<li>toBeLessThanOrEqual 小于等于</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;two plus two&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">    expect(value).toBeGreaterThan(<span class="number">3</span>)</span><br><span class="line">    expect(value).toBeGreaterThanOrEqual(<span class="number">3.5</span>)</span><br><span class="line">    expect(value).toBeLessThan(<span class="number">5</span>)</span><br><span class="line">    expect(value).toBeLessThanOrEqual(<span class="number">4.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toBe 和 toEqual 在数字类型上作用等同</span></span><br><span class="line">    expect(value).toBe(<span class="number">4</span>)</span><br><span class="line">    expect(value).toEqual(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>toBeCloseTo 对于浮点数的计算  </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;adding floating point numbers&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line">    <span class="comment">// expect(value).toBe(0.3) 因为舍入问题的存在，这种判断不奏效</span></span><br><span class="line">    expect(value).toBeCloseTo(<span class="number">0.3</span>)  <span class="comment">// 这种判断有用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>字符串</li>
</ol>
<ul>
<li>字符串数据类型可使用正则表达式进行匹配判断</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;there is no I in team&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(<span class="string">&#x27;team&#x27;</span>).not.toMatch(<span class="regexp">/I/</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;but there is a &quot;stop&quot; in Christoph&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(<span class="string">&#x27;Christoph&#x27;</span>).toMatch(<span class="regexp">/stop/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>数组</li>
</ol>
<ul>
<li>toContain 判断数组中是否存在某个特定的元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shoppingList = [<span class="string">&#x27;diapers&#x27;</span>, <span class="string">&#x27;beer&#x27;</span>]</span><br><span class="line">test(<span class="string">&#x27;the shopping list has beer on it&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(shoppingList).toContain(<span class="string">&#x27;beer&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>异常</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileAndroidCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConfigError(<span class="string">&#x27;you are using the wrong JDK&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;compiling android goes as expected&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(compileAndroidCode).toThrow()</span><br><span class="line">    expect(compileAndroidCode).toThrow(ConfigError)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样可以使用明确的错误消息或正则表达式</span></span><br><span class="line">    expect(compileAndroidCode).toThrow(<span class="string">&#x27;you are using the wrong JDK&#x27;</span>)</span><br><span class="line">    expect(compileAndroidCode).toThrow(<span class="regexp">/JDK/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="处理异步"><a href="#处理异步" class="headerlink" title="处理异步"></a>处理异步</h3><p>在 Javascript 中，异步操作是很常见的。处理异步时，最重要的一点是告知Jest 当前它测试的代码是否已完成，然后它可以转移到另一个测试。</p>
<p>例如，假设有一个 fetchData(callback) 函数，获取一些数据并在完成时调用 callback(data)。 你期望返回的数据是一个字符串 ‘peanut butter’。有以下几种方式可以实现：</p>
<ol>
<li>回调 callback</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        callback(<span class="string">&#x27;not peanut butter&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">10000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;Test fetchData Module&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    test(<span class="string">&#x27;the data is peanut butter&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            expect(data).toBe(<span class="string">&#x27;peanut butter&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fetchData(callback)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>看起来很对是吧，把expect写在callbak里了，来看看执行结果：<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/121723/34/3097/161064/5ecd1d84E8f58702e/5af19e5501423491.jpg" alt="callback"></p>
<p>fetchData 返回的是 not peanut butter， 明显是错误的，之所以可以通过测试，是因为默认情况下，Jest 测试一旦执行到末尾就会完成。fetchData 执行结束时，此测试就在没有调用回调函数前结束。</p>
<p>正确的回调应该使用单个参数调用 done，而不是将测试放在一个空参数的函数，Jest会等done回调函数执行结束后，结束测试， 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;the data is peanut butter&#x27;</span>, <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            expect(data).toBe(<span class="string">&#x27;peanut butter&#x27;</span>)</span><br><span class="line">            done()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            done(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fetchData(callback)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Promises  </li>
</ol>
<p>如果 fetchData 使用 Promise，可以使用 then（）/catch（） 或者 resolves / rejects。一定不要忘记把 promise 作为返回值,如果你忘了 return 语句的话，在 fetchData 返回的这个 promise 被 resolve、then() 有机会执行之前，测试就已经被视为已经完成了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">&#x27;not peanut butter&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">describe(<span class="string">&#x27;Test fetchData Module&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    test(<span class="string">&#x27;the data is peanut butter&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            expect(data).toBe(<span class="string">&#x27;peanut butter&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    test(<span class="string">&#x27;the data is peanut butter&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expect(fetchData()).resolves.toBe(<span class="string">&#x27;peanut butter&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Async/Await</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;the data is peanut butter&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> fetchData()</span><br><span class="line">    expect(data).toBe(<span class="string">&#x27;peanut butter&#x27;</span>)</span><br><span class="line">    <span class="comment">// await expect(fetchData()).resolves.toBe(&#x27;peanut butter&#x27;)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>补充： 如果使用catch 或者 rejects 时，需要添加 expect.assertions 来验证一定数量的断言被调用,否则不会让测试失败。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;not peanut butter&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;the data is peanut butter&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// expect.assertions(1)</span></span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        expect(data).toBe(<span class="string">&#x27;peanut butter11&#x27;</span>)</span><br><span class="line">    &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行上述代码是不会报错的，但我们期望reject的时候可以报错提醒我们，在指定了断言的次数expect.assertions(1)之后，如果没有出现断言的时候，就会报错，如下图<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/115148/20/8291/305438/5ecd2be6E97a0c53e/944a215811e4e31a.jpg" alt="expect.assertions"></p>
<p>额外的expect.assertions(number) 其实是验证在测试期间所调用的断言数量，这在测试多层异步代码时很有用，以确保实际调用回调中的断言次数。</p>
<h3 id="Mock-Functions"><a href="#Mock-Functions" class="headerlink" title="Mock Functions"></a>Mock Functions</h3><p>在项目里，往往一个模块会调用外部一个或者多个模块的方法。比如你要测试一个 Order 模块 的 price() 方法，而 price() 方法需要在 Product 和 Customer 模块中调用一些函数。如果你希望单元测试所测试的 Order 模块是独立的，那么你就不想直接使用真正的 Product 或 Customer，因为 Customer 的错误会直接导致 Order 的单元测试失败。这种情况下，你就需要使用一个替身作为依赖的对象。在单元测试中，我们可能并不需要 Product 或者 Customer 内部的执行方法，只想知道它是否被正确调用或者返回指定值即可。</p>
<p>Mock函数提供的以下三种特性，在我们写测试代码时十分有用：</p>
<ul>
<li>捕获函数调用情况</li>
<li>设置函数返回值</li>
<li>改变函数的内部实现</li>
</ul>
<ol>
<li>jest.fn()</li>
</ol>
<p>jest.fn() 是创建 Mock 函数最简单的方式，如果没有定义函数内部的实现，jest.fn()会返回undefined作为返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;test jest.fn()&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> mockFn = jest.fn()</span><br><span class="line">    <span class="keyword">let</span> result = mockFn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言mockFn的执行后返回undefined</span></span><br><span class="line">    expect(result).toBeUndefined()</span><br><span class="line">    <span class="comment">// 断言mockFn被调用</span></span><br><span class="line">    expect(mockFn).toBeCalled()</span><br><span class="line">    <span class="comment">// 断言mockFn被调用了一次</span></span><br><span class="line">    expect(mockFn).toBeCalledTimes(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 断言mockFn传入的参数为1, 2, 3</span></span><br><span class="line">    expect(mockFn).toHaveBeenCalledWith(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>jest.fn()所创建的 Mock 函数还可以设置返回值，定义内部实现或返回Promise对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">&#x27;test jest.fn() return dafault value&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> mockFn = jest.fn().mockReturnValue(<span class="string">&#x27;default&#x27;</span>)</span><br><span class="line">    <span class="comment">// 断言mockFn执行后返回值为default</span></span><br><span class="line">    expect(mockFn()).toBe(<span class="string">&#x27;default&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;test jest.fn() inner function&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> mockFn = jest.fn(<span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 断言mockFn执行后返回100</span></span><br><span class="line">    expect(mockFn(<span class="number">10</span>, <span class="number">10</span>)).toBe(<span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;test jest.fn() return promise&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> mockFn = jest.fn().mockResolvedValue(<span class="string">&#x27;default&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> mockFn()</span><br><span class="line">    <span class="comment">// 断言mockFn通过await关键字执行后返回值为default</span></span><br><span class="line">    expect(result).toBe(<span class="string">&#x27;default&#x27;</span>)</span><br><span class="line">    <span class="comment">// 断言mockFn调用后返回的是Promise对象</span></span><br><span class="line">    expect(<span class="built_in">Object</span>.prototype.toString.call(mockFn())).toBe(<span class="string">&#x27;[object Promise]&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>jest.mock()  </li>
</ol>
<p>如果我们要测试的模块调用的其他模块不需要实际的请求，这时候我们需要使用 jest.mock() 方法去 mock 整个模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">() =&gt;</span> <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>)</span><br><span class="line">jest.mock(<span class="string">&#x27;./foo&#x27;</span>)</span><br><span class="line">foo.mockImplementation(<span class="function">() =&gt;</span> <span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;Test Mock Foo Module&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    test(<span class="string">&#x27;should return 42&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        expect(foo()).toBe(<span class="number">42</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们可以看到 jest.mock() 方法中的第二个参数是一个函数，那么我们就可以完全接管整个 foo 模块，被 Mock 之后我们的测试就可以使用 Mock 所返回的数据或方法，从而保证模块所返回的内容是我们所期望的。但这时需要注意的是，该模板的所有功能都已经被 Mock 掉，而不会再从原模块当中返回，所以我们就需要重新实现该模块中的所有功能。</p>
<ol start="3">
<li>jest.spyOn()  </li>
</ol>
<p>spy 并不会影响到原有模块的功能代码，而只是充当一个监护人的作用。我们可以像下面这样创建并使用 spy：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bot = &#123;</span><br><span class="line">    sayHello: <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">describe(<span class="string">&#x27;bot&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    it(<span class="string">&#x27;should say hello&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> spy = jest.spyOn(bot, <span class="string">&#x27;sayHello&#x27;</span>)</span><br><span class="line">        bot.sayHello(<span class="string">&#x27;Michael&#x27;</span>)</span><br><span class="line">        expect(spy).toHaveBeenCalledWith(<span class="string">&#x27;Michael&#x27;</span>)</span><br><span class="line">        <span class="comment">// 恢复 bot 对象原本的 sayHello 方法</span></span><br><span class="line">        spy.mockRestore()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们通过 jest.spyOn（） 监听了 bot 的 sayHello 方法，它就像间谍一样监听了所有对 bot 中 sayHello 方法的调用。由于创建 spy 时，Jest 实际上修改了 bot 对象的 sayHello 属性，所以在断言完成后，我们还要通过 mockRestore 来恢复 bot 对象原本的 sayHello 方法。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>测试只是一种工具和手段，代码质量是依靠设计和维护的。</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>Jest</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua</title>
    <url>/2021/04/30/Lua/</url>
    <content><![CDATA[<h1 id="Lua简介"><a href="#Lua简介" class="headerlink" title="Lua简介"></a>Lua简介</h1><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。是巴西里约热内卢天主教大学里的一个研究小组于 1993 年开发的。</p>
<h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><strong>轻量级:</strong> 它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。</li>
<li><strong>可扩展:</strong> Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。</li>
<li><strong>其他特性:</strong><ul>
<li>支持面向过程编程和函数式编程；</li>
<li>自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；</li>
<li>语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；</li>
<li>通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。</li>
</ul>
</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>游戏开发</li>
<li>独立应用脚本</li>
<li>Web 应用脚本</li>
<li>扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench</li>
<li>安全系统，如入侵检测系统</li>
</ul>
<h1 id="安装Lua"><a href="#安装Lua" class="headerlink" title="安装Lua"></a>安装Lua</h1><h2 id="Mac-系统"><a href="#Mac-系统" class="headerlink" title="Mac 系统"></a>Mac 系统</h2><figure class="highlight plain"><figcaption><span>-R -O</span><a href="http://www.lua.org/ftp/lua-5.3.0.tar.gz">link</a></figcaption><table><tr><td class="code"><pre><span class="line">tar zxf lua-5.3.0.tar.gz</span><br><span class="line">cd lua-5.3.0</span><br><span class="line">make macosx test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install lua</span><br></pre></td></tr></table></figure>

<h2 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统"></a>Windows 系统</h2><blockquote>
<p>下载地址：<a href="https://github.com/rjpcomputing/luaforwindows/releases%EF%BC%8C">https://github.com/rjpcomputing/luaforwindows/releases，</a><br>双击安装后即可在该环境下编写 Lua 程序并运行。<br>windows下你可以使用一个叫”SciTE”的IDE环境来执行lua程序。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/162297/36/15434/38802/6062bfedEc939a251/3a32aa64ba897736.png"></p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。<br>局部变量的作用域为从声明位置开始到所在语句块结束。<br>变量的默认值均为 nil。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 5               -- 全局变量</span><br><span class="line">local b &#x3D; 5         -- 局部变量</span><br><span class="line"></span><br><span class="line">function joke()</span><br><span class="line">    c &#x3D; 5           -- 全局变量</span><br><span class="line">    local d &#x3D; 6     -- 局部变量</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">joke()</span><br><span class="line">print(c,d)          --&gt; 5 nil</span><br><span class="line"></span><br><span class="line">do</span><br><span class="line">    local a &#x3D; 6     -- 局部变量</span><br><span class="line">    b &#x3D; 6           -- 对局部变量重新赋值</span><br><span class="line">    print(a,b);     --&gt; 6 6</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(a,b)      --&gt; 5 6</span><br></pre></td></tr></table></figure>
<blockquote>
<p>do … end这种表达方式只是一种定义局部变量和执行一个语句块的组合，没有其他特殊含义。</p>
</blockquote>
<h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>Lua 可以对一个变量进行赋值，也可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 1 </span><br><span class="line">i,j &#x3D; 2,3</span><br><span class="line">x,y,z &#x3D; 4,5</span><br><span class="line">print(a, i, j, x, y, z)</span><br></pre></td></tr></table></figure>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Lua 是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。<br>Lua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th>类型描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nil</td>
<td>只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）</td>
</tr>
<tr>
<td align="center">boolean</td>
<td>包含两个值：false和true</td>
</tr>
<tr>
<td align="center">number</td>
<td>表示双精度类型的实浮点数</td>
</tr>
<tr>
<td align="center">string</td>
<td>字符串由一对双引号或单引号来表示</td>
</tr>
<tr>
<td align="center">table</td>
<td>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表</td>
</tr>
<tr>
<td align="center">function</td>
<td>由 C 或 Lua 编写的函数</td>
</tr>
<tr>
<td align="center">thread</td>
<td>表示执行的独立线路，用于执行协同程序</td>
</tr>
<tr>
<td align="center">userdata</td>
<td>表示任意存储在变量中的C数据结构</td>
</tr>
</tbody></table>
<p>我们可以使用 type 函数测试给定变量或者值的类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(type(&quot;Hello world&quot;))      --&gt; string</span><br><span class="line">print(type(10.4*3))             --&gt; number</span><br><span class="line">print(type(print))              --&gt; function</span><br><span class="line">print(type(type))               --&gt; function</span><br><span class="line">print(type(true))               --&gt; boolean</span><br><span class="line">print(type(nil))                --&gt; nil</span><br><span class="line">print(type(type(X)))            --&gt; string</span><br></pre></td></tr></table></figure>
<h2 id="nil（空）"><a href="#nil（空）" class="headerlink" title="nil（空）"></a>nil（空）</h2><ul>
<li>nil 类型表示一种没有任何有效值，它只有一个值 – nil，例如打印一个没有赋值的变量，便会输出一个 nil 值</li>
<li>对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉，执行下面代码就知：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;1</span><br><span class="line">print(a)</span><br><span class="line">a&#x3D;nil</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure></li>
<li>**nil 作比较时应该加上双引号 “**，试下如下代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type(X)&#x3D;&#x3D;nil</span><br><span class="line">type(X)&#x3D;&#x3D;&quot;nil&quot;</span><br></pre></td></tr></table></figure>
type(X)==nil 结果为 false 的原因是 type(X) 实质是返回的 “nil” 字符串，是一个 string 类型，不信你执行一下 <code>type(type(X))</code></li>
</ul>
<h2 id="boolean（布尔）"><a href="#boolean（布尔）" class="headerlink" title="boolean（布尔）"></a>boolean（布尔）</h2><p>boolean 类型只有两个可选值：true和 false，Lua 把 false 和 nil 看作是 false，其他的都为 true，<strong>数字 0 也是 true</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if false or nil then</span><br><span class="line">    print(&quot;至少有一个是 true&quot;)</span><br><span class="line">else</span><br><span class="line">    print(&quot;false 和 nil 都为 false&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if 0 then</span><br><span class="line">    print(&quot;数字 0 是 true&quot;)</span><br><span class="line">else</span><br><span class="line">    print(&quot;数字 0 为 false&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="number（数字）"><a href="#number（数字）" class="headerlink" title="number（数字）"></a>number（数字）</h2><p>Lua 默认只有一种 number 类型 – double（双精度）类型，以下几种写法都被看作是 number 类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(type(2))</span><br><span class="line">print(type(2.2))</span><br><span class="line">print(type(0.2))</span><br><span class="line">print(type(2e+1))</span><br><span class="line">print(type(0.2e-1))</span><br><span class="line">print(type(7.8263692594256e-06))</span><br></pre></td></tr></table></figure>
<h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><h3 id="字符串的定义"><a href="#字符串的定义" class="headerlink" title="字符串的定义"></a>字符串的定义</h3><ul>
<li>字符串由一对双引号或单引号来表示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string1 &#x3D; &quot;this is string1&quot;</span><br><span class="line">string2 &#x3D; &#39;this is string2&#39;</span><br></pre></td></tr></table></figure></li>
<li>也可以用 2 个方括号 “[[]]” 来表示”一块”字符串：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#x3D; [[</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;&gt;百度&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">]]</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure></li>
<li>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字,试运行如下代码:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;2&quot; + 6)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="字符串常见的操作"><a href="#字符串常见的操作" class="headerlink" title="字符串常见的操作"></a>字符串常见的操作</h3><p>Lua 提供了很多的方法来支持字符串的操作：</p>
<ul>
<li><p>字符串全部转为大写字母。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string.upper(&#39;lua&#39;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串全部转为小写字母。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string.lower(&#39;LUA&#39;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在字符串中替换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string.gsub(&quot;aaa&quot;,&quot;a&quot;,&quot;z&quot;,3); -- aaa要操作的字符串；a 被 z 替换 3 次 (如果忽略3，则表示全部替换)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在一个指定的目标字符串中搜索指定的内容,返回其具体位置。不存在则返回 nil。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string.find(&quot;Hello Lua user&quot;, &quot;Lua&quot;) </span><br></pre></td></tr></table></figure>
</li>
<li><p>返回一个类似printf的格式化字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string.format(&quot;the value is:%d&quot;,4) -- %d, %i 接受一个数字并将其转化为有符号的整数格式</span><br><span class="line">string.format(&quot;the value is:%f&quot;,9.990000) -- %f 接受一个数字并将其转化为浮点数格式</span><br><span class="line">string.format(&quot;the value is:%s&quot;,&#39;a&#39;) -- %s 接受一个字符串并按照给定的参数格式化该字符串</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算字符串长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str &#x3D; &#39;abc&#39;</span><br><span class="line">string.len(str) 或者</span><br><span class="line">print(#str)</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接两个字符串，使用的是 ..</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;abc&quot;..&quot;xyz&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串截取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str&#x3D;&#39;m.jd.com&#39;</span><br><span class="line">string.sub(str, 4, -1) -- str要操作的字符串；4 截取开始的位置；截取结束位置，默认为 -1，最后一个字符。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="table（表）"><a href="#table（表）" class="headerlink" title="table（表）"></a>table（表）</h2><h3 id="table（表）的定义"><a href="#table（表）的定义" class="headerlink" title="table（表）的定义"></a>table（表）的定义</h3><p>在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建一个空的 table</span><br><span class="line">local tbl1 &#x3D; &#123;&#125;</span><br><span class="line"> </span><br><span class="line">-- 直接初始表</span><br><span class="line">local tbl2 &#x3D; &#123;&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>Lua 中的表（table）其实是一个”关联数组”，数组的索引可以是数字或者是字符串:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; &#123;&#125;</span><br><span class="line">a[&quot;key&quot;] &#x3D; &quot;value&quot;</span><br><span class="line">key &#x3D; 10</span><br><span class="line">a[key] &#x3D; 22</span><br><span class="line">a[key] &#x3D; a[key] + 11</span><br><span class="line">for k, v in pairs(a) do</span><br><span class="line">    print(k .. &quot; : &quot; .. v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引默认以 1 开始。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local tbl &#x3D; &#123;&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;&#125;</span><br><span class="line">for key, val in pairs(tbl) do</span><br><span class="line">    print(&quot;Key&quot;, key)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; &#123;&#125;</span><br><span class="line">for i &#x3D; 1, 5 do</span><br><span class="line">    a[i] &#x3D; i</span><br><span class="line">end</span><br><span class="line">for key, val in pairs(a) do</span><br><span class="line">  print(key, val)</span><br><span class="line">end</span><br><span class="line">a[&quot;key1&quot;] &#x3D; &quot;val&quot;</span><br><span class="line">print(a[&quot;key1&quot;])</span><br><span class="line">print(a[&quot;key2&quot;])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="table（表）的操作"><a href="#table（表）的操作" class="headerlink" title="table（表）的操作"></a>table（表）的操作</h3><ul>
<li>Table 连接</li>
<li>插入和移除</li>
<li>Table 排序</li>
<li>Table 最大值</li>
</ul>
<h4 id="Table-连接"><a href="#Table-连接" class="headerlink" title="Table 连接"></a><strong>Table 连接</strong></h4><p>可以使用 concat() 输出一个列表中元素连接成的字符串:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruits &#x3D; &#123;&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;&#125;</span><br><span class="line">-- 返回连接后的字符串</span><br><span class="line">print(&quot;连接后的字符串 &quot;,table.concat(fruits))</span><br><span class="line"></span><br><span class="line">-- 指定连接字符</span><br><span class="line">print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;))</span><br><span class="line"></span><br><span class="line">-- 指定索引来连接</span><br><span class="line">print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;, 2,3))</span><br></pre></td></tr></table></figure>

<h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a><strong>插入和删除</strong></h4><p>可以使用 insert() 和 remove() 来分别实现 table的插入和删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruits &#x3D; &#123;&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;&#125;</span><br><span class="line"></span><br><span class="line">-- 在末尾插入</span><br><span class="line">table.insert(fruits,&quot;mango&quot;)</span><br><span class="line">print(&quot;索引为 4 的元素为 &quot;,fruits[4])</span><br><span class="line"></span><br><span class="line">-- 在索引为 2 的键处插入</span><br><span class="line">table.insert(fruits,2,&quot;grapes&quot;)</span><br><span class="line">print(&quot;索引为 2 的元素为 &quot;,fruits[2])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for key, val in pairs(fruits) do</span><br><span class="line">    print(val)</span><br><span class="line">end</span><br><span class="line">table.remove(fruits)</span><br><span class="line">print(&quot;------------&quot;)</span><br><span class="line">for key, val in pairs(fruits) do</span><br><span class="line">    print(val)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="Table-排序"><a href="#Table-排序" class="headerlink" title="Table 排序"></a><strong>Table 排序</strong></h4><p>使用sort() 方法对 Table 进行排序，默认排序顺序是根据字符串Unicode码点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruits &#x3D; &#123;&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;grapes&quot;&#125;</span><br><span class="line">for k,v in ipairs(fruits) do</span><br><span class="line">    print(k,v)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">table.sort(fruits)</span><br><span class="line">print(&quot;--------------------&quot;)</span><br><span class="line">for k,v in ipairs(fruits) do</span><br><span class="line">    print(k,v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="Table-最大值"><a href="#Table-最大值" class="headerlink" title="Table 最大值"></a>Table 最大值</h4><p>table.maxn 在 Lua5.2 之后该方法已经不存在了。</p>
<h2 id="function（函数）"><a href="#function（函数）" class="headerlink" title="function（函数）"></a>function（函数）</h2><p>在 Lua 中，函数是被看作是”第一类值”，函数可以存在变量里。</p>
<blockquote>
<p>第一类值表示函数与其他传统类型的值（例如数字和字符串类型）具有相同的权利。即函数可以存储在变量中，可以作为实参传递给其他函数，还可以作为其他函数的返回值，如下两段代码:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--函数可以存储在变量中:</span><br><span class="line"></span><br><span class="line">local function f1()</span><br><span class="line">    print(&quot;Hello&quot;)</span><br><span class="line">end</span><br><span class="line">--等价于</span><br><span class="line">local f1 &#x3D; function()</span><br><span class="line">    print(&quot;Hello&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--以匿名函数的方式通过参数传递:</span><br><span class="line"></span><br><span class="line">function testFun(tab,fun)</span><br><span class="line">    for k ,v in pairs(tab) do</span><br><span class="line">        print(fun(k,v));</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">tab&#x3D;&#123;key1&#x3D;&quot;val1&quot;,key2&#x3D;&quot;val2&quot;&#125;;</span><br><span class="line">testFun(tab,</span><br><span class="line">    function(key,val)--匿名函数</span><br><span class="line">        return key..&quot;&#x3D;&quot;..val;</span><br><span class="line">    end</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)</span><br><span class="line">    function_body</span><br><span class="line">    return result_params_comma_separated</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li>optional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。</li>
<li>function_name: 指定函数名称。</li>
<li>argument1, argument2, argument3…, argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。</li>
<li>function_body: 函数体，函数中需要执行的代码语句块。</li>
<li>result_params_comma_separated: 函数返回值，Lua函数可以返回多个值，每个值以逗号隔开。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li>以下实例定义了函数 max()，参数为 num1, num2，用于比较两值的大小，并返回最大值：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function max(num1, num2)</span><br><span class="line">   if (num1 &gt; num2) then</span><br><span class="line">      result &#x3D; num1;</span><br><span class="line">   else</span><br><span class="line">      result &#x3D; num2;</span><br><span class="line">   end</span><br><span class="line">   return result;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 调用函数</span><br><span class="line">print(&quot;两值比较最大值为 &quot;,max(10,4))</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">- 可以将函数作为参数传递给函数，如下实例：</span><br></pre></td></tr></table></figure>
myprint = function(param)<br> print(“这是打印函数 -   ##”,param,”##”)<br>end</li>
</ul>
<p>function add(num1,num2,functionPrint)<br>   result = num1 + num2<br>   – 调用传递的函数参数<br>   functionPrint(result)<br>end<br>– myprint 函数作为参数传递<br>add(2,5,myprint)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 多返回值</span><br><span class="line">Lua函数可以返回多个结果值，在return后列出要返回的值的列表即可返回多值，如：</span><br></pre></td></tr></table></figure>
<p>– 获取table中的最大值</p>
<p>function maximum (a)<br>    local mi = 1             – 最大值索引<br>    local m = a[mi]          – 最大值<br>    for i,val in ipairs(a) do<br>       if val &gt; m then<br>           mi = i<br>           m = val<br>       end<br>    end<br>    return m, mi<br>end</p>
<p>print(maximum({8,10,23,12,5}))</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 可变参数</span><br><span class="line">Lua 函数可以接受可变数目的参数。</span><br><span class="line">- 在函数参数列表中使用三点 ... 表示函数有可变的参数；</span><br><span class="line">- 可以通过 &quot;#&quot; 来获取可变参数的数量。</span><br></pre></td></tr></table></figure>
<p>– 求平均值</p>
<p>function average(…)<br>   result = 0<br>   local arg={…}    – arg 为一个表，局部变量<br>   for i,v in ipairs(arg) do<br>      result = result + v<br>   end<br>   print(“总共传入 “ .. #arg .. “ 个数”)<br>   return result/#arg<br>end</p>
<p>print(“平均值为”,average(10,5,3,4,5,6))</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## thread（线程）</span><br><span class="line">在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。</span><br><span class="line"></span><br><span class="line">|  方法   | 描述  |</span><br><span class="line">|  :----:  | :----  |</span><br><span class="line">| create() | 创建 coroutine，返回 coroutine， 参数是一个函数，当和 resume 配合使用的时候就唤醒函数调用 |</span><br><span class="line">| resume() | 启动 coroutine，和 create 配合使用 |</span><br><span class="line">| yield() | 挂起 coroutine，将 coroutine 设置为挂起状态，这个和 resume 配合使用能有很多有用的效果 |</span><br><span class="line">| status() | 查看 coroutine 的状态 (coroutine 的状态有三种：dead，suspended，running) |</span><br><span class="line">| running() | 返回正在跑的 coroutine，一个 coroutine 就是一个线程，当使用running的时候，就是返回一个 corouting 的线程号 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 简单示例</span><br></pre></td></tr></table></figure>
<p>co = coroutine.create(<br>    function(i)<br>        print(i);<br>    end<br>)<br>coroutine.resume(co, 1)   – 1<br>print(coroutine.status(co))  – dead</p>
<p>print(“————-“)</p>
<p>co2 = coroutine.create(<br>    function()<br>        for i=1,10 do<br>            print(i)<br>            if i == 3 then<br>                print(coroutine.status(co2))  –running<br>                print(coroutine.running()) –thread:XXXXXX<br>            end<br>            coroutine.yield()<br>        end<br>    end<br>)</p>
<p>coroutine.resume(co2) –1<br>coroutine.resume(co2) –2<br>coroutine.resume(co2) –3</p>
<p>print(coroutine.status(co2))   – suspended<br>print(coroutine.running())</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 当create一个coroutine的时候就是在新线程中注册了一个事件。当使用resume触发事件的时候，create的coroutine函数就被执行了，当遇到yield的时候就代表挂起当前线程，等候再次resume触发事件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 详细示例</span><br></pre></td></tr></table></figure>
<p>function foo (a)<br>    print(“foo 函数输出”, a)<br>    return coroutine.yield(2 * a) – 返回  2*a 的值<br>end</p>
<p>co = coroutine.create(function (a , b)<br>    print(“第一次协同程序执行输出”, a, b) – co-body 1 10<br>    local r = foo(a + 1)</p>
<pre><code>print(&quot;第二次协同程序执行输出&quot;, r)
local r, s = coroutine.yield(a + b, a - b)  -- a，b的值为第一次调用协同程序时传入
 
print(&quot;第三次协同程序执行输出&quot;, r, s)
return b, &quot;结束协同程序&quot;                   -- b的值为第二次调用协同程序时传入
</code></pre>
<p>end)</p>
<p>print(“main”, coroutine.resume(co, 1, 10)) – true, 4<br>print(“–分割线—-“)<br>print(“main”, coroutine.resume(co, “r”)) – true 11 -9<br>print(“—分割线—“)<br>print(“main”, coroutine.resume(co, “x”, “y”)) – true 10 end<br>print(“—分割线—“)<br>print(“main”, coroutine.resume(co, “x”, “y”)) – cannot resume dead coroutine<br>print(“—分割线—“)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; resume和yield的配合强大之处在于，resume处于主程中，它将外部状态（数据）传入到协同程序内部；而yield则将内部的状态（数据）返回到主程中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 生产者-消费者问题</span><br></pre></td></tr></table></figure>
<p>local newProductor</p>
<p>function productor()<br>    local i = 0<br>    while true do<br>        i = i + 1<br>        send(i)     – 将生产的物品发送给消费者<br>    end<br>end</p>
<p>function consumer()<br>    while true do<br>        local i = receive()     – 从生产者那里得到物品<br>        print(i)<br>    end<br>end</p>
<p>function receive()<br>    local status, value = coroutine.resume(newProductor)<br>    return value<br>end</p>
<p>function send(x)<br>    coroutine.yield(x)     – x表示需要发送的值，值返回以后，就挂起该协同程序<br>end</p>
<p>– 启动程序<br>newProductor = coroutine.create(productor)<br>consumer()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">以上代码执行步骤：</span><br><span class="line">- 创建newProductor协同程序</span><br><span class="line">- 执行consumer函数</span><br><span class="line">- 到consumer中执行recieve（）</span><br><span class="line">- recieve中启动newProductor，执行productor函数</span><br><span class="line">- 到productor中执行send（1）&#x2F;&#x2F;生产者中i &#x3D; 1</span><br><span class="line">- send（1）挂起newProductor，并发送1</span><br><span class="line">**注意协同程序下次从这里继续**</span><br><span class="line">- 继续执行receive，value&#x3D;1，</span><br><span class="line">- 到consumer（）中local i&#x3D;1，打印i</span><br><span class="line">- 执行consumer（）中的while循环</span><br><span class="line">- ......</span><br><span class="line"></span><br><span class="line">## userdata（自定义类型）</span><br><span class="line">userdata 是一种用户自定义数据，用于表示一种由应用程序或 C&#x2F;C++ 语言库所创建的类型，可以将任意 C&#x2F;C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 数组</span><br><span class="line">Lua并没有提供专门的数组对象来对数组进行操作，Lua的数组是使用table来实现的。当 key 为整数时，table 就可以当成数组来用。而且这个数组是一个 索引从1开始 ，没有固定长度，可以根据需要自动增长的数组。可以是一维数组和多维数组。</span><br><span class="line"></span><br><span class="line">## Table的长度</span><br><span class="line">### 对于一个数组我们通常可以使用#和table.getn来获取其长度</span><br></pre></td></tr></table></figure>
<p>array = {“a”, “b”}<br>print(#array)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 如果不是数组，使用#是不能获取table长度的，可以使用如下方法进行获取：</span><br></pre></td></tr></table></figure>
<p>tabletest = {a=1,b=2,c=3,d=4,e=5}<br>local count=0<br>for k,v in pairs(tabletest) do<br>    count = count + 1<br>end<br>print(count)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 一维数组</span><br></pre></td></tr></table></figure>
<p>array = {“a”, “b”}<br>for i= 0, #array do<br>   print(array[i])<br>end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 二维数组</span><br><span class="line">多维数组即数组中包含数组或一维数组的索引键对应一个数组。</span><br></pre></td></tr></table></figure>
<p>array = { {1,2},{‘a’,’b’},3,’c’ }<br>for i=1, #array do<br>  if (type(array[i]) == ‘table’) then<br>    for j=1, #array[i] do<br>      print(array[i][j])<br>    end<br>  else<br>    print(array[i])<br>  end<br>end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># Lua 流程控制</span><br><span class="line">Lua 编程语言流程控制语句通过程序设定一个或多个条件语句来设定。在条件为 true 时执行指定程序代码，在条件为 false 时执行其他指定代码。</span><br><span class="line">## if 语句</span><br></pre></td></tr></table></figure>
<p>–[ 0 为 true ]<br>if(0)<br>then<br>    print(“0 为 true”)<br>end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## if...else 语句</span><br></pre></td></tr></table></figure>
<p>a = 100;</p>
<p>if( a &lt; 20 )<br>then<br>   print(“a 小于 20” )<br>else<br>   print(“a 大于 20” )<br>end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## if 嵌套语句</span><br></pre></td></tr></table></figure>
<p>a = 100;<br>b = 200;</p>
<p>if( a == 100 )<br>then<br>   if( b == 200 )<br>   then<br>      print(“a 的值为 100 b 的值为 200” );<br>   end<br>end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 循环</span><br><span class="line">很多情况下我们需要做一些有规律性的重复操作，因此在程序中就需要重复执行某些语句。</span><br><span class="line">一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。</span><br><span class="line">循环结构是在一定条件下反复执行某段程序的流程结构，被反复执行的程序被称为循环体。</span><br><span class="line">循环语句是由循环体及循环的终止条件两部分组成的。</span><br><span class="line">## for 循环</span><br><span class="line">### 数值for循环</span><br></pre></td></tr></table></figure>
<p>for var=exp1,exp2,exp3 do<br>    &lt;循环体&gt;<br>end  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 &quot;执行体&quot;。exp3 是可选的，如果不指定，默认为1。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>for i=1,10 do<br>    print(i)<br>end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 泛型for循环</span><br><span class="line">泛型 for 循环通过一个迭代器函数来遍历所有值。</span><br></pre></td></tr></table></figure>
<p>–打印数组a的所有值<br>a = {“one”, “two”, “three”}<br>for i, v in ipairs(a) do<br>    print(i, v)<br>end </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; i是数组索引值，v是对应索引的元素值。ipairs是Lua提供的一个迭代器函数，用来迭代数组。</span><br><span class="line">## while 循环</span><br><span class="line">Lua 编程语言中 while 循环语句在判断条件为 true 时会重复执行循环体语句。</span><br></pre></td></tr></table></figure>
<p>while(循环条件)<br>do<br>   &lt;循环体&gt;<br>end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">a&#x3D;10</span><br><span class="line">while( a &lt; 20 )</span><br><span class="line">do</span><br><span class="line">   print(&quot;a 的值为:&quot;, a)</span><br><span class="line">   a &#x3D; a+1</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><p>以下实例使用了for循环嵌套:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for m&#x3D;1,9 do                           </span><br><span class="line">    local s &#x3D; &quot;&quot;                       </span><br><span class="line">    for n&#x3D;1,9 do                       </span><br><span class="line">        if n &lt;&#x3D; m then                 </span><br><span class="line">            s &#x3D; s..m..&quot;x&quot;..n..&quot;&#x3D;&quot;..m*n </span><br><span class="line">            if n ~&#x3D; m then   -- ~&#x3D; 不等于           </span><br><span class="line">                s &#x3D; s..&quot;, &quot;            </span><br><span class="line">            end</span><br><span class="line">        end        </span><br><span class="line">    end</span><br><span class="line">    print(s)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>循环控制语句用于控制程序的流程， 以实现程序的各种结构方式。</p>
<ul>
<li>break</li>
<li>goto<h3 id="break"><a href="#break" class="headerlink" title="break"></a><strong>break</strong></h3>Lua 编程语言 break 语句插入在循环体中，用于退出当前循环或语句，并开始脚本执行紧接着的语句。<br>如果你使用循环嵌套，break语句将停止最内层循环的执行，并开始执行的外层的循环语句。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i&#x3D;1,10 do</span><br><span class="line">  if(i&gt;5) </span><br><span class="line">  then </span><br><span class="line">    break</span><br><span class="line">  else  </span><br><span class="line">    print(i)</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a><strong>goto</strong></h3>goto 语句允许将控制流程无条件地转到被标记的语句处。<br>语法格式如下所示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goto label</span><br></pre></td></tr></table></figure>
Label 的格式为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:: Label ::</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>以下实例中使用了 goto：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i&#x3D;1, 3 do</span><br><span class="line">    if i &lt;&#x3D; 2 then</span><br><span class="line">        print(i, &quot;yes continue&quot;)</span><br><span class="line">        goto continue</span><br><span class="line">    end</span><br><span class="line">    print(i, &quot; no continue&quot;)</span><br><span class="line">    ::continue::</span><br><span class="line">    print([[i&#39;m end]])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Redux基础及原理探究</title>
    <url>/2020/08/31/Redux%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h3 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1.核心概念"></a>1.核心概念</h3><ul>
<li>state：应用的状态，树形结构，可以囊括很多子state。</li>
<li>action：想要更改state中的数据，需要发起（dispatch）一个action。action是一个简单对象，描述了state的变化。按照约定，action具有type属性来描述它的类型。</li>
<li>action creator：一个创建action的函数，是一个创建action的工厂。</li>
<li>reducer：根据action的描述来生成新的state。</li>
<li>dispatch：发起action的函数，其内部会调用reducer来生成新的state。</li>
<li>store：维持应用所有state树的一个对象，改变store内state的唯一途径是对它dispatch一个action。一个应用有且仅有一个store。</li>
<li>store creator：一个创建store的函数。</li>
<li>store enhancer：一个组合store creator的高阶函数，返回一个强化班的store creator，通过复合函数改变store的接口。</li>
</ul>
<h3 id="2-核心API"><a href="#2-核心API" class="headerlink" title="2.核心API"></a>2.核心API</h3><h4 id="2-1-store"><a href="#2-1-store" class="headerlink" title="2.1 store"></a>2.1 store</h4><p>store是一个对象，拥有四个方法属性。通过createStore函数创建store。</p>
<p>store对象所包含的方法如下：</p>
<ul>
<li>getState()：返回当前store的state树。</li>
<li>dispatch(action)：分发action，这是改变state的唯一方式。根据当前state和action，经由reducer生成新的state。</li>
<li>subscribe(listener)：添加一个变化监听器。每当dispatch action的时候就会执行listener，state树中的一部分可能已经发生了变化，可以通过getState()来拿到当前state。</li>
<li>replaceReducer(nextReducer)：替换store当前用来计算state的reducer。</li>
</ul>
<h4 id="2-2-createStore"><a href="#2-2-createStore" class="headerlink" title="2.2 createStore"></a>2.2 createStore</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">createStore(reducer, [preloadedState], enhancer)</span><br></pre></td></tr></table></figure>
<p>创建一个store用来存放应用的所有state，一个应用有且仅有一个store。</p>
<p>参数说明：</p>
<ul>
<li>reducer：一个函数，接受两个参数，分别是当前state树和要处理的action，返回新的state树。</li>
<li>preloadedState：可选参数，初始state。</li>
<li>enhancer[ɪnˈhɑːnsə(r)]：一个组合store creator的高阶函数，返回一个新的强化的store creator，即返回一个价钱版的createStore。</li>
</ul>
<h4 id="2-3-combineReducers"><a href="#2-3-combineReducers" class="headerlink" title="2.3 combineReducers"></a>2.3 combineReducers</h4><p>随着应用程序变得越来越复杂，可以考虑将reducer拆分成多个单独的函数，独立负责state的一部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">combineReducers(reducers)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>reducers：一个对象，它的值（value）对应不同的reducer函数，这些reducer函数会被合并成一个总的reducer。</li>
</ul>
<p>返回值：返回一个新的reducer，调用reducers对象里的所有reducer，构造一个与reduces对象结构相同的state（新的state对象与reducers对象拥有相同的key）。</p>
<p>combineReducers(reducers)会生成一个reducer，调用我们传入的各个子reducer，子reducer会根据它的key来筛选出state的一部分来进行处理，最后将所有子reducer的处理结果合并成一个新的state。</p>
<p>由combineReducers()返回的state对象，会将传入的每个 reducer返回的state按其传递给combineReducers()时对应的 key进行命名。例如，我们可以调用<code>combineReducers(&#123; todos: myTodosReducer, counter: myCounterReducer &#125;)</code>将state结构变为<code>&#123; todos, counter &#125;</code>。</p>
<h4 id="2-4-applyMiddleware"><a href="#2-4-applyMiddleware" class="headerlink" title="2.4 applyMiddleware"></a>2.4 applyMiddleware</h4><p>middleware可以让我们包装store的dispatch方法来增强其功能。它接受dispatch作为参数，返回一个新的dispatch。新的dispatch作为下一个middleware的参数。middleware函数的典型结构为：<code>(&#123; getState, dispatch &#125;) =&gt; next =&gt; action =&gt; &#123; next(state) &#125;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">applyMiddleware(...middlewares)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>middlewares：middleware数组对象，每个middleware接受store的dispatch和getState方法作为参数，返回一个函数，该函数会被传入下一个middleware作为dispatch方法，被称为next。数组的最后一个middleware会接受真实store dispatch方法作为next参数。注意在组合middlewara的过程中不可以dispatch action，因为此时的dispatch并不是最终的dispatch。</li>
</ul>
<p>返回值：返回一个函数，应用了middleware后的store enhancer，即返回一个增强版的createStore。这个store enhancer的签名是<code>createStore =&gt; createStore</code>。</p>
<h4 id="2-5-compose"><a href="#2-5-compose" class="headerlink" title="2.5 compose"></a>2.5 compose</h4><p>从右到左来组合多个函数，即先执行右侧函数，执行结果作为左侧函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">compose(...functions)</span><br></pre></td></tr></table></figure>

<p>参数说明：需要组合的多个函数，每个函数接受一个参数，返回值提供给左侧的函数作为参数，最右侧函数可以接受多个参数。</p>
<p><code>compose(funcA, funcB, funcC)</code> =&gt; <code>compose(funcA(funcB(funcC())))</code></p>
<h4 id="2-6-bindActionCreators"><a href="#2-6-bindActionCreators" class="headerlink" title="2.6 bindActionCreators"></a>2.6 bindActionCreators</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bindActionCreators(actionCreators, dispatch)</span><br></pre></td></tr></table></figure>
<p>将一个value为不同action creator的对象，转换成拥有相同key的对象，value为使用dispatch分发action creator所创建的action的函数。</p>
<p>参数说明：</p>
<ul>
<li>actionCreators：一个action creator函数或者是一个value为action creator的对象。</li>
<li>store的dispatch函数</li>
</ul>
<p>返回值：</p>
<ul>
<li>如果传入的是一个action creator函数，那么返回结果也会是一个函数，这个函数直接分发action creator所创建的action。</li>
<li>如果传入的是一个value为action creator的对象，那么返回的也会是一个对象，返回的对象与传入的对象拥有相同的key，value为直接分发对应action creator所创建的action的函数。</li>
</ul>
<p>示例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// action creator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// action creator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeTodo</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&#x27;REMOVE_TODO&#x27;</span>,</span><br><span class="line">    id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundActionCreators = bindActionCreators(TodoActionCreators, dispatch)</span><br><span class="line"><span class="comment">// boundActionCreators的结构如下</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   addTodo: function (this, ...args) &#123;</span></span><br><span class="line"><span class="comment">//     return dispatch(addTodo.apply(this, args))</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   removeTodo: function (this, ...args) &#123;</span></span><br><span class="line"><span class="comment">//     return dispatch(removeTodo.apply(this, args))</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>需要把action creator传递给子组件，但是又不想让这个子组件察觉到Redux的存在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...bindActionCreators(appActions, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(App)</span><br></pre></td></tr></table></figure>

<h3 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3.源码解析"></a>3.源码解析</h3><h4 id="3-1-createStore"><a href="#3-1-createStore" class="headerlink" title="3.1 createStore"></a>3.1 createStore</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ActionTypes <span class="keyword">from</span> <span class="string">&#x27;./utils/actionTypes&#x27;</span></span><br><span class="line"><span class="keyword">import</span> isPlainObject <span class="keyword">from</span> <span class="string">&#x27;./utils/isPlainObject&#x27;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>store创建函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>reducer 一个函数，接受两个参数，用来根据传入的action生成新的state</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>preloadState 初始state</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>enhancer 一个组合store creator的高阶函数，返回一个新的强化的store creator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, preloadState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只能有一个enhancer</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> preloadState === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">&#x27;function&#x27;</span>) || (<span class="keyword">typeof</span> enhancer === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">3</span>] === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">&#x27;It looks like you are passing several store enhancers to &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;createStore(). This is not supported. Instead, compose them &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;together to a single function.&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reducer必须是函数类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Expected the reducer to be a function.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果第二参数是函数的话，说明它是一个enhancer</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadState === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      enhancer = preloadState</span><br><span class="line">      preloadState = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// enhancer如果存在则必须是函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Expected the enhancer to be a function.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行enhancer</span></span><br><span class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前reducer</span></span><br><span class="line">  <span class="keyword">let</span> currentReducer = reducer</span><br><span class="line">  <span class="comment">// 当前state</span></span><br><span class="line">  <span class="keyword">let</span> currentState = preloadState</span><br><span class="line">  <span class="comment">// 是否正在dispatch action</span></span><br><span class="line">  <span class="keyword">let</span> isDispatching = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 当前的观察者列表</span></span><br><span class="line">  <span class="keyword">let</span> currentListeners = []</span><br><span class="line">  <span class="comment">// 该对象是对currentListeners的浅拷贝，用来避免在dispatch action时订阅或者取消订阅影响currentListeners，导致bug</span></span><br><span class="line">  <span class="comment">// 注意不论我们订阅或者是取消订阅，操作的都是nextListeners，当我们更新完state，执行观察者的时候，会更新currentListeners，指向nextListeners</span></span><br><span class="line">  <span class="keyword">let</span> nextListeners = currentListeners</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description </span>获取store的状态树</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getState</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;You may not call store.getState() while the reducer is executing. &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;The reducer has already received the state as an argument. &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;Pass it down from the top reducer instead of reading it from the store.&#x27;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description </span>分发action</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>action 简单对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// action必须是一个简单对象</span></span><br><span class="line">    <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;Actions must be plain objects. &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;Use custom middleware for async actions.&#x27;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// action对象必须拥有type属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;Actions may not have an undefined &quot;type&quot; property. &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;Have you misspelled a constant?&#x27;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 禁止在reducer中分发action</span></span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Reducers may not dispatch actions.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 正在dispatch action</span></span><br><span class="line">      isDispatching = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 生成新的state，禁止在生成过程中分发action</span></span><br><span class="line">      currentState = currentReducer(currentState, action)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isDispatching = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新观察者列表，并通知相关观察者</span></span><br><span class="line">    <span class="keyword">const</span> listeners = (currentListeners = nextListeners)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">      listeners[i]()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回action对象</span></span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@description </span>确保nextListeners是对currentListeners的浅拷贝</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ensureCanMutateNextListeners</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果nextListeners指向currentListeners，那么就浅拷贝currentListeners</span></span><br><span class="line">    <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">      nextListeners = currentListeners.slice()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description </span>订阅state的变化</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>listener 在state发生变化后执行的回调函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns </span>解除订阅的函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span> (<span class="params">listener</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// listener必须是函数类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Expected the listener to be a function.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;You may not call store.subscribe() while the reducer is executing. &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;If you would like to be notified after the store has been updated, subscribe from a &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;component and invoke store.getState() in the callback to access the latest state. &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;See https://redux.js.org/api/store#subscribelistener for more details.&#x27;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保nextListeners指向的不是currentListeners，而是currentListeners的浅拷贝</span></span><br><span class="line">    ensureCanMutateNextListeners()</span><br><span class="line">    <span class="comment">// 将listener加入到nextListeners</span></span><br><span class="line">    nextListeners.push(listener)</span><br><span class="line">    <span class="comment">// 已经订阅</span></span><br><span class="line">    <span class="keyword">let</span> isSubscribed = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 返回取消订阅函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unSubscribe</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果已经取消订阅，则不需要任何操作</span></span><br><span class="line">      <span class="keyword">if</span> (!isSubscribed) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 找到需要取消订阅的listener的索引</span></span><br><span class="line">      <span class="keyword">const</span> index = nextListeners.indexOf(listener)</span><br><span class="line">      <span class="comment">// 将其从nextListeners中移除</span></span><br><span class="line">      nextListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 取消订阅成功</span></span><br><span class="line">      isSubscribed = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description </span>替换reducer</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">nextReducer</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span> (<span class="params">nextReducer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 新的reducer也必须是函数类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Expected the reducer to be a function.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 替换reducer</span></span><br><span class="line">    currentReducer = nextReducer</span><br><span class="line">    <span class="comment">// 分发替换reducer的action</span></span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: ActionTypes.REPLACE</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回store对象，包括四个方法属性</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getState, <span class="comment">// 获取当前state</span></span><br><span class="line">    dispatch, <span class="comment">// 分发action，执行reducer生成新的state，并通知listener</span></span><br><span class="line">    subscribe, <span class="comment">// 订阅dispatch</span></span><br><span class="line">    replaceReducer <span class="comment">// 替换reducer</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-combineReducers"><a href="#3-2-combineReducers" class="headerlink" title="3.2 combineReducers"></a>3.2 combineReducers</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>组合reducers，生成一个根reducer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">reducers</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="variable">reducer</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span> (<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// reducers对象的key是要处理state子树，value是处理state子树的reducer</span></span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">  <span class="comment">// 去掉不是函数类型的reducer</span></span><br><span class="line">  <span class="keyword">const</span> finallyReducers = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = reducerKeys[i]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      finallyReducers[key] = reducers[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最终的state对象所包含的key</span></span><br><span class="line">  <span class="keyword">const</span> finallyKeys = <span class="built_in">Object</span>.keys(finallyReducers)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span> (<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 新的state</span></span><br><span class="line">    <span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line">    <span class="comment">// state是否改变</span></span><br><span class="line">    <span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finallyKeys.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 根据key处理对应的state子树</span></span><br><span class="line">      <span class="keyword">const</span> key = finallyKeys[key]</span><br><span class="line">      <span class="keyword">const</span> reducer = finallyReducers[key]</span><br><span class="line">      <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">      <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line">      <span class="comment">// 如果state子树发生改变那么就可以认为整个state树发生改变</span></span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果state发生改变就返回新的state，否则的话返回原来的state</span></span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-compose"><a href="#3-3-compose" class="headerlink" title="3.3 compose"></a>3.3 compose</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fns.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fns[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体执行效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f0 = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="keyword">return</span> x * <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> f1 = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> f2 = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(x) &#125;</span><br><span class="line">compose(f2, f1, f0)(<span class="number">100</span>) <span class="comment">// 执行 f2(f1(f0(100))) 打印201</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-applyMiddleware"><a href="#3-4-applyMiddleware" class="headerlink" title="3.4 applyMiddleware"></a>3.4 applyMiddleware</h4><p>react-thunk是一个典型的middleware，用来处理异步action。通常情况下action是一个包含type属性的对象，但是通过使用指定的middleware，action可以是一个函数，这个函数会被指定的middleware执行。react-thunk的源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span> (<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123;dispatch, getState&#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果action为函数，那么就执行它</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 真正执行的dispatch是经过middleware包装后的dispatch</span></span><br><span class="line">      <span class="keyword">return</span> action(dispatch, getState, extraArgument)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleware()</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk</span><br></pre></td></tr></table></figure>

<p>middleware的主要功能是包装store的dispatch方法，applyMiddleware的主要功能是用来组合middleware。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> compose <span class="keyword">from</span> <span class="string">&#x27;./compose&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span> (<span class="params">middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 原始store对象</span></span><br><span class="line">    <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">    <span class="comment">// 在构造middleware的过程中禁止dispatch action</span></span><br><span class="line">    <span class="keyword">let</span> dispatch = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;Dispatching while constructing your middleware is not allowed. &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;Other middleware would not be applied to this dispatch.&#x27;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">action, ...args</span>) =&gt;</span> dispatch(action, ...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line">    <span class="comment">// 返回一个新的store对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch <span class="comment">// 经过包装后的dispatch</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-bindActionCreators"><a href="#3-5-bindActionCreators" class="headerlink" title="3.5 bindActionCreators"></a>3.5 bindActionCreators</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>直接分发（dispatch）actionCreator创建的action</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>actionCreator action创建函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>dispatch 分发action的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>一个分发（dispatch）actionCreator创建的action的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span> (<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">this</span>, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(actionCreator.apply(<span class="built_in">this</span>, args)) <span class="comment">// dispatch action</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>直接分发传递进来的actionCreators所创建的actions</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>actionCreators value为action创建函数的对象 | 一个action创建函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>dispatch 分发action的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>一个对象或一个函数，直接分发actionCreators创建的actions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params">actionCreators, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators !== <span class="string">&#x27;object&#x27;</span> || actionCreators === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">`bindActionCreators expected an object or a function, instead received <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        actionCreators === <span class="literal">null</span> ? <span class="string">&#x27;null&#x27;</span> : <span class="keyword">typeof</span> actionCreators</span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span>. `</span> +</span><br><span class="line">        <span class="string">`Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个对象，key为action创建函数的名字，value为分发actionCreator创建的action的函数</span></span><br><span class="line">  <span class="keyword">const</span> boundActionCreators = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> actionCreators) &#123;</span><br><span class="line">    <span class="keyword">const</span> actionCreator = actionCreators[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreator === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> boundActionCreators</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>应用中有且仅有一个store，可以将reducer进行拆分来管理不同的自子state，通过combineReducers来创建一个跟reducer。</li>
<li>不要直接修改state对象，而是要生成一个全新的对象。例如，不要使用<code>Object.assign(state, newData)</code>，而应该使用<code>Object.assign(&#123;&#125;, state, newData)</code>。</li>
<li>在reducer层级的任何一级都可以调用combineReducers，我们可以将复杂的reducer拆分成单独的孙子级的reducer，甚至是更多层。</li>
<li>middleware只是包装了store的dispatch方法。</li>
<li>applyMiddleware的作用是组合middleware，生成新的store，store的dispatch方法经过middleware包装。</li>
</ul>
]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>Taro(三)</title>
    <url>/2020/10/17/Taro(%E4%B8%89)/</url>
    <content><![CDATA[<h2 id="七、小程序运行时"><a href="#七、小程序运行时" class="headerlink" title="七、小程序运行时"></a>七、小程序运行时</h2><p>为了使 Taro 组件转换成小程序组件并运行在小程序环境下， Taro 主要做了两个方面的工作：编译以及运行时适配。编译过程会做很多工作，例如：将 JSX 转换成小程序 .wxml 模板，生成小程序的配置文件、页面及组件的代码等等。编译生成好的代码仍然不能直接运行在小程序环境里，那运行时又是如何与之协同工作的呢？…</p>
<h3 id="7-1-注册程序、页面以及自定义组件"><a href="#7-1-注册程序、页面以及自定义组件" class="headerlink" title="7.1 注册程序、页面以及自定义组件"></a>7.1 注册程序、页面以及自定义组件</h3><p>在小程序中会区分程序、页面以及组件，通过调用对应的函数，并传入包含生命周期回调、事件处理函数等配置内容的 object 参数来进行注册：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>而在 Taro 里，它们都是一个组件类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; &#125;</span><br><span class="line">  handleClick () &#123; &#125;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<ul>
<li>那么 Taro 的组件类是如何转换成小程序的程序、页面或组件的呢？</li>
<li>例如，有一个组件：customComponent，编译过程会在组件底部添加一行这样的代码（此处代码作示例用，与实际项目生成的代码不尽相同）：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Component(createComponent(customComponent));</span><br></pre></td></tr></table></figure>

<ul>
<li>createComponent 方法是整个运行时的入口，在运行的时候，会根据传入的组件类，返回一个组件的配置对象<blockquote>
<p>在小程序里，程序的功能及配置与页面和组件差异较大，因此运行时提供了两个方法 createApp 和 createComponent 来分别创建程序和组件（页面）。createApp 的实现非常简单</p>
</blockquote>
</li>
</ul>
<p>createComponent 方法主要做了这样几件事情：</p>
<ul>
<li>将组件的 state 转换成小程序组件配置对象的 data</li>
<li>将组件的生命周期对应到小程序组件的生命周期</li>
<li>将组件的事件处理函数对应到小程序的事件处理函数</li>
</ul>
<h3 id="7-2-组件-state-转换"><a href="#7-2-组件-state-转换" class="headerlink" title="7.2 组件 state 转换"></a>7.2 组件 state 转换</h3><p>其实在 Taro（React） 组件里，除了组件的 state，JSX 里还可以访问 props 、render 函数里定义的值、以及任何作用域上的成员。而在小程序中，与模板绑定的数据均来自对应页面（或组件）的 data。因此 JSX 模板里访问到的数据都会对应到小程序组件的 data 上。接下来我们通过列表渲染的例子来说明 state 和 data 是如何对应的…</p>
<p>在 JSX 里访问 state</p>
<blockquote>
<p>在小程序的组件上使用 wx:for 绑定一个数组，就可以实现循环渲染。例如，在 Taro 里你可能会这么写：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.list.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>)&#125;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后的小程序组件模板：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;view wx:<span class="keyword">for</span>=<span class="string">&quot;&#123;&#123;list&#125;&#125;&quot;</span> wx:<span class="keyword">for</span>-item=<span class="string">&quot;item&quot;</span>&gt;</span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<p>其中 state.list 只需直接对应到小程序（页面）组件的 data.list 上即可…</p>
<p>在 render 里生成了新的变量</p>
<p>然而事情通常没有那么简单，在 Taro 里也可以这么用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.list.map(<span class="function"><span class="params">item</span> =&gt;</span> ++item).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span>)&#125;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后的小程序组件模板是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;view wx:<span class="keyword">for</span>=<span class="string">&quot;&#123;&#123;$anonymousCallee_1&#125;&#125;&quot;</span> wx:<span class="keyword">for</span>-item=<span class="string">&quot;item&quot;</span>&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在编译时会给 Taro 组件创建一个 _createData 的方法，里面会生成 $anonymousCallee_1 这个变量， $anonymousCallee<strong>1 是由编译器生成的，对 this.state.list 进行相关操作后的变量。 $anonymousCallee</strong>1 最终会被放到组件的 data 中给模板调用：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $anonymousCallee_1 = <span class="built_in">this</span>.state.list.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++item;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>render 里 return 之前的所有定义变量或者对 props、state 计算产生新变量的操作，都会被编译到 _createData 方法里执行，这一点在前面 JSX 编译成小程序模板的相关文章中已经提到。每当 Taro 调用 this.setState API 来更新数据时，都会调用生成的 _createData 来获取最新数据…</p>
</blockquote>
<h3 id="7-3-将组件的生命周期对应到小程序组件的生命周期"><a href="#7-3-将组件的生命周期对应到小程序组件的生命周期" class="headerlink" title="7.3 将组件的生命周期对应到小程序组件的生命周期"></a>7.3 将组件的生命周期对应到小程序组件的生命周期</h3><blockquote>
<p>初始化过程里的生命周期对应很简单，在小程序的生命周期回调函数里调用 Taro 组件里对应的生命周期函数即可，例如：小程序组件 ready 的回调函数里会调用 Taro 组件的 componentDidMount 方法。它们的执行过程和对应关系如下图…</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/88595/18/7355/40049/5dfb4602E7f9b20b7/8a7e4b779f5c9422.jpg"></p>
<p>小程序页面的 componentWillMount 有一点特殊，会有两种初始化方式。由于小程序的页面需要等到 onLoad 之后才可以获取到页面的路由参数，因此如果是启动页面，会等到 onLoad 时才会触发。而对于小程序内部通过 navigateTo 等 API 跳转的页面，Taro 做了一个兼容，调用 navigateTo 时将页面参数存储在一个全局对象中，在页面 attached 的时候从全局对象里取到，这样就不用等到页面 onLoad 即可获取到路由参数，触发 componentWillMount 生命周期…</p>
<p>状态更新</p>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/106521/3/7426/31329/5dfb463bE58b19784/746931b709b55cfb.jpg"></p>
<ul>
<li>Taro 组件的 setState 行为最终会对应到小程序的 setData。Taro 引入了如 nextTick ，编译时识别模板中用到的数据，在 setData 前进行数据差异比较等方式来提高 setState 的性能。</li>
<li>如上图，组件调用 setState 方法之后，并不会立刻执行组件更新逻辑，而是会将最新的 state 暂存入一个数组中，等 nextTick 回调时才会计算最新的 state 进行组件更新。这样即使连续多次的调用 setState 并不会触发多次的视图更新。在小程序中 nextTick 是这么实现的…</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nextTick = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">  fn = <span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span> ? fn.bind(<span class="literal">null</span>, ...args) : fn</span><br><span class="line">  <span class="keyword">const</span> timerFunc = wx.nextTick ? wx.nextTick : <span class="built_in">setTimeout</span></span><br><span class="line">  timerFunc(fn)</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>除了计算出最新的组件 state ，在组件状态更新过程里还会调用前面提到过的 _createData 方法，得到最终小程序组件的 data，并调用小程序的 setData 方法来进行组件的更新</p>
<h3 id="7-4-事件处理函数对应"><a href="#7-4-事件处理函数对应" class="headerlink" title="7.4 事件处理函数对应"></a>7.4 事件处理函数对应</h3><p>在小程序的组件里，事件响应函数需要配置在 methods 字段里。而在 JSX 里，事件是这样绑定的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;View onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;&lt;/View&gt;</span><br></pre></td></tr></table></figure>

<p>编译的过程会将 JSX 转换成小程序模板：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;view bindclick=<span class="string">&quot;handleClick&quot;</span>&gt;&lt;/view&gt;...</span><br></pre></td></tr></table></figure>

<p>在 createComponent 方法里，会将事件响应函数 handleClick 添加到 methods 字段中，并且在响应函数里调用真正的 this.handleClick 方法。</p>
<p>在编译过程中，会提取模板中绑定过的方法，并存到组件的 $events 字段里，这样在运行时就可以只将用到的事件响应函数配置到小程序组件的 methods 字段中。</p>
<p>在运行时通过 processEvent 这个方法来处理事件的对应，省略掉处理过程，就是这样的…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processEvent</span>(<span class="params">eventHandlerName, obj</span>) </span>&#123;</span><br><span class="line">  obj[eventHandlerName] = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    scope[eventHandlerName].apply(callScope, realArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的核心作用就是解析出事件响应函数执行时真正的作用域 callScope 以及传入的参数。在 JSX 里，我们可以像下面这样通过 bind 传入参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;View onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>, arga, argb)&#125;&gt;&lt;/View&gt;</span><br></pre></td></tr></table></figure>

<p>小程序不支持通过 bind 的方式传入参数，但是小程序可以用 data 开头的方式，将数据传递到 event.currentTarget.dataset 中。编译过程会将 bind 方式传递的参数对应到 dataset 中，processEvent 函数会从 dataset 里取到传入的参数传给真正的事件响应函数。</p>
<p>至此，经过编译之后的 Taro 组件终于可以运行在小程序环境里了…</p>
<h3 id="7-5-对-API-进行-Promise-化的处理"><a href="#7-5-对-API-进行-Promise-化的处理" class="headerlink" title="7.5 对 API 进行 Promise 化的处理"></a>7.5 对 API 进行 Promise 化的处理</h3><blockquote>
<p>Taro 对小程序的所有 API 进行了一个分类整理，将其中的异步 API 做了一层 Promise 化的封装。例如，wx.getStorage 经过下面的处理对应到 Taro.getStorage(此处代码作示例用，与实际源代码不尽相同)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Taro[<span class="string">&#x27;getStorage&#x27;</span>] = <span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, options)</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    [<span class="string">&#x27;fail&#x27;</span>, <span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;complete&#x27;</span>].forEach(<span class="function">(<span class="params">k</span>) =&gt;</span> &#123;</span><br><span class="line">      obj[k] = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        options[k] &amp;&amp; options[k](res)</span><br><span class="line">        <span class="keyword">if</span> (k === <span class="string">&#x27;success&#x27;</span>) &#123;</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k === <span class="string">&#x27;fail&#x27;</span>) &#123;</span><br><span class="line">          reject(res)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    wx[<span class="string">&#x27;getStorage&#x27;</span>](obj)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>就可以这么调用了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小程序的调用方式</span></span><br><span class="line">Taro.getStorage(&#123;</span><br><span class="line">  key: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">success</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在 Taro 里也可以这样调用</span></span><br><span class="line">Taro.getStorage(&#123;</span><br><span class="line">  key: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;)...</span><br></pre></td></tr></table></figure>

<h2 id="八、H5-运行时"><a href="#八、H5-运行时" class="headerlink" title="八、H5 运行时"></a>八、H5 运行时</h2><h3 id="8-1-H5-运行时解析"><a href="#8-1-H5-运行时解析" class="headerlink" title="8.1 H5 运行时解析"></a>8.1 H5 运行时解析</h3><blockquote>
<p>首先，我们选用 Nerv 作为 Web 端的运行时框架。你可能会有问题：同样是类 React 框架，为何我们不直接用 React，而是用 Nerv 呢？<br>为了更快更稳。开发过程中前端框架本身有可能会出现问题。如果是第三方框架，很有可能无法得到及时的修复，导致整个项目的进度受影响。Nerv 就不一样。作为团队自研的产品，出现任何问题我们都可以在团队内部快速得到解决。与此同时，Nerv 也具有与 React 相同的 API，同样使用 Virtual DOM 技术进行优化，正常使用与 React 并没有区别，完全可以满足我们的需要。</p>
</blockquote>
<p>使用 Taro 之后，我们书写的是类似于下图的代码…</p>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/85585/15/7357/213299/5dfb48dbE72b5b45a/30977175349dae04.png"></p>
<p>我们注意到，就算是转换过的代码，也依然存在着 view、button 等在 Web 开发中并不存在的组件。如何在 Web 端正常使用这些组件？这是我们碰到的第一个问题</p>
<h3 id="8-1-1-组件实现"><a href="#8-1-1-组件实现" class="headerlink" title="8.1.1 组件实现"></a>8.1.1 组件实现</h3><p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/94514/10/7444/106813/5dfb4900Ecaea3260/acbb909c42c72547.png"></p>
<p>作为开发者，你第一反应或许会尝试在编译阶段下功夫，尝试直接使用效果类似的 Web 组件替代：用 div 替代 view，用 img 替代 image，以此类推。</p>
<p>费劲心机搞定标签转换之后，上面这个差异似乎是解决了。但很快你就会碰到一些更加棘手的问题：hover-start-time、hover-stay-time 等等这些常规 Web 开发中并不存在的属性要如何处理？</p>
<p>回顾一下：在前面讲到多端转换的时候，我们说到了 babel。在 Taro 中，我们使用 babylon 生成 AST，babel-traverse 去修改和移动 AST 中的节点。但 babel 所做的工作远远不止这些。</p>
<p>我们不妨去 babel 的 playground 看一看代码在转译前后的对比：在使用了@babel/preset-env 的 BUILT-INS 之后，简单的一句源码 new Map()，在 babel 编译后却变成了好几行代码…</p>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/107508/31/1180/104356/5dfb4930Eca3a9a65/17016a525139f5d7.png"></p>
<p>注意看这几个文件：core-js/modules/web.dom.iterable，core-js/modules/es6.array.iterator，core-js/modules/es6.map。我们可以在 core-js 的 Git 仓库找到他们的真身。很明显，这几个模块就是对应的 es 特性运行时的实现。</p>
<p>从某种角度上讲，我们要做的事情和 babel 非常像。babel 把基于新版 ECMAScript 规范的代码转换为基于旧 ECMAScript 规范的代码，而 Taro 希望把基于 React 语法的代码转换为小程序的语法。我们从 babel 受到了启发：既然 babel 可以通过运行时框架来实现新特性，那我们也同样可以通过运行时代码，实现上面这些 Web 开发中不存在的功能。</p>
<p>举个例子。对于 view 组件，首先它是个普通的类 React 组件，它把它的子组件如实展示出来…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Nerv, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;nervjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;<span class="built_in">this</span>.props.children&#125;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来，我们需要对 hover-start-time 做处理。与 Taro 其他地方的命名规范一致，我们这个 View 组件接受的属性名将会是驼峰命名法：hoverStartTime。hoverStartTime 参数决定我们将在 View 组件触发 touch 事件多久后改变组件的样式…</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    hoverStartTime = <span class="number">50</span>,</span><br><span class="line">    onTouchStart</span><br><span class="line">  &#125; = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> _onTouchStart = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// @TODO 触发touch样式改变</span></span><br><span class="line">    &#125;, hoverStartTime);</span><br><span class="line">    onTouchStart &amp;&amp; onTouchStart(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div onTouchStart=&#123;_onTouchStart&#125;&gt;</span><br><span class="line">      &#123;<span class="built_in">this</span>.props.children&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>再稍加修饰，我们就能得到一个功能完整的 Web 版 View 组件</p>
<p>view 可以说是小程序最简单的组件之一了。text 的实现甚至比上面的代码还要简单得多。但这并不说明组件的实现之路上就没有障碍。复杂如 swiper，scroll-view，tabbar，我们需要花费大量的精力分析小程序原生组件的 API，交互行为，极端值处理，接受的属性等等，再通过 Web 技术实现。…</p>
<h3 id="8-2-API-适配"><a href="#8-2-API-适配" class="headerlink" title="8.2 API 适配"></a>8.2 API 适配</h3><blockquote>
<p>除了组件，小程序下有一些 API 也是 Web 开发中所不具备的。比如小程序框架内置的 wx.request/wx.getStorage 等 API；但在 Web 开发中，我们使用的是 fetch/localStorage 等内置的函数或者对象</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/106825/8/7473/124175/5dfb4985E4d2133de/82548ed913b69f37.png"></p>
<p>小程序的 API 实现是个巨大的黑盒，我们仅仅知道如何使用它，使用它会得到什么结果，但对它内部的实现一无所知。</p>
<p>如何让 Web 端也能使用小程序框架中提供的这些功能？既然已经知道这个黑盒的入参出参情况，那我们自己打造一个黑盒就好了。</p>
<p>换句话说，我们依然通过运行时框架来实现这些 Web 端不存在的能力。</p>
<p>具体说来，我们同样需要分析小程序原生 API，最后通过 Web 技术实现。有兴趣可以在 Git 仓库中看到这些原生 API 的实现。下面以 wx.setStorage 为例进行简单解析。</p>
<p>wx.setStorage 是一个异步接口，可以把 key: value 数据存储在本地缓存。很容易联想到，在 Web 开发中也有类似的数据存储概念，这就是 localStorage。到这里，我们的目标已经十分明确：我们需要借助于 localStorage，实现一个与 wx.setStorage 相同的 API。…</p>
<blockquote>
<p>而在 Web 中，如果我们需要往本地存储写入数据，使用的 API 是 localStorage.setItem(key, value)。我们很容易就可以构思出这个函数的雏形</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setStorage</span>(<span class="params">&#123; key, value &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">localStorage</span>.setItem(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们顺手做点优化，把基于异步回调的 API 都给做了一层 Promise 包装，这可以让代码的流程处理更加方便。所以这段代码看起来会像下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setStorage</span>(<span class="params">&#123; key, value &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">localStorage</span>.setItem(key, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">errMsg</span>: <span class="string">&#x27;setStorage:ok&#x27;</span> &#125;);</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>看起来很完美，但开发的道路不会如此平坦。我们还需要处理其余的入参：success、fail 和 complete。success 回调会在操作成功完成时调用，fail 会在操作失败的时候执行，complete 则无论如何都会执行。setStorage 函数只会在 key 值是 String 类型时有正确的行为，所以我们为这个函数添加了一个简单的类型判断，并在异常情况下执行 fail 回调。经过这轮变动，这段代码看起来会像下面这样…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setStorage</span>(<span class="params">&#123; key, value, success, fail, complete &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123; <span class="attr">errMsg</span>: <span class="string">&#x27;setStorage:ok&#x27;</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(key, value);</span><br><span class="line">    success &amp;&amp; success(res);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fail &amp;&amp; fail(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(res);</span><br><span class="line">  &#125;</span><br><span class="line">  complete &amp;&amp; complete(res);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">errMsg</span>: <span class="string">&#x27;setStorage:ok&#x27;</span> &#125;);</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>把这个 API 实现挂载到 Taro 模块之后，我们就可以通过 Taro.setStorage 来调用这个 API 了。</p>
<p>当然，也有一些 API 是 Web 端无论如何无法实现的，比如 wx.login，又或者 wx.scanCode。我们维护了一个 API 实现情况的列表，在实际的多端项目开发中应该尽可能避免使用它们…</p>
<h3 id="8-3-路由"><a href="#8-3-路由" class="headerlink" title="8.3 路由"></a>8.3 路由</h3><blockquote>
<p>作为小程序的一大能力，小程序框架中以栈的形式维护了当前所有的页面，由框架统一管理。用户只需要调用 wx.navigateTo,wx.navigateBack,wx.redirectTo 等官方 API，就可以实现页面的跳转、回退、重定向，而不需要关心页面栈的细节。但是作为多端项目，当我们…</p>
</blockquote>
<p>小程序的路由比较轻量。使用时，我们先通过 app.json 为小程序配置页面列表:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;pages&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pages/logs/logs&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在运行时，小程序内维护了一个页面栈，始终展示栈顶的页面（Page 对象）。当用户进行跳转、后退等操作时，相应的会使页面栈进行入栈、出栈等操作<br>同时，在页面栈发生路由变化时，还会触发相应页面的生命周期</p>
</blockquote>
<p>对于 Web 端单页应用路由，我们则以 react-router 为例进行说明</p>
<ul>
<li>首先，react-router 开始通过 history 工具监听页面路径的变化。</li>
<li>在页面路径发生变化时，react-router 会根据新的 location 对象，触发 UI 层的更新。</li>
<li>至于 UI 层如何更新，则是取决于我们在 Route 组件中对页面路径和组件的绑定，甚至可以实现嵌套路由。</li>
<li>可以说，react-router 的路由方案是组件级别的。</li>
<li>具体到 Taro，为了保持跟小程序的行为一致，我们不需要细致到组件级别的路由方案，但需要为每次路由保存完整的页面栈。</li>
<li>实现形式上，我们参考 react-router：监听页面路径变化，再触发 UI 更新。这是 React 的精髓之一，单向数据流…</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/85653/15/7454/12059/5dfb4a06Ed6a96cb0/9f223d0aecac549c.png"></p>
<blockquote>
<p>@tarojs/router 包中包含了一个轻量的 history 实现。history 中维护了一个栈，用来记录页面历史的变化。对历史记录的监听，依赖两个事件：hashchange 和 popstate。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例代码 */</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;popstate&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>对于使用 Hash 模式的页面路由，每次页面跳转都会依次触发 popstate 和 hashchange 事件。由于在 popstate 的回调中可以取到当前页面的 state，我们选择它作为主要跳转逻辑的容器。</li>
<li>作为 UI 层，@tarojs/router 包提供了一个 Router 组件，维护页面栈。与小程序类似，用户不需要手动调用 Router 组件，而是由 Taro 自动处理。</li>
<li>对于历史栈来说，无非就是三种操作：push, pop，还有 replace。在历史栈变动时触发 Router 的回调，就可以让 Router 也同步变化。这就是 Taro 中路由的基本原理…</li>
</ul>
<h3 id="8-4-Redux-处理"><a href="#8-4-Redux-处理" class="headerlink" title="8.4 Redux 处理"></a>8.4 Redux 处理</h3><ul>
<li>每当提到 React 的数据流，我们就不得不提到 Redux。通过合并 Reducer，Redux 可以让大型应用中的数据流更加规则、可预测。</li>
<li>我们在 Taro 中加入了 Redux 的支持，通过导入@tarojs/redux，即可在小程序端使用 Redux 的功能。</li>
<li>对于 Web 端，我们尝试直接使用 nerv-redux 包提供支持，但这会带来一些问题…</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Nerv <span class="keyword">from</span> <span class="string">&#x27;nervjs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;nerv-redux&#x27;</span></span><br><span class="line"></span><br><span class="line">@connect(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Nerv</span>.<span class="title">Componnet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentDidShow</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;didShow&#x27;</span>) &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;didMount&#x27;</span>) &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<ul>
<li>回想一下前面讲的 componentDidShow 的实现：我们继承，并且改写 componentDidMount。</li>
<li>但是对于使用 Redux 的页面来说，我们继承的类，是经过@connect 修饰过的一个高阶组件。</li>
<li>问题就出在这里：这个高阶组件的签名里并没有 componentDidShow 这一个函数。所以我们的 componentDidMount 内，理所当然是取不到 componentDidShow 的。</li>
<li>为了解决这个问题，我们对 react-redux 代码进行了一些小改装，这就是@taro/redux-h5 的由来…</li>
</ul>
<h2 id="九、更多参考"><a href="#九、更多参考" class="headerlink" title="九、更多参考"></a>九、更多参考</h2><p>Taro 官方文档 <a href="https://taro.aotu.io/home/in.html">https://taro.aotu.io/home/in.html</a></p>
<h2 id="十、官方文档"><a href="#十、官方文档" class="headerlink" title="十、官方文档"></a>十、官方文档</h2><p>Taro 小册子 <a href="https://git.jd.com/huangli47/taro-ebook/tree/master/ebook">https://git.jd.com/huangli47/taro-ebook/tree/master/ebook</a></p>
]]></content>
  </entry>
  <entry>
    <title>Taro(二)</title>
    <url>/2020/10/17/Taro(%E4%BA%8C)/</url>
    <content><![CDATA[<h2 id="四、CLI-原理及不同端的运行机制"><a href="#四、CLI-原理及不同端的运行机制" class="headerlink" title="四、CLI 原理及不同端的运行机制"></a>四、CLI 原理及不同端的运行机制</h2><h3 id="4-1-taro-cli-包"><a href="#4-1-taro-cli-包" class="headerlink" title="4.1 taro-cli 包"></a>4.1 taro-cli 包</h3><h4 id="4-1-1-Taro-命令"><a href="#4-1-1-Taro-命令" class="headerlink" title="4.1.1 Taro 命令"></a>4.1.1 Taro 命令</h4><blockquote>
<p>taro-cli 包位于 Taro 工程的 Packages 目录下，通过 npm install -g @tarojs/cli 全局安装后，将会生成一个 Taro 命令。主要负责项目初始化、编译、构建等。直接在命令行输入 Taro ，会看到如下提示…</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">➜ taro</span><br><span class="line">👽 Taro v0<span class="number">.0</span><span class="number">.63</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Usage: taro &lt;command&gt; [options]</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    -V, --version       output the version number</span><br><span class="line">    -h, --help          output usage information</span><br><span class="line"></span><br><span class="line">  Commands:</span><br><span class="line"></span><br><span class="line">    init [projectName]  Init a project <span class="keyword">with</span> <span class="keyword">default</span> templete</span><br><span class="line">    build               Build a project <span class="keyword">with</span> options</span><br><span class="line">    update              Update packages <span class="keyword">of</span> taro</span><br><span class="line">    help [cmd]          display help <span class="keyword">for</span> [cmd]...</span><br></pre></td></tr></table></figure>

<p>里面包含了 Taro 所有命令用法及作用。</p>
<h4 id="4-1-2-包管理与发布"><a href="#4-1-2-包管理与发布" class="headerlink" title="4.1.2 包管理与发布"></a>4.1.2 包管理与发布</h4><ul>
<li>首先，我们需要了解 taro-cli 包与 Taro 工程的关系。</li>
<li>将 Taro 工程 Clone 之后，可以看到工程的目录结构如下，整体结构还是比较清晰的：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CHANGELOG.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── build</span><br><span class="line">├── docs</span><br><span class="line">├── lerna-debug.log</span><br><span class="line">├── lerna.json        <span class="comment">// Lerna 配置文件</span></span><br><span class="line">├── package.json</span><br><span class="line">├── packages</span><br><span class="line">│   ├── eslint-config-taro</span><br><span class="line">│   ├── eslint-plugin-taro</span><br><span class="line">│   ├── postcss-plugin-constparse</span><br><span class="line">│   ├── postcss-pxtransform</span><br><span class="line">│   ├── taro</span><br><span class="line">│   ├── taro-<span class="keyword">async</span>-<span class="keyword">await</span></span><br><span class="line">│   ├── taro-cli</span><br><span class="line">│   ├── taro-components</span><br><span class="line">│   ├── taro-components-rn</span><br><span class="line">│   ├── taro-h5</span><br><span class="line">│   ├── taro-plugin-babel</span><br><span class="line">│   ├── taro-plugin-csso</span><br><span class="line">│   ├── taro-plugin-sass</span><br><span class="line">│   ├── taro-plugin-uglifyjs</span><br><span class="line">│   ├── taro-redux</span><br><span class="line">│   ├── taro-redux-h5</span><br><span class="line">│   ├── taro-rn</span><br><span class="line">│   ├── taro-rn-runner</span><br><span class="line">│   ├── taro-router</span><br><span class="line">│   ├── taro-transformer-wx</span><br><span class="line">│   ├── taro-weapp</span><br><span class="line">│   └── taro-webpack-runner</span><br><span class="line">└── yarn.lock...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Taro 项目主要是由一系列 NPM 包组成，位于工程的 Packages 目录下。它的包管理方式和 Babel 项目一样，将整个项目作为一个 monorepo 来进行管理，并且同样使用了包管理工具 Lerna</p>
</blockquote>
<p>Packages 目录下十几个包中，最常用的项目初始化与构建的命令行工具 Taro CLI 就是其中一个。在 Taro 工程根目录运行 lerna publish 命令之后，lerna.json 里面配置好的所有的包会被发布到 NPM 上</p>
<h4 id="4-1-3-taro-cli-包的目录结构如下"><a href="#4-1-3-taro-cli-包的目录结构如下" class="headerlink" title="4.1.3 taro-cli 包的目录结构如下"></a>4.1.3 taro-cli 包的目录结构如下</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">./</span><br><span class="line">├── bin        <span class="comment">// 命令行</span></span><br><span class="line">│   ├── taro              <span class="comment">// taro 命令</span></span><br><span class="line">│   ├── taro-build        <span class="comment">// taro build 命令</span></span><br><span class="line">│   ├── taro-update       <span class="comment">// taro update 命令</span></span><br><span class="line">│   └── taro-init         <span class="comment">// taro init 命令</span></span><br><span class="line">├── package.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── src</span><br><span class="line">│   ├── build.js        <span class="comment">// taro build 命令调用，根据 type 类型调用不同的脚本</span></span><br><span class="line">│   ├── config</span><br><span class="line">│   │   ├── babel.js        <span class="comment">// Babel 配置</span></span><br><span class="line">│   │   ├── babylon.js      <span class="comment">// JavaScript 解析器 babylon 配置</span></span><br><span class="line">│   │   ├── browser_list.js <span class="comment">// autoprefixer browsers 配置</span></span><br><span class="line">│   │   ├── index.js        <span class="comment">// 目录名及入口文件名相关配置</span></span><br><span class="line">│   │   └── uglify.js</span><br><span class="line">│   ├── creator.js</span><br><span class="line">│   ├── h5.js       <span class="comment">// 构建h5 平台代码</span></span><br><span class="line">│   ├── project.js  <span class="comment">// taro init 命令调用，初始化项目</span></span><br><span class="line">│   ├── rn.js       <span class="comment">// 构建React Native 平台代码</span></span><br><span class="line">│   ├── util        <span class="comment">// 一系列工具函数</span></span><br><span class="line">│   │   ├── index.js</span><br><span class="line">│   │   ├── npm.js</span><br><span class="line">│   │   └── resolve_npm_files.js</span><br><span class="line">│   └── weapp.js        <span class="comment">// 构建小程序代码转换</span></span><br><span class="line">├── templates           <span class="comment">// 脚手架模版</span></span><br><span class="line">│   └── <span class="keyword">default</span></span><br><span class="line">│       ├── appjs</span><br><span class="line">│       ├── config</span><br><span class="line">│       │   ├── dev</span><br><span class="line">│       │   ├── index</span><br><span class="line">│       │   └── prod</span><br><span class="line">│       ├── editorconfig</span><br><span class="line">│       ├── eslintrc</span><br><span class="line">│       ├── gitignor...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过上面的目录树可以发现，taro-cli 工程的文件并不算多，主要目录有：/bin、/src、/template</p>
</blockquote>
<h3 id="4-2-用到的核心库"><a href="#4-2-用到的核心库" class="headerlink" title="4.2 用到的核心库"></a>4.2 用到的核心库</h3><ul>
<li>tj/commander.js Node.js - 命令行接口全面的解决方案</li>
<li>jprichardson/node-fs-extra - 在 Node.js 的 fs 基础上增加了一些新的方法，更好用，还可以拷贝模板。</li>
<li>chalk/chalk - 可以用于控制终端输出字符串的样式</li>
<li>SBoudrias/Inquirer.js - Node.js 命令行交互工具，通用的命令行用户界面集合，可以和用户进行交互</li>
<li>sindresorhus/ora - 实现加载中的状态是一个 Loading 加前面转起来的小圈圈，成功了是一个 Success 加前面一个小钩钩</li>
<li>SBoudrias/mem-fs-editor - 提供一系列 API，方便操作模板文件</li>
<li>shelljs/shelljs - ShellJS 是 Node.js 扩展，用于实现 Unix shell 命令执行。</li>
</ul>
<h3 id="4-3-Taro-Init"><a href="#4-3-Taro-Init" class="headerlink" title="4.3 Taro Init"></a>4.3 Taro Init</h3><p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/88040/24/7314/51974/5dfb311bEef964024/24ef0e40d268b7fc.png"></p>
<blockquote>
<p>当我们全局安装 taro-cli 包之后，我们的命令行里就有了 Taro 命令</p>
</blockquote>
<ul>
<li>那么 Taro 命令是怎样添加进去的呢？其原因在于 package.json 里面的 bin 字段：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;bin&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;taro&quot;</span>: <span class="string">&quot;bin/taro&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码指定，Taro 命令对应的可执行文件为 bin/taro 。NPM 会寻找这个文件，在 [prefix]/bin 目录下建立符号链接。在上面的例子中，Taro 会建立符号链接 [prefix]/bin/taro。由于 [prefix]/bin 目录会在运行时加入系统的 PATH 变量，因此在运行 NPM 时，就可以不带路径，直接通过命令来调用这些脚本。</p>
<ul>
<li>关于 prefix，可以通过 npm config get prefix 获取。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm config get prefix</span><br><span class="line">/usr/local</span><br></pre></td></tr></table></figure>

<p>通过下列命令可以更加清晰的看到它们之间的符号链接…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ ls -al <span class="string">`which taro`</span></span><br><span class="line">lrwxr-xr-x  <span class="number">1</span> chengshuai  admin  <span class="number">40</span>  <span class="number">6</span> <span class="number">15</span> <span class="number">10</span>:<span class="number">51</span> /usr/local/bin/taro -&gt; ../lib/node_modules/@tarojs/cli/bin/taro...</span><br></pre></td></tr></table></figure>

<h4 id="4-3-1-命令关联与参数解析"><a href="#4-3-1-命令关联与参数解析" class="headerlink" title="4.3.1 命令关联与参数解析"></a>4.3.1 命令关联与参数解析</h4><blockquote>
<p>这里就不得不提到一个有用的包：tj/commander.js ，Node.js 命令行接口全面的解决方案，灵感来自于 Ruby’s commander。可以自动的解析命令和参数，合并多选项，处理短参等等，功能强大，上手简单</p>
</blockquote>
<p>更主要的，commander 支持 Git 风格的子命令处理，可以根据子命令自动引导到以特定格式命名的命令执行文件，文件名的格式是 [command]-[subcommand]，例如</p>
<ul>
<li>taro init =&gt; taro-init</li>
<li>taro build =&gt; taro-build</li>
<li>/bin/taro 文件内容不多，核心代码也就那几行 .command() 命令：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;getPkgVersion&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../src/util&#x27;</span>)</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .version(getPkgVersion())</span><br><span class="line">  .usage(<span class="string">&#x27;&lt;command&gt; [options]&#x27;</span>)</span><br><span class="line">  .command(<span class="string">&#x27;init [projectName]&#x27;</span>, <span class="string">&#x27;Init a project with default templete&#x27;</span>)</span><br><span class="line">  .command(<span class="string">&#x27;build&#x27;</span>, <span class="string">&#x27;Build a project with options&#x27;</span>)</span><br><span class="line">  .command(<span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;Update packages of taro&#x27;</span>)</span><br><span class="line">  .parse(process.argv)...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过上面代码可以发现，init，build ，update 等命令都是通过.command(name, description)方法定义的，然后通过 .parse(arg) 方法解析参数</p>
</blockquote>
<h4 id="4-3-2-参数解析及与用户交互"><a href="#4-3-2-参数解析及与用户交互" class="headerlink" title="4.3.2 参数解析及与用户交互"></a>4.3.2 参数解析及与用户交互</h4><ul>
<li>commander 包可以自动解析命令和参数，在配置好命令之后，还能够自动生成 help（帮助）命令和 version（版本查看） 命令。并且通过 program.args 便可以获取命令行的参数，然后再根据参数来调用不同的脚本。</li>
<li>但当我们运行 taro init 命令后，如下所示的命令行交互又是怎么实现的呢？…</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ taro init taroDemo</span><br><span class="line">Taro 即将创建一个新项目!</span><br><span class="line">Need help? Go and open issue: https:<span class="comment">//github.com/NervJS/taro/issues/new</span></span><br><span class="line"></span><br><span class="line">Taro v0<span class="number">.0</span><span class="number">.50</span></span><br><span class="line"></span><br><span class="line">? 请输入项目介绍！</span><br><span class="line">? 请选择模板 默认模板...</span><br></pre></td></tr></table></figure>

<p>这里使用的是 SBoudrias/Inquirer.js 来处理命令行交互。</p>
<p>用法其实很简单</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">&#x27;inquirer&#x27;</span>)  <span class="comment">// npm i inquirer -D</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> conf.description !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      prompts.push(&#123;</span><br><span class="line">        type: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;description&#x27;</span>,</span><br><span class="line">        message: <span class="string">&#x27;请输入项目介绍！&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<ul>
<li>prompt()接受一个问题对象的数据，在用户与终端交互过程中，将用户的输入存放在一个答案对象中，然后返回一个 Promise，通过 then()获取到这个答案对象。<br>借此，新项目的名称、版本号、描述等信息可以直接通过终端交互插入到项目模板中，完善交互流程。</li>
<li>当然，交互的问题不仅限于此，可以根据自己项目的情况，添加更多的交互问题。inquirer.js 强大的地方在于，支持很多种交互类型，除了简单的 input，还有 confirm、list、password、checkbox 等，具体可以参见项目的工程 README。<br>此外，你在执行异步操作的过程中，还可以使用 sindresorhus/ora 来添加一下 Loading 效果。使用 chalk/chalk 给终端的输出添加各种样式…</li>
</ul>
<h4 id="4-3-3-模版文件操作"><a href="#4-3-3-模版文件操作" class="headerlink" title="4.3.3 模版文件操作"></a>4.3.3 模版文件操作</h4><p>最后就是模版文件操作了，主要分为两大块：</p>
<ul>
<li>将输入的内容插入到模板中</li>
<li>根据命令创建对应目录结构，copy 文件</li>
<li>更新已存在文件内容</li>
</ul>
<blockquote>
<p>这些操作基本都是在 /template/index.js 文件里。<br>这里还用到了 shelljs/shelljs 执行 shell 脚本，如初始化 Git： git init，项目初始化之后安装依赖 npm install 等</p>
</blockquote>
<p>拷贝模板文件</p>
<p>拷贝模版文件主要是使用 jprichardson/node-fs-extra 的 copyTpl()方法，此方法使用 ejs 模板语法，可以将输入的内容插入到模版的对应位置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.fs.copyTpl(</span><br><span class="line">  project,</span><br><span class="line">  path.join(projectPath, <span class="string">&#x27;project.config.json&#x27;</span>),</span><br><span class="line">  &#123;description, projectName&#125;</span><br><span class="line">);...</span><br></pre></td></tr></table></figure>

<h3 id="4-4-Taro-Build"><a href="#4-4-Taro-Build" class="headerlink" title="4.4 Taro Build"></a>4.4 Taro Build</h3><ul>
<li>taro build 命令是整个 Taro 项目的灵魂和核心，主要负责多端代码编译（H5，小程序，React Native 等）。</li>
<li>Taro 命令的关联，参数解析等和 taro init 其实是一模一样的，那么最关键的代码转换部分是怎样实现的呢？…</li>
</ul>
<h4 id="4-4-1-编译工作流与抽象语法树（AST）"><a href="#4-4-1-编译工作流与抽象语法树（AST）" class="headerlink" title="4.4.1 编译工作流与抽象语法树（AST）"></a>4.4.1 编译工作流与抽象语法树（AST）</h4><blockquote>
<p>Taro 的核心部分就是将代码编译成其他端（H5、小程序、React Native 等）代码。一般来说，将一种结构化语言的代码编译成另一种类似的结构化语言的代码包括以下几个步骤</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/96906/16/7374/30011/5dfb338eE70cc9fd9/efe8147142d6aa89.png"></p>
<p>首先是 Parse，将代码解析（Parse）成抽象语法树（Abstract Syntex Tree），然后对 AST 进行遍历（traverse）和替换(replace)（这对于前端来说其实并不陌生，可以类比 DOM 树的操作），最后是生成（generate），根据新的 AST 生成编译后的代码…</p>
<h4 id="4-4-2-Babel-模块"><a href="#4-4-2-Babel-模块" class="headerlink" title="4.4.2 Babel 模块"></a>4.4.2 Babel 模块</h4><p>Babel 是一个通用的多功能的 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做转换编译器（transpiler）。 意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码…</p>
<h4 id="4-4-3-解析页面-Config-配置"><a href="#4-4-3-解析页面-Config-配置" class="headerlink" title="4.4.3 解析页面 Config 配置"></a>4.4.3 解析页面 Config 配置</h4><blockquote>
<p>在业务代码编译成小程序的代码过程中，有一步是将页面入口 JS 的 Config 属性解析出来，并写入 *.json 文件，供小程序使用。那么这一步是怎么实现的呢？这里将这部分功能的关键代码抽取出来：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. babel-traverse方法， 遍历和更新节点</span></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="function"><span class="title">ClassProperty</span>(<span class="params">astPath</span>)</span> &#123; <span class="comment">// 遍历类的属性声明</span></span><br><span class="line">    <span class="keyword">const</span> node = astPath.node</span><br><span class="line">    <span class="keyword">if</span> (node.key.name === <span class="string">&#x27;config&#x27;</span>) &#123; <span class="comment">// 类的属性名为 config</span></span><br><span class="line">      configObj = traverseObjectNode(node)</span><br><span class="line">      astPath.remove() <span class="comment">// 将该方法移除掉</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 遍历，解析为 JSON 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseObjectNode</span>(<span class="params">node, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="string">&#x27;ClassProperty&#x27;</span> || node.type === <span class="string">&#x27;ObjectProperty&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> properties = node.value.properties</span><br><span class="line">      obj = &#123;&#125;</span><br><span class="line">      properties.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">        obj[p.key.name] = traverseObjectNode(p.value)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="string">&#x27;ObjectExpression&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> properties = node.properties</span><br><span class="line">    obj = &#123;&#125;</span><br><span class="line">    properties.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// const t = require(&#x27;babel-types&#x27;)  AST 节点的 Lodash 式工具库</span></span><br><span class="line">      <span class="keyword">const</span> key = t.isIdentifier(p.key) ? p.key.name : p.key.value</span><br><span class="line">      obj[key] = traverseObjectNode(p.value)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="string">&#x27;ArrayExpression&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.elements.map(<span class="function"><span class="params">item</span> =&gt;</span> traverseObjectNode(item))</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<h2 id="五、Taro-组件库及-API-的设计与适配"><a href="#五、Taro-组件库及-API-的设计与适配" class="headerlink" title="五、Taro 组件库及 API 的设计与适配"></a>五、Taro 组件库及 API 的设计与适配</h2><h3 id="5-1-多端差异"><a href="#5-1-多端差异" class="headerlink" title="5.1 多端差异"></a>5.1 多端差异</h3><h4 id="5-1-1-组件差异"><a href="#5-1-1-组件差异" class="headerlink" title="5.1.1 组件差异"></a>5.1.1 组件差异</h4><p>小程序、H5 以及快应用都可以划分为 XML 类，React Native 归为 JSX 类，两种语言风牛马不相及，给适配设置了非常大的障碍。XML 类有个明显的特点是关注点分离（Separation of Concerns），即语义层（XML）、视觉层（CSS）、交互层（JavaScript）三者分离的松耦合形式，JSX 类则要把三者混为一体，用脚本来包揽三者的工作…</p>
<p>不同端的组件的差异还体现在定制程度上</p>
<ul>
<li>H5 标签（组件）提供最基础的功能——布局、表单、媒体、图形等等；</li>
<li>小程序组件相对 H5 有了一定程度的定制，我们可以把小程序组件看作一套类似于 H5 的 UI 组件库；</li>
<li>React Native 端组件也同样如此，而且基本是专“组”专用的，比如要触发点击事件就得用 Touchable 或者 Text 组件，要渲染文本就得用 Text 组件（虽然小程序也提供了 Text 组件，但它的文本仍然可以直接放到 view 之类的组件里）…</li>
</ul>
<h4 id="5-1-2-API-差异"><a href="#5-1-2-API-差异" class="headerlink" title="5.1.2 API 差异"></a>5.1.2 API 差异</h4><p>各端 API 的差异具有定制化、接口不一、能力限制的特点</p>
<ul>
<li>定制化：各端所提供的 API 都是经过量身打造的，比如小程序的开放接口类 API，完全是针对小程序所处的微信环境打造的，其提供的功能以及外在表现都已由框架提供实现，用户上手可用，毋须关心内部实现。</li>
<li>接口不一：相同的功能，在不同端下的调用方式以及调用参数等也不一样，比如 socket，小程序中用 wx.connectSocket 来连接，H5 则用 new WebSocket() 来连接，这样的例子我们可以找到很多个。</li>
<li>能力限制：各端之间的差异可以进行定制适配，然而并不是所有的 API（此处特指小程序 API，因为多端适配是向小程序看齐的）在各个端都能通过定制适配来实现，因为不同端所能提供的端能力“大异小同”，这是在适配过程中不可抗拒、不可抹平的差异…</li>
</ul>
<h3 id="5-2-多端适配"><a href="#5-2-多端适配" class="headerlink" title="5.2 多端适配"></a>5.2 多端适配</h3><h4 id="5-2-1-样式处理"><a href="#5-2-1-样式处理" class="headerlink" title="5.2.1 样式处理"></a>5.2.1 样式处理</h4><p>H5 端使用官方提供的 WEUI 进行适配，React Native 端则在组件内添加样式，并通过脚本来控制一些状态类的样式，框架核心在编译的时候把源代码的 class 所指向的样式通过 css-to-react-native 进行转译，所得 StyleSheet 样式传入组件的 style 参数，组件内部会对样式进行二次处理，得到最终的样式…</p>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/104718/12/7499/47989/5dfb3fedE9cfe19c7/d29edbfd298253d4.png"></p>
<p>为什么需要对样式进行二次处理？</p>
<blockquote>
<p>部分组件是直接把传入 style 的样式赋给最外层的 React Native 原生组件，但部分经过层层封装的组件则不然，我们要把容器样式、内部样式和文本样式离析。为了方便解释，我们把这类组件简化为以下的形式：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;View style=&#123;wrapperStyle&#125;&gt;</span><br><span class="line">  &lt;View style=&#123;containerStyle&#125;&gt;</span><br><span class="line">    &lt;Text style=&#123;textStyle&#125;&gt;Hello World&lt;/Text&gt;</span><br><span class="line">  &lt;/View&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设组件有样式 margin-top、background-color 和 font-size，转译传入组件后，就要把分别把它们传到 wrapperStyle、containerStyle 和 textStyle，可参考 ScrollView 的 style 和 contentContainerStyle…</p>
</blockquote>
<h4 id="5-2-2-组件封装"><a href="#5-2-2-组件封装" class="headerlink" title="5.2.2 组件封装"></a>5.2.2 组件封装</h4><blockquote>
<p>组件的封装则是一个“仿制”的过程，利用端提供的原材料，加工成通用的组件，暴露相对统一的调用方式。我们用 <Button /> 这个组件来举例，在小程序端它也许是长这样子的</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">  size=<span class="string">&quot;mini&quot;</span></span><br><span class="line">  plain=&#123;&#123; plain &#125;&#125;</span><br><span class="line">  loading=&#123;&#123; loading &#125;&#125;</span><br><span class="line">  hover-<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;you-hover-me&quot;</span></span><br><span class="line">&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果要实现 H5 端这么一个按钮，大概会像下面这样，在组件内部把小程序的按钮特性实现一遍，然后暴露跟小程序一致的调用方式，就完成了 H5 端一个组件的设计</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">  &#123;...omit(<span class="built_in">this</span>.props, [<span class="string">&#x27;hoverClass&#x27;</span>, <span class="string">&#x27;onTouchStart&#x27;</span>, <span class="string">&#x27;onTouchEnd&#x27;</span>])&#125;</span><br><span class="line">  className=&#123;cls&#125;</span><br><span class="line">  style=&#123;style&#125;</span><br><span class="line">  onClick=&#123;onClick&#125;</span><br><span class="line">  disabled=&#123;disabled&#125;</span><br><span class="line">  onTouchStart=&#123;_onTouchStart&#125;</span><br><span class="line">  onTouchEnd=&#123;_onTouchEnd&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;loading &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;weui-loading&#x27;</span> /&gt;</span></span>&#125;</span><br><span class="line">  &#123;children&#125;</span><br><span class="line">&lt;/button&gt;...</span><br></pre></td></tr></table></figure>

<ul>
<li>其他端的组件适配相对 H5 端来说会更曲折复杂一些，因为 H5 跟小程序的语言较为相似，而其他端需要整合特定端的各种组件，以及利用端组件的特性来实现，比如在 React Native 中实现这个按钮，则需要用到 &lt;Touchable* /&gt;、<View />、<Text />，要实现动画则需要用上 &lt;Animated.View /&gt;，还有就是相对于 H5 和小程序比较容易实现的 touch 事件，在 React Native 中则需要用上 PanResponder 来进行“仿真”，总之就是，因“端”制宜，一切为了最后只需一行代码通行多端！</li>
<li>除了属性支持外，事件回调的参数也需要进行统一，为此，需要在内部进行处理，比如 Input 的 onInput 事件，需要给它造一个类似小程序相同事件的回调参数，比如 { target: { value: text }, detail: { value: text } }，这样，开发者们就可以像下面这样处理回调事件，无需关心中间发生了什么…</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onInputHandler</span>(<span class="params">&#123; target, detail &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target.value, detail.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、JSX-转换微信小程序模板的实现"><a href="#六、JSX-转换微信小程序模板的实现" class="headerlink" title="六、JSX 转换微信小程序模板的实现"></a>六、JSX 转换微信小程序模板的实现</h2><h3 id="6-1-代码的本质"><a href="#6-1-代码的本质" class="headerlink" title="6.1 代码的本质"></a>6.1 代码的本质</h3><blockquote>
<p>不管是任意语言的代码，其实它们都有两个共同点</p>
</blockquote>
<ul>
<li>它们都是由字符串构成的文本</li>
<li>它们都要遵循自己的语言规范</li>
</ul>
<p>第一点很好理解，既然代码是字符串构成的，我们要修改/编译代码的最简单的方法就是使用字符串的各种正则表达式。例如我们要将 JSON 中一个键名 foo 改为 bar，只要写一个简单的正则表达式就能做到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jsonStr.replace(<span class="regexp">/(?&lt;=&quot;)foo(?=&quot;\s*:)/i</span>, <span class="string">&#x27;bar&#x27;</span>)...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译就是把一段字符串改成另外一段字符串</p>
</blockquote>
<h3 id="6-2-Babel"><a href="#6-2-Babel" class="headerlink" title="6.2 Babel"></a>6.2 Babel</h3><blockquote>
<p>JavaScript 社区其实有非常多 parser 实现，比如 Acorn、Esprima、Recast、Traceur、Cherow 等等。但我们还是选择使用 Babel，主要有以下几个原因</p>
</blockquote>
<ul>
<li>Babel 可以解析还没有进入 ECMAScript 规范的语法。例如装饰器这样的提案，虽然现在没有进入标准但是已经广泛使用有一段时间了；</li>
<li>Babel 提供插件机制解析 TypeScript、Flow、JSX 这样的 JavaScript 超集，不必单独处理这些语言；</li>
<li>Babel 拥有庞大的生态，有非常多的文档和样例代码可供参考；</li>
<li>除去 parser 本身，Babel 还提供各种方便的工具库可以优化、生成、调试代码…</li>
</ul>
<p>Babylon（ @babel/parser）</p>
<blockquote>
<p>Babylon 就是 Babel 的 parser。它可以把一段符合规范的 JavaScript 代码输出成一个符合 Esprima 规范的 AST。 大部分 parser 生成的 AST 数据结构都遵循 Esprima 规范，包括 ESLint 的 parser ESTree。这就意味着我们熟悉了 Esprima 规范的 AST 数据结构还能去写 ESLint 插件</p>
</blockquote>
<p>我们可以尝试解析 n * n 这句简单的表达式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">&quot;babylon&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`n * n`</span>;</span><br><span class="line">babylon.parse(code);...</span><br></pre></td></tr></table></figure>

<p>最终 Babylon 会解析成这样的数据结构：<br><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/85776/36/7301/115301/5dfb42c2Eccb38a5f/aa0004a25a7ee488.png"><br>你也可以使用 ASTExploroer 快速地查看代码的 AST</p>
<p>Babel-traverse (@babel/traverse)</p>
<blockquote>
<p>babel-traverse 可以遍历由 Babylon 生成的抽象语法树，并把抽象语法树的各个节点从拓扑数据结构转化成一颗路径（Path）树，Path 表示两个节点之间连接的响应式（Reactive）对象，它拥有添加、删除、替换节点等方法。当你调用这些修改树的方法之后，路径信息也会被更新。除此之外，Path 还提供了一些操作作用域（Scope） 和标识符绑定（Identifier Binding） 的方法可以去做处理一些更精细复杂的需求。可以说 babel-traverse 是使用 Babel 作为编译器最核心的模块…</p>
</blockquote>
<p>让我们尝试一下把一段代码中的 n _ n 变为 x _ x</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">&quot;@babel/parser&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">&quot;babel-traverse&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`function square(n) &#123;</span></span><br><span class="line"><span class="string">  return n * n;</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babylon.parse(code);</span><br><span class="line"></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="function"><span class="title">enter</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      path.node.type === <span class="string">&quot;Identifier&quot;</span> &amp;&amp;</span><br><span class="line">      path.node.name === <span class="string">&quot;n&quot;</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      path.node.name = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);...</span><br></pre></td></tr></table></figure>

<p>Babel-types（@babel/types）</p>
<blockquote>
<p>babel-types 是一个用于 AST 节点的 Lodash 式工具库，它包含了构造、验证以及变换 AST 节点的方法。 该工具库包含考虑周到的工具方法，对编写处理 AST 逻辑非常有用。例如我们之前在 babel-traverse 中改变标识符 n 的代码可以简写为：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">&quot;babel-traverse&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">&quot;babel-types&quot;</span>;</span><br><span class="line"></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="function"><span class="title">enter</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t.isIdentifier(path.node, &#123; <span class="attr">name</span>: <span class="string">&quot;n&quot;</span> &#125;)) &#123;</span><br><span class="line">      path.node.name = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以发现使用 babel-types 能提高我们转换代码的可读性，在配合 TypeScript 这样的静态类型语言后，babel-types 的方法还能提供类型校验的功能，能有效地提高我们转换代码的健壮性和可靠性…</p>
</blockquote>
<h3 id="6-3-实践例子"><a href="#6-3-实践例子" class="headerlink" title="6.3 实践例子"></a>6.3 实践例子</h3><p>以一个简单 Page 页面为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Taro, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;@tarojs/taro&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; View, Text &#125; <span class="keyword">from</span> <span class="string">&#x27;@tarojs/components&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  config = &#123;</span><br><span class="line">    navigationBarTitleText: <span class="string">&#x27;首页&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    numbers: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.onTest()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> oddNumbers = <span class="built_in">this</span>.state.numbers.filter(<span class="function"><span class="params">number</span> =&gt;</span> number &amp; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ScrollView className=<span class="string">&#x27;home&#x27;</span> scrollTop=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">        奇数：</span><br><span class="line">        &#123;</span><br><span class="line">          oddNumbers.map(<span class="function"><span class="params">number</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Text</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span>)</span><br><span class="line">        &#125;</span><br><span class="line">        偶数：</span><br><span class="line">        &#123;</span><br><span class="line">          numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> number % <span class="number">2</span> === <span class="number">0</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Text</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;/ScrollView&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<h4 id="6-3-1-设计思路"><a href="#6-3-1-设计思路" class="headerlink" title="6.3.1 设计思路"></a>6.3.1 设计思路</h4><ul>
<li>Taro 的结构主要分两个方面：运行时和编译时。运行时负责把编译后到代码运行在本不能运行的对应环境中，你可以把 Taro 运行时理解为前端开发当中 polyfill。举例来说，小程序新建一个页面是使用 Page 方法传入一个字面量对象，并不支持使用类。如果全部依赖编译时的话，那么我们要做到事情大概就是把类转化成对象，把 state 变为 data，把生命周期例如 componentDidMount 转化成 onReady，把事件由可能的类函数（Class method）和类属性函数(Class property function) 转化成字面量对象方法（Object property function）等等。</li>
<li>但这显然会让我们的编译时工作变得非常繁重，在一个类异常复杂时出错的概率也会变高。但我们有更好的办法：实现一个 createPage 方法，接受一个类作为参数，返回一个小程序 Page 方法所需要的字面量对象。这样不仅简化了编译时的工作，我们还可以在 createPage 对编译时产出的类做各种操作和优化。通过运行时把工作分离了之后，再编译时我们只需要在文件底部加上一行代码 Page(createPage(componentName)) 即可…</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://m.360buyimg.com/img/jfs/t1/85776/36/7301/115301/5dfb42c2Eccb38a5f/aa0004a25a7ee488.png"></p>
<ul>
<li>回到一开始那段代码，我们定义了一个类属性 config，config 是一个对象表达式（Object Expression），这个对象表达式只接受键值为标识符（Identifier）或字符串，而键名只能是基本类型。这样简单的情况我们只需要把这个对象表达式转换为 JSON 即可。另外一个类属性 state 在 Page 当中有点像是小程序的 data，但它在多数情况不是完整的 data。这里我们不用做过多的操作，babel 的插件 transform-class-proerties 会把它编译到类的构造器中。函数 handleClick 我们交给运行时处理，有兴趣的同学可以跳到 Taro 运行时原理查看具体技术细节。</li>
<li>再来看我们的 render()函数，它的第一行代码通过 filter 把数字数组的所有偶数项都过滤掉，真正用来循环的是 oddNumbers，而 oddNumbers 并没有在 this.state 中，所以我们必须手动把它加入到 this.state。和 React 一样，Taro 每次更新都会调用 render 函数，但和 React 不同的是，React 的 render 是一个创建虚拟 DOM 的方法，而 Taro 的 render 会被重命名为 _createData，它是一个创建数据的方法：在 JSX 使用过的数据都在这里被创建最后放到小程序 Page 或 Component 工厂方法中的 data。最终我们的 render 方法会被编译为…</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">_createData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.__state = <span class="built_in">arguments</span>[<span class="number">0</span>] || <span class="built_in">this</span>.state || &#123;&#125;;</span><br><span class="line">  <span class="built_in">this</span>.__props = <span class="built_in">arguments</span>[<span class="number">1</span>] || <span class="built_in">this</span>.props || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oddNumbers = <span class="built_in">this</span>.__state.numbers.filter(<span class="function"><span class="params">number</span> =&gt;</span> number &amp; <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">Object</span>.assign(<span class="built_in">this</span>.__state, &#123;</span><br><span class="line">    oddNumbers: oddNumbers</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.__state;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<h4 id="6-3-2-WXML-和-JSX"><a href="#6-3-2-WXML-和-JSX" class="headerlink" title="6.3.2 WXML 和 JSX"></a>6.3.2 WXML 和 JSX</h4><p>在 Taro 里 render 的所有 JSX 元素都会在 JavaScript 文件中被移除，它们最终将会编译成小程序的 WXML。每个 WXML 元素和 HTML 元素一样，我们可以把它定义为三种类型：Element、Text、Comment。其中 Text 只有一个属性: 内容（content），它对应的 AST 类型是 JSXText，我们只需要将前文源码中对应字符串的奇数和偶数转换成 Text 即可。而对于 Comment 而言我们可以将它们全部清除，不参与 WXML 的编译。Element 类型有它的名字（tagName）、children、属性（attributes），其中 children 可能是任意 WXML 类型，属性是一个对象，键值和键名都是字符串。我们将把重点放在如何转换成为 WXML 的 Element 类型。</p>
<p>首先我们可以先看 <View className='home'>，它在 AST 中是一个 JSXElement，它的结构和我们定义 Element 类型差不多。我们先将 JSXElement 的 ScrollView 从驼峰式的 JSX 命名转化为短横线（kebab case）风格，className 和 scrollTop 的值分别代表了 JSXAttribute 值的两种类型：StringLiteral 和 JSXExpressionContainer，className 是简单的 StringLiteral 处理起来很方便，scrollTop 处理起来稍微麻烦点，我们需要用两个花括号{} 把内容包起来…</p>
<p>接下来我们再思考一下每一个 JSXElement 出现的位置，你可以发现其实它的父元素只有几种可能性：return、循环、条件（逻辑）表达式。而在上一篇文章中我们提到，babel-traverse 遍历的 AST 类型是响应式的——也就是说只要我们按照 JSXElement 父元素类型的顺序穷举处理这几种可能性，把各种可能性大结果应用到 JSX 元素之后删除掉原来的表达式，最后就可以把一个复杂的 JSX 表达式转换为一个简单的 WXML 数据结构。…</p>
<p>我们先看第一个循环：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oddNumbers.map(<span class="function"><span class="params">number</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Text</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure>

<p>Text 的父元素是一个 map 函数（CallExpression），我们可以把函数的 callee: oddNumbers 作为 wx:for 的值，并把它放到 state 中，匿名函数的第一个参数是 wx:for-item 的值，函数的第二个参数应该是 wx:for-index 的值，但代码中没有传所以我们可以不管它。然后我们把这两个 wx: 开头的参数作为 attribute 传入 Text 元素就完成了循环的处理。而对于 onClick 而言，在 Taro 中 on 开头的元素参数都是事件，所以我们只要把 this. 去掉即可。Text 元素的 children 是一个 JSXExpressionContainer，我们按照之前的处理方式处理即可。最后这行我们生成出来的数据结构应该是这样…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">&#x27;element&#x27;</span>,</span><br><span class="line">  tagName: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">  attributes: [</span><br><span class="line">    &#123; <span class="attr">bindtap</span>: <span class="string">&#x27;handleClick&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&#x27;wx:for&#x27;</span>: <span class="string">&#x27;&#123;&#123;oddNumbers&#125;&#125;&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&#x27;wx:for-item&#x27;</span>: <span class="string">&#x27;number&#x27;</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  children: [</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&#x27;text&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;&#123;&#123;number&#125;&#125;&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>

<p>有了这个数据结构生成一段 WXML 就非常简单了</p>
<p>再来看第二个循环表达式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> number % <span class="number">2</span> === <span class="number">0</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Text</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span>)...</span><br></pre></td></tr></table></figure>

<p>它比第一个循环表达式多了一个逻辑表达式（Logical Operators），我们知道 expr1 &amp;&amp; expr2 意味着如果 expr1 能转换成 true 则返回 expr2，也就是说我们只要把 number % 2 === 0 作为值生成一个键名 wx:if 的 JSXAttribute 即可。但由于 wx:if 和 wx:for 同时作用于一个元素可能会出现问题，所以我们应该生成一个 block 元素，把 wx:if 挂载到 block 元素，原元素则全部作为 children 传入 block 元素中。这时 babel-traverse 会检测到新的元素 block，它的父元素是一个 map 循环函数，因此我们可以按照第一个循环表达式的处理方法来处理这个表达式。</p>
<p>这里我们可以思考一下 this.props.text || this.props.children 的解决方案。当用户在 JSX 中使用 || 作为逻辑表达式时很可能是 this.props.text 和 this.props.children 都有可能作为结果返回。这里 Taro 将它编译成了 this.props.text ? this.props.text: this.props.children，按照条件表达式（三元表达式）的逻辑，也就是说会生成两个 block，一个 wx:if 和一个 wx:else：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;block wx:<span class="keyword">if</span>=<span class="string">&quot;&#123;&#123;text&#125;&#125;&quot;</span>&gt;&#123;&#123;text&#125;&#125;&lt;/block&gt;</span><br><span class="line">&lt;block wx:<span class="keyword">else</span>&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Vue3迁移指南</title>
    <url>/2020/09/27/Vue3%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Vue 3</code>已经正式发布，我们现有的项目基本都是基于<code>Vue 2</code>进行开发的，如何由<code>Vue 2.x</code>迁移到<code>Vue 3.x</code>，<a href="https://v3.cn.vuejs.org/guide/migration/introduction.html#%E6%A6%82%E8%A7%88">官方文档</a>已经提供了迁移指南，本文是对官方迁移指南的总结。</p>
<h2 id="重大改变"><a href="#重大改变" class="headerlink" title="重大改变"></a>重大改变</h2><p><code>Vue 3</code>相较于<code>Vue 2</code>有许多<code>Break Change</code>的重大改变，是我们在迁移时需要重点关注的：</p>
<h3 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h3><ul>
<li>变更为使用应用程序实例</li>
<li>全局和内部API可以被<code>tree shaking</code></li>
</ul>
<h3 id="模版指令"><a href="#模版指令" class="headerlink" title="模版指令"></a>模版指令</h3><ul>
<li><code>v-model</code>用法的变更</li>
<li><code>v-for</code>节点上<code>key</code>用法的变更</li>
<li><code>v-if</code>和<code>v-for</code>优先级的变更</li>
<li><code>v-bind=&quot;object&quot;</code>合并策略的变更</li>
<li><code>v-for</code>中的<code>ref</code>不再注册为<code>ref</code>数组</li>
</ul>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul>
<li>只能使用普通函数创建功能组件</li>
<li><code>functional</code>属性及选项被遗弃</li>
<li>使用<code>defineAsyncComponent</code>创建异步组件</li>
</ul>
<h3 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h3><ul>
<li>渲染函数的API变更</li>
<li><code>$scopedSlots</code>property已删除，所有插槽都通过<code>$slots</code>作为函数暴露</li>
<li>自定义指令的API和组组件的生命周期保持一致</li>
<li>某些过渡<code>class</code>被重命名</li>
<li>组件的<code>watch</code>选项和实例的<code>$watch</code>方法不再支持点分隔字符串路径</li>
<li>应用程序容器的<code>innerHTML</code>将替换为根组件模版</li>
</ul>
<h3 id="其他改变"><a href="#其他改变" class="headerlink" title="其他改变"></a>其他改变</h3><ul>
<li><code>destroyed</code>生命周期被重命名为<code>unmounted</code>，<code>beforeDestroy</code>被重命名为<code>beforeUnmount</code></li>
<li>组件的默认属性不能访问<code>this</code></li>
<li><code>data</code>选项应使用声明为函数</li>
<li><code>mixin</code>的<code>data</code>与组件的<code>data</code>选项只进行简单的合并</li>
<li><code>attribute</code>强制行为的变更</li>
<li><code>&lt;template&gt;</code>在没有特殊的指令标记时，将被视为普通的元素，而不是渲染其内容</li>
</ul>
<h3 id="移除API"><a href="#移除API" class="headerlink" title="移除API"></a>移除API</h3><ul>
<li>按键修饰符</li>
<li>移除<code>$on</code>，<code>$off</code>和<code>$once</code>实例方法</li>
<li>移除过滤器，建议使用计算属性或方法</li>
<li>移除<code>inline-template</code>属性</li>
<li>移除<code>$destroy</code>实例方法</li>
</ul>
<h2 id="全局API——createApp"><a href="#全局API——createApp" class="headerlink" title="全局API——createApp"></a>全局API——<code>createApp</code></h2><p><code>Vue 2.x</code>有许多全局API和配置，这些API和配置可以全局改变<code>Vue</code>的行为。例如，要创建全局组件，可以使用<code>Vue.component</code>。</p>
<p>从技术上讲，<code>Vue 2</code>没有“app”的概念，我们定义的应用程序只是通过<code>new Vue()</code>创建的根<code>Vue</code>实例。从同一个<code>Vue</code>构造函数创建的每个根实例共享相同的全局配置，因此：</p>
<ul>
<li>全局配置使得在测试期间很容易意外地污染其他测试用例；</li>
<li>全局配置使得在同一页面上的多个“app”之间共享同一个 Vue 副本非常困难。</li>
</ul>
<p><code>Vue 3.x</code>中引入了一个新的全局API：<code>createApp</code>，调用<code>createApp</code>返回一个应用实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>任何全局改变 Vue 行为的 API 现在都会移动到应用实例上，以下是当前全局 API 及其相应实例 API 的表：</p>
<table>
<thead>
<tr>
<th>2.x 全局 API</th>
<th>3.x 实例 API (app)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config</td>
<td>app.config</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td>移除</td>
</tr>
<tr>
<td>Vue.config.ignoredElements</td>
<td>app.config.isCustomElement</td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
</tbody></table>
<p>使用<code>createApp(/* options */)</code>初始化后，应用实例<code>app</code>可用于挂载具有<code>app.mount(domTarget)</code>。</p>
<p>Vue 3 应用程序实例还可以提供可由应用程序内的任何组件注入的依赖项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在入口</span></span><br><span class="line">app.provide(<span class="string">&#x27;guide&#x27;</span>, <span class="string">&#x27;Vue 3 Guide&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    book: &#123;</span><br><span class="line">      <span class="keyword">from</span>: <span class="string">&#x27;guide&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; book &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在应用程序之间共享配置 (如组件或指令) 的一种方法是创建工厂功能，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">&#x27;./Foo.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">&#x27;./Bar.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createMyApp = <span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = createApp(options)</span><br><span class="line">  app.directive(<span class="string">&#x27;focus&#x27;</span> <span class="comment">/* ... */</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createMyApp(Foo).mount(<span class="string">&#x27;#foo&#x27;</span>)</span><br><span class="line">createMyApp(Bar).mount(<span class="string">&#x27;#bar&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="全局-API-Treeshaking"><a href="#全局-API-Treeshaking" class="headerlink" title="全局 API Treeshaking"></a>全局 API Treeshaking</h2><p>在<code>Vue 3</code>中，全局和内部<code>API</code>都经过了重构，并考虑到了<code>tree-shaking</code>的支持。因此，全局<code>API</code>现在只能作为<code>ES</code>模块构建的命名导出进行访问。例如，我们想要手动操作<code>DOM</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line">nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 一些和DOM有关的东西</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>受影响的<code>API</code>如下：</p>
<ul>
<li>Vue.nextTick</li>
<li>Vue.observable (用<code>Vue.reactive</code>替换)</li>
<li>Vue.version</li>
<li>Vue.compile</li>
<li>Vue.set</li>
<li>Vue.delete</li>
</ul>
<p>除了公共<code>API</code>，许多内部组件/帮助器现在也被导出为命名导出，只有当编译器的输出是这些特性时，才允许编译器导入这些特性，例如以下模板：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;div v-show=<span class="string">&quot;ok&quot;</span>&gt;hello&lt;/div&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>被编译为类似于以下的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, Transition, withDirectives, vShow &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h(Transition, [withDirectives(h(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>), [[vShow, <span class="built_in">this</span>.ok]])])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这实际上意味着只有在应用程序实际使用了<code>Transition</code>组件时才会导入它。换句话说，如果应用程序没有任何 <code>Transition</code>组件，那么支持此功能的代码将不会出现在最终的捆绑包中。</p>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><ul>
<li><code>v-model</code>prop和事件默认名称已更改</li>
<li><code>v-bind</code>的<code>.sync</code>修饰符和组件的<code>model</code>选项已移除，可用<code>v-model</code>作为代替</li>
<li>可以在同一个组件上使用多个<code>v-model</code>进行双向绑定</li>
<li>可以自定义<code>v-model </code>修饰符</li>
</ul>
<p>在<code>Vue 2</code>中，开发者使用<code>v-model</code>指令必须使用名为<code>value</code>的<code>prop</code>。如果开发者出于不同的目的需要使用其他的<code>prop</code>，他们就不得不使用<code>v-bind.sync</code>。</p>
<p>在<code>Vue 3</code>中，双向数据绑定的<code>API</code>已经标准化，减少了开发者在使用<code>v-model</code>指令时的混淆并且在使用 <code>v-model</code>指令时可以更加灵活。</p>
<p>在<code>3.x</code>中，自定义组件上的<code>v-model</code>相当于传递了<code>modelValue prop</code>并接收抛出的 <code>update:modelValue</code>事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ChildComponent v-model=<span class="string">&quot;pageTitle&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 简写: --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent</span><br><span class="line">  :modelValue=<span class="string">&quot;pageTitle&quot;</span></span><br><span class="line">  @update:modelValue=<span class="string">&quot;pageTitle = $event&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>若需要更改<code>model</code>名称，而可以将一个<code>argument</code>传递给<code>model</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ChildComponent v-model:title=<span class="string">&quot;pageTitle&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 简写: --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent :title=<span class="string">&quot;pageTitle&quot;</span> @update:title=<span class="string">&quot;pageTitle = $event&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>这也可以作为<code>.sync</code>修饰符的替代，而且允许我们在自定义组件上使用多个<code>v-model</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ChildComponent v-model:title=<span class="string">&quot;pageTitle&quot;</span> v-model:content=<span class="string">&quot;pageContent&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 简写： --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent</span><br><span class="line">  :title=<span class="string">&quot;pageTitle&quot;</span></span><br><span class="line">  @update:title=<span class="string">&quot;pageTitle = $event&quot;</span></span><br><span class="line">  :content=<span class="string">&quot;pageContent&quot;</span></span><br><span class="line">  @update:content=<span class="string">&quot;pageContent = $event&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="key-attribute"><a href="#key-attribute" class="headerlink" title="key attribute"></a>key attribute</h2><ul>
<li>对于<code>v-if</code>/<code>v-else</code>/<code>v-else-if</code>的各分支项<code>key</code>将不再是必须的，因为现在<code>Vue</code>会自动生成唯一的<code>key</code></li>
<li><code>&lt;template v-for&gt;</code>的<code>key</code>应该设置在<code>&lt;template&gt;</code>标签上 ，而不是设置在它的子节点上</li>
</ul>
<h2 id="v-if-与-v-for-的优先级对比"><a href="#v-if-与-v-for-的优先级对比" class="headerlink" title="v-if 与 v-for 的优先级对比"></a>v-if 与 v-for 的优先级对比</h2><p>两者作用于同一个元素上时<code>v-if</code>会拥有比<code>v-for</code>更高的优先级。由于语法上存在歧义，建议避免在同一元素上同时使用两者。比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。</p>
<h2 id="v-bind-合并行为"><a href="#v-bind-合并行为" class="headerlink" title="v-bind 合并行为"></a>v-bind 合并行为</h2><p><code>v-bind</code>的绑定顺序会影响渲染结果，如果一个元素同时定义了<code>v-bind=&quot;object&quot;</code>和一个相同的单独的<code>property</code>，那么声明绑定的顺序决定了它们如何合并。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-for的Ref数组"><a href="#v-for的Ref数组" class="headerlink" title="v-for的Ref数组"></a>v-for的Ref数组</h2><p>在<code>Vue 2</code>中，在<code>v-for</code>里使用的<code>ref attribute</code>会用<code>ref</code>数组填充相应的<code>$refs property</code>。在<code>Vue 3</code>中，这样的用法将不再在<code>$ref</code>中自动创建数组。要从单个绑定获取多个<code>ref</code>，需要将<code>ref</code>绑定到一个更灵活的函数上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:ref</span>=<span class="string">&quot;setItemRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onBeforeUpdate, onUpdated &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> itemRefs = []</span><br><span class="line">    <span class="keyword">const</span> setItemRef = <span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">      itemRefs.push(el)</span><br><span class="line">    &#125;</span><br><span class="line">    onBeforeUpdate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      itemRefs = []</span><br><span class="line">    &#125;)</span><br><span class="line">    onUpdated(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(itemRefs)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      itemRefs,</span><br><span class="line">      setItemRef</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><ul>
<li>在<code>3.x</code>中，函数式组件的性能提升可以忽略不计，因此建议只使用有状态的组件</li>
<li>函数式组件只能使用接收<code>props</code>和<code>context</code>的普通函数创建</li>
<li><code>functional attribute</code>在单文件组件 (SFC) <code>&lt;template&gt;</code>已被移除</li>
<li><code>&#123; functional: true &#125;</code>选项在通过函数创建组件已被移除</li>
</ul>
<p>在<code>Vue 3</code>中，所有的函数式组件都是用普通函数创建的，换句话说，不需要定义<code>&#123; functional: true &#125;</code>组件选项。此外，现在不是在<code>render</code>函数中隐式提供<code>h</code>，而是全局导入<code>h</code>。</p>
<h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>在<code>Vue 2</code>中异步组件是通过将组件定义为返回<code>Promise</code>的函数来创建的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncPage = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./NextPage.vue&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>或者，对于带有选项的更高阶的组件语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncPage = &#123;</span><br><span class="line">  component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./NextPage.vue&#x27;</span>),</span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  timeout: <span class="number">3000</span>,</span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  loading: LoadingComponent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Vue 3</code>中，由于函数式组件被定义为纯函数，因此异步组件的定义需要通过将其包装在新的<code>defineAsyncComponent</code>助手方法中来显式地定义，同时<code>component</code>选项现在被重命名为<code>loader</code>，以便准确地传达不能直接提供组件定义的信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ErrorComponent <span class="keyword">from</span> <span class="string">&#x27;./components/ErrorComponent.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> LoadingComponent <span class="keyword">from</span> <span class="string">&#x27;./components/LoadingComponent.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带选项的异步组件</span></span><br><span class="line"><span class="keyword">const</span> asyncPage = defineAsyncComponent(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./NextPage.vue&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带选项的异步组件</span></span><br><span class="line"><span class="keyword">const</span> asyncPageWithOptions = defineAsyncComponent(&#123;</span><br><span class="line">  loader: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./NextPage.vue&#x27;</span>),</span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  timeout: <span class="number">3000</span>,</span><br><span class="line">  errorComponent: ErrorComponent,</span><br><span class="line">  loadingComponent: LoadingComponent</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="渲染函数-API"><a href="#渲染函数-API" class="headerlink" title="渲染函数 API"></a>渲染函数 API</h2><p>在<code>Vue 3.x</code>中，<code>h</code>是全局导入的，而不是作为参数自动传入渲染函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统一-Slot"><a href="#统一-Slot" class="headerlink" title="统一 Slot"></a>统一 Slot</h2><p>在<code>Vue 3.x</code>中，插槽被定义为当前节点的子对象，当你需要以编程方式引用作用域<code>slot</code>时，它们现在被统一到<code>$slots</code>选项中。</p>
<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>在<code>Vue 3</code>中，将自定义指令的API与组件的生命周期保持一致：</p>
<ul>
<li>bind → beforeMount，指令绑定到元素后发生，只发生一次。</li>
<li>inserted → mounted，元素插入父 DOM 后发生。</li>
<li>beforeUpdate，在元素本身更新之前调用。</li>
<li>移除<code>update</code>，改用<code>updated</code>。</li>
<li>componentUpdated → updated，组件和子级被更新，调用这个钩子。</li>
<li>beforeUnmount，在卸载元素之前调用。</li>
<li>unbind -&gt; unmounted，指令被移除，调用这个钩子。</li>
</ul>
<h2 id="过渡的-class-名更改"><a href="#过渡的-class-名更改" class="headerlink" title="过渡的 class 名更改"></a>过渡的 class 名更改</h2><p>过渡类名<code>v-enter</code>修改为<code>v-enter-from</code>、过渡类名<code>v-leave</code>修改为<code>v-leave-from</code>，变得更加明确易读。</p>
<h2 id="在-prop-的默认函数中访问-this"><a href="#在-prop-的默认函数中访问-this" class="headerlink" title="在 prop 的默认函数中访问 this"></a>在 prop 的默认函数中访问 this</h2><p>在属性的默认函数中无法访问<code>this</code>，替代方案为：</p>
<ul>
<li>把组件接收到的原始 <code>prop</code>作为参数传递给默认函数；</li>
<li>注入<code>API</code>可以在默认函数中使用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    theme: &#123;</span><br><span class="line">      <span class="keyword">default</span> (props) &#123;</span><br><span class="line">        <span class="comment">// `props` 是传递给组件的原始值。</span></span><br><span class="line">        <span class="comment">// 在任何类型/默认强制转换之前</span></span><br><span class="line">        <span class="comment">// 也可以使用 `inject` 来访问注入的 property</span></span><br><span class="line">        <span class="keyword">return</span> inject(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;default-theme&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Data-选项"><a href="#Data-选项" class="headerlink" title="Data 选项"></a>Data 选项</h2><p><code>data</code>组件选项声明不再接收纯<code>JavaScript object</code>，只接受返回<code>object</code>的<code>function</code>。当合并来自<code>mixin</code>或<code>extend</code>的多个<code>data</code>返回值时，是浅层次合并的而不是深层次合并的(只合并根级属性)。</p>
<h2 id="attribute-强制行为"><a href="#attribute-强制行为" class="headerlink" title="attribute 强制行为"></a>attribute 强制行为</h2><p>删除枚举<code>attribute</code>的内部概念，并将这些<code>attribute</code>视为普通的非布尔<code>attribute</code>。</p>
<p>2.x 和 3.x 行为的比较</p>
<table>
<thead>
<tr>
<th>Attributes</th>
<th>v-bind value 2.x</th>
<th>v-bind value 3.x</th>
<th>HTML 输出</th>
</tr>
</thead>
<tbody><tr>
<td>2.x “枚举attribute” i.e. contenteditable, draggable and spellcheck.</td>
<td>undefined, false</td>
<td>undefined, null</td>
<td>移除</td>
</tr>
<tr>
<td>2.x “枚举attribute” i.e. contenteditable, draggable and spellcheck.</td>
<td>true, ‘true’, ‘’, 1, ‘foo’</td>
<td>true, ‘true’</td>
<td>“true”</td>
</tr>
<tr>
<td>2.x “枚举attribute” i.e. contenteditable, draggable and spellcheck.</td>
<td>null, ‘false’</td>
<td>false, ‘false’</td>
<td>“false”</td>
</tr>
<tr>
<td>其他非布尔attribute eg. aria-checked, tabindex, alt, etc.</td>
<td>undefined, null, false</td>
<td>undefined, null</td>
<td>移除</td>
</tr>
<tr>
<td>其他非布尔attribute eg. aria-checked, tabindex, alt, etc.</td>
<td>‘false’</td>
<td>false, ‘false’</td>
<td>“false”</td>
</tr>
</tbody></table>
<h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><ul>
<li>不再支持使用数字 (即键码) 作为<code>v-on</code>修饰符</li>
<li>不再支持<code>config.keyCodes</code></li>
</ul>
<p>建议对任何要用作修饰符的键使用 kebab-cased (短横线) 大小写名称：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 3 在 v-on 上使用 按键修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.delete</span>=<span class="string">&quot;confirmDelete&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="事件-API"><a href="#事件-API" class="headerlink" title="事件 API"></a>事件 API</h2><p><code>$on</code>，<code>$off</code>和<code>$once</code>实例方法已被移除，应用实例不再实现事件触发接口，<code>$emit</code>仍然是现有<code>API</code>的一部分，因为它用于触发由父组件以声明方式附加的事件处理程序。</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>在<code>Vue 3.x</code>中，<code>filters</code>已删除，不再受支持。建议用方法调用或计算属性替换它们。</p>
<h2 id="内联模板-Attribute"><a href="#内联模板-Attribute" class="headerlink" title="内联模板 Attribute"></a>内联模板 Attribute</h2><p>在<code>Vue 2.x</code>中，为子组件提供了<code>inline-template attribute</code>，以便将其内部内容用作模板，而不是将其作为分发内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>它们被编译为组件自己的模板<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>不是父级所包含的内容。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>Vue 3.x</code>中不再支持此功能，所有模板都直接写在<code>HTML</code>页面中。</p>
<ul>
<li><p>使用<code>&lt;script&gt;</code>标签：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/html&quot;</span> id=<span class="string">&quot;my-comp-template&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; hello &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComp = &#123;</span><br><span class="line">  template: <span class="string">&#x27;#my-comp-template&#x27;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认 Slot</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-comp</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; childState &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; parentMsg &#125;&#125; &#123;&#123; childState &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">my-comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  在子模板中，在传递时渲染默认slot</span></span><br><span class="line"><span class="comment">  在必要的private状态下。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:childState</span>=<span class="string">&quot;childState&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h2><p>在<code>Vue 3</code>中，组件正式支持多根节点组件，即片段。</p>
<h2 id="自定义元素"><a href="#自定义元素" class="headerlink" title="自定义元素"></a>自定义元素</h2><p>如果我们想添加在<code>Vue</code>外部定义的自定义元素 (例如使用<code>Web</code>组件<code>API</code>)，我们需要“指示”<code>Vue</code>将其视为自定义元素。以下面的模板为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plastic-button</span>&gt;</span><span class="tag">&lt;/<span class="name">plastic-button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>Vue 3.0</code>中，此检查在模板编译期间执行指示编译器将<code>&lt;plastic-button&gt;</code>视为自定义元素：</p>
<ul>
<li><p>如果使用生成步骤：将<code>isCustomElement</code>传递给<code>Vue</code>模板编译器，如果使用<code>vue-loader</code>，则应通过 <code>vue-loader</code>的<code>compilerOptions</code>选项传递：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack 中的配置</span></span><br><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">    use: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      compilerOptions: &#123;</span><br><span class="line">        isCustomElement: <span class="function"><span class="params">tag</span> =&gt;</span> tag === <span class="string">&#x27;plastic-button&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果使用动态模板编译，请通过<code>app.config.isCustomElement</code>传递：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line">app.config.isCustomElement = <span class="function"><span class="params">tag</span> =&gt;</span> tag === <span class="string">&#x27;plastic-button&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>自定义元素规范提供了一种将自定义元素用作自定义内置模板的方法，方法是向内置元素添加<code>is</code>属性。在<code>Vue 3.0</code>中，我们仅将<code>Vue</code>对<code>is</code>属性的特殊处理限制到<code>&lt;component&gt;</code>tag。</p>
<ul>
<li><p>在保留的<code>&lt;component&gt;</code>tag上使用时，它的行为将与<code>Vue 2.x</code>中完全相同；</p>
</li>
<li><p>在普通组件上使用时，它的行为将类似于普通 prop：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">is</span>=<span class="string">&quot;bar&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2.x 行为：渲染<code>bar</code>组件。</li>
<li>3.x 行为：通过<code>is</code>prop渲染<code>foo</code>组件。</li>
</ul>
</li>
<li><p>在普通元素上使用时，它将作为<code>is</code>选项传递给<code>createElement</code>调用，并作为原生<code>attribute</code>渲染，这支持使用自定义的内置元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">&quot;plastic-button&quot;</span>&gt;</span>点击我！<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2.x 行为：渲染 plastic-button 组件。</li>
<li>3.x 行为：通过回调渲染原生的 button。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>, &#123; <span class="attr">is</span>: <span class="string">&#x27;plastic-button&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>在<code>Vue 3.x</code>中引入了一个新的指令<code>v-is</code>，用于<code>DOM</code>内模板解析解决方案。<code>v-is</code>指令像一个动态的<code>2.x :is</code>绑定。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://v3.cn.vuejs.org/guide/migration/introduction.html#%E6%A6%82%E8%A7%88">https://v3.cn.vuejs.org/guide/migration/introduction.html#%E6%A6%82%E8%A7%88</a></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue CLI3和TypeScript项目实践</title>
    <url>/2020/06/19/VueCLI3%E5%92%8CTypeScript%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="typescript入门"><a href="#typescript入门" class="headerlink" title="typescript入门"></a>typescript入门</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型包括：boolean、number、string、null、undefined 以及 ES6 中的新类型 Symbol。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 布尔值</span><br><span class="line">let isShow: boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数字</span><br><span class="line">let num: number &#x3D; 6</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">let name: string &#x3D; &quot;bob&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null 和 undefined</span><br><span class="line">let u: undefined &#x3D; undefined</span><br><span class="line">let n: null &#x3D; null</span><br><span class="line">&#x2F;&#x2F; undefined 和 null 是所有类型的子类型，可以赋值给其他类型</span><br><span class="line">let num: number &#x3D; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; void 可以用 void 表示没有任何返回值的函数</span><br><span class="line">function alertName(): void &#123;</span><br><span class="line">    alert(&#39;My name is Tom&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><ul>
<li>ECMAScript<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let b: Boolean &#x3D; new Boolean(1)</span><br><span class="line">let e: Error &#x3D; new Error(&#39;Error occurred&#39;)</span><br><span class="line">let d: Date &#x3D; new Date()</span><br><span class="line">let r: RegExp &#x3D; &#x2F;[a-z]&#x2F;</span><br></pre></td></tr></table></figure></li>
<li>DOM 和 BOM，有Document、HTMLElement、Event、NodeList 等<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let body: HTMLElement &#x3D; document.body</span><br></pre></td></tr></table></figure>
<h3 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h3></li>
<li>any 类型的变量，允许被赋值为任意类型<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let anything: any &#x3D; &#39;seven&#39;</span><br><span class="line">anything &#x3D; 7</span><br></pre></td></tr></table></figure></li>
<li>变量如果在声明的时候，未指定其类型，没有赋值，会被推断成 any 类型，不做类型检查<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 被推断成 any 类型，不做类型检查</span><br><span class="line">let anything;</span><br><span class="line">anything &#x3D; &#39;seven&#39;</span><br><span class="line">anything &#x3D; 7</span><br></pre></td></tr></table></figure>
<h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3>若没有指定类型，ts会推断出一个类型<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let anything &#x3D; &#39;seven&#39; &#x2F;&#x2F; 推断为string类型</span><br><span class="line">anything &#x3D; 7 &#x2F;&#x2F; 会报错</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">let anything: string &#x3D; &#39;seven&#39; &#x2F;&#x2F; 推断为string类型</span><br><span class="line">anything &#x3D; 7 &#x2F;&#x2F; 会报错</span><br></pre></td></tr></table></figure>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3>使用 | 分隔每个类型。</li>
</ul>
<p>当不确定联合类型的变量哪个类型的时：</p>
<ul>
<li>只能访问该变量类型里共有的属性或方法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    return something.length   &#x2F;&#x2F; 报错</span><br><span class="line">    return something.toString().length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以使用<strong>类型断言</strong>来手动指定一个值的类型，通过 &lt;类型&gt;值 或 值 as 类型<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if ((&lt;string&gt;something).length) &#123; &#x2F;&#x2F; 或 something as string</span><br><span class="line">        return (&lt;string&gt;something).length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
_注：类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的，比如<boolean>something会报错。</li>
<li>联合类型的变量在被赋值时，会根据类型推论推断出一个类型<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber &#x3D; &#39;seven&#39;;</span><br><span class="line">console.log(myFavoriteNumber.length); &#x2F;&#x2F; 5</span><br><span class="line">myFavoriteNumber &#x3D; 7;</span><br><span class="line">console.log(myFavoriteNumber.length); &#x2F;&#x2F; 编译时报错</span><br><span class="line">&#x2F;&#x2F; index.ts(5,30): error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.</span><br></pre></td></tr></table></figure>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3></li>
<li><strong>类型别名</strong>，用来给一个类型起个新名字<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Something &#x3D; string | number</span><br><span class="line">let something: Something &#x3D; &#39;king&#39;</span><br></pre></td></tr></table></figure></li>
<li><strong>字符串字面量类型</strong>，用来约束取值只能是某几个字符串中的一个<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type EventNames &#x3D; &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;</span><br><span class="line">function handleEvent(ele: Element, event: EventNames) &#123; &#x2F;&#x2F; event只能取这三种字符串，否则报错</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口（对象类型）"><a href="#接口（对象类型）" class="headerlink" title="接口（对象类型）"></a>接口（对象类型）</h3>使用接口（Interfaces）来定义对象的类型，接口一般首字母大写<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义的属性必须严格匹配，不允许增加或减少</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 可选属性</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 定义任意属性，</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    [propName: string]: any; &#x2F;&#x2F; [propName: string] 定义了任意属性取 string 类型的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集。例如，若定义[propName: string]: string，则确定属性和可选属性都必须是string类型</p>
</blockquote>
</li>
</ul>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><ul>
<li>类型+方括号<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fibonacci: number[] &#x3D; [1, 2, 3]</span><br></pre></td></tr></table></figure></li>
<li>Array<elemType><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fibonacci: Array&lt;number&gt; &#x3D; [1, 2, 3]</span><br></pre></td></tr></table></figure></li>
<li>用接口表示数组<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface NumberArray &#123;</span><br><span class="line">    [index: number]: number</span><br><span class="line">&#125;</span><br><span class="line">let fibonacci: NumberArray &#x3D; [1, 2, 3]</span><br></pre></td></tr></table></figure>
_注: 类数组，比如 arguments，其不是数组类型，不能用普通的数组的方式来描述，而应该用接口；类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3>数组合并了相同类型的对象，而元组合并了不同类型的对象<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tom: [string, number] &#x3D; [&#39;Tom&#39;, 25]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以只赋值其中一项</span><br><span class="line">let tom: [string, number]</span><br><span class="line">tom[0] &#x3D; &#39;Tom&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当添加越界的元素时，其类型会被限制为元组中每个类型的联合类型：</span><br><span class="line">let tom: [string, number]</span><br><span class="line">tom &#x3D; [&#39;Tom&#39;, 25]</span><br><span class="line">tom.push(&#39;male&#39;)</span><br><span class="line">tom.push(true) &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3></li>
<li>函数声明<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum(x: number, y?: number): number &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数表达式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mySum &#x3D; function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的代码虽然可以编译通过，但其并没有对左边的mySum进行了类型定义，只是通过赋值操作进行类型推论而推断出来的。正确的写法如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mySum: (x: number, y: number) &#x3D;&gt; number </span><br><span class="line">   &#x3D; </span><br><span class="line">  (x: number, y: number) &#x3D;&gt; &#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个 =&gt; 用来表示函数的定义，左边是输入类型(需要用括号括起来)，右边是输出类型；第二个=&gt;是箭头函数</p>
</blockquote>
</li>
<li>用接口或type定义函数的形状<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 接口</span><br><span class="line">interface SumFunc &#123;</span><br><span class="line">   (x: number, y: number): number</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 2. type，tslint更建议使用这种方式</span><br><span class="line">type SumFunc &#x3D; (x: number, y: number) &#x3D;&gt; number</span><br><span class="line">const mySum: SumFunc &#x3D; (x: number, y: number) &#x3D;&gt; &#123;</span><br><span class="line">   return x+y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3>TypeScript 有三种访问修饰符：</li>
<li>public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认是 public；</li>
<li>private 修饰的属性或方法是私有的，外部和子类都不能访问；当构造函数修饰为 private 时，该类不允许被继承或者实例化；</li>
<li>protected 修饰的属性或方法是受保护的，在子类中允许被访问；当构造函数修饰为 protected 时，该类只允许被继承，不允许被实例化<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  protected name: string</span><br><span class="line">  private age: number</span><br><span class="line">  protected constructor (name, age) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.age &#x3D; age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  private food: string</span><br><span class="line">  constructor (name, age, food) &#123;</span><br><span class="line">    super(name, age)</span><br><span class="line">    this.food &#x3D; food</span><br><span class="line">  &#125;</span><br><span class="line">  public sayHi() &#123;</span><br><span class="line">    console.log(&#96;Meow, My name is $&#123;this.name&#125;&#96;)</span><br><span class="line">    &#x2F;&#x2F; console.log(&#96;Meow, My age is $&#123;this.age&#125;&#96;) &#x2F;&#x2F; 报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const animal &#x3D; new Animal(&#39;Jack&#39;, 2) &#x2F;&#x2F; 报错</span><br><span class="line">const cat &#x3D; new Cat(&#39;Jack&#39;, 2, &#39;fish&#39;)</span><br><span class="line">console.log(cat.sayHi())</span><br></pre></td></tr></table></figure>
<h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3>接口（Interfaces）可以用于对「对象的形状」进行描述。若是不同类之间有一些共有的特性，可以把特性提取成接口，用 <strong>implements</strong> 关键字来实现：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert(): void</span><br><span class="line">&#125;</span><br><span class="line">interface Light &#123;</span><br><span class="line">    lightOn(): void</span><br><span class="line">&#125;</span><br><span class="line">class Car implements Alarm, Light &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        console.log(&#39;Car alert&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    lightOn() &#123;</span><br><span class="line">        console.log(&#39;Car light on&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>接口继承接口：继承类型<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert(): void</span><br><span class="line">&#125;</span><br><span class="line">interface LightableAlarm extends Alarm &#123;</span><br><span class="line">    lightOn(): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>接口继承类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number;</span><br><span class="line">    constructor(x: number, y: number) &#123;</span><br><span class="line">        this.x &#x3D; x</span><br><span class="line">        this.y &#x3D; y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Point3d extends Point &#123;</span><br><span class="line">    z: number</span><br><span class="line">&#125;</span><br><span class="line">let point3d: Point3d &#x3D; &#123;x: 1, y: 2, z: 3&#125;</span><br><span class="line"></span><br><span class="line">interface PointInstanceType &#123;</span><br><span class="line">    x: number</span><br><span class="line">    y: number</span><br><span class="line">&#125;</span><br><span class="line">function printPoint(p: Point) &#123;</span><br><span class="line">    console.log(p.x, p.y);</span><br><span class="line">&#125;</span><br><span class="line">function printPoint(p: Point) &#123;</span><br><span class="line">    console.log(p.x, p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Point 当做一个类来用（使用 new Point 创建它的实例），也可以将 Point 当做一个类型来用。类型 PointInstanceType 和类型 Point 是等价的，只是缺少了构造函数、静态属性或静态方法</p>
</blockquote>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3>在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] &#x3D; []</span><br><span class="line">    for (let i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] &#x3D; value</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">createArray&lt;string&gt;(3, &#39;x&#39;)</span><br></pre></td></tr></table></figure></li>
<li>使用泛型接口定义函数形状<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface CreateArrayFunc &#123;</span><br><span class="line">    &lt;T&gt;(length: number, value: T): Array&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line">let createArray: CreateArrayFunc</span><br><span class="line">createArray &#x3D; function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] &#x3D; [];</span><br><span class="line">    for (let i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] &#x3D; value</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">createArray &lt;string&gt; (3, &#39;x&#39;); &#x2F;&#x2F; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</span><br></pre></td></tr></table></figure></li>
<li>泛型类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T</span><br><span class="line">    add: (x: T, y: T) &#x3D;&gt; T</span><br><span class="line">&#125;</span><br><span class="line">let myGenericNumber &#x3D; new GenericNumber&lt;number&gt;()</span><br><span class="line">myGenericNumber.zeroValue &#x3D; 0</span><br><span class="line">myGenericNumber.add &#x3D; function(x, y) &#123; return x + y; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="vue-cli3-typescript"><a href="#vue-cli3-typescript" class="headerlink" title="vue-cli3 + typescript"></a>vue-cli3 + typescript</h2><h3 id="安装ts插件"><a href="#安装ts插件" class="headerlink" title="安装ts插件"></a>安装ts插件</h3></li>
<li>ts-loader 让webpack识别 .ts .tsx文件</li>
<li>@typescript-eslint/parser ts文件解析器（不安装的话，eslint无法解析ts语法，会报Parsing error错误）</li>
<li>@typescript-eslint/eslint-plugin 版本号需要与@typescript-eslint/parser的版本一致，解析器相关的配置选项<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i ts-loader typescript @typescript-eslint&#x2F;parser @typescript-eslint&#x2F;eslint-plugin --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h3>找到./vue.config.js，配置如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configureWebpack: config &#x3D;&gt; &#123;</span><br><span class="line">   &#x2F;&#x2F; 更改入口文件</span><br><span class="line">   config.entry.app &#x3D; &#39;.&#x2F;src&#x2F;main.ts&#39;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 加上.ts 后缀（引入.ts的时候不写后缀）</span><br><span class="line">   config.resolve.extensions.push(&#39;.ts&#39;)</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;  添加webpack对.ts的解析</span><br><span class="line">   config.module.rules.push(&#123;</span><br><span class="line">    test: &#x2F;\.ts$&#x2F;,</span><br><span class="line">    exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">    enforce: &#39;pre&#39;,</span><br><span class="line">    loader: &#39;tslint-loader&#39;</span><br><span class="line">   &#125;)</span><br><span class="line">   config.module.rules.push(&#123;</span><br><span class="line">    test: &#x2F;\.tsx?$&#x2F;,</span><br><span class="line">    loader: &#39;ts-loader&#39;,</span><br><span class="line">    exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">    options: &#123;</span><br><span class="line">        appendTsSuffixTo: [&#x2F;\.vue$&#x2F;],</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加-tsconfig-json"><a href="#添加-tsconfig-json" class="headerlink" title="添加 tsconfig.json"></a>添加 tsconfig.json</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;include&quot;: [</span><br><span class="line">    &quot;src&#x2F;**&#x2F;*&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;exclude&quot;: [</span><br><span class="line">    &quot;node_modules&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &#x2F;&#x2F; 用来指定允许从没有默认导出的模块中默认导入，即允许import React from &#39;react&#39;而不用只能import * as React from &#39;react&#39;</span><br><span class="line">    &quot;allowSyntheticDefaultImports&quot;: true,</span><br><span class="line">    &#x2F;&#x2F; 用于指定是否启用装饰器特性</span><br><span class="line">    &quot;experimentalDecorators&quot;: true,</span><br><span class="line">    &#x2F;&#x2F; 允许编译javascript文件</span><br><span class="line">    &quot;allowJs&quot;: true,</span><br><span class="line">    &quot;module&quot;: &quot;esnext&quot;,</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">    &#x2F;&#x2F; 如何处理模块</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class="line">    &#x2F;&#x2F; 将每个文件作为单独的模块</span><br><span class="line">    &quot;isolatedModules&quot;: true,</span><br><span class="line">    &quot;lib&quot;: [</span><br><span class="line">      &quot;dom&quot;,</span><br><span class="line">      &quot;es5&quot;,</span><br><span class="line">      &quot;es2015.promise&quot;</span><br><span class="line">    ],</span><br><span class="line">    &#x2F;&#x2F; 是否包含可以用于 debug 的 sourceMap</span><br><span class="line">    &quot;sourceMap&quot;: true,</span><br><span class="line">    &quot;pretty&quot;: true,</span><br><span class="line">    &#x2F;&#x2F; 基准目录</span><br><span class="line">    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;,</span><br><span class="line">    &#x2F;&#x2F; 指定特殊模块的路径</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">      &quot;*&quot;: [&quot;src&#x2F;types&#x2F;*&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改-eslintrc-js配置"><a href="#修改-eslintrc-js配置" class="headerlink" title="修改.eslintrc.js配置"></a>修改.eslintrc.js配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  root: true,</span><br><span class="line">  env: &#123;</span><br><span class="line">    node: true,</span><br><span class="line">    &#39;browser&#39;: true,</span><br><span class="line">    &#39;commonjs&#39;: true,</span><br><span class="line">    &#39;es6&#39;: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  parser: &#39;vue-eslint-parser&#39;,</span><br><span class="line">  extends: [</span><br><span class="line">    &#39;plugin:vue&#x2F;essential&#39;,</span><br><span class="line">    &#39;@vue&#x2F;standard&#39;,</span><br><span class="line">    &#x2F;&#x2F; 新增配置项</span><br><span class="line">    &quot;plugin:@typescript-eslint&#x2F;recommended&quot;</span><br><span class="line">  ],</span><br><span class="line">  &#x2F;&#x2F; 新增配置项</span><br><span class="line">  plugins: [&#39;@typescript-eslint&#39;],</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    &#x2F;&#x2F; 新增配置项</span><br><span class="line">    parser: &#39;@typescript-eslint&#x2F;parser&#39;,</span><br><span class="line">    ecmaFeatures: &#123;</span><br><span class="line">      &#39;legacyDecorators&#39;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    &#39;semi&#39;: [&#39;error&#39;, &#39;never&#39;],</span><br><span class="line">    &#39;no-extra-semi&#39;: 2,</span><br><span class="line">        &quot;space-before-function-paren&quot;: 0,</span><br><span class="line">    &#39;no-console&#39;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,</span><br><span class="line">    &#39;no-debugger&#39;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,</span><br><span class="line">    &#39;@typescript-eslint&#x2F;no-unused-vars&#39;: [0, &#123; args: &#39;none&#39; &#125;], &#x2F;&#x2F; 不限制定义的类型是否使用</span><br><span class="line">    &#39;@typescript-eslint&#x2F;explicit-function-return-type&#39;: 0, &#x2F;&#x2F; 不限制定义返回函数的类型</span><br><span class="line">    &#39;@typescript-eslint&#x2F;no-empty-function&#39;: 0, &#x2F;&#x2F; 不限制是空函数</span><br><span class="line">    &#39;@typescript-eslint&#x2F;no-explicit-any&#39;: 0, &#x2F;&#x2F; 不限制设置any类型</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="修改main-js"><a href="#修改main-js" class="headerlink" title="修改main.js"></a>修改main.js</h3><p>把项目主文件 main.js 修改成 main.ts ，里面的写法基本不变，但是有一点需要注意： 引入Vue文件的时候，需要加上 .vue 后缀，因为 TypeScript 默认只识别 *.ts 文件，不识别 *.vue 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br></pre></td></tr></table></figure>
<h3 id="让-ts-识别-vue"><a href="#让-ts-识别-vue" class="headerlink" title="让 ts 识别 .vue"></a>让 ts 识别 .vue</h3><p>由于 TypeScript 默认并不支持 *.vue 后缀的文件，在 vue 项目中引入的时候需要创建一个 vue-shim.d.ts 文件，例如 src/types/vue-shim.d.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare module &quot;*.vue&quot; &#123;</span><br><span class="line">  import Vue from &quot;vue&quot;;</span><br><span class="line">  export default Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="开发vue项目"><a href="#开发vue项目" class="headerlink" title="开发vue项目"></a>开发vue项目</h3><h4 id="安装vue相关插件"><a href="#安装vue相关插件" class="headerlink" title="安装vue相关插件"></a>安装vue相关插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i vue-class-component vue-property-decorator vuex-class --save</span><br></pre></td></tr></table></figure>
<h4 id="vue-class-component"><a href="#vue-class-component" class="headerlink" title="vue-class-component"></a>vue-class-component</h4><p>让 TypeScript 正确推断 Vue 组件选项中的类型，有两种方案，一种是Vue.extend（vue api上的用法），一种是使用vue-class-component</p>
<p>1）Vue.extend，使用基础 Vue 构造器，创建一个“子类”，其用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">   ... &#x2F;&#x2F; 类型推断已启用</span><br><span class="line">&#125;)</span><br><span class="line">export default &#123;</span><br><span class="line">   &#x2F;&#x2F; 这里不会有类型推断，</span><br><span class="line">   &#x2F;&#x2F; 因为 TypeScript 不能确认这是 Vue 组件的选项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）vue-class-component的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Component from &#39;vue-class-component&#39;</span><br><span class="line">@Component(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    propMessage: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default class App extends Vue &#123;</span><br><span class="line">  &#x2F;&#x2F; initial data</span><br><span class="line">  msg &#x3D; 123</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; use prop values for initial data</span><br><span class="line">  helloMsg &#x3D; &#39;Hello, &#39; + this.propMessage</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; lifecycle hook</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    this.greet()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; computed</span><br><span class="line">  get computedMsg () &#123;</span><br><span class="line">    return &#39;computed &#39; + this.msg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; method</span><br><span class="line">  greet () &#123;</span><br><span class="line">    alert(&#39;greeting: &#39; + this.msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Prop</strong></p>
<p>当从父组件传递数据到子组件时，通过 Prop 来实现；为了确保 Prop 的类型安全，我们会给 Prop 添加指定类型验证，之前的做法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    testProps: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      required: true,</span><br><span class="line">      default: () &#x3D;&gt; (&#123; message: &#39;test&#39; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述定义了一个 testProps，它的类型是 Object。只定义Object，并不能获取更多的信息，在 TypeScript 看来，这将会是一个 any 类型。可以通过 TypeScript 添加更多的类型说明：</p>
<ul>
<li>若是使用 Vue.extend() 或vue-class-component，给Prop添加类型注释时，需要以函数返回值的形式给 type 断言：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">interface User &#123;</span><br><span class="line">  name: string,</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    testProps: &#123;</span><br><span class="line">      type: Object as () &#x3D;&gt; User</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>若是使用 vue-propperty-decorator，给 prop 添加类型推荐时，就会变得简单：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Component, Vue, Prop &#125; from &#39;vue-property-decorator&#39;</span><br><span class="line">interface User &#123;</span><br><span class="line">  name: string,</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line">@Component</span><br><span class="line">export default class Test extends Vue &#123;</span><br><span class="line">  @Prop(&#123; type: User &#125;)</span><br><span class="line">  private test: &#123; value: string &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h4>在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，简化书写，新增了这 7 个装饰器：</li>
<li>@Component (完全继承于vue-class-component)</li>
<li>@Emit</li>
<li>@Inject</li>
<li>@Provice</li>
<li>@Prop</li>
<li>@Watch</li>
<li>@Model<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Component, Emit, Inject, Model, Prop, Provide, Vue, Watch &#125; from &#39;vue-property-decorator&#39;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">export class MyComponent extends Vue &#123;</span><br><span class="line">  @Prop(&#123; default: &#39;default value&#39; &#125;)</span><br><span class="line">  propA: string</span><br><span class="line"></span><br><span class="line">  @Prop([String, Boolean])</span><br><span class="line">  propB: string | boolean</span><br><span class="line"> </span><br><span class="line">  count &#x3D; 0</span><br><span class="line"></span><br><span class="line">  @Watch(&#39;child&#39;)</span><br><span class="line">  onChildChanged(val: string, oldVal: string) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  @Emit(&#39;reset&#39;)</span><br><span class="line">  emitTodo(n: number)&#123;</span><br><span class="line">    this.count +&#x3D; n</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 上面的代码等同于</span><br><span class="line">  methods: &#123;</span><br><span class="line">    emitTodo(n) &#123;</span><br><span class="line">      this.count +&#x3D; n</span><br><span class="line">      this.$emit(&#39;emitTodo&#39;, n)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Model(&#39;textInput&#39;, &#123; type: String &#125;) value</span><br><span class="line">  &#x2F;&#x2F; 上面的代码等同于</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &#39;value&#39;,</span><br><span class="line">    event: &#39;textInput&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: String</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 在上一层级父组件里声明的provide，下一层级子组件无论多少级都可以通过inject来访问到provide的数据</span><br><span class="line">  &#x2F;&#x2F; 父组件</span><br><span class="line">  @Provide()</span><br><span class="line">  name &#x3D; &#39;foo&#39;</span><br><span class="line">  &#x2F;&#x2F; 子组件</span><br><span class="line">  @Inject(&#39;name&#39;)</span><br><span class="line">  &#x2F;&#x2F; 上面的代码等同于</span><br><span class="line">  &#x2F;&#x2F; 父组件</span><br><span class="line">  provide: &#123;</span><br><span class="line">     name: &#39;foo&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 子组件</span><br><span class="line">  inject: [name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vuex-class"><a href="#vuex-class" class="headerlink" title="vuex-class"></a>vuex-class</h4>vuex-class 是基于 vue-class-component 对 Vuex 提供的装饰器。<br>目录结构：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store  </span><br><span class="line">├── modules                  </span><br><span class="line">│   ├── home.ts    </span><br><span class="line">│   └── xxx.ts  </span><br><span class="line">├── index.ts  </span><br><span class="line">└── type.ts   </span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">index.ts</span><br></pre></td></tr></table></figure>
import Vue from ‘vue’<br>import Vuex from ‘vuex’<br>Vue.use(Vuex)<br>// 自动引入 modules 文件夹下的js文件，以文件名字作为对象的key<br>const modulesContext = require.context(‘./modules’, false, /.*.ts/)<br>const modules = modulesContext.keys().reduce((prev, cur) =&gt; {<br>const key = cur.match(/(\w+).ts/)[1]<br>prev[key] = modulesContext(cur).default<br>return prev<br>}, {})</li>
</ul>
<p>export default new Vuex.Store({<br>  modules<br>})</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_注：会报“Property &#39;context&#39; does not exist on type &#39;NodeRequire&#39;.”的错误，这里需要安装webpack类型声明：</span><br></pre></td></tr></table></figure>
<p>npm i @types/webpack-env –save-dev</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">home.ts </span><br></pre></td></tr></table></figure>
<p>import TYPES from ‘../types’<br>import {<br>  QueryParam,<br>  ResponseData<br>} from ‘@/types/index.d’<br>import * as Api from ‘@/utils/api.ts’</p>
<p>interface State {<br>  skuInfo: any,<br>  [propName: string]: any<br>}</p>
<p>const initState: State = {<br>  skuInfo: {}<br>}<br>export default {<br>  namespaced: true,<br>  state: initState,<br>  mutations: {<br>    [TYPES.SET_SKU_INFO] (state, skuInfo) {<br>      state.skuInfo = skuInfo<br>    }<br>  },<br>  actions: {<br>    getSkuInfo ({ dispatch, commit, getters, rootGetters }, { skuId }) {<br>      return new Promise((resolve, reject) =&gt; {<br>        Api.requestData({<br>          functionId: ‘getSkuInfo’,<br>          bodyParams: {<br>            skuId<br>          }<br>        }).then((resData: ResponseData) =&gt; {<br>          const { code, data } = resData<br>          if (code === ‘1’ &amp;&amp; data) {<br>            commit(TYPES.SET_SKU_INFO, data)<br>            resolve(data)<br>          } else {<br>            reject(resData)<br>          }<br>        }).catch(err =&gt; {<br>          console.log(err, ‘getSkuInfo err!’)<br>          reject(err)<br>        })<br>      })<br>    }<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在组件中使用 ‘home’ 模块中定义的 &#39;skuInfo&#39; State和 ‘getSkuInfo’ Action</span><br><span class="line">* 第一种方式：  </span><br></pre></td></tr></table></figure>
<p>import Vue from ‘vue’<br>import Component from ‘vue-class-component’<br>import { State, Action, namespace } from ‘vuex-class’<br>const homeModule = namespace(‘home’)</p>
<p>@Component<br>export class Home extends Vue {<br>  @homeModule.State(‘skuInfo’) skuInfo<br>  @homeModule.Action(‘getSkuInfo’) getSkuInfo: ({ skuId }) =&gt; Promise<any><br>  created () {<br>    this.getSkuInfo({ skuId: 64967590189 })<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 第二种方式：</span><br></pre></td></tr></table></figure>
<p>import Vue from ‘vue’<br>import Component from ‘vue-class-component’<br>import { State, Action } from ‘vuex-class’</p>
<p>@Component<br>export class Home extends Vue {<br>  @State(‘skuInfo’, { namespace: ‘home’ }) skuInfo: any<br>  @Action(‘getSkuInfo’, { namespace: ‘home’ }) getSkuInfo: ({ skuId }) =&gt; Promise<any><br>  created () {<br>    this.getSkuInfo({ skuId: 64967590189 })<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上面的代码相当于：</span><br></pre></td></tr></table></figure>
<p>import Vue from ‘vue’<br>import { mapState, mapActions } from ‘vuex’<br>export default Vue.extend({<br>   computed: {<br>     …mapState(‘home’, [‘skuInfo’])<br>   },<br>   methods: {<br>     …mapActions(‘home’, [‘getSkuInfo’])<br>   }<br>})</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 书写声明文件</span><br><span class="line">#### 为本项目定义类型文件(可以重复引用)</span><br></pre></td></tr></table></figure>
<p>// 1. 全局类型声明，无需import<br>// 1.1<br>declare type QueryParam = string | string[]</p>
<p>declare interface ResponseData {<br>  code: number | string;<br>  data?: any;<br>  msg?: string;<br>}</p>
<p>// 1.2 定义一个命名空间，声明这个拥有多个子属性的全局变量<br>// 用法：homeData.QueryParam 或 homeData.ResponseData<br>declare namespace homeData {<br>  type QueryParam = string | string[]</p>
<p>  interface ResponseData {<br>    code: number | string;<br>    data?: any;<br>    msg?: string;<br>  }<br>}</p>
<p>// 2.1 模块类型声明，需import引入类型文件<br>export type QueryParam = string | string[]</p>
<p>export interface ResponseData {<br>  code: number | string;<br>  data?: any;<br>  msg?: string;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 为第三方库定义类型声明文件</span><br><span class="line"></span><br><span class="line">若是引用的第三方库已经定义好了类型声明文件，直接npm安装即可，例如webpack：</span><br></pre></td></tr></table></figure>
<p>npm i @types/webpack-env –save-dev</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">尝试使用npm install @type&#x2F;xxx 命令来安装声明文件，若是安装失败，则第三方库没有提供声明文件时，需要自己书写声明文件。</span><br><span class="line"></span><br><span class="line">**全局库**</span><br><span class="line"></span><br><span class="line">即通过 &lt;script&gt; 标签引入第三方库，能在全局命名空间下访问的（例如：不需要使用任何形式的import）。</span><br><span class="line">假设通过script标签引入jQuery，类型声明如下：</span><br><span class="line">创建一个 global.d.ts 文件，用来存放全局类型声明，例如 src&#x2F;types&#x2F;global.d.ts</span><br></pre></td></tr></table></figure>
<p>declare var jQuery: (selector: string) =&gt; any</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**模块化库**</span><br><span class="line"></span><br><span class="line">有两种写法，一种是全局类型声明，另一种则是模块导出声明。以为第三方工具类库@yolkpie&#x2F;utils定义类型声明文件为例：  </span><br><span class="line">* **全局类型声明**  </span><br><span class="line"></span><br><span class="line">创建一个 global.d.ts 文件，用来存放全局类型声明，例如 src&#x2F;types&#x2F;global.d.ts</span><br></pre></td></tr></table></figure>
<p>// 只需要对引用到的方法进行类型声明<br>declare module ‘@yolkpie/utils’ {<br>  export function isSupportWebp(): boolean<br>  export function rem(): void<br>  export function formatDate(date: Date|string|number, format?: string): string<br>}<br>declare module ‘vue-awesome-swiper’ {<br>  export const swiper: any<br>  export const swiperSlide: any<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* **模块导出声明**  </span><br><span class="line"></span><br><span class="line">创建一个 types 目录，专门用来管理自己写的声明文件，将 @yolkpie&#x2F;utils 的声明文件放到 types&#x2F;@yolkpie&#x2F;utils&#x2F;index.d.ts 中。这种方式需要配置下 tsconfig.json 中的 paths 和 baseUrl 字段。</span><br><span class="line">目录结构：</span><br></pre></td></tr></table></figure>
<p>src<br>└── types<br>    └── @yolkpie<br>        ├── utils<br>        │   └── index.d.ts<br>        ├── global.d.ts<br>        └── vue-shim.d.ts   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsconfig.json 内容：</span><br></pre></td></tr></table></figure>
<p>{<br>    “compilerOptions”: {<br>        “baseUrl”: “./“,<br>        “paths”: {<br>            “<em>“: [“src/types/</em>“]<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这样配置之后，通过 import 导入 @yolkpie&#x2F;utils  的时候，也会去 types 目录下寻找对应的模块的声明文件了。</span><br><span class="line">例如：src&#x2F;types&#x2F;@yolkpie&#x2F;utils&#x2F;index.d.ts</span><br></pre></td></tr></table></figure>
<p>// 1.直接export<br>export function isSupportWebp(): boolean<br>export function rem(): void<br>export function formatDate(date: Date|string|number, format?: string): string</p>
<p>// 2.export和declare混合<br>declare function isSupportWebp(): boolean<br>declare function rem(): void<br>declare function formatDate(date: Date|string|number, format?: string): string<br>declare namespace jQuery {<br>  function ajax(url: string, settings?: any): void;<br>}<br>export {<br>  rem,<br>  isSupportWebp,<br>  formatDate<br>}</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue服务器端渲染</title>
    <url>/2020/02/03/Vue%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h2 id="1-服务器端渲染-SSR-简介"><a href="#1-服务器端渲染-SSR-简介" class="headerlink" title="1. 服务器端渲染(SSR)简介"></a>1. 服务器端渲染(SSR)简介</h2><h3 id="1-1-什么是服务器端渲染-SSR-？"><a href="#1-1-什么是服务器端渲染-SSR-？" class="headerlink" title="1.1 什么是服务器端渲染(SSR)？"></a>1.1 什么是服务器端渲染(SSR)？</h3><blockquote>
<ul>
<li>Vue.js 是构建客户端应用程序的框架</li>
<li>默认情况下浏览器输出Vue组件，生成DOM并操作DOM</li>
<li>服务器端渲染则是服务器端生成静态的HTML字符串，浏览器将静态标记“混合”为客户端可交互的应用程序</li>
<li>服务器渲染的 Vue.js 应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行</li>
</ul>
</blockquote>
<h3 id="1-2-为什么使用服务器端渲染-SSR-？"><a href="#1-2-为什么使用服务器端渲染-SSR-？" class="headerlink" title="1.2 为什么使用服务器端渲染(SSR)？"></a>1.2 为什么使用服务器端渲染(SSR)？</h3><p>与传统 SPA（Single-Page Application - 单页应用程序）相比，服务器端渲染(SSR)的优势主要在于：</p>
<blockquote>
<ul>
<li>更好的 SEO</li>
</ul>
</blockquote>
<blockquote>
<p>搜索引擎爬虫抓取工具可以直接查看完全渲染的页面,如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。</p>
</blockquote>
<blockquote>
<ul>
<li>更快的内容到达时间</li>
</ul>
</blockquote>
<blockquote>
<p>无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。</p>
</blockquote>
<h3 id="1-3-使用服务器端渲染-SSR-需要权衡的地方"><a href="#1-3-使用服务器端渲染-SSR-需要权衡的地方" class="headerlink" title="1.3 使用服务器端渲染(SSR)需要权衡的地方"></a>1.3 使用服务器端渲染(SSR)需要权衡的地方</h3><blockquote>
<ul>
<li>开发条件所限</li>
</ul>
</blockquote>
<blockquote>
<p>浏览器特定代码，只能在某些生命周期钩子函数中使用；一些外部扩展库可能需要经过特殊处理才能在服务器端使用。</p>
</blockquote>
<blockquote>
<ul>
<li>涉及构建设置和部署的更多要求</li>
</ul>
</blockquote>
<blockquote>
<p>与可以部署在任何静态文件服务器上的完全静态单页面应用程序(SPA)不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。</p>
</blockquote>
<blockquote>
<ul>
<li>更多的服务器端负载</li>
</ul>
</blockquote>
<blockquote>
<p>在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源(CPU-intensive - CPU 密集)，因此如果你预料在高流量环境(high traffic)下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
</blockquote>
<h3 id="1-4-一个简单的服务器端渲染"><a href="#1-4-一个简单的服务器端渲染" class="headerlink" title="1.4 一个简单的服务器端渲染"></a>1.4 一个简单的服务器端渲染</h3><h4 id="1-4-1-安装依赖"><a href="#1-4-1-安装依赖" class="headerlink" title="1.4.1 安装依赖"></a>1.4.1 安装依赖</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install vue vue-server-renderer --save</span><br></pre></td></tr></table></figure>
<h4 id="1-4-2-渲染一个-Vue-实例"><a href="#1-4-2-渲染一个-Vue-实例" class="headerlink" title="1.4.2 渲染一个 Vue 实例"></a>1.4.2 渲染一个 Vue 实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第 1 步：创建一个 Vue 实例</span></span><br><span class="line"><span class="keyword">const</span> Vue = <span class="built_in">require</span>(<span class="string">&#x27;vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;Hello World&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 步：创建一个 renderer</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer&#x27;</span>).createRenderer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 3 步：将 Vue 实例渲染为 HTML</span></span><br><span class="line">renderer.renderToString(app, <span class="function">(<span class="params">err, html</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">  <span class="built_in">console</span>.log(html)</span><br><span class="line">  <span class="comment">// =&gt; &lt;div data-server-rendered=&quot;true&quot;&gt;Hello World&lt;/div&gt;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 2.5.0+，如果没有传入回调函数，则会返回 Promise：</span></span><br><span class="line">renderer.renderToString(app).then(<span class="function"><span class="params">html</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(html)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="1-4-3-与服务器集成"><a href="#1-4-3-与服务器集成" class="headerlink" title="1.4.3 与服务器集成"></a>1.4.3 与服务器集成</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Vue = <span class="built_in">require</span>(<span class="string">&#x27;vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)()</span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer&#x27;</span>).createRenderer()</span><br><span class="line"></span><br><span class="line">server.get(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      url: req.url</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`&lt;div&gt;访问的 URL 是： &#123;&#123; url &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  renderer.renderToString(app, <span class="function">(<span class="params">err, html</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      res.status(<span class="number">500</span>).end(<span class="string">&#x27;Internal Server Error&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.end(<span class="string">`</span></span><br><span class="line"><span class="string">      &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">      &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;<span class="subst">$&#123;html&#125;</span>&lt;/body&gt;</span></span><br><span class="line"><span class="string">      &lt;/html&gt;</span></span><br><span class="line"><span class="string">    `</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>
<h4 id="1-4-4-使用页面模板"><a href="#1-4-4-使用页面模板" class="headerlink" title="1.4.4 使用页面模板"></a>1.4.4 使用页面模板</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--vue-ssr-outlet--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><font color="red">注意</font> <code>&lt;!--vue-ssr-outlet--&gt;</code> 注释 – 这里将是应用程序 HTML 标记注入的地方。</p>
<h4 id="1-4-5-使用模板插值"><a href="#1-4-5-使用模板插值" class="headerlink" title="1.4.5 使用模板插值"></a>1.4.5 使用模板插值</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用三花括号(triple-mustache)进行 HTML 不转义插值(non-HTML-escaped interpolation) --&gt;</span></span><br><span class="line">    &#123;&#123;&#123; meta &#125;&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--vue-ssr-outlet--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过传入一个”渲染上下文对象”，作为 renderToString 函数的第二个参数，来提供插值数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> context = &#123;</span><br><span class="line">  title: <span class="string">&#x27;vue ssr&#x27;</span>,</span><br><span class="line">  meta: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;meta charset=&quot;utf-8&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br><span class="line">renderer.renderToString(app, context, <span class="function">(<span class="params">err, html</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 页面 title 将会是 &quot;vue ssr&quot;</span></span><br><span class="line">  <span class="comment">// meta 标签也会注入</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="1-5-服务器端渲染注意事项"><a href="#1-5-服务器端渲染注意事项" class="headerlink" title="1.5 服务器端渲染注意事项"></a>1.5 服务器端渲染注意事项</h3><blockquote>
<ul>
<li>为避免造成交叉请求状态污染，每个请求应该都是全新的、独立的应用程序实例。</li>
<li>由于没有动态更新，所有的生命周期钩子函数中，只有 beforeCreate 和 created 会在服务器端渲染(SSR)过程中被调用。</li>
<li>通用代码不可接受特定平台的 API，因此如果你的代码中，直接使用了像 window 或 document，这种仅浏览器可用的全局变量，则会在 Node.js 中执行时抛出错误，反之也是如此。</li>
<li>大多数自定义指令直接操作 DOM，因此会在服务器端渲染(SSR)过程中导致错误。</li>
<li>浏览器可能会更改的一些特殊的 HTML 结构，例如，浏览器会在 <code>&lt;table&gt;</code> 内部自动注入 <code>&lt;tbody&gt;</code>，然而，由于 Vue 生成的虚拟 DOM(virtual DOM) 不包含 <code>&lt;tbody&gt;</code>，所以会导致无法匹配。</li>
</ul>
</blockquote>
<h2 id="2-服务器端渲染构建步骤"><a href="#2-服务器端渲染构建步骤" class="headerlink" title="2 服务器端渲染构建步骤"></a>2 服务器端渲染构建步骤</h2><p>我们使用 <code>webpack</code> 来处理服务器和客户端的应用程序，大部分源码可以使用通用方式编写，可以使用 <code>webpack</code> 支持的所有功能，一个基本项目可能像是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── build</span><br><span class="line">│   ├── webpack.base.config.js     # 基本配置文件</span><br><span class="line">│   ├── webpack.client.config.js   # 客户端配置文件</span><br><span class="line">│   ├── webpack.server.config.js   # 服务端配置文件</span><br><span class="line">└── src</span><br><span class="line">    ├── router          </span><br><span class="line">    │    └── index.js              # 路由工厂</span><br><span class="line">    ├── store          </span><br><span class="line">    │    └── index.js              # 状态工厂</span><br><span class="line">    └── components             </span><br><span class="line">    │    ├── comp1.vue             # 组件1</span><br><span class="line">    │    └── copm2.vue             # 组件2</span><br><span class="line">    ├── App.vue                    # 顶级 vue 组件</span><br><span class="line">    ├── index.template.html        # html 模板</span><br><span class="line">    ├── app.js                     # 通用 entry, 根vue实例工厂</span><br><span class="line">    ├── entry-client.js            # client entry</span><br><span class="line">    ├── entry-server.js            # server entry</span><br><span class="line">├── server.js                      # server 服务</span><br></pre></td></tr></table></figure>
<h3 id="2-1-app-js"><a href="#2-1-app-js" class="headerlink" title="2.1 app.js"></a>2.1 app.js</h3><p><code>app.js</code> 是我们应用程序的「通用 entry」。在纯客户端应用程序中，我们将在此文件中创建根 Vue 实例，并直接挂载到 DOM。但是，对于服务器端渲染(SSR)，责任转移到纯客户端 entry 文件。<code>app.js</code> 简单地使用 export 导出一个 <code>createApp</code> 函数</p>
<h3 id="2-2-entry-client-js"><a href="#2-2-entry-client-js" class="headerlink" title="2.2 entry-client.js"></a>2.2 entry-client.js</h3><p>客户端 entry 只需创建应用程序，并且将其挂载到 DOM 中</p>
<h3 id="2-3-entry-server-js"><a href="#2-3-entry-server-js" class="headerlink" title="2.3 entry-server.js"></a>2.3 entry-server.js</h3><p>服务器 entry 使用 default export 导出函数，并在每次渲染中重复调用此函数。此时，除了创建和返回应用程序实例之外，还会执行<code>服务器端路由匹配</code>和<code>服务器端数据预取</code>逻辑。</p>
<p>对于客户端应用程序和服务器应用程序，我们都要使用 webpack 打包 - 服务器需要「服务器 bundle」然后用于服务器端渲染(SSR)，而「客户端 bundle」会发送给浏览器，用于混合静态标记。</p>
<p><img src= "/img/loading.gif" data-src="webpack-bundle.png" alt="webpack打包步骤"></p>
<h2 id="3-本文将一步步带您构建一个完整的vue-ssr项目"><a href="#3-本文将一步步带您构建一个完整的vue-ssr项目" class="headerlink" title="3 本文将一步步带您构建一个完整的vue ssr项目"></a>3 本文将一步步带您构建一个完整的vue ssr项目</h2><blockquote>
<ol>
<li>首先，搭建一个包含交互的简单vue ssr demo，涉及webpack对服务端应用程序和客户端应用程序的打包配置(参考demo1)。</li>
<li>然后，引入vue-router进行路由相关操作(参考demo2)。</li>
<li>接着，引入vuex来执行数据预取和状态控制(参考demo3)。</li>
<li>最后，使用serverBundle和clientBundle进行构建优化(参考demo4)，并在开发环境中进行热重载(参考demo5)。</li>
</ol>
</blockquote>
<h3 id="3-1-搭建一个包含交互的简单vue-ssr-demo"><a href="#3-1-搭建一个包含交互的简单vue-ssr-demo" class="headerlink" title="3.1 搭建一个包含交互的简单vue ssr demo"></a>3.1 搭建一个包含交互的简单vue ssr demo</h3><h4 id="3-1-1-通用代码"><a href="#3-1-1-通用代码" class="headerlink" title="3.1.1 通用代码"></a>3.1.1 通用代码</h4><p><code>components/Comp1.vue</code>，vue组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>组件1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    btnClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;comp1 cilck&#x27;</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>App.vue</code>作为应用程序模板</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Comp1</span>&gt;</span><span class="tag">&lt;/<span class="name">Comp1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Comp1 <span class="keyword">from</span> <span class="string">&quot;./components/Comp1&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123; Comp1 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>app.js</code>作为创建根vue实例的工厂</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; app &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>entry-server.js</code>作为服务器端应用程序的入口，每次渲染中重复调用此函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; app &#125; = createApp()</span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>entry-client.js</code>作为客户端应用程序的入口，将vue实例挂载到dom中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; app &#125; = createApp()</span><br><span class="line">app.$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="3-1-2-构建配置"><a href="#3-1-2-构建配置" class="headerlink" title="3.1.2 构建配置"></a>3.1.2 构建配置</h4><p>将配置文件分为三个文件：base, client 和 server。基本配置(base config)包含在两个环境共享的配置，例如，输出路径(output path)，别名(alias)和 loader。服务器配置(server config)和客户端配置(client config)，可以通过使用 webpack-merge 来简单地扩展基本配置。</p>
<p><code>webpack.base.config.js</code>主要包含服务器端应用程序和客户端应用程序打包的共享配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/lib/plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;[name].bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;vue-loader&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|jpeg|png|gif|svg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: <span class="number">10000</span>    <span class="comment">// 10Kb</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>webpack.server.config.js</code>生成一个库文件，用于创建传递给<code>renderToString</code>的根vue实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.base.config&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = merge(base, &#123;</span><br><span class="line">  target: <span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    server: path.resolve(__dirname, <span class="string">&#x27;../src/entry-server.js&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    libraryTarget: <span class="string">&#x27;commonjs2&#x27;</span> <span class="comment">//构建一个可以被其他模块引入的模块，该模块通过commonJS2规范导出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>webpack.client.config.js</code>生成用户激活服务器端静态标记的client bundle</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.base.config&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(base, &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    client: path.resolve(__dirname, <span class="string">&#x27;../src/entry-client.js&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3-执行构建"><a href="#3-1-3-执行构建" class="headerlink" title="3.1.3 执行构建"></a>3.1.3 执行构建</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package.json</span></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build:server&quot;: &quot;webpack --config build/webpack.server.config.js&quot;,</span><br><span class="line">    &quot;build:client&quot;: &quot;webpack --config build/webpack.client.config.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-4-服务器代码"><a href="#3-1-4-服务器代码" class="headerlink" title="3.1.4 服务器代码"></a>3.1.4 服务器代码</h4><p>在分别执行服务器端应用程序构建和客户端应用程序构建之后生成server bundle和client bundle，用于编写服务器代码。</p>
<p><code>server.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Vue = <span class="built_in">require</span>(<span class="string">&#x27;vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> server = express()</span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer&#x27;</span>).createRenderer(&#123;</span><br><span class="line">  template: <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).readFileSync(<span class="string">&#x27;./src/index.template.html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> createApp = <span class="built_in">require</span>(<span class="string">&#x27;./dist/server.bundle&#x27;</span>).default</span><br><span class="line"><span class="keyword">const</span> context = &#123;</span><br><span class="line">  title: <span class="string">&#x27;vue ssr&#x27;</span>,</span><br><span class="line">  meta: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;meta charset=&quot;utf-8&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br><span class="line">server.use(express.static(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">server.get(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = createApp()</span><br><span class="line">  renderer.renderToString(app, context, <span class="function">(<span class="params">err, html</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      res.status(<span class="number">500</span>).end(<span class="string">&#x27;Internal Server Error&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.end(html)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-1-5客户端激活"><a href="#3-1-5客户端激活" class="headerlink" title="3.1.5客户端激活"></a>3.1.5客户端激活</h4><p>客户端激活，指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。</p>
<p>在客户端入口中，我们通过app.$mount(‘#app’)进行应用程序挂载，由于服务器已经渲染好了 HTML，我们显然无需将其丢弃再重新创建所有的 DOM 元素。相反，我们需要”激活”这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化）。</p>
<p>在服务器渲染的HTML里应用程序根元素上有一个特殊的属性——data-server-rendered，该特殊属性能够让客户端Vue知道这部分Html是由Vue在服务器端渲染的，并且应该以激活模式进行挂载。</p>
<p>在开发模式下，Vue 将推断客户端生成的虚拟 DOM 树(virtual DOM tree)，是否与从服务器渲染的 DOM 结构(DOM structure)匹配。如果无法匹配，它将退出混合模式，丢弃现有的 DOM 并从头开始渲染。在生产模式下，此检测会被跳过，以避免性能损耗。</p>
<h3 id="3-2-路由和代码分割"><a href="#3-2-路由和代码分割" class="headerlink" title="3.2 路由和代码分割"></a>3.2 路由和代码分割</h3><p>我们的服务器代码使用了一个 * 处理程序，它接受任意 URL。这允许我们将访问的 URL 传递到我们的 Vue 应用程序中，然后对客户端和服务器复用相同的路由配置。</p>
<p>使用官方提供的 vue-router，类似于 createApp，我们也需要给每个请求一个新的 router 实例，所以文件导出一个 createRouter 函数</p>
<p><code>router/index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Comp1 <span class="keyword">from</span> <span class="string">&#x27;../components/Comp1.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Comp2 <span class="keyword">from</span> <span class="string">&#x27;../components/Comp2.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRouter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    routes: [&#123;</span><br><span class="line">      path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      redirect: <span class="string">&#x27;/comp1&#x27;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: <span class="string">&#x27;/comp1&#x27;</span>,</span><br><span class="line">      component: Comp1</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: <span class="string">&#x27;/comp2&#x27;</span>,</span><br><span class="line">      component: Comp2</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后更新<code>app.js</code>，创建router实例注入到根vue实例中并返回router</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 router 实例</span></span><br><span class="line">  <span class="keyword">const</span> router = createRouter()</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// 注入 router 到根 Vue 实例</span></span><br><span class="line">    router,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 返回 app 和 router</span></span><br><span class="line">  <span class="keyword">return</span> &#123; app, router &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>entry-server.js</code> 中实现服务器端路由逻辑(server-side routing logic)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">    <span class="comment">// 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise，</span></span><br><span class="line">    <span class="comment">// 以便服务器能够等待所有的内容在渲染前，就已经准备就绪。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; app, router &#125; = createApp()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器端 router 的位置</span></span><br><span class="line">    router.push(context.url)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等到 router 将可能的异步组件和钩子函数解析完</span></span><br><span class="line">    router.onReady(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> matchedComponents = router.getMatchedComponents()</span><br><span class="line">      <span class="comment">// 匹配不到的路由，执行 reject 函数，并返回 404</span></span><br><span class="line">      <span class="keyword">if</span> (!matchedComponents.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(&#123; <span class="attr">code</span>: <span class="number">404</span> &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Promise 应该 resolve 应用程序实例，以便它可以渲染</span></span><br><span class="line">      resolve(app)</span><br><span class="line">    &#125;, reject)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>router.onReady</code>该方法把一个回调排队，在路由完成初始导航时调用，这意味着它可以解析所有的异步进入钩子和路由初始化相关联的异步组件。这可以有效确保服务端渲染时服务端和客户端输出的一致。</p>
<p>然后再次进行打包构建，服务器只需将请求的路径设置到渲染上下文中</p>
<p><code>server.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server.get(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> context = &#123;</span><br><span class="line">    url: req.url</span><br><span class="line">  &#125;</span><br><span class="line">  createApp(context).then(<span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="3-3-数据预取和状态"><a href="#3-3-数据预取和状态" class="headerlink" title="3.3 数据预取和状态"></a>3.3 数据预取和状态</h3><h4 id="3-3-1-服务器端数据预取"><a href="#3-3-1-服务器端数据预取" class="headerlink" title="3.3.1 服务器端数据预取"></a>3.3.1 服务器端数据预取</h4><p>在服务器端渲染(SSR)期间，我们本质上是在渲染我们应用程序的”快照”，所以如果应用程序依赖于一些异步数据，那么在开始渲染过程之前，需要先预取和解析好这些数据。</p>
<p>另一个需要关注的问题是在客户端，在挂载(mount)到客户端应用程序之前，需要获取到与服务器端应用程序完全相同的数据 - 否则，客户端应用程序会因为使用与服务器端应用程序不同的状态，然后导致混合失败。</p>
<p>为了解决这个问题，获取的数据需要位于视图组件之外，即放置在专门的数据预取存储容器(data store)或”状态容器(state container)）”中。首先，在服务器端，我们可以在渲染之前预取数据，并将数据填充到 store 中。此外，我们将在 HTML 中序列化(serialize)和内联预置(inline)状态。这样，在挂载(mount)到客户端应用程序之前，可以直接从 store 获取到内联预置(inline)状态。</p>
<p>使用官方提供的状态管理库Vuex，类似于 createApp和createRouter，我们也需要给每个请求一个新的store实例。</p>
<p><code>store/index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">      username: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">      <span class="function"><span class="title">getUsername</span>(<span class="params">&#123; commit &#125;</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// `store.dispatch()`会返回 Promise，以便我们能够知道数据在何时更新</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 模拟异步请求</span></span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">&#x27;yujihu&#x27;</span>)</span><br><span class="line">          &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> commit(<span class="string">&#x27;setUsername&#x27;</span>, result));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">      <span class="function"><span class="title">setUsername</span>(<span class="params">state, username</span>)</span> &#123;</span><br><span class="line">        state.username = username;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后更新<code>app.js</code>，创建store实例注入到根vue实例中并返回store</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 router 和 store 实例</span></span><br><span class="line">  <span class="keyword">const</span> router = createRouter()</span><br><span class="line">  <span class="keyword">const</span> store = createStore()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// 创建应用程序实例，将 router 和 store 注入</span></span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暴露 app, router 和 store。</span></span><br><span class="line">  <span class="keyword">return</span> &#123; app, router, store &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要通过访问路由，来决定获取哪部分数据 - 这也决定了哪些组件需要渲染。事实上，给定路由所需的数据，也是在该路由上渲染组件时所需的数据。所以在路由组件中放置数据预取逻辑，是很自然的事情。</p>
<p>我们将在路由组件上暴露出一个自定义静态函数 asyncData。注意，由于此函数会在组件实例化之前调用，所以它无法访问 this。需要将 store 和路由信息作为参数传递进去：<br><code>components/Comp1.vue</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>组件1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  asyncData (&#123; store, route &#125;) &#123;</span><br><span class="line"><span class="javascript">    <span class="comment">// 触发 action 后，会返回 Promise</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> store.dispatch(<span class="string">&#x27;getUsername&#x27;</span>)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    btnClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;comp1 cilck&#x27;</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>entry-server.js</code> 中，我们可以通过路由获得与 <code>router.getMatchedComponents()</code> 相匹配的组件，如果组件暴露出 <code>asyncData</code>，我们就调用这个方法。然后我们需要将解析完成的状态，附加到渲染上下文(render context)中。</p>
<p><code>entry-server.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">  <span class="comment">// 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise，</span></span><br><span class="line">    <span class="comment">// 以便服务器能够等待所有的内容在渲染前，</span></span><br><span class="line">    <span class="comment">// 就已经准备就绪。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; app, router, store &#125; = createApp()</span><br><span class="line">    <span class="comment">// 设置服务器端 router 的位置</span></span><br><span class="line">    router.push(context.url)</span><br><span class="line">    <span class="comment">// 等到 router 将可能的异步组件和钩子函数解析完</span></span><br><span class="line">    router.onReady(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> matchedComponents = router.getMatchedComponents()</span><br><span class="line">      <span class="comment">// 匹配不到的路由，执行 reject 函数，并返回 404</span></span><br><span class="line">      <span class="keyword">if</span> (!matchedComponents.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(&#123; <span class="attr">code</span>: <span class="number">404</span> &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对所有匹配的路由组件调用 `asyncData()`</span></span><br><span class="line">      <span class="built_in">Promise</span>.all(matchedComponents.map(<span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Component.asyncData) &#123;</span><br><span class="line">          <span class="keyword">return</span> Component.asyncData(&#123;</span><br><span class="line">            store,</span><br><span class="line">            route: router.currentRoute</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在所有预取钩子(preFetch hook) resolve 后，</span></span><br><span class="line">        <span class="comment">// 我们的 store 现在已经填充入渲染应用程序所需的状态。</span></span><br><span class="line">        <span class="comment">// 当我们将状态附加到上下文，并且 `template` 选项用于 renderer 时，</span></span><br><span class="line">        <span class="comment">// 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。</span></span><br><span class="line">        context.state = store.state</span><br><span class="line">        resolve(app)</span><br><span class="line">      &#125;).catch(reject)</span><br><span class="line">    &#125;, reject)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用 template 时，context.state 将作为 window.__INITIAL_STATE__ 状态，自动嵌入到最终的 HTML 中。而在客户端，在挂载到应用程序之前，store 就应该获取到状态：</p>
<p><code>entry-client.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; app, router, store &#125; = createApp()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__INITIAL_STATE__) &#123;</span><br><span class="line">  store.replaceState(<span class="built_in">window</span>.__INITIAL_STATE__)</span><br><span class="line">&#125;</span><br><span class="line">app.$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-客户端数据预取"><a href="#3-3-2-客户端数据预取" class="headerlink" title="3.3.2 客户端数据预取"></a>3.3.2 客户端数据预取</h4><p>由于服务器端渲染只会进行首屏渲染，后续路由跳转及数据预取则交给客户端应用程序处理。可以在路由导航之前（router.beforeResolve）解析数据，也可以在匹配要渲染的视图后（组件的beforeMount钩子中）再获取数据。</p>
<blockquote>
<ol>
<li>在路由导航之前解析数据</li>
</ol>
</blockquote>
<blockquote>
<blockquote>
<p>使用此策略，应用程序会等待视图所需数据全部解析之后，再传入数据并处理当前视图。好处在于，可以直接在数据准备就绪时，传入视图渲染完整内容，但是如果数据预取需要很长时间，用户在当前视图会感受到”明显卡顿”。因此，如果使用此策略，建议提供一个数据加载指示器(data loading indicator)。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>我们可以通过检查匹配的组件，并在全局路由钩子函数中执行 asyncData 函数，来在客户端实现此策略。注意，在初始路由准备就绪之后，我们应该注册此钩子，这样我们就不必再次获取服务器提取的数据。</p>
</blockquote>
</blockquote>
<p><code>entry-client.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.onReady(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 添加路由钩子函数，用于处理 asyncData.</span></span><br><span class="line">  <span class="comment">// 在初始路由 resolve 后执行，</span></span><br><span class="line">  <span class="comment">// 以便我们不会二次预取(double-fetch)已有的数据。</span></span><br><span class="line">  <span class="comment">// 使用 `router.beforeResolve()`，以便确保所有异步组件都 resolve。</span></span><br><span class="line">  router.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> matched = router.getMatchedComponents(to)</span><br><span class="line">    <span class="keyword">const</span> prevMatched = router.getMatchedComponents(<span class="keyword">from</span>)</span><br><span class="line">    <span class="comment">// 我们只关心非预渲染的组件</span></span><br><span class="line">    <span class="comment">// 所以我们对比它们，找出两个匹配列表的差异组件</span></span><br><span class="line">    <span class="keyword">let</span> diffed = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> activated = matched.filter(<span class="function">(<span class="params">c, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> diffed || (diffed = (prevMatched[i] !== c))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!activated.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> next()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里如果有加载指示器(loading indicator)，就触发</span></span><br><span class="line">    <span class="built_in">Promise</span>.all(activated.map(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (c.asyncData) &#123;</span><br><span class="line">        <span class="keyword">return</span> c.asyncData(&#123; store, <span class="attr">route</span>: to &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 停止加载指示器(loading indicator)</span></span><br><span class="line">      next()</span><br><span class="line">    &#125;).catch(next)</span><br><span class="line">  &#125;)</span><br><span class="line">  app.$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="2">
<li>匹配要渲染的视图后，再获取数据<blockquote>
<p>此策略将客户端数据预取逻辑，放在视图组件的 beforeMount 函数中。当路由导航被触发时，可以立即切换视图，因此应用程序具有更快的响应速度。然而，传入视图在渲染时不会有完整的可用数据。因此，对于使用此策略的每个视图组件，都需要具有条件加载状态。</p>
</blockquote>
</li>
</ol>
</blockquote>
<blockquote>
<blockquote>
<p>这可以通过纯客户端(client-only)的全局 mixin 来实现：</p>
</blockquote>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  beforeMount () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; asyncData &#125; = <span class="built_in">this</span>.$options</span><br><span class="line">    <span class="keyword">if</span> (asyncData) &#123;</span><br><span class="line">      <span class="comment">// 将获取数据操作分配给 promise</span></span><br><span class="line">      <span class="comment">// 以便在组件中，我们可以在数据准备就绪后</span></span><br><span class="line">      <span class="comment">// 通过运行 `this.dataPromise.then(...)` 来执行其他任务</span></span><br><span class="line">      <span class="built_in">this</span>.dataPromise = asyncData(&#123;</span><br><span class="line">        store: <span class="built_in">this</span>.$store,</span><br><span class="line">        route: <span class="built_in">this</span>.$route</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="3-4-利用bundle-renderer优化"><a href="#3-4-利用bundle-renderer优化" class="headerlink" title="3.4 利用bundle renderer优化"></a>3.4 利用bundle renderer优化</h3><p>到目前为止，在每次编辑过应用程序源代码之后，我们都必须重新打包代码并重启服务，这在开发过程中会影响开发效率。此外，Node.js 本身不支持 source map。</p>
<p><code>vue-server-renderer</code> 提供一个名为 <code>createBundleRenderer</code> 的 API，用于处理此问题，通过使用 webpack 的自定义插件，server bundle 将生成为可传递到 bundle renderer 的特殊 JSON 文件。所创建的 bundle renderer，用法和普通 renderer 相同，但是 bundle renderer 提供以下优点：</p>
<blockquote>
<ul>
<li>内置的 source map 支持（在 webpack 配置中使用 devtool: ‘source-map’）</li>
<li>在开发环境甚至部署过程中热重载（通过读取更新后的 bundle，然后重新创建 renderer 实例）</li>
<li>关键 CSS(critical CSS) 注入（在使用 *.vue 文件时）：自动内联在渲染过程中用到的组件所需的CSS。</li>
<li>使用 clientManifest 进行资源注入：自动推断出最佳的预加载(preload)和预取(prefetch)指令，以及初始渲染所需的代码分割 chunk。</li>
</ul>
</blockquote>
<h4 id="3-4-1-生成server-bundle"><a href="#3-4-1-生成server-bundle" class="headerlink" title="3.4.1 生成server bundle"></a>3.4.1 生成server bundle</h4><p>修改<code>webpack.server.config.js</code>，生成传递给<code>createBundleRenderer</code>的 server bundle。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.base.config&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> VueSSRServerPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer/server-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">&#x27;webpack-node-externals&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(base, &#123;</span><br><span class="line">  target: <span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    server: path.resolve(__dirname, <span class="string">&#x27;../src/entry-server.js&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    libraryTarget: <span class="string">&#x27;commonjs2&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 对 bundle renderer 提供 source map 支持</span></span><br><span class="line">  devtool: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">  <span class="comment">// https://webpack.js.org/configuration/externals/#function</span></span><br><span class="line">  <span class="comment">// https://github.com/liady/webpack-node-externals</span></span><br><span class="line">  <span class="comment">// 外置化应用程序依赖模块。可以使服务器构建速度更快，</span></span><br><span class="line">  <span class="comment">// 并生成较小的 bundle 文件。</span></span><br><span class="line">  externals: nodeExternals(&#123;</span><br><span class="line">    <span class="comment">// 不要外置化 webpack 需要处理的依赖模块。</span></span><br><span class="line">    <span class="comment">// 你可以在这里添加更多的文件类型。例如，未处理 *.vue 原始文件，</span></span><br><span class="line">    <span class="comment">// 你还应该将修改 `global`（例如 polyfill）的依赖模块列入白名单</span></span><br><span class="line">    whitelist: <span class="regexp">/\.css$/</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 这是将服务器的整个输出</span></span><br><span class="line">  <span class="comment">// 构建为单个 JSON 文件的插件。</span></span><br><span class="line">  <span class="comment">// 默认文件名为 `vue-ssr-server-bundle.json`</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueSSRServerPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>打包后会生成<code>vue-ssr-server-bundle.json</code>，传递给<code>createBundleRenderer</code>。</p>
<h4 id="3-4-2-生成-clientManifest"><a href="#3-4-2-生成-clientManifest" class="headerlink" title="3.4.2 生成 clientManifest"></a>3.4.2 生成 clientManifest</h4><p>除了 server bundle 之外，我们还可以生成客户端构建清单(client build manifest)。使用客户端清单(client manifest)和服务器 bundle(server bundle)，renderer 现在具有了服务器和客户端的构建信息，因此它可以自动推断和注入资源预加载 / 数据预取指令(preload / prefetch directive)，以及 css 链接 / script 标签到所渲染的 HTML。</p>
<p>带来的好处:</p>
<blockquote>
<ol>
<li>在生成的文件名中有哈希时，可以取代 html-webpack-plugin 来注入正确的资源 URL。</li>
<li>在通过 webpack 的按需代码分割特性渲染 bundle 时，我们可以确保对 chunk 进行最优化的资源预加载/数据预取，并且还可以将所需的异步 chunk 智能地注入为 <code>&lt;script&gt;</code> 标签，以避免客户端的瀑布式请求(waterfall request)，以及改善可交互时间(TTI - time-to-interactive)。</li>
</ol>
</blockquote>
<p>要使用客户端清单(client manifest)，客户端配置(client config)将如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> VueSSRClientPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer/client-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.base.config&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(base, &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    client: path.resolve(__dirname, <span class="string">&#x27;../src/entry-client.js&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 此插件在输出目录中</span></span><br><span class="line">    <span class="comment">// 生成 `vue-ssr-client-manifest.json`。</span></span><br><span class="line">    <span class="keyword">new</span> VueSSRClientPlugin()</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    <span class="comment">// 将 webpack 运行时分离到一个引导 chunk 中，</span></span><br><span class="line">    <span class="comment">// 以便可以在之后正确注入异步 chunk。</span></span><br><span class="line">    <span class="comment">// 这也为你的 应用程序/vendor 代码提供了更好的缓存。</span></span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      name: <span class="string">&#x27;manifest&#x27;</span>,</span><br><span class="line">      minChunks: <span class="literal">Infinity</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用webpack打包构建后会生成vue-ssr-server-bundle.json和vue-ssr-client-manifest.json，服务器就可已使用createBundleRenderer。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createBundleRenderer &#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> template = fs.readFileSync(<span class="string">&#x27;./src/index.template.html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> serverBundle = <span class="built_in">require</span>(<span class="string">&#x27;./dist/vue-ssr-server-bundle.json&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> clientManifest = <span class="built_in">require</span>(<span class="string">&#x27;./dist/vue-ssr-client-manifest.json&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> renderer = createBundleRenderer(serverBundle, &#123;</span><br><span class="line">  template,</span><br><span class="line">  clientManifest</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="3-4-3-开发过程热重载，主要使用webpack-hot-middleware和webpack-dev-middleware这两个webpack插件。具体代码请参考demo5-build-setup-dev-server-js和demo5-server-js。"><a href="#3-4-3-开发过程热重载，主要使用webpack-hot-middleware和webpack-dev-middleware这两个webpack插件。具体代码请参考demo5-build-setup-dev-server-js和demo5-server-js。" class="headerlink" title="3.4.3 开发过程热重载，主要使用webpack-hot-middleware和webpack-dev-middleware这两个webpack插件。具体代码请参考demo5/build/setup-dev-server.js和demo5/server.js。"></a>3.4.3 开发过程热重载，主要使用<code>webpack-hot-middleware</code>和<code>webpack-dev-middleware</code>这两个webpack插件。具体代码请参考demo5/build/setup-dev-server.js和demo5/server.js。</h4><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><blockquote>
<ul>
<li>服务器端渲染即为服务器生成静态的html字符串，客户端应用程序将静态的html激活为动态的DOM。服务器端渲染通常只会渲染用于请求的第一个url的页面，即只进行首屏渲染，后续则由客户端应用程序激活代理，控制路由、请求及交互。</li>
<li>服务器渲染的 Vue.js 应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。</li>
<li>为避免交叉请求造成状态污染的情况，每个请求都应是全新的、独立的应用程序实例。我们会提取一个工厂函数（createApp），用于创建根vue实例。</li>
<li>所有的生命周期钩子函数中，只有beforeCreate和created会在服务器端渲染(SSR)过程中被调用，其他任何生命周期的代码只会在客户端执行。</li>
<li>客户端入口（entry-client.js）职责是将根vue实例挂在到dom中，用于将服务器端生成的html激活。</li>
<li>服务器端入口（entry-server.js）职责是暴露一个创建根vue实例的方法，可以传入服务器端渲染上下文，我们的服务器代码会为每个请求都调用该方法创建根vue实例并生成html。</li>
<li>关于路由跳转，我们的服务器代码并不会处理请求的url，会透传给服务器端应用程序，由其控制路由跳转。</li>
<li>关于数据预取，通用的数据预取是服务器端渲染最复杂的问题，分为客户端数据预取和服务器端数据预取。</li>
<li>服务器端数据预取，针对用户的请求我们需要预取相关的数据然后进行渲染，需要页面组件暴露asyncData方法，在页面渲染前调用路由匹配组件的该方法，填充到vue store中，并挂载到服务器渲染上下文上，生成的页面会自动挂在store中内容，客户端程序只需将其同步到客户端store中。</li>
<li>客户端数据预取，由于服务器端只进行首屏渲染，后续路由跳转及数据预取则交给客户端应用程序处理。可以在路由导航之前（router.beforeResolve）解析数据，也可以在匹配要渲染的视图后（组件的beforeMount钩子中）再获取数据。</li>
<li>用webpack对服务器端应用程序和客户端应用程序分别进行打包，生成server bundle用于在服务器生成根vue实例，并进行相应的路由匹配、数据预取逻辑，生成client bundle用于在客户端激活服务器端发送的静态html。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title>核心Diff算法</title>
    <url>/2020/09/19/diff/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>虚拟DOM的核心之一就是它的Diff算法，其中最为核心的就是核心Diff算法，只有在新旧虚拟DOM的子节点都是多个的时候，核心Diff算法才会派上用场。</p>
<p>无论何种类型的核心Diff算法，它们采用的核心思想是一致的：</p>
<ul>
<li>1、找到需要移动的节点，并移动它们；</li>
<li>2、添加新的节点；</li>
<li>3、移除不存在的节点。</li>
</ul>
<p>新旧虚拟DOM子节点的可能情况如下：</p>
<table>
<thead>
<tr>
<th align="center">旧的children的个数</th>
<th align="center">新的children的个数</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td>patch</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td>remove</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">n</td>
<td>remove旧的子节点，mount新的子节点</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td>mount</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td>无操作</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">n</td>
<td>mount</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">1</td>
<td>remove旧的子节点，mount新的子节点</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">0</td>
<td>remove</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">n</td>
<td>核心Diff</td>
</tr>
</tbody></table>
<h3 id="虚拟DOM的结构"><a href="#虚拟DOM的结构" class="headerlink" title="虚拟DOM的结构"></a>虚拟DOM的结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface VNode &#123;</span><br><span class="line">  _isVNode: <span class="literal">true</span>                  <span class="comment">// _isVNode是一个始终为 true 的值，有了它，我们就可以判断一个对象是否是 VNode 对象</span></span><br><span class="line">  el: Element | <span class="literal">null</span>              <span class="comment">// 当一个 VNode 被渲染为真实 DOM 之后，el 属性的值会引用该真实DOM</span></span><br><span class="line">  flags: VNodeFlags</span><br><span class="line">  tag: string | FunctionalComponent | ComponentClass | <span class="literal">null</span></span><br><span class="line">  data: VNodeData | <span class="literal">null</span></span><br><span class="line">  children: VNodeChildren</span><br><span class="line">  childFlags: ChildrenFlags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>_isVNode：是一个始终为 true 的值，有了它，我们就可以判断一个对象是否是 VNode 对象。</li>
<li>el：当一个 VNode 被渲染为真实 DOM 之后，el 属性的值会引用该真实DOM。</li>
<li>flags：VNode 的类型。</li>
<li>tag：标签名称。</li>
<li>data： VNode 数据，用于对 VNode 进行描述。假如一个 VNode 的类型是 html 标签，则 VNodeData 中可以包含 class、style 以及一些事件。</li>
<li>children：子节点。</li>
<li>childFlags：子节点的类型。</li>
</ul>
<h3 id="无key时的核心Diff算法"><a href="#无key时的核心Diff算法" class="headerlink" title="无key时的核心Diff算法"></a>无key时的核心Diff算法</h3><p>我们经常会遇到一个可排序的列表，假设我们又一个由<code>li</code>标签组成的列表，它们是<code>ul</code>标签子节点，我们可以使用下面的数组来表示 ul 标签的 children：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  h(<span class="string">&#x27;li&#x27;</span>, <span class="literal">null</span>, <span class="number">1</span>),</span><br><span class="line">  h(<span class="string">&#x27;li&#x27;</span>, <span class="literal">null</span>, <span class="number">2</span>),</span><br><span class="line">  h(<span class="string">&#x27;li&#x27;</span>, <span class="literal">null</span>, <span class="number">3</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>接着由于数据变化导致了列表的顺序发生了变化，新的列表顺序如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  h(<span class="string">&#x27;li&#x27;</span>, <span class="literal">null</span>, <span class="number">3</span>),</span><br><span class="line">  h(<span class="string">&#x27;li&#x27;</span>, <span class="literal">null</span>, <span class="number">1</span>),</span><br><span class="line">  h(<span class="string">&#x27;li&#x27;</span>, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>我们能够注意到：更新前后的真实 DOM 元素都是 li 标签。我们可以复用 li 标签，这样就能减少“移除”和“新建” DOM 元素带来的性能开销。当新旧 VNode 所描述的是相同标签时，那么这两个 VNode 之间的差异就仅存在于 VNodeData 和 children 上，所以我们完全可以通过遍历新旧 VNode，并一一比对它们，这样对于任何一个 DOM 元素来说，由于它们都是相同的标签，所以更新的过程是不会“移除”和“新建”任何 DOM 元素的，而是复用已有 DOM 元素，需要更新的只有 VNodeData 和 children。</p>
<p>更新操作如下图表示：</p>
<p><img src= "/img/loading.gif" data-src="diff2.png" alt="diff2"></p>
<p>当新的 children 比旧的 children 的长度要长时，多出来的子节点是没办法应用 patch 函数的，此时我们应该把多出来的子节点作为新的节点添加上去。类似的，如果新的 children 比旧的 children 的长度要短时，我们应该把旧的 children 中多出来的子节点移除，如下图所示：</p>
<p><img src= "/img/loading.gif" data-src="diff3.png" alt="diff3"><br><img src= "/img/loading.gif" data-src="diff4.png" alt="diff4"></p>
<h3 id="React的核心Diff算法"><a href="#React的核心Diff算法" class="headerlink" title="React的核心Diff算法"></a>React的核心Diff算法</h3><p>前面，我们通过减少 DOM 操作的次数使得更新的性能得到了提升，但它仍然存在可优化的空间。我们通过观察新旧 children 可以很容易的发现：新旧 children 中的节点只有顺序是不同的，所以最佳的操作应该是通过移动元素的位置来达到更新的目的。</p>
<p>能够移动元素的关键在于：我们需要在新旧 children 的节点中保存映射关系，以便我们能够在旧 children 的节点中找到可复用的节点。这时候我们就需要给 children 中的节点添加唯一标识，也就是我们常说的 key，在没有 key 的情况下，我们是没办法知道新 children 中的节点是否可以在旧 children 中找到可复用的节点的。</p>
<p>为了明确的知道新旧 children 中节点的映射关系，我们需要在 VNode 创建伊始就为其添加唯一的标识，即 key 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旧 children</span></span><br><span class="line">[</span><br><span class="line">  h(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">key</span>: <span class="string">&#x27;a&#x27;</span> &#125;, <span class="number">1</span>),</span><br><span class="line">  h(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">key</span>: <span class="string">&#x27;b&#x27;</span> &#125;, <span class="number">2</span>),</span><br><span class="line">  h(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">key</span>: <span class="string">&#x27;c&#x27;</span> &#125;, <span class="number">3</span>)</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 新 children</span></span><br><span class="line">[</span><br><span class="line">  h(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">key</span>: <span class="string">&#x27;c&#x27;</span> &#125;, <span class="number">3</span>)</span><br><span class="line">  h(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">key</span>: <span class="string">&#x27;a&#x27;</span> &#125;, <span class="number">1</span>),</span><br><span class="line">  h(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">key</span>: <span class="string">&#x27;b&#x27;</span> &#125;, <span class="number">2</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>有了 key 我们就能够明确的知道新旧 children 中节点的映射关系，如下图所示：</p>
<p><img src= "/img/loading.gif" data-src="diff5.png" alt="diff5"></p>
<p>知道了映射关系，我们就很容易判断新 children 中的节点是否可被复用：只需要遍历新 children 中的每一个节点，并去旧 children 中寻找是否存在具有相同 key 值的节点。</p>
<p>现在我们已经找到了可复用的节点，并进行了合适的更新操作，下一步需要做的，就是判断一个节点是否需要移动以及如何移动。</p>
<p>我们可以先考虑不需要移动的情况，当新旧 children 中的节点顺序不变时，就不需要额外的移动操作，如下：</p>
<p><img src= "/img/loading.gif" data-src="diff6.png" alt="diff6"></p>
<ul>
<li>1、取出新 children 的第一个节点，即 li-a，并尝试在旧 children 中寻找 li-a，结果是我们找到了，并且 li-a 在旧 children 中的索引为 0。</li>
<li>2、取出新 children 的第二个节点，即 li-b，并尝试在旧 children 中寻找 li-b，也找到了，并且 li-b 在旧 children 中的索引为 1。</li>
<li>3、取出新 children 的第三个节点，即 li-c，并尝试在旧 children 中寻找 li-c，同样找到了，并且 li-c 在旧 children 中的索引为 2。</li>
</ul>
<p>总结一下我们在“寻找”的过程中，先后遇到的索引顺序为：0-&gt;1-&gt;2。这是一个递增的顺序，这说明如果在寻找的过程中遇到的索引呈现递增趋势，则说明新旧 children 中节点顺序相同，不需要移动操作。相反的，如果在寻找的过程中遇到的索引值不呈现递增趋势，则说明需要移动操作。</p>
<p>我们在寻找过程中有一个重要的数字，寻找过程中在旧 children 中所遇到的最大索引值。如果在后续寻找的过程中发现存在索引值比最大索引值小的节点，意味着该节点需要被移动。</p>
<p>现在我们已经有办法找到需要移动的节点了，接下来要解决的问题就是：应该如何移动这些节点？为了弄明白这个问题，我们还是先来看下图：</p>
<p><img src= "/img/loading.gif" data-src="diff7.png" alt="diff7"></p>
<p>新 children 中的第一个节点是 li-c，它在旧 children 中的索引为 2，由于 li-c 是新 children 中的第一个节点，所以它始终都是不需要移动的，只需要调用 patch 函数更新即可。</p>
<p>li-c 节点更新完毕，接下来是新 children 中的第二个节点 li-a，它在旧 children 中的索引是 0，由于 0 &lt; 2 所以 li-a 是需要移动的节点。新 children 中的节点顺序实际上就是更新完成之后节点应有的最终顺序，只需把 li-a 节点对应的真实 DOM 移动到 li-c 节点所对应真实 DOM 的后面。</p>
<p>当新 children 中包含了一个全新的节点时，我们尝试在旧的 children 中寻找该节点时，是找不到可复用节点的，这时就没办法通过移动节点来完成更新操作。此时应该将该节点挂载到合适的位置。</p>
<p>除了要将全新的节点添加到容器元素之外，我们还应该把已经不存在了的节点移除。在我们遍历完新 children 后，再遍历一次旧的 children ，并尝试拿着旧 children 中的节点去新 children 中寻找相同的节点，如果找不到则说明该节点已经不存在于新 children 中了，这时我们应该将该节点对应的真实 DOM 移除。</p>
<p>至此，第一个完整的 Diff 算法我们就讲解完毕了，这个算法就是 React 所采用的 Diff 算法。但该算法仍然存在可优化的空间。</p>
<h3 id="Vue2-x的核心Diff算法"><a href="#Vue2-x的核心Diff算法" class="headerlink" title="Vue2.x的核心Diff算法"></a>Vue2.x的核心Diff算法</h3><p>React 的 Diff 算法是存在优化空间的，想要要找到优化的关键点，我们首先要知道它存在什么问题。来看下图：</p>
<p><img src= "/img/loading.gif" data-src="diff8.png" alt="diff8"></p>
<p>在这个例子中，我们可以通过肉眼观察从而得知最优的解决方案应该是：把 li-c 节点对应的真实 DOM 移动到最前面即可，只需要一次移动即可完成更新。然而，React 所采用的 Diff 算法在更新如上案例的时候，会进行两次移动。</p>
<p>采用双端比较的方式，可以来避免多余的DOM移动操作。所谓双端比较，就是同时从新旧 children 的两端开始进行比较的一种方式，所以我们需要四个索引值，分别指向新旧 children 的两端，如下图所示：</p>
<p><img src= "/img/loading.gif" data-src="diff9.png" alt="diff9"></p>
<p>在一次比较过程中，最多需要进行四次比较：</p>
<ul>
<li>1、使用旧 children 的头一个 VNode 与新 children 的头一个 VNode 比对，即 oldStartVNode 和 newStartVNode 比较对。</li>
<li>2、使用旧 children 的最后一个 VNode 与新 children 的最后一个 VNode 比对，即 oldEndVNode 和 newEndVNode 比对。</li>
<li>3、使用旧 children 的头一个 VNode 与新 children 的最后一个 VNode 比对，即 oldStartVNode 和 newEndVNode 比对。</li>
<li>4、使用旧 children 的最后一个 VNode 与新 children 的头一个 VNode 比对，即 oldEndVNode 和 newStartVNode 比对。</li>
</ul>
<p>在如上四步比对过程中，试图去寻找可复用的节点，即拥有相同 key 值的节点。这四步比对中，在任何一步中寻找到了可复用节点，则会停止后续的步骤，可以用下图来描述在一次比对过程中的四个步骤：</p>
<p><img src= "/img/loading.gif" data-src="diff10.png" alt="diff10"></p>
<p>每次比对完成之后，如果在某一步骤中找到了可复用的节点，我们就需要将相应的位置索引后移/前移一位。以上图为例：</p>
<ul>
<li>第一步：拿旧 children 中的 li-a 和新 children 中的 li-d 进行比对，由于二者 key 值不同，所以不可复用，什么都不做。</li>
<li>第二步：拿旧 children 中的 li-d 和新 children 中的 li-c 进行比对，同样不可复用，什么都不做。</li>
<li>第三步：拿旧 children 中的 li-a 和新 children 中的 li-c 进行比对，什么都不做。</li>
<li>第四步：拿旧 children 中的 li-d 和新 children 中的 li-d 进行比对，由于这两个节点拥有相同的 key 值，所以我们在这次比对的过程中找到了可复用的节点。</li>
</ul>
<p>由于我们在第四步的比对中找到了可复用的节点，这说明：li-d 节点所对应的真实 DOM 原本是最后一个子节点，并且更新之后它应该变成第一个子节点。所以我们需要把 li-d 所对应的真实 DOM 移动到最前方即可。</p>
<p>对于上面的四步比较，需要进行移动操作的其实只有两步，包括刚刚的第四步，以及第三步。如果在第三步中找到了可以复用的节点，说明该节点原本是第一个节点，在更新后变成了最后一个节点，所以需要把它对应的真是 DOM 移动到最后面即可。</p>
<p>下面来处理非理想的情况，如果在上述四个步骤中均无法找到可以复用的节点，我们只能拿新 children 中的第一个节点尝试去旧 children 中寻找，试图找到拥有相同 key 值的节点。如果找到则意味着：旧 children 中的这个节点所对应的真实 DOM 在新 children 的顺序中，已经变成了第一个节点。所以我们需要把该节点所对应的真实 DOM 移动到最前头。</p>
<p>我们尝试拿着新 children 中的第一个节点去旧 children 中寻找与之拥有相同 key 值的可复用节点，然后并非总是能够找得到，当新的 children 中拥有全新的节点时，就会出现找不到的情况，我们应该将其挂载到容器中。</p>
<p>同时我们需要考虑循环结束后新 children 有剩余节点的情况，此时也需要将剩余的节点挂载到容器中。</p>
<p>最后一个需要考虑的情况是：当有元素被移除时的情况。如果在循环结束后旧的 children 有剩余测节点，则这些剩余的节点需要被移除。</p>
<p>以上就是相对完整的双端比较算法的实现，这是 Vue2.x 所采用的算法，借鉴于开源项目：<a href="https://github.com/snabbdom/snabbdom">snabbdom</a>。</p>
<h3 id="Vue3-x的核心Diff算法"><a href="#Vue3-x的核心Diff算法" class="headerlink" title="Vue3.x的核心Diff算法"></a>Vue3.x的核心Diff算法</h3><p>优化核心Diff算法，本质上还是要避免核心Diff算法的执行。所以在真正执行核心Diff算法前先进行预处理，去除相同的前缀与后缀节点，仅对它们执行 patch 操作。</p>
<p><img src= "/img/loading.gif" data-src="diff11.png" alt="diff11"></p>
<p>在去掉相同的前缀与后缀节点后，如果新旧 children 均有剩余节点，此时需要执行核心Diff算法。</p>
<p>无论是 React 的 Diff 算法，还是 Vue2(snabbdom) 的 Diff 算法，其重点无非就是：判断是否有节点需要移动，以及应该如何移动和寻找出那些需要被添加或移除的节点。</p>
<p>首先，我们需要构造一个数组 source，该数组的长度等于新 children 在经过预处理之后剩余未处理节点的数量，并且该数组中每个元素的初始值为 -1，如下图所示：</p>
<p><img src= "/img/loading.gif" data-src="diff12.png" alt="diff12"></p>
<p>source 数组将用来存储新 children 中的节点在旧 children 中的位置，后面将会使用它计算出一个最长递增子序列，并用于 DOM 移动。如下图所示：</p>
<p><img src= "/img/loading.gif" data-src="diff13.png" alt="diff13"></p>
<p>可以看到 source 数组的第四个元素值仍然为初始值 -1，这是因为新 children 中的 li-g 节点不存在于旧 children 中。除此之外，还有一件很重要的事儿需要做，即判断是否需要移动节点，判断的方式类似于 React 所采用的方式。</p>
<p>对于移动节点，我们会根据 source 数组计算出一个最长递增子序列，并用于 DOM 移动操作。</p>
<p>出数组 source 的最长递增子序列为 [ 0, 1 ]。我们知道 source 数组的值为 [2, 3, 1, -1]，很显然最长递增子序列应该是 [ 2, 3 ]，但为什么计算出的结果是 [ 0, 1 ] 呢？其实 [ 0, 1 ] 代表的是最长递增子序列中的各个元素在 source 数组中的位置索引，如下图所示：</p>
<p><img src= "/img/loading.gif" data-src="diff14.png" alt="diff14"></p>
<p>我们对新 children 中的剩余未处理节点进行了重新编号，li-c 节点的位置是 0，以此类推。而最长递增子序列是 [ 0, 1 ] 这告诉我们：新 children 的剩余未处理节点中，位于位置 0 和位置 1 的节点的先后关系与他们在旧 children 中的先后关系相同。或者我们可以理解为位于位置 0 和位置 1 的节点是不需要被移动的节点，即上图中 li-c 节点和 li-d 节点将在接下来的操作中不会被移动。换句话说只有 li-b 节点和 li-g 节点是可能被移动的节点，但是我们发现与 li-g 节点位置对应的 source 数组元素的值为 -1，这说明 li-g 节点应该作为全新的节点被挂载，所以只有 li-b 节点需要被移动。</p>
<p>使用两个索引 i 和 j 分别指向新 children 中剩余未处理节点的最后一个节点和最长递增子序列数组中的最后一个位置，并从后向前遍历。判断当前节点的位置索引值 i 是否与子序列中位于 j 位置的值相等，如果不相等，则说明该节点需要被移动；如果相等则说明该节点不需要被移动，并且会让 j 指向下一个位置。为了将节点挂载到正确的位置，我们需要找到当前节点的真实位置索引(i + nextStart)，以及当前节点的后一个节点，并挂载该节点的前面即可。</p>
<p>对于最长递增子序列的求解，这是一个算法题，使用动态规划进行求解，感兴趣的同学可以查阅相关资料。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>无论是 React 的 Diff 算法，还是 Vue2(snabbdom) 的 Diff 算法，抑或是 Vue3 的核心 Diff 算法，其重点无非就是：判断是否有节点需要移动，以及应该如何移动和寻找出那些需要被添加或移除的节点。</p>
<p>核心 Diff 算法的目的是避免创建和移除 DOM 的开销，尽可能的复用节点，只是进行 patch，并移动。而复用的关键是新旧 children 的节点保持映射关系，通常开发者通过指定 key prop 来暗示某些节点在不同的渲染下保持稳定。</p>
<p>核心 Diff 算法最好的优化手段就是避免它们的执行。</p>
]]></content>
      <categories>
        <category>diff</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>react</tag>
        <tag>diff</tag>
      </tags>
  </entry>
  <entry>
    <title>es6新特性</title>
    <url>/2020/02/04/es6%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="一-es6对象的扩展"><a href="#一-es6对象的扩展" class="headerlink" title="一. es6对象的扩展"></a>一. es6对象的扩展</h2><h3 id="1-属性的简洁表示法"><a href="#1-属性的简洁表示法" class="headerlink" title="1. 属性的简洁表示法"></a>1. 属性的简洁表示法</h3><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> birth =<span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Person =&#123;</span><br><span class="line"></span><br><span class="line">  name:<span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//等同于birth: birth</span></span><br><span class="line"> birth,   </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 等同于hello: function ()...</span></span><br><span class="line"> hello()&#123; console.log(&amp;#39;我的名字是&amp;#39;,this.name);&#125;  </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-属性名表达式"><a href="#2-属性名表达式" class="headerlink" title="2. 属性名表达式"></a>2. 属性名表达式</h3><p>JavaScript 定义对象的属性，有两种方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"></span><br><span class="line">obj.foo =<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"></span><br><span class="line">obj[<span class="string">&#x27;a&#x27;</span>+<span class="string">&#x27;bc&#x27;</span>]=<span class="number">123</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ES6 允许字面量定义对象时，用表达式作为对象的属性名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey =<span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj =&#123;</span><br><span class="line"></span><br><span class="line"> [propKey]:<span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line"> [<span class="string">&#x27;a&#x27;</span>+<span class="string">&#x27;bc&#x27;</span>]:<span class="number">123</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>表达式还可以用于定义方法名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj =&#123;</span><br><span class="line"></span><br><span class="line">  [<span class="string">&#x27;h&#x27;</span>+<span class="string">&#x27;ello&#x27;</span>]()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span> ;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hello()</span><br></pre></td></tr></table></figure>
<h3 id="3-属性的遍历"><a href="#3-属性的遍历" class="headerlink" title="3.属性的遍历"></a>3.属性的遍历</h3><p>遍历对象属性的方法:</p>
<p><strong>（1）for…in</strong>   循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<p><strong>（2）Object.keys(obj)</strong>   返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<p><strong>（3）Object.getOwnPropertyNames(obj)</strong>   返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong>   返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p><strong>（5）Reflect.ownKeys(obj)</strong>   返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(&#123;[<span class="built_in">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>,<span class="number">10</span>:<span class="number">0</span>,<span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [2, 10, b, a, Symbol()]</span></span><br></pre></td></tr></table></figure>
<h3 id="4-super-关键字"><a href="#4-super-关键字" class="headerlink" title="4.super 关键字"></a>4.super 关键字</h3></li>
</ul>
<p>this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto =&#123;</span><br><span class="line"></span><br><span class="line">    foo:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line"></span><br><span class="line">    foo:<span class="string">&#x27;world&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">find</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.foo;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.find()</span><br></pre></td></tr></table></figure>
<p>JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto =&#123;</span><br><span class="line"></span><br><span class="line">    x:<span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line"></span><br><span class="line">    x:<span class="string">&#x27;world&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.foo();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.foo()</span><br></pre></td></tr></table></figure>
<h3 id="5-解构赋值"><a href="#5-解构赋值" class="headerlink" title="5.解构赋值"></a>5.解构赋值</h3><p>对象的解构赋值用于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>&#123; x, y,...aa &#125;=&#123; <span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">a</span>:<span class="number">3</span>, <span class="attr">b</span>:<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>
<p>解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj =&#123; <span class="attr">a</span>:&#123; <span class="attr">b</span>:<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>&#123;...x &#125;= obj;</span><br><span class="line"></span><br><span class="line">obj.a.b =<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">x.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 =&#123; <span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o2 =&#123; <span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">o2.__proto__ = o1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>&#123;...o3 &#125;= o2;</span><br><span class="line"></span><br><span class="line">o3 <span class="comment">// &#123; b: 2 &#125;</span></span><br><span class="line"></span><br><span class="line">o3.a<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = <span class="built_in">Object</span>.create(&#123; <span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">o.z =<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>&#123; x,...newObj &#125;= o;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>&#123; y, z &#125;= newObj;</span><br><span class="line"></span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">z <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h3 id="6-扩展运算符"><a href="#6-扩展运算符" class="headerlink" title="6.扩展运算符"></a>6.扩展运算符</h3><p>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> z =&#123; <span class="attr">a</span>:<span class="number">3</span>, <span class="attr">b</span>:<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n =&#123;...z &#125;;</span><br><span class="line"></span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>
<p>数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo =&#123;...[a,b,c]&#125;;</span><br><span class="line"></span><br><span class="line">foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;0: a, 1: b, 2: c&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果扩展运算符后面不是对象，则会自动将其转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于 &#123;...Object(1)&#125;</span></span><br><span class="line"></span><br><span class="line">&#123;..<span class="number">.1</span>&#125; <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，扩展运算符后面是整数1，会自动转为数值的包装对象Number{1}。由于该对象没有自身属性，所以返回一个空对象。</p>
<p>如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;...<span class="string">&#x27;hello&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;0: &#x27;h&#x27;, 1: &#x27;e&#x27;, 2: &#x27;l&#x27;, 3: &#x27;l&#x27;, 4: &#x27;o&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p>扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并不会抛出错误，因为 x 属性只是被定义，但没执行</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> aWithXGetter =&#123;</span><br><span class="line"></span><br><span class="line">    ...a,</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getx</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;not throw yet&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会抛出错误，因为 x 属性被执行了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> runtimeError =&#123;</span><br><span class="line"></span><br><span class="line">    ...a,</span><br><span class="line"></span><br><span class="line">    ...&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">getaa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;throw now&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二．Es6对象的新增方法"><a href="#二．Es6对象的新增方法" class="headerlink" title="二．Es6对象的新增方法"></a>二．Es6对象的新增方法</h2><h3 id="1-Object-is"><a href="#1-Object-is" class="headerlink" title="1.Object.is()"></a>1.Object.is()</h3><p>ES5 比较两个值是否相等：相等运算符（==）和严格相等运算符（===）。</p>
<p>Object.is它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;,&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>不同之处只有两个：一是+0不等于-0，二是NaN等于自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span>===-<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">NaN</span>===<span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>,-<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Object-assign"><a href="#2-Object-assign" class="headerlink" title="2.Object.assign()"></a>2.Object.assign()</h3><p>用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target =&#123; <span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 =&#123; <span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source2 =&#123; <span class="attr">c</span>:<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line"></span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target =&#123; <span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 =&#123; <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source2 =&#123; <span class="attr">c</span>:<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line"></span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果该参数不是对象，则会先转成对象，然后返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>) <span class="comment">// [object]</span></span><br></pre></td></tr></table></figure>
<p>由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>Object.assign只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;<span class="attr">b</span>:c&#125;,</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(&#123;&#125;,<span class="string">&#x27;invisible&#x27;</span>,&#123;</span><br><span class="line"></span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    value:<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; b: c &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>（1）浅拷贝</strong></p>
<p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<p><strong>（2）同名属性的替换</strong></p>
<p>对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target =&#123; <span class="attr">a</span>:&#123; <span class="attr">b</span>:c, <span class="attr">d</span>:e;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source =&#123; <span class="attr">a</span>:&#123; <span class="attr">b</span>:<span class="string">&#x27;hello&#x27;</span>;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）数组的处理</strong></p>
<p>Object.assign可以用来处理数组，但是会把数组视为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<p><strong>（4）取值函数的处理</strong></p>
<p>Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source =&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getfoo</span>(<span class="params"></span>)</span>&#123;return1&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target =&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><p><strong>（1）为对象添加属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span>.assign(<span class="built_in">this</span>,&#123;x, y&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。</p>
<p><strong>（2）为对象添加方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype,&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">someMethod</span>(<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        ···</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line"></span><br><span class="line">SomeClass.prototype.someMethod =<span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>（3）克隆对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">functionclone</span>(<span class="params">origin</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">functionclone</span>(<span class="params">origin</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Object-getOwnPropertyDescriptors"><a href="#3-Object-getOwnPropertyDescriptors" class="headerlink" title="3.Object.getOwnPropertyDescriptors()"></a>3.Object.getOwnPropertyDescriptors()</h3><p>ES5 的Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）。</p>
<p>ES2017 引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line"></span><br><span class="line">    foo:<span class="number">123</span>,</span><br><span class="line"></span><br><span class="line">    getbar()&#123;return&amp;#39;abc&amp;#39;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p>该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source =&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">setfoo</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target1 =&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target1, source);</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(target1,&amp;#39;foo&amp;#39;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: undefined,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，source对象的foo属性的值是一个赋值函数，Object.assign方法将这个属性拷贝给target1对象，结果该属性的值变成了undefined。这是因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p>
<p>这时，Object.getOwnPropertyDescriptors()方法配合Object.defineProperties()方法，就可以实现正确拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source =&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">setfoo</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target2 =&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target2, <span class="built_in">Object</span>.getOwnPropertyDescriptors(source));</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(target2, &amp;#39;foo&amp;#39;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; get: undefined,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   set: [Function: set foo],</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>Object.getOwnPropertyDescriptors()方法的另一个用处，是配合Object.create()方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</span><br></pre></td></tr></table></figure>
<p>另外，Object.getOwnPropertyDescriptors()方法可以实现一个对象继承另一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(</span><br><span class="line"></span><br><span class="line">    prot,</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyDescriptors(&#123;</span><br><span class="line"></span><br><span class="line">        foo:<span class="number">123</span>,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="4-proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#4-proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="4.__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a>4.__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h3><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。</p>
<h3 id="（1）Object-setPrototypeOf"><a href="#（1）Object-setPrototypeOf" class="headerlink" title="（1）Object.setPrototypeOf()"></a>（1）Object.setPrototypeOf()</h3><p>Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>该方法等同于下面的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">functionsetPrototypeOf</span>(<span class="params">obj, proto</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">obj.__proto__ = proto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proto =&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj =&#123; <span class="attr">x</span>:<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y =<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">proto.z =<span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">obj.y <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">obj.z <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>
<p>上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。</p>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>
<h3 id="（2）Object-getPrototypeOf"><a href="#（2）Object-getPrototypeOf" class="headerlink" title="（2）Object.getPrototypeOf()"></a>（2）Object.getPrototypeOf()</h3><p>该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">functionRectangle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rec =newRectangle();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec)=== Rectangle.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果参数是undefined或null，它们无法转为对象，所以会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br></pre></td></tr></table></figure>
<h3 id="5-Object-keys-，Object-values-，Object-entries"><a href="#5-Object-keys-，Object-values-，Object-entries" class="headerlink" title="5.Object.keys()，Object.values()，Object.entries()"></a>5.Object.keys()，Object.values()，Object.entries()</h3><h4 id="（1）Object-keys"><a href="#（1）Object-keys" class="headerlink" title="（1）Object.keys()"></a>（1）Object.keys()</h4><p>ES5 的Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<p>ES2017 <a href="https://github.com/tc39/proposal-object-values-entries">引入</a>了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>&#123;keys, values, entries&#125;= <span class="built_in">Object</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj =&#123; <span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// a,b,c</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> values(obj))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span>[key, value] <span class="keyword">of</span> entries(obj))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log([key, value]); <span class="comment">// [a, 1], [b, 2], [c, 3]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（2）Object-values"><a href="#（2）Object-values" class="headerlink" title="（2）Object.values()"></a>（2）Object.values()</h4><p>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123; <span class="attr">foo</span>:<span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>:<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&#x27;bar&#x27;, 42]</span></span><br></pre></td></tr></table></figure>
<p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123;<span class="number">100</span>:<span class="string">&#x27;a&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;b&#x27;</span>,<span class="number">7</span>:<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。</p>
<p>Object.values只返回对象自身的可遍历属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;,&#123;<span class="attr">p</span>:&#123;<span class="attr">value</span>:<span class="number">42</span>&#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Object.create方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的enumerable默认是false，Object.values不会返回这个属性。只要把enumerable改成true，Object.values就会返回属性p的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;,&#123;<span class="attr">p</span>:</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        value:<span class="number">42</span>,</span><br><span class="line"></span><br><span class="line">        enumerable:<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// [42]</span></span><br></pre></td></tr></table></figure>
<p>Object.values会过滤属性名为 Symbol 值的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(&#123;[<span class="built_in">Symbol</span>()]:<span class="number">123</span>, <span class="attr">foo</span>:<span class="string">&#x27;abc&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;,&#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure>
<h4 id="（3）Object-entries"><a href="#（3）Object-entries" class="headerlink" title="（3）Object.entries()"></a>（3）Object.entries()</h4><p>Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123; <span class="attr">foo</span>:<span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>:<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.entries(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [[&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 42] ]</span></span><br></pre></td></tr></table></figure>
<p>除了返回值不一样，该方法的行为与Object.values基本一致。</p>
<p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.entries(&#123;[<span class="built_in">Symbol</span>()]:<span class="number">123</span>, <span class="attr">foo</span>:<span class="string">&#x27;abc&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [[ &#x27;foo&#x27;, &#x27;abc&#x27;] ]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，原对象有两个属性，Object.entries只输出属性名非 Symbol 值的属性。将来可能会有Reflect.ownEntries()方法，返回对象自身的所有属性。</p>
<p>Object.entries的基本用途是遍历对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj =&#123; <span class="attr">one</span>:<span class="number">1</span>, <span class="attr">two</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span>[k, v] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line"></span><br><span class="line">        <span class="string">`<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(k)&#125;</span>: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(v)&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// one: 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// two: 2</span></span><br></pre></td></tr></table></figure>
<p>Object.entries方法的另一个用处是，将对象转为真正的Map结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123; <span class="attr">foo</span>:<span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>:<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map =newMap(<span class="built_in">Object</span>.entries(obj));</span><br><span class="line"></span><br><span class="line">map <span class="comment">// Map &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="（4）Object-fromEntries"><a href="#（4）Object-fromEntries" class="headerlink" title="（4）Object.fromEntries()"></a>（4）Object.fromEntries()</h3><p>Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。因此特别适合将 Map 结构转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> entries =newMap([</span><br><span class="line"></span><br><span class="line">    [<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line"></span><br><span class="line">    [<span class="string">&#x27;baz&#x27;</span>,<span class="number">42</span>]</span><br><span class="line"></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.fromEntries(entries)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map =newMap().set(<span class="string">&#x27;foo&#x27;</span>,<span class="literal">true</span>).set(<span class="string">&#x27;bar&#x27;</span>,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.fromEntries(map)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; foo: true, bar: false &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>react源码之react入口函数</title>
    <url>/2021/05/31/react%E6%BA%90%E7%A0%81%E4%B9%8Breact%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>react源码版本是17.0.2</p>
<h2 id="1-react-入口"><a href="#1-react-入口" class="headerlink" title="1. react 入口"></a>1. react 入口</h2><p>react入口函数有三种模式：</p>
<ul>
<li>legacy(传统)模式： <code>ReactDOM.render(, rootNode)</code>；<strong>LegacyRoot = 0</strong>。<blockquote>
<p>这是当前 React app 使用的方式。构建dom的过程是同步的，所以在render阶段，如果diff特别耗时，会导致js一直阻塞高优先级的任务(例如用户的点击事件)，表现为页面的卡顿，无法响应。</p>
</blockquote>
</li>
<li>blocking(阻塞)模式： <code>ReactDOM.createBlockingRoot(rootNode).render()</code>；<strong>BlockingRoot = 1</strong>。目前正在实验中。作为迁移到 concurrent 模式的第一个步骤。<blockquote>
<p>最新的react文档指出，下面所有关于 “blocking 模式” 和 createBlockingRoot 的说法都已过时，应忽略。</p>
</blockquote>
</li>
<li>concurrent(并发)模式： <code>ReactDOM.createRoot(rootNode).render()</code>；<strong>ConcurrentRoot = 2</strong>。<blockquote>
<p>目前在实验中，未来稳定之后，打算作为 React 的默认开发模式。将长任务分成一个个小任务，每一帧都预留出时间片(5ms)供react执行js代码，通过调度实现异步可中断、带优先级的更新任务.高优先级的任务可以打断低优先级任务。当前时间片时间用完，就暂停react的任务，将主线程控制权交还给浏览器使其有时间渲染 UI。react等待下一帧的时间片，再继续被打断的任务。</p>
</blockquote>
</li>
</ul>
<p>下图为入口函数的执行过程：<br><img src= "/img/loading.gif" data-src="%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0.png" alt="入口函数"></p>
<h3 id="1-1-react-入口函数"><a href="#1-1-react-入口函数" class="headerlink" title="1.1 react 入口函数"></a>1.1 react 入口函数</h3><h4 id="legacy模式入口"><a href="#legacy模式入口" class="headerlink" title="legacy模式入口"></a>legacy模式入口</h4><p><code>ReactDOM.render(&lt;App /&gt;, rootElement)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> legacyRenderSubtreeIntoContainer(<span class="literal">null</span>, element, container, <span class="literal">false</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">legacyRenderSubtreeIntoContainer</span>(<span class="params">parentComponent, children, container, forceHydrate, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> root = container._reactRootContainer;</span><br><span class="line">  <span class="keyword">var</span> fiberRoot;</span><br><span class="line">  <span class="comment">// 第一次执行ReactDOM.render时，root为null</span></span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="comment">// 创建根DOM实例，里面有_internalRoot属性，存放fiberRoot</span></span><br><span class="line">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);</span><br><span class="line">    fiberRoot = root._internalRoot;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> originalCallback = callback;</span><br><span class="line">      callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class="line">        originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 首次渲染不进行批量更新</span></span><br><span class="line">    unbatchedUpdates(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// children 是传入ReactDOM.render方法的第一参数，react元素&lt;App/&gt;</span></span><br><span class="line">       children = element = &#123;</span><br><span class="line">          $$typeof: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">          key: <span class="literal">null</span>,</span><br><span class="line">          props: &#123;&#125;,</span><br><span class="line">          ref: <span class="literal">null</span>,</span><br><span class="line">          type: App</span><br><span class="line">        &#125;</span><br><span class="line">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fiberRoot = root._internalRoot;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> _originalCallback = callback;</span><br><span class="line">      callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class="line">        _originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="comment">// Update</span></span><br><span class="line">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getPublicRootInstance(fiberRoot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">legacyCreateRootFromDOMContainer</span>(<span class="params">container, forceHydrate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是服务器端渲染    </span></span><br><span class="line">  <span class="comment">// 是否需要复用原先的dom节点，再合并（为true表示需要有子节点且是服务器端渲染</span></span><br><span class="line">  <span class="keyword">var</span> shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); </span><br><span class="line">  <span class="comment">// 如果不是服务端渲染</span></span><br><span class="line">  <span class="keyword">if</span> (!shouldHydrate) &#123;</span><br><span class="line">    <span class="keyword">var</span> rootSibling;</span><br><span class="line">    <span class="comment">// 把container（即传入div#app）的子节点全部删除</span></span><br><span class="line">    <span class="keyword">while</span> (rootSibling = container.lastChild) &#123;</span><br><span class="line">      container.removeChild(rootSibling);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> createLegacyRoot(container, shouldHydrate ? &#123;</span><br><span class="line">    hydrate: <span class="literal">true</span></span><br><span class="line">  &#125; : <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLegacyRoot</span>(<span class="params">container, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// LegacyRoot = 0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMBlockingRoot(container, LegacyRoot, options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDOMBlockingRoot</span>(<span class="params">container, tag, options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._internalRoot = createRootImpl(container, tag, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="concurrent模式入口"><a href="#concurrent模式入口" class="headerlink" title="concurrent模式入口"></a>concurrent模式入口</h4><p><code>ReactDOM.createRoot(rootNode).render(&lt;App/&gt;)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRoot</span>(<span class="params">container, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMRoot(container, options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Concurrent 模式，ConcurrentRoot = 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDOMRoot</span>(<span class="params">container, options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._internalRoot = createRootImpl(container, ConcurrentRoot, options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ReactDOM.unstable_createRoot(document.getElementById(&#x27;root&#x27;)).render(&lt;App /&gt;)</span></span><br><span class="line"><span class="comment">  ReactDOM.unstable_createRoot(document.getElementById(&#x27;root&#x27;)) 返回ReactDOMRoot实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> root = <span class="built_in">this</span>._internalRoot;</span><br><span class="line">  updateContainer(children, root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建fiberRoot-和-rootFiber的公共逻辑"><a href="#创建fiberRoot-和-rootFiber的公共逻辑" class="headerlink" title="创建fiberRoot 和 rootFiber的公共逻辑"></a>创建fiberRoot 和 rootFiber的公共逻辑</h4><ul>
<li>调用createRootImpl，会调用到createFiberRoot创建fiberRootNode，然后调用createHostRootFiber创建rootFiber<blockquote>
<p>其中fiberRootNode是整个项目的根节点，包含应用挂载的目标节点，记录整个应用更新过程的各种信息<br>rootFiber是当前应用挂载的节点，即ReactDOM.render调用后的根节点</p>
</blockquote>
</li>
<li>fiberRoot和rootFiber的关系<blockquote>
<p>fiberRoot.current = rootFiber<br>rootFiber.stateNode = fiberRoot<br>rootFiber.child = fiber</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRootImpl</span>(<span class="params">container, tag, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 是否是服务器端渲染</span></span><br><span class="line">  <span class="keyword">var</span> hydrate = options != <span class="literal">null</span> &amp;&amp; options.hydrate === <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> hydrationCallbacks = options != <span class="literal">null</span> &amp;&amp; options.hydrationOptions || <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// Legacy模式下，tag=0；Concurrent 模式下，tag=2</span></span><br><span class="line">  <span class="keyword">var</span> root = createContainer(container, tag, hydrate);</span><br><span class="line">  <span class="comment">// 事件挂载</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;</span><br><span class="line">    <span class="comment">// 监听所有原生事件，暂不细讲</span></span><br><span class="line">    listenToAllSupportedEvents(rootContainerElement);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Legacy模式下，tag=0；Concurrent 模式下，tag=2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createContainer</span>(<span class="params">containerInfo, tag, hydrate, hydrationCallbacks</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createFiberRoot(containerInfo, tag, hydrate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Legacy模式下，tag=0；Concurrent 模式下，tag=2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFiberRoot</span>(<span class="params">containerInfo, tag, hydrate, hydrationCallbacks</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取fiberRoot</span></span><br><span class="line">  <span class="keyword">var</span> root = <span class="keyword">new</span> FiberRootNode(containerInfo, tag, hydrate);</span><br><span class="line">  <span class="comment">// 获取rootFiber，Legacy模式下，tag=0；Concurrent 模式下，tag=2</span></span><br><span class="line">  <span class="keyword">var</span> uninitializedFiber = createHostRootFiber(tag);</span><br><span class="line">  <span class="comment">// fiberRoot和rootFiber相关联</span></span><br><span class="line">  root.current = uninitializedFiber;</span><br><span class="line">  uninitializedFiber.stateNode = root;</span><br><span class="line">  <span class="comment">/*初始化rootFiber的更新队列updateQueue</span></span><br><span class="line"><span class="comment">  uninitializedFiber.updateQueue = &#123;</span></span><br><span class="line"><span class="comment">      baseState: fiber.memoizedState,</span></span><br><span class="line"><span class="comment">      baseQueue: null,</span></span><br><span class="line"><span class="comment">      shared: &#123;</span></span><br><span class="line"><span class="comment">        pending: null</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      effects: null</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">  initializeUpdateQueue(uninitializedFiber);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化更新队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeUpdateQueue</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> queue = &#123;</span><br><span class="line">    baseState: fiber.memoizedState,</span><br><span class="line">    firstBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">    lastBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">    shared: &#123;</span><br><span class="line">      pending: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    effects: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  fiber.updateQueue = queue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Legacy模式下，tag=0；Concurrent 模式下，tag=2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberRootNode</span>(<span class="params">containerInfo, tag, hydrate</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.tag = tag; <span class="comment">// 标记不同组件类型，如函数组件、类组件、文本、原生组件...</span></span><br><span class="line">    <span class="built_in">this</span>.current = <span class="literal">null</span>; <span class="comment">// FiberRoot.current = RootFiber</span></span><br><span class="line">    <span class="built_in">this</span>.containerInfo = containerInfo; <span class="comment">// 与fiberRoot关联的DOM容器信息,render方法接收的第二个参数</span></span><br><span class="line">    <span class="built_in">this</span>.callbackNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.callbackPriority = NoLanePriority;</span><br><span class="line">    <span class="built_in">this</span>.eventTimes = createLaneMap(NoLanes); <span class="comment">// 更新任务开始时间，是长度为31的数组，初始值是[0,0,...]</span></span><br><span class="line">    <span class="built_in">this</span>.expirationTimes = createLaneMap(NoTimestamp); <span class="comment">// 更新任务过期时间，是长度为31的数组，初始值是[-1,-1,...]</span></span><br><span class="line">    <span class="built_in">this</span>.pendingLanes = NoLanes; <span class="comment">// 未执行任务的lanes</span></span><br><span class="line">    <span class="built_in">this</span>.suspendedLanes = NoLanes; <span class="comment">// 挂起任务的lanes</span></span><br><span class="line">    <span class="built_in">this</span>.pingedLanes = NoLanes; <span class="comment">// 挂起后恢复的任务lanes</span></span><br><span class="line">    <span class="built_in">this</span>.expiredLanes = NoLanes; <span class="comment">// 过期任务的lanes</span></span><br><span class="line">    <span class="built_in">this</span>.finishedLanes = NoLanes; <span class="comment">// 已完成任务的lanes</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Legacy模式下，tag=0；Concurrent 模式下，tag=2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHostRootFiber</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var NoMode = 0;</span></span><br><span class="line"><span class="comment">var StrictMode = 1; </span></span><br><span class="line"><span class="comment">var BlockingMode = 2;</span></span><br><span class="line"><span class="comment">var ConcurrentMode = 4;</span></span><br><span class="line"><span class="comment">var ProfileMode = 8;*/</span></span><br><span class="line">  <span class="keyword">var</span> mode;</span><br><span class="line">  <span class="keyword">if</span> (tag === ConcurrentRoot) &#123;</span><br><span class="line">    mode = ConcurrentMode | BlockingMode | StrictMode;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === BlockingRoot) &#123;</span><br><span class="line">    mode = BlockingMode | StrictMode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mode = NoMode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( isDevToolsPresent) &#123; <span class="comment">// 处于开发者工具模式，mode = ProfileMode = 8</span></span><br><span class="line">    mode |= ProfileMode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// HostRoot = 3，根组件的tag值</span></span><br><span class="line">  <span class="keyword">return</span> createFiber(HostRoot, <span class="literal">null</span>, <span class="literal">null</span>, mode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> createFiber = <span class="function"><span class="keyword">function</span> (<span class="params">tag, pendingProps, key, mode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FiberNode(tag, pendingProps, key, mode);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: WorkTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="literal">null</span> | string,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Instance</span></span><br><span class="line">  <span class="built_in">this</span>.tag = tag; <span class="comment">// 标记不同组件类型，如函数组件、类组件、文本、原生组件...</span></span><br><span class="line">  <span class="built_in">this</span>.key = key; <span class="comment">// react 元素上的 key</span></span><br><span class="line">  <span class="built_in">this</span>.elementType = <span class="literal">null</span>; <span class="comment">// createElement的第一个参数，ReactElement 上的 type</span></span><br><span class="line">  <span class="built_in">this</span>.type = <span class="literal">null</span>;  <span class="comment">// 表示fiber的真实类型 ，跟 elementType 基本一样，在使用了懒加载之类的功能时可能会不一样</span></span><br><span class="line">  <span class="built_in">this</span>.stateNode = <span class="literal">null</span>; <span class="comment">// 实例对象，比如 class 组件 new 完后就挂载在这个属性上面，如果是RootFiber，那么它上面挂的是 FiberRoot,如果是原生节点就是 dom 对象</span></span><br><span class="line">  <span class="comment">// Fiber</span></span><br><span class="line">  <span class="built_in">this</span>.return = <span class="literal">null</span>; <span class="comment">// 父节点，指向上一个 fiber</span></span><br><span class="line">  <span class="built_in">this</span>.child = <span class="literal">null</span>; <span class="comment">// 子节点，指向自身下面的第一个子 fiber</span></span><br><span class="line">  <span class="built_in">this</span>.sibling = <span class="literal">null</span>; <span class="comment">// 兄弟组件, 指向一个兄弟节点</span></span><br><span class="line">  <span class="built_in">this</span>.index = <span class="number">0</span>; <span class="comment">//  一般如果没有兄弟节点的话是0；当某个父节点下的子节点是数组类型的时候会给每个子节点一个 index，index 和 key 要一起做 diff</span></span><br><span class="line">  <span class="built_in">this</span>.ref = <span class="literal">null</span>; <span class="comment">// reactElement 上的 ref 属性</span></span><br><span class="line">  <span class="built_in">this</span>.pendingProps = pendingProps; <span class="comment">// 新的 props</span></span><br><span class="line">  <span class="built_in">this</span>.memoizedProps = <span class="literal">null</span>; <span class="comment">// 旧的 props</span></span><br><span class="line">  <span class="built_in">this</span>.updateQueue = <span class="literal">null</span>; <span class="comment">// fiber 上的更新队列执行一次 setState，就会往这个属性上挂一个新的更新, 每条更新最终会形成一个链表结构，最后做批量更新</span></span><br><span class="line">  <span class="built_in">this</span>.memoizedState = <span class="literal">null</span>;  <span class="comment">// 对应  memoizedProps，上次渲染的 state，相当于当前的 state</span></span><br><span class="line">  <span class="built_in">this</span>.mode = mode; <span class="comment">// 表示当前组件下的子组件的渲染方式</span></span><br><span class="line">  <span class="comment">// Effects</span></span><br><span class="line">  <span class="built_in">this</span>.flags = NoFlags; <span class="comment">// 表示当前 fiber 要进行何种更新（更新、删除等）</span></span><br><span class="line">  <span class="built_in">this</span>.nextEffect = <span class="literal">null</span>;  <span class="comment">// 指向下个需要更新的fiber</span></span><br><span class="line">  <span class="built_in">this</span>.firstEffect = <span class="literal">null</span>;  <span class="comment">// 指向所有子节点里，需要更新的 fiber 里的第一个</span></span><br><span class="line">  <span class="built_in">this</span>.lastEffect = <span class="literal">null</span>;  <span class="comment">// 指向所有子节点中需要更新的 fiber 的最后一个</span></span><br><span class="line">  <span class="built_in">this</span>.lanes = NoLanes; <span class="comment">// 任务优先级</span></span><br><span class="line">  <span class="built_in">this</span>.childLanes = NoLanes; <span class="comment">// child 任务优先级</span></span><br><span class="line">  <span class="built_in">this</span>.alternate = <span class="literal">null</span>; <span class="comment">// current 树和 workInprogress 树之间的相互引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeUpdateQueue</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> queue = &#123;</span><br><span class="line">    baseState: fiber.memoizedState,</span><br><span class="line">    baseQueue: <span class="literal">null</span>,</span><br><span class="line">    shared: &#123;</span><br><span class="line">      pending: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    effects: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  fiber.updateQueue = queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>执行非批量更新的操作 unbatchedUpdates</strong> </p>
<ul>
<li>保存初始上下文，增加非批量上下文，删除批量更新上下文， 执行函数， 重置上下文，重置时间和执行同步队列  </li>
<li>非批量更新下，会走同步更新逻辑，因为是第一次更新，需要用户尽快看到页面内容，不走异步更新的逻辑  </li>
<li>执行完fn，需要恢复之前的执行环境 prevExecutionContext</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// react transaction 事务机制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unbatchedUpdates</span>(<span class="params">fn, a</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 初始 executionContext = NoContext = 0</span></span><br><span class="line">    <span class="comment">// NoContext = 0b000000 = 0</span></span><br><span class="line">    <span class="comment">// BatchedContext = 0b000001 = 1</span></span><br><span class="line">    <span class="comment">// LegacyUnbatchedContext = 0b001000 = 8</span></span><br><span class="line">    <span class="keyword">var</span> prevExecutionContext = executionContext;</span><br><span class="line">    <span class="comment">// executionContext &amp;= ~BatchedContext的效果其实就是还原了上次executionContext |= BatchedContext;</span></span><br><span class="line">    <span class="comment">// 去除批量更新的标记 假设executionContext=0b000001，~BatchedContext=11111110，0b000001&amp;11111110=0</span></span><br><span class="line">    executionContext &amp;= ~BatchedContext; <span class="comment">// ~00000001=11111110；00000000&amp;11111110=00000000；带符号的二进制转换成十进制，保留符号位取反加1，11111110取反10000001，加1得10000010=-2</span></span><br><span class="line">    <span class="comment">// 更新executionContext为非批量 LegacyUnbatchedContext</span></span><br><span class="line">    executionContext |= LegacyUnbatchedContext; <span class="comment">// 00000000&amp;00001000=00001000=8</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn(a);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 在执行完回调之后，会恢复上下文</span></span><br><span class="line">      executionContext = prevExecutionContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-创建更新-updateContainer"><a href="#1-2-创建更新-updateContainer" class="headerlink" title="1.2 创建更新 updateContainer"></a>1.2 创建更新 updateContainer</h3><ul>
<li>获取rootFiber</li>
<li>获取当前时间</li>
<li>获取更新优先级lane </li>
<li>创建更新</li>
<li>将更新加入更新队列</li>
<li>更新任务调度</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// container为fiberRoot，第一次，parentComponent=null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateContainer</span>(<span class="params">element, container, parentComponent, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current$<span class="number">1</span> = container.current; <span class="comment">// 获取rootFiber</span></span><br><span class="line">  <span class="keyword">var</span> eventTime = requestEventTime(); <span class="comment">// 获取当前时间</span></span><br><span class="line">  <span class="keyword">var</span> lane = requestUpdateLane(current$<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 创建更新</span></span><br><span class="line">  <span class="keyword">var</span> update = createUpdate(eventTime, lane);</span><br><span class="line">  <span class="comment">/* rootFiber的update.payload存放的不是更新的state</span></span><br><span class="line"><span class="comment">     而是存放的ReactDOM.render中传入的第一个参数，即通过jsx的createElement生成的元素</span></span><br><span class="line"><span class="comment">     element = &#123;</span></span><br><span class="line"><span class="comment">        $$typeof: REACT_ELEMENT_TYPE,</span></span><br><span class="line"><span class="comment">        key: null,</span></span><br><span class="line"><span class="comment">        props: &#123;&#125;,</span></span><br><span class="line"><span class="comment">        ref: null,</span></span><br><span class="line"><span class="comment">        type: ƒ App(props)</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">    update.payload = &#123;element&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  update.payload = &#123;</span><br><span class="line">    element: element</span><br><span class="line">  &#125;;</span><br><span class="line">  callback = callback === <span class="literal">undefined</span> ? <span class="literal">null</span> : callback;</span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  enqueueUpdate(current$<span class="number">1</span>, update);</span><br><span class="line">  scheduleUpdateOnFiber(current$<span class="number">1</span>, lane, eventTime);</span><br><span class="line">  <span class="keyword">return</span> lane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）获取当前时间  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestEventTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行完unbatchedUpdates之后，executionContext = LegacyUnbatchedContext = 00001000 = 8，非批量更新</span></span><br><span class="line">  <span class="comment">// RenderContext = 00010000 = 16</span></span><br><span class="line">  <span class="comment">// CommitContext = 00100000 = 32</span></span><br><span class="line">  <span class="comment">// 在render和commit阶段，直接获取当前真实时间</span></span><br><span class="line">  <span class="keyword">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class="line">    <span class="keyword">return</span> now();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他阶段，对所有更新使用相同的开始时间，除非重新进入react</span></span><br><span class="line">  <span class="comment">// 有currentEventTime，返回currentEventTime</span></span><br><span class="line">  <span class="keyword">if</span> (currentEventTime !== NoTimestamp) &#123;</span><br><span class="line">    <span class="keyword">return</span> currentEventTime;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 没有currentEventTime，初次更新，没有任务，计算一个新的当前时间并赋给全局变量。</span></span><br><span class="line">  currentEventTime = now();</span><br><span class="line">  <span class="keyword">return</span> currentEventTime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// performance.now(), 从 page load 的时候从零开始计数,单位是ms</span></span><br><span class="line"><span class="keyword">var</span> initialTimeMs = performance.now()</span><br><span class="line"><span class="comment">// 如果初始时间相当小，小于10s，则now为当前时间；否则，当前时间减去初始时间 initialTimeMs</span></span><br><span class="line"><span class="keyword">var</span> now = initialTimeMs &lt; <span class="number">10000</span> ? performance.now : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> performance.now() - initialTimeMs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2）获取更新优先级lane，requestUpdateLane</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestUpdateLane</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    入口为ConcurrentRoot， mode = ConcurrentMode | BlockingMode | StrictMode</span></span><br><span class="line"><span class="comment">    入口为BlockingRoot， mode = BlockingMode | StrictMode</span></span><br><span class="line"><span class="comment">    其他情况，mode = NoMode</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">var</span> mode = fiber.mode; <span class="comment">// Legacy模式下是0，开发者模式下是8</span></span><br><span class="line">  <span class="comment">// BlockingMode = 8，ConcurrentMode = 16</span></span><br><span class="line">  <span class="keyword">if</span> ((mode &amp; BlockingMode) === NoMode) &#123; <span class="comment">// 不是BlockingMode 模式，说明是Legacy模式，同步更新</span></span><br><span class="line">    <span class="comment">// 同步的，旧模式中lane只为SyncLane = 1</span></span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">  <span class="comment">// BlockingMode 模式</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((mode &amp; ConcurrentMode) === NoMode) &#123; <span class="comment">// 非ConcurrentMode模式</span></span><br><span class="line">      <span class="comment">// 通过获取当前优先级getCurrentPriorityLevel 判断，是同步还是批量同步更新</span></span><br><span class="line">    <span class="keyword">return</span> getCurrentPriorityLevel() === ImmediatePriority$<span class="number">1</span> ? SyncLane : SyncBatchedLane; <span class="comment">// 同步或同步批量</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 以下是Concurrent模式的代码逻辑</span></span><br><span class="line">  <span class="comment">// 获取当前fiberRoot所拥有的lanes（已占用的赛道）；刚加载时，workInProgressRootIncludedLanes=0</span></span><br><span class="line">  <span class="keyword">if</span> (currentEventWipLanes === NoLanes) &#123;</span><br><span class="line">    currentEventWipLanes = workInProgressRootIncludedLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取调度优先级</span></span><br><span class="line">  <span class="comment">// getCurrentPriorityLevel() =&gt; return currentPriorityLevel</span></span><br><span class="line">  <span class="comment">// 刚开始，currentPriorityLevel = NormalPriority(3) &lt;=&gt; NormalPriority$1(97)</span></span><br><span class="line">  <span class="keyword">var</span> schedulerPriority = getCurrentPriorityLevel(); </span><br><span class="line">  <span class="keyword">var</span> lane;</span><br><span class="line">  <span class="comment">// 若是事件产生的更新，且是离散事件的执行环境(click、keydown、focus等不连续事件)，且当前的调度优先级是用户阻塞型优先级</span></span><br><span class="line">  <span class="comment">// InputDiscreteLanePriority = 12</span></span><br><span class="line">  <span class="keyword">if</span> ( </span><br><span class="line">  (executionContext &amp; DiscreteEventContext) !== NoContext &amp;&amp; schedulerPriority === UserBlockingPriority$<span class="number">2</span>) &#123;</span><br><span class="line">    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调度优先级转换为更新任务优先级</span></span><br><span class="line">    <span class="keyword">var</span> schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority);</span><br><span class="line">    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lane;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">根据更新任务优先级lanePriority获取优先级lane（赛车的初始赛道）</span></span><br><span class="line"><span class="comment">从lanePriority对应高优先级lane开始，从高到低，递归获取未被占用的lane</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findUpdateLane</span>(<span class="params">lanePriority, wipLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (lanePriority) &#123;</span><br><span class="line">    <span class="keyword">case</span> NoLanePriority:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SyncLanePriority:</span><br><span class="line">      <span class="keyword">return</span> SyncLane;</span><br><span class="line">    <span class="keyword">case</span> SyncBatchedLanePriority:</span><br><span class="line">      <span class="keyword">return</span> SyncBatchedLane;</span><br><span class="line">    <span class="keyword">case</span> InputDiscreteLanePriority:</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> _lane = pickArbitraryLane(InputDiscreteLanes &amp; ~wipLanes); <span class="comment">// lanes &amp; -lanes</span></span><br><span class="line">        <span class="keyword">if</span> (_lane === NoLane) &#123;</span><br><span class="line">          <span class="comment">// 上一个优先级的InputDiscreteLanes被占满，下移到到相邻的较低优先级范围内寻找空闲的lane</span></span><br><span class="line">          <span class="comment">// 从高到低，循环遍历没被占用的赛道</span></span><br><span class="line">          <span class="keyword">return</span> findUpdateLane(InputContinuousLanePriority, wipLanes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// _lane不等于0，说明InputDiscreteLanes没有被占满</span></span><br><span class="line">        <span class="keyword">return</span> _lane;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> InputContinuousLanePriority:</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> _lane2 = pickArbitraryLane(InputContinuousLanes &amp; ~wipLanes);</span><br><span class="line">        <span class="keyword">if</span> (_lane2 === NoLane) &#123;</span><br><span class="line">          <span class="keyword">return</span> findUpdateLane(DefaultLanePriority, wipLanes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _lane2;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> DefaultLanePriority:</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">           DefaultLanes &amp; ~wipLanes，从DefaultLanes中去除已被占用的lanes</span></span><br><span class="line"><span class="comment">           pickArbitraryLane(lanes): 找到lanes中最靠左的那个1所对应的lanes值，找到lanes中优先级最高lane</span></span><br><span class="line"><span class="comment">           lanes 为0时，pickArbitraryLane(lanes)才会等于0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">var</span> _lane3 = pickArbitraryLane(DefaultLanes &amp; ~wipLanes);</span><br><span class="line">        <span class="keyword">if</span> (_lane3 === NoLane) &#123;  </span><br><span class="line">          <span class="comment">// 若DefaultLanes以前的lanes都被占满，则到TransitionLanes寻找空闲的lane，TransitionLanes的可用位数更多</span></span><br><span class="line">          _lane3 = pickArbitraryLane(TransitionLanes &amp; ~wipLanes);</span><br><span class="line">          <span class="comment">// 若连TransitionLanes都被占用了，那么这时候赋值一个默认优先级级别的lane，可能会打断正在进行更新任务</span></span><br><span class="line">          <span class="keyword">if</span> (_lane3 === NoLane) &#123;</span><br><span class="line">            _lane3 = pickArbitraryLane(DefaultLanes);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _lane3;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> TransitionPriority: </span><br><span class="line">    <span class="keyword">case</span> RetryLanePriority:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IdleLanePriority:</span><br><span class="line">      <span class="keyword">var</span> lane = pickArbitraryLane(IdleLanes &amp; ~wipLanes);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (lane === NoLane) &#123;</span><br><span class="line">        lane = pickArbitraryLane(IdleLanes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> lane;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  找到lanes中最靠左的那个1所对应的lanes值，lanes中，1越靠左，个数越少，优先级越高</span></span><br><span class="line"><span class="comment">  ~a: 取反；-a：取反+1</span></span><br><span class="line"><span class="comment">  例如：0110 &amp; -0110 = 0010</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickArbitraryLane</span>(<span class="params">lanes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    getHighestPriorityLane(lanes) =&gt; lanes &amp; -lanes</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> getHighestPriorityLane(lanes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getCurrentPriorityLevel：Scheduler调度优先级转换为react-dom中Scheduler调度优先级</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// react-dom.development.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentPriorityLevel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (Scheduler_getCurrentPriorityLevel()) &#123;</span><br><span class="line">    <span class="keyword">case</span> Scheduler_ImmediatePriority:</span><br><span class="line">      <span class="keyword">return</span> ImmediatePriority$<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Scheduler_UserBlockingPriority:</span><br><span class="line">      <span class="keyword">return</span> UserBlockingPriority$<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Scheduler_NormalPriority:</span><br><span class="line">      <span class="keyword">return</span> NormalPriority$<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Scheduler_LowPriority:</span><br><span class="line">      <span class="keyword">return</span> LowPriority$<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Scheduler_IdlePriority:</span><br><span class="line">      <span class="keyword">return</span> IdlePriority$<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// scheduler.development.js</span></span><br><span class="line"><span class="comment">// 初始，currentPriorityLevel = NormalPriority = 3，普通</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_getCurrentPriorityLevel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> currentPriorityLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>schedulerPriorityToLanePriority：调度优先级转换为更新任务优先级</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">schedulerPriorityToLanePriority</span>(<span class="params">schedulerPriorityLevel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (schedulerPriorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">      <span class="keyword">return</span> SyncLanePriority;</span><br><span class="line">    <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">      <span class="keyword">return</span> InputContinuousLanePriority;</span><br><span class="line">    <span class="keyword">case</span> NormalPriority:</span><br><span class="line">    <span class="keyword">case</span> LowPriority:</span><br><span class="line">      <span class="keyword">return</span> DefaultLanePriority; <span class="comment">// 普通优先级和低优先级具有相同的更新任务优先级</span></span><br><span class="line">    <span class="keyword">case</span> IdlePriority:</span><br><span class="line">      <span class="keyword">return</span> IdleLanePriority;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> NoLanePriority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）创建更新</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建更新</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUpdate</span>(<span class="params">eventTime, lane</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> update = &#123;</span><br><span class="line">    eventTime: eventTime, <span class="comment">// 更新的开始时间</span></span><br><span class="line">    lane: lane, <span class="comment">// 更新优先级</span></span><br><span class="line">    <span class="comment">/*var UpdateState = 0;</span></span><br><span class="line"><span class="comment">    var ReplaceState = 1;</span></span><br><span class="line"><span class="comment">    var ForceUpdate = 2;</span></span><br><span class="line"><span class="comment">    var CaptureUpdate = 3;*/</span></span><br><span class="line">    tag: UpdateState, <span class="comment">// 更新的类型，0：更新；1: 替换；2：强制更新；3：捕获性的更新</span></span><br><span class="line">    payload: <span class="literal">null</span>, <span class="comment">// 更新的内容，比如setState接收的第一个参数</span></span><br><span class="line">    callback: <span class="literal">null</span>, <span class="comment">// 对应更新后的回调，比如setState(&#123;&#125;, callback )</span></span><br><span class="line">    next: <span class="literal">null</span> <span class="comment">// 指向下一个更新</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）将更新插入到更新链表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">fiber, update</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*fiber.updateQueue的初始值为：</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">      baseState: fiber.memoizedState,</span></span><br><span class="line"><span class="comment">      baseQueue: null,</span></span><br><span class="line"><span class="comment">      shared: &#123;</span></span><br><span class="line"><span class="comment">        pending: null</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      effects: null</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">  <span class="keyword">var</span> updateQueue = fiber.updateQueue;</span><br><span class="line">  <span class="comment">// 若updateQueue为null，说明fiber已被卸载</span></span><br><span class="line">  <span class="keyword">if</span> (updateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Only occurs if the fiber has been unmounted.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sharedQueue = updateQueue.shared;</span><br><span class="line">  <span class="keyword">var</span> pending = sharedQueue.pending;</span><br><span class="line">  <span class="comment">// update1指向updtae2，update2执行update3...update3指向update1</span></span><br><span class="line">  <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123; <span class="comment">// 第一次更新，创建循环单链表</span></span><br><span class="line">    <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      update1.next = update1</span></span><br><span class="line"><span class="comment">      sharedQueue.pending = update1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    update.next = update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 将新的update插入到pending之后</span></span><br><span class="line">    <span class="comment">// update1.next=update2,update2.next=update3,update3.next=update1</span></span><br><span class="line">    <span class="comment">// sharedQueue.pending = update3</span></span><br><span class="line">    update.next = pending.next;</span><br><span class="line">    pending.next = update;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等待更新的update</span></span><br><span class="line">  sharedQueue.pending = update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react源码之调度入口</title>
    <url>/2021/06/16/react%E6%BA%90%E7%A0%81%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%85%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="2-调度入口"><a href="#2-调度入口" class="headerlink" title="2. 调度入口"></a>2. 调度入口</h2><ul>
<li>获取rootFiber；更新fiber的lanes；从当前fiber往上遍历至fiberRoot，更新父fiber的childLanes</li>
<li>更新rootFiber的pendingLanes和eventTimes</li>
<li>若是同步非批量更新，调用performSyncWorkOnRoot(root)；同步非批量更新和异步更新，调用ensureRootIsScheduled(root, eventTime)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params">fiber, lane, eventTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 得到fiberRoot节点</span></span><br><span class="line">  <span class="comment">// 更新fiber的lanes；从当前fiber往上遍历至fiberRoot，更新父fiber的childLanes</span></span><br><span class="line">  <span class="keyword">var</span> root = markUpdateLaneFromFiberToRoot(fiber, lane);</span><br><span class="line">  <span class="comment">// 更新rootFiber的pendingLanes和eventTimes</span></span><br><span class="line">  markRootUpdated(root, lane, eventTime);</span><br><span class="line">  <span class="keyword">if</span> (root === workInProgressRoot) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前任务被暂停，即workInProgressRootRenderLanes都是被暂停的lanes</span></span><br><span class="line">    <span class="comment">// 从suspendedLanes中移除已经恢复任务的lanes和已经更新完成任务的lanes</span></span><br><span class="line">    <span class="comment">// 更新expirationTimes数组，对suspendedLanes对应index的过期时间设置为-1</span></span><br><span class="line">    <span class="keyword">if</span> (workInProgressRootExitStatus === RootSuspendedWithDelay) &#123;</span><br><span class="line">      markRootSuspended$<span class="number">1</span>(root, workInProgressRootRenderLanes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lane === SyncLane) &#123; <span class="comment">// 同步更新</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">// 当前是同步非批量更新，且非render或非commit阶段</span></span><br><span class="line">    (executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp; <span class="comment">// Check if we&#x27;re not already rendering</span></span><br><span class="line">    (executionContext &amp; (RenderContext | CommitContext)) === NoContext) &#123;</span><br><span class="line">      <span class="comment">// 执行同步更新</span></span><br><span class="line">      performSyncWorkOnRoot(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 批量更新</span></span><br><span class="line">      ensureRootIsScheduled(root, eventTime);</span><br><span class="line">      <span class="comment">// ???</span></span><br><span class="line">      <span class="keyword">if</span> (executionContext === NoContext &amp;&amp; (fiber.mode &amp; ConcurrentMode) === NoMode) &#123;</span><br><span class="line">        resetRenderTimer();</span><br><span class="line">        flushSyncCallbacksOnlyInLegacyMode();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 异步更新</span></span><br><span class="line">    <span class="comment">// Schedule other updates after in case the callback is sync.</span></span><br><span class="line">    ensureRootIsScheduled(root, eventTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-markUpdateLaneFromFiberToRoot-更新fiber的lanes-返回fiberRoot"><a href="#2-1-markUpdateLaneFromFiberToRoot-更新fiber的lanes-返回fiberRoot" class="headerlink" title="2.1 markUpdateLaneFromFiberToRoot: 更新fiber的lanes,返回fiberRoot"></a>2.1 markUpdateLaneFromFiberToRoot: 更新fiber的lanes,返回fiberRoot</h3><p>从当前fiber开始往上到rootFiber更新所有fiber的childLanes</p>
<ul>
<li>更新当前fiber的lanes和alternate的lanes，</li>
<li>从下往上遍历父fiber，更新父fiber的childLanes和父fiber.alternate的childLanes，直到rootFiber </li>
<li>返回fiberRoot</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markUpdateLaneFromFiberToRoot</span>(<span class="params">sourceFiber, lane</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 更新当前fiber的lanes，将lane加入到sourceFiber.lanes中</span></span><br><span class="line">  <span class="comment">// mergeLanes(a, b) =&gt; a | b</span></span><br><span class="line">  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);</span><br><span class="line">  <span class="comment">// 第一次更新，sourceFiber.alternate = null</span></span><br><span class="line">  <span class="keyword">var</span> alternate = sourceFiber.alternate;</span><br><span class="line">  <span class="comment">// alternate非空，也更新alternate的lanes</span></span><br><span class="line">  <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">    alternate.lanes = mergeLanes(alternate.lanes, lane);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> node = sourceFiber;</span><br><span class="line">  <span class="comment">// 获取当前fiber的父fiber，若当前fiber为rootFiber，其父fiber为null</span></span><br><span class="line">  <span class="keyword">var</span> parent = sourceFiber.return;</span><br><span class="line">  <span class="comment">// 从当前fiber开始，从下往上，遍历父fiber，更新父fiber的childLanes和父fiber.alternate的childLanes，直到rootFiber</span></span><br><span class="line">  <span class="keyword">while</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">    parent.childLanes = mergeLanes(parent.childLanes, lane);</span><br><span class="line">    alternate = parent.alternate;</span><br><span class="line">    <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">      alternate.childLanes = mergeLanes(alternate.childLanes, lane);</span><br><span class="line">    &#125;</span><br><span class="line">    node = parent;</span><br><span class="line">    parent = parent.return;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回fiberRoot（rootFiber.tag=3=HostRoot）</span></span><br><span class="line">  <span class="keyword">if</span> (node.tag === HostRoot) &#123;</span><br><span class="line">    <span class="keyword">var</span> root = node.stateNode;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="2-2-markRootUpdated：更新rootFiber的pendingLanes和eventTimes"><a href="#2-2-markRootUpdated：更新rootFiber的pendingLanes和eventTimes" class="headerlink" title="2.2 markRootUpdated：更新rootFiber的pendingLanes和eventTimes"></a>2.2 markRootUpdated：更新rootFiber的pendingLanes和eventTimes</h3><ul>
<li>将当前更新的lane和更新开始时间分别保存到rootFiber.pendingLanes和rootFiber.eventTimes</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新rootFiber的pendingLanes和eventTimes（将当前更新的lane和更新开始时间分别保存到rootFiber.pendingLanes和rootFiber.eventTimes）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markRootUpdated</span>(<span class="params">root, updateLane, eventTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将当前更新的lane(updateLane)放入到rootFiber的pendingLanes中</span></span><br><span class="line">  root.pendingLanes |= updateLane;</span><br><span class="line">  <span class="comment">// 获取比当前updateLane优先级更高的lanes</span></span><br><span class="line">  <span class="keyword">var</span> higherPriorityLanes = updateLane - <span class="number">1</span>; <span class="comment">// Turns 0b1000 into 0b0111</span></span><br><span class="line"> <span class="comment">// ??? 目的是剔除掉suspendedLanes 和 pingedLanes中优先级低于本次更新优先级（updateLane）的lane</span></span><br><span class="line">  <span class="comment">// 实现上方注释中的 “取消同等或较低优先级的更新。”</span></span><br><span class="line">  root.suspendedLanes &amp;= higherPriorityLanes;</span><br><span class="line">  root.pingedLanes &amp;= higherPriorityLanes;</span><br><span class="line">  <span class="comment">// 获取所有的更新开始时间数组eventTimes，31位</span></span><br><span class="line">  <span class="keyword">var</span> eventTimes = root.eventTimes;</span><br><span class="line">  <span class="comment">// 找到lanes中最靠左的那个1在lanes中的index</span></span><br><span class="line">  <span class="keyword">var</span> index = laneToIndex(updateLane); </span><br><span class="line">  <span class="comment">// 将当前更新的开始时间保存到root的更新时间数组中</span></span><br><span class="line">  eventTimes[index] = eventTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-ensureRootIsScheduled-定义了高优先级任务插队逻辑（赛车抢赛道）"><a href="#2-3-ensureRootIsScheduled-定义了高优先级任务插队逻辑（赛车抢赛道）" class="headerlink" title="2.3 ensureRootIsScheduled: 定义了高优先级任务插队逻辑（赛车抢赛道）"></a>2.3 ensureRootIsScheduled: 定义了高优先级任务插队逻辑（赛车抢赛道）</h3><p>获取优先级最高的lane，高优先级任务打断低优先级任务</p>
<ul>
<li>1）循环遍历root.pendingLanes，没有过期时间，计算过期时间；有过期时间，判断是否过期，若过期，加入到root.expiredLanes中</li>
<li>2）从root.expiredLanes和root.pendingLanes未执行任务中找出优先级最高的lane和对应的优先级，获取lanes集合的优先级顺序是，过期任务的expiredLanes&gt;非空闲且非挂起任务的lanes &gt; 非空闲且挂起又恢复任务的lanes &gt; 空闲且非挂起任务的lanes &gt; 空闲且挂起又恢复任务的lanes</li>
<li>3）比较新旧任务的优先级，两者相等，无需调度；前者大于后者，取消旧任务</li>
<li>4）新任务的优先级高于旧任务，根据新任务的优先级来进行不同的调度任务：<blockquote>
<p>同步优先级：调用scheduleSyncCallback去同步执行任务。<br>同步批量执行：调用scheduleCallback，将任务以立即执行的优先级去加入调度。<br>属于concurrent模式的优先级：调用scheduleCallback，将任务通过lanePriorityToSchedulerPriority获取到的新任务优先级去加入调度。</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureRootIsScheduled</span>(<span class="params">root, currentTime</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取旧任务</span></span><br><span class="line">  <span class="keyword">var</span> existingCallbackNode = root.callbackNode; </span><br><span class="line">    <span class="comment">// 从root.pendingLanes最左边的第一个1开始，循环遍历，没有过期时间，计算过期时间；有过期时间，判断是否过期，若过期，加入到root.expiredLanes中</span></span><br><span class="line">  markStarvedLanesAsExpired(root, currentTime); <span class="comment">// Determine the next lanes to work on, and their priority.</span></span><br><span class="line">    <span class="comment">// 从root.pendingLanes未执行任务中和root.expiredLanes中找出优先级最高的lane（过期任务的优先级最高）</span></span><br><span class="line">  <span class="keyword">var</span> nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); </span><br><span class="line">    <span class="comment">// 获取新任务的优先级，即nextLanes对应的优先级，return_highestLanePriority</span></span><br><span class="line">  <span class="keyword">var</span> newCallbackPriority = returnNextLanesPriority();</span><br><span class="line">    <span class="comment">// nextLanes为未执行任务中优先级最高的lanes，若它为空，则说明不需要调度，取消回调，return</span></span><br><span class="line">  <span class="keyword">if</span> (nextLanes === NoLanes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">      root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">      root.callbackPriority = NoLanePriority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 若存在旧任务</span></span><br><span class="line">  <span class="comment">// 新任务的优先级高于或等于旧任务优先级</span></span><br><span class="line">  <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取旧任务的优先级</span></span><br><span class="line">    <span class="keyword">var</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line">    <span class="comment">// 若新旧任务的优先级一样，进入batchedUpdate的逻辑</span></span><br><span class="line">    <span class="comment">// 无需再次发起一次调度，直接复用旧任务即可，让旧任务在处理更新的时候顺便把新任务给做了</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackPriority === newCallbackPriority) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新旧任务的优先级不相等，则说明新任务的优先级一定高于旧任务，这种情况就是高优先级任务插队，需要把旧任务取消掉</span></span><br><span class="line">    <span class="comment">// 每次获取nextLanes时，都是从root.pendingLanes中获取优先级最高的lanes，nextLanes对应的优先级newCallbackPriority也是最高的</span></span><br><span class="line">    cancelCallback(existingCallbackNode); <span class="comment">// existingCallbackNode.callback = null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> newCallbackNode;</span><br><span class="line">  <span class="comment">// 若新任务的优先级为同步优先级，则同步调度，传统的同步渲染和过期任务会走这里</span></span><br><span class="line">  <span class="keyword">if</span> (newCallbackPriority === SyncLanePriority) &#123;</span><br><span class="line">    newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(<span class="literal">null</span>, root));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newCallbackPriority === SyncBatchedLanePriority) &#123; <span class="comment">// 同步模式到concurrent模式的过渡模式：blocking模式会走这里</span></span><br><span class="line">    newCallbackNode = scheduleCallback(ImmediatePriority$<span class="number">1</span>, performSyncWorkOnRoot.bind(<span class="literal">null</span>, root));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// concurrent模式的渲染会走这里</span></span><br><span class="line">    <span class="comment">// 根据任务优先级获取Scheduler的调度优先级</span></span><br><span class="line">    <span class="keyword">var</span> schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);</span><br><span class="line">    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root));</span><br><span class="line">  &#125;</span><br><span class="line">  root.callbackPriority = newCallbackPriority;</span><br><span class="line">  root.callbackNode = newCallbackNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1）markStarvedLanesAsExpired"><a href="#1）markStarvedLanesAsExpired" class="headerlink" title="1）markStarvedLanesAsExpired"></a>1）markStarvedLanesAsExpired</h4><ul>
<li>循环遍历pendingLanes（未执行的任务包含的lane），如果没过期时间就计算一个过期时间，如果过期了就加入root.expiredLanes中</li>
<li>在下次调用getNextLane函数的时候会优先返回expiredLanes</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStarvedLanesAsExpired</span>(<span class="params">root, currentTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pendingLanes = root.pendingLanes;</span><br><span class="line">  <span class="keyword">var</span> suspendedLanes = root.suspendedLanes;</span><br><span class="line">  <span class="keyword">var</span> pingedLanes = root.pingedLanes;</span><br><span class="line">  <span class="keyword">var</span> expirationTimes = root.expirationTimes; </span><br><span class="line">  <span class="keyword">var</span> lanes = pendingLanes;</span><br><span class="line">  <span class="keyword">while</span> (lanes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 以8位二进制0001100为例</span></span><br><span class="line">    <span class="comment">// clz32(lanes) = 3，7 - 3 = 4，index = 4</span></span><br><span class="line">    <span class="comment">// lane = 1 &lt;&lt; 4 = 00010000</span></span><br><span class="line">    <span class="keyword">var</span> index = pickArbitraryLaneIndex(lanes); <span class="comment">// 31 - clz32(lanes)</span></span><br><span class="line">    <span class="keyword">var</span> lane = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">    <span class="keyword">var</span> expirationTime = expirationTimes[index];</span><br><span class="line">        <span class="comment">// 当前没有过期时间就计算一个过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expirationTime === NoTimestamp) &#123;</span><br><span class="line">        <span class="comment">// 当前lane不是挂起任务或当前lane是挂起任务被恢复的lanes，计算当前任务的过期时间</span></span><br><span class="line">      <span class="keyword">if</span> ((lane &amp; suspendedLanes) === NoLanes || (lane &amp; pingedLanes) !== NoLanes) &#123;</span><br><span class="line">        expirationTimes[index] = computeExpirationTime(lane, currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expirationTime &lt;= currentTime) &#123; <span class="comment">// 当前任务过期了</span></span><br><span class="line">      root.expiredLanes |= lane; <span class="comment">// 在expiredLanes加入当前遍历到的lane</span></span><br><span class="line">    &#125;</span><br><span class="line">    lanes &amp;= ~lane;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据优先级，计算lane的过期时间，过期时间分为3种情况：</span></span><br><span class="line"><span class="comment">// 1）用户阻塞型优先级：currentTime + 250（250 ms 后过期），需要用户交互的任务，如按钮点击；</span></span><br><span class="line"><span class="comment">// 2）普通优先级：currentTime + 5000（5 后过期），不必让用户立即感受到的更xin</span></span><br><span class="line"><span class="comment">// 3) 更低优先级或空闲优先级（永不过期）：-1，不必运行的任务（例如，隐藏界面以外的内容）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeExpirationTime</span>(<span class="params">lane, currentTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取lane对应的更新任务优先级</span></span><br><span class="line">  getHighestPriorityLanes(lane); <span class="comment">// lane=512，对应的return_highestLanePriority=DefaultLanePriority=8</span></span><br><span class="line">  <span class="keyword">var</span> priority = return_highestLanePriority;</span><br><span class="line">  <span class="comment">// InputContinuousLanePriority = 10</span></span><br><span class="line">  <span class="keyword">if</span> (priority &gt;= InputContinuousLanePriority) &#123;</span><br><span class="line">    <span class="keyword">return</span> currentTime + <span class="number">250</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priority &gt;= TransitionPriority) &#123; <span class="comment">// TransitionPriority = 6</span></span><br><span class="line">    <span class="keyword">return</span> currentTime + <span class="number">5000</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 任何空闲或更低的优先级都不应该过期</span></span><br><span class="line">    <span class="keyword">return</span> NoTimestamp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）getNextLanes"><a href="#2）getNextLanes" class="headerlink" title="2）getNextLanes"></a>2）getNextLanes</h4><p>获取下一个执行任务的lanes，即从root.pendingLanes未执行任务和root.expiredLanes中找出优先级最高的lane</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNextLanes</span>(<span class="params">root, wipLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pendingLanes = root.pendingLanes;</span><br><span class="line">    <span class="comment">// 没有未执行任务的时，return</span></span><br><span class="line">  <span class="keyword">if</span> (pendingLanes === NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = NoLanePriority;</span><br><span class="line">    <span class="keyword">return</span> NoLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> nextLanes = NoLanes;</span><br><span class="line">  <span class="keyword">var</span> nextLanePriority = NoLanePriority;</span><br><span class="line">  <span class="keyword">var</span> expiredLanes = root.expiredLanes;</span><br><span class="line">  <span class="keyword">var</span> suspendedLanes = root.suspendedLanes;</span><br><span class="line">  <span class="keyword">var</span> pingedLanes = root.pingedLanes; </span><br><span class="line">  <span class="comment">/*检查是有任务过期</span></span><br><span class="line"><span class="comment">    1）任务已过期，设置渲染任务为同步优先级，nextLanes=expiredLanes,nextLanePriority=SyncLanePriority，过期任务优先级最高</span></span><br><span class="line"><span class="comment">    2）任务未过期，从未执行任务的lanes(pendingLanes)获取lanes集合的优先级顺序是，非空闲且非挂起任务的lanes &gt; 非空闲且挂起又恢复任务的lanes &gt; 空闲且非挂起任务的lanes &gt; 空闲且挂起任务的lanes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     3）通过getHighestPriorityLanes，从获取到优先级lanes集合中拿到优先级最高lanes</span></span><br><span class="line"><span class="comment">   拿到nextLanes后，通过getHighestPriorityLanes(lanes)，获取lanes对应的优先级nextLanePriority */</span></span><br><span class="line">  <span class="keyword">if</span> (expiredLanes !== NoLanes) &#123; <span class="comment">// 有任务过期</span></span><br><span class="line">    nextLanes = expiredLanes;</span><br><span class="line">    nextLanePriority = return_highestLanePriority = SyncLanePriority; <span class="comment">// 15，过期任务优先级最高，需要立即执行</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 无任务过期</span></span><br><span class="line">    <span class="comment">// 获取未执行任务lans中非空闲优先级的任务lans</span></span><br><span class="line">    <span class="keyword">var</span> nonIdlePendingLanes = pendingLanes &amp; NonIdleLanes;</span><br><span class="line">    <span class="comment">// 从未执行任务lans中，先取非挂起任务的lans，从非挂起任务的lans中获取最高的优先级的lane和lane对应的优先级</span></span><br><span class="line">    <span class="comment">// 若全是非挂起任务的lans，则从非挂起任务的lans中获取最高的优先级的lanes和lanes对应的优先级</span></span><br><span class="line">    <span class="keyword">if</span> (nonIdlePendingLanes !== NoLanes) &#123; <span class="comment">// 有非空闲任务的lans</span></span><br><span class="line">      <span class="keyword">var</span> nonIdleUnblockedLanes = nonIdlePendingLanes &amp; ~suspendedLanes; <span class="comment">// 去掉挂起任务的lans</span></span><br><span class="line">    <span class="comment">// nonIdleUnblockedLanes：nonIdlePendingLanes中去掉挂起任务的lans</span></span><br><span class="line">      <span class="keyword">if</span> (nonIdleUnblockedLanes !== NoLanes) &#123; <span class="comment">// 说明nonIdlePendingLanes中，除了有非挂起任务的lans，还有其他的lans</span></span><br><span class="line">        nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);</span><br><span class="line">        nextLanePriority = return_highestLanePriority;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// nonIdleUnblockedLanes为null，说明nonIdlePendingLanes中只有挂起任务的lans</span></span><br><span class="line">        <span class="comment">// 从nonIdlePendingLanes中获取挂起任务lanes中被恢复的lanes</span></span><br><span class="line">        <span class="keyword">var</span> nonIdlePingedLanes = nonIdlePendingLanes &amp; pingedLanes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nonIdlePingedLanes !== NoLanes) &#123;</span><br><span class="line">          nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);</span><br><span class="line">          nextLanePriority = return_highestLanePriority;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有空闲任务的lans</span></span><br><span class="line">      <span class="comment">// 从未执行任务的lans中去掉挂起任务的lans，即获取非阻塞任务lans</span></span><br><span class="line">      <span class="keyword">var</span> unblockedLanes = pendingLanes &amp; ~suspendedLanes;</span><br><span class="line">      <span class="comment">// 也是优先取非挂起任务的lans，没有的话，再取挂起任务的lans</span></span><br><span class="line">      <span class="comment">// 从lanes中，获取最高的优先级的lanes和lanes对应的优先级</span></span><br><span class="line">      <span class="keyword">if</span> (unblockedLanes !== NoLanes) &#123;</span><br><span class="line">        nextLanes = getHighestPriorityLanes(unblockedLanes);</span><br><span class="line">        nextLanePriority = return_highestLanePriority;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pingedLanes !== NoLanes) &#123;</span><br><span class="line">          nextLanes = getHighestPriorityLanes(pingedLanes);</span><br><span class="line">          nextLanePriority = return_highestLanePriority;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 如果nextLanes=0，则说明不需要调度任务，return</span></span><br><span class="line">  <span class="keyword">if</span> (nextLanes === NoLanes) &#123;</span><br><span class="line">    <span class="keyword">return</span> NoLanes;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 通过getEqualOrHigherPriorityLanes获取比nextLanes优先级更高的lanes</span></span><br><span class="line">    <span class="comment">// 如果未执行任务的pendingLanes中有比nextLanes优先级更高的lanes，也放入到nextLanes中</span></span><br><span class="line">    <span class="comment">// getEqualOrHigherPriorityLanes(0b001100) = 0b001111</span></span><br><span class="line">  nextLanes = pendingLanes &amp; getEqualOrHigherPriorityLanes(nextLanes);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// wipLanes不为空，说明正在渲染，若渲染任务的lanes不等于新任务的lanes，且其不为挂起任务</span></span><br><span class="line">  <span class="comment">// 判断新旧任务的优先级，旧任务优先级高，忽略新任务，继续执行旧任务，往下渲染；新任务优先级高，那就打断旧任务，插队</span></span><br><span class="line">  <span class="keyword">if</span> (wipLanes !== NoLanes &amp;&amp; wipLanes !== nextLanes &amp;&amp; </span><br><span class="line">  (wipLanes &amp; suspendedLanes) === NoLanes) &#123;</span><br><span class="line">    getHighestPriorityLanes(wipLanes);</span><br><span class="line">    <span class="keyword">var</span> wipLanePriority = return_highestLanePriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextLanePriority &lt;= wipLanePriority) &#123;</span><br><span class="line">      <span class="keyword">return</span> wipLanes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      return_highestLanePriority = nextLanePriority;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nextLanes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getHighestPriorityLanes：从优先级lanes集合中拿到优先级最高lanes和对应的更新任务优先级</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据lanes，获取最高的优先级的lanes和lanes对应的优先级</span></span><br><span class="line"><span class="comment">// 若所有的lanes都未匹配到，则返回lanes和DefaultLanePriority</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHighestPriorityLanes</span>(<span class="params">lanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((SyncLane &amp; lanes) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = SyncLanePriority;</span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((SyncBatchedLane &amp; lanes) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = SyncBatchedLanePriority;</span><br><span class="line">    <span class="keyword">return</span> SyncBatchedLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((InputDiscreteHydrationLane &amp; lanes) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = InputDiscreteHydrationLanePriority;</span><br><span class="line">    <span class="keyword">return</span> InputDiscreteHydrationLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> inputDiscreteLanes = InputDiscreteLanes &amp; lanes;</span><br><span class="line">  <span class="keyword">if</span> (inputDiscreteLanes !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = InputDiscreteLanePriority;</span><br><span class="line">    <span class="keyword">return</span> inputDiscreteLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((lanes &amp; InputContinuousHydrationLane) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = InputContinuousHydrationLanePriority;</span><br><span class="line">    <span class="keyword">return</span> InputContinuousHydrationLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> inputContinuousLanes = InputContinuousLanes &amp; lanes;</span><br><span class="line">  <span class="keyword">if</span> (inputContinuousLanes !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = InputContinuousLanePriority;</span><br><span class="line">    <span class="keyword">return</span> inputContinuousLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((lanes &amp; DefaultHydrationLane) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = DefaultHydrationLanePriority;</span><br><span class="line">    <span class="keyword">return</span> DefaultHydrationLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> defaultLanes = DefaultLanes &amp; lanes;</span><br><span class="line">  <span class="keyword">if</span> (defaultLanes !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = DefaultLanePriority;</span><br><span class="line">    <span class="keyword">return</span> defaultLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((lanes &amp; TransitionHydrationLane) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = TransitionHydrationPriority;</span><br><span class="line">    <span class="keyword">return</span> TransitionHydrationLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> transitionLanes = TransitionLanes &amp; lanes;</span><br><span class="line">  <span class="keyword">if</span> (transitionLanes !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = TransitionPriority;</span><br><span class="line">    <span class="keyword">return</span> transitionLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> retryLanes = RetryLanes &amp; lanes;</span><br><span class="line">  <span class="keyword">if</span> (retryLanes !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = RetryLanePriority;</span><br><span class="line">    <span class="keyword">return</span> retryLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lanes &amp; SelectiveHydrationLane) &#123;</span><br><span class="line">    return_highestLanePriority = SelectiveHydrationLanePriority;</span><br><span class="line">    <span class="keyword">return</span> SelectiveHydrationLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((lanes &amp; IdleHydrationLane) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = IdleHydrationLanePriority;</span><br><span class="line">    <span class="keyword">return</span> IdleHydrationLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> idleLanes = IdleLanes &amp; lanes;</span><br><span class="line">  <span class="keyword">if</span> (idleLanes !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = IdleLanePriority;</span><br><span class="line">    <span class="keyword">return</span> idleLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((OffscreenLane &amp; lanes) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = OffscreenLanePriority;</span><br><span class="line">    <span class="keyword">return</span> OffscreenLane;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return_highestLanePriority = DefaultLanePriority;</span><br><span class="line">  <span class="keyword">return</span> lanes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getEqualOrHigherPriorityLanes：获取比当前lanes优先级更高或相等的lanes集合</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEqualOrHigherPriorityLanes</span>(<span class="params">lanes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 假设lanes=0b001100,getLowestPriorityLane(0b001100) = 0b001000</span></span><br><span class="line">  <span class="comment">// 0b001000 &lt;&lt; 1 = 0b010000</span></span><br><span class="line">  <span class="comment">// 0b010000 - 1  = 0b001111</span></span><br><span class="line">  <span class="keyword">return</span> (getLowestPriorityLane(lanes) &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从lanes中获取最低优先级的lane，即找到lanes中最靠左的那个1所对应的lane</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLowestPriorityLane</span>(<span class="params">lanes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// This finds the most significant non-zero bit.</span></span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">31</span> - clz32(lanes);</span><br><span class="line">  <span class="keyword">return</span> index &lt; <span class="number">0</span> ? NoLanes : <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到lanes中最靠左的那个1在lanes中的index </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickArbitraryLaneIndex</span>(<span class="params">lanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">31</span> - clz32(lanes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">laneToIndex</span>(<span class="params">lane</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pickArbitraryLaneIndex(lane);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>lanePriorityToSchedulerPriority：更新任务优先级转为调度优先级</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lanePriorityToSchedulerPriority</span>(<span class="params">lanePriority</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (lanePriority) &#123;</span><br><span class="line">    <span class="keyword">case</span> SyncLanePriority:</span><br><span class="line">    <span class="keyword">case</span> SyncBatchedLanePriority:</span><br><span class="line">      <span class="keyword">return</span> ImmediatePriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> InputDiscreteHydrationLanePriority:</span><br><span class="line">    <span class="keyword">case</span> InputDiscreteLanePriority:</span><br><span class="line">    <span class="keyword">case</span> InputContinuousHydrationLanePriority:</span><br><span class="line">    <span class="keyword">case</span> InputContinuousLanePriority:</span><br><span class="line">      <span class="keyword">return</span> UserBlockingPriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DefaultHydrationLanePriority:</span><br><span class="line">    <span class="keyword">case</span> DefaultLanePriority:</span><br><span class="line">    <span class="keyword">case</span> TransitionHydrationPriority:</span><br><span class="line">    <span class="keyword">case</span> TransitionPriority:</span><br><span class="line">    <span class="keyword">case</span> SelectiveHydrationLanePriority:</span><br><span class="line">    <span class="keyword">case</span> RetryLanePriority:</span><br><span class="line">      <span class="keyword">return</span> NormalPriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IdleHydrationLanePriority:</span><br><span class="line">    <span class="keyword">case</span> IdleLanePriority:</span><br><span class="line">    <span class="keyword">case</span> OffscreenLanePriority:</span><br><span class="line">      <span class="keyword">return</span> IdlePriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NoLanePriority:</span><br><span class="line">      <span class="keyword">return</span> NoPriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react源码之调度开始</title>
    <url>/2021/06/16/react%E6%BA%90%E7%A0%81%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<h2 id="3-调度开始"><a href="#3-调度开始" class="headerlink" title="3.调度开始"></a>3.调度开始</h2><p>上一节讲到，react根据更新任务的优先级lanePriority来执行不同的调度任务.</p>
<ul>
<li>lanePriority=SyncLanePriority，执行同步调度，scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root))</li>
<li>lanePriority!=SyncLanePriority&amp;&amp;!=SyncBatchedLanePriority，执行异步调度，scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root))</li>
</ul>
<p>同步调度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleSyncCallback</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Push this callback into an internal queue. We&#x27;ll flush these either in</span></span><br><span class="line">  <span class="comment">// the next tick, or earlier if something calls `flushSyncCallbackQueue`.</span></span><br><span class="line">  <span class="comment">// 将同步更新任务，推入同步队列中</span></span><br><span class="line">  <span class="keyword">if</span> (syncQueue === <span class="literal">null</span>) &#123; <span class="comment">// 当前同步任务队列为空，可以立即执行当前更新任务</span></span><br><span class="line">    syncQueue = [callback]; <span class="comment">// Flush the queue in the next tick, at the earliest.</span></span><br><span class="line"></span><br><span class="line">    immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前同步任务队列不为空，说明当前已经有调度任务在执行</span></span><br><span class="line">    <span class="comment">// Push onto existing queue. Don&#x27;t need to schedule a callback because</span></span><br><span class="line">    <span class="comment">// we already scheduled one when we created the queue.</span></span><br><span class="line">    syncQueue.push(callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fakeCallbackNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步调度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleCallback</span>(<span class="params">reactPriorityLevel, callback, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将react优先级转为调度优先级</span></span><br><span class="line">  <span class="keyword">var</span> priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);</span><br><span class="line">  <span class="keyword">return</span> Scheduler_scheduleCallback(priorityLevel, callback, options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactPriorityToSchedulerPriority</span>(<span class="params">reactPriorityLevel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (reactPriorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> ImmediatePriority$<span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> Scheduler_ImmediatePriority;</span><br><span class="line">    <span class="keyword">case</span> UserBlockingPriority$<span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> Scheduler_UserBlockingPriority;</span><br><span class="line">    <span class="keyword">case</span> NormalPriority$<span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> Scheduler_NormalPriority;</span><br><span class="line">    <span class="keyword">case</span> LowPriority$<span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> Scheduler_LowPriority;</span><br><span class="line">    <span class="keyword">case</span> IdlePriority$<span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> Scheduler_IdlePriority;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上可知，无论是同步任务调度还是异步任务调度，最终都会执行Scheduler_scheduleCallback。</p>
<h3 id="3-1-前置说明"><a href="#3-1-前置说明" class="headerlink" title="3.1 前置说明"></a>3.1 前置说明</h3><h4 id="存和取任务"><a href="#存和取任务" class="headerlink" title="存和取任务"></a>存和取任务</h4><ul>
<li>更新任务进入调度程序时，会根据任务是否是延时任务，存入taskQueue或timerQueue任务队列中。其中，taskQueue存放需要立即执行的任务；timerQueue存放延时执行的任务。</li>
<li>任务插入(push)任务队列时，会根据sortIndex、id 属性进行优先级排序(siftUp)，优先级最高的任务排在队列首位。<br>Scheduler会优先取出(peek)taskQueue中的任务去执行，任务执行完成之后，从taskQueue移除(pop)，移除之后对任务队列重新排序(siftDown)。</li>
<li>若taskQueue为空，timerQueue中的任务会开始定时器任务，到达任务开始执行时间后，从timerQueue中取出(peek、pop)首个任务，存入(push)taskQueue中.</li>
</ul>
<p>任务队列采用的是二叉堆(最小堆)，即父节点的键值总是小于或等于任何一个子节点的键值。添加元素时，在数组的最末尾插入新节点，然后自下而上调整子节点和父节点的位置(siftUp)；删除元素时，将数组的末尾元素放入到根节点，然后自上而下调整子节点和父节点的位置(siftDown).</p>
<p>二叉堆添加和删除元素代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将node插入到heap中，并根据sortIndex、id 属性进行优先级排序，值越小优先级越高</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">heap, node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = heap.length;</span><br><span class="line">  heap.push(node);</span><br><span class="line">  siftUp(heap, node, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二叉堆(最小堆)-父结点的键值总是小于或等于任何一个子节点的键值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">siftUp</span>(<span class="params">heap, node, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = i;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> parentIndex = index - <span class="number">1</span> &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> parent = heap[parentIndex];</span><br><span class="line">    <span class="comment">// 当前node的优先级更高</span></span><br><span class="line">    <span class="keyword">if</span> (parent !== <span class="literal">undefined</span> &amp;&amp; compare(parent, node) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      heap[parentIndex] = node;</span><br><span class="line">      heap[index] = parent;</span><br><span class="line">      index = parentIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先比较sortIndex，再比较index，值越小，优先级越高</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Compare sort index first, then task id.</span></span><br><span class="line">  <span class="keyword">var</span> diff = a.sortIndex - b.sortIndex;</span><br><span class="line">  <span class="keyword">return</span> diff !== <span class="number">0</span> ? diff : a.id - b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从heap堆里取出第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">peek</span>(<span class="params">heap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> first = heap[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> first === <span class="literal">undefined</span> ? <span class="literal">null</span> : first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从heap堆里取出第一个元素，并删除该元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params">heap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> first = heap[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> last = heap.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (last !== first) &#123;</span><br><span class="line">      heap[<span class="number">0</span>] = last;</span><br><span class="line">      siftDown(heap, last, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从二叉堆中取出优先级最高的元素，即根节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">siftDown</span>(<span class="params">heap, node, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = i;</span><br><span class="line">  <span class="keyword">var</span> length = heap.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; length) &#123;</span><br><span class="line">    <span class="keyword">var</span> leftIndex = (index + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> left = heap[leftIndex];</span><br><span class="line">    <span class="keyword">var</span> rightIndex = leftIndex + <span class="number">1</span>; <span class="comment">// index+1 &lt;&lt;&lt; 1</span></span><br><span class="line">    <span class="keyword">var</span> right = heap[rightIndex]; <span class="comment">// If the left or right node is smaller, swap with the smaller of those.</span></span><br><span class="line">    <span class="keyword">if</span> (left !== <span class="literal">undefined</span> &amp;&amp; compare(left, node) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (right !== <span class="literal">undefined</span> &amp;&amp; compare(right, left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        heap[index] = right;</span><br><span class="line">        heap[rightIndex] = node;</span><br><span class="line">        index = rightIndex; </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        heap[index] = left;</span><br><span class="line">        heap[leftIndex] = node;</span><br><span class="line">        index = leftIndex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right !== <span class="literal">undefined</span> &amp;&amp; compare(right, node) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      heap[index] = right;</span><br><span class="line">      heap[rightIndex] = node;</span><br><span class="line">      index = rightIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Neither child is smaller. Exit.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>peek、pop都是用于从二叉堆任务队列里取出首个任务，pop会从二叉堆中移除首个任务，然后进行堆排序；peek只是单纯的取出二叉堆的首个任务，不会移除元素。</p>
<h4 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h4><p><strong>1）调度分为两个阶段</strong>：</p>
<ul>
<li>第一阶段：新任务进来后，根据任务过期时间和插入顺序，对任务进行二叉堆的堆排序，优先级最高的任务放在队列的首位。此时并不会立即执行任务队列里的任务，而是port.postMessage(null)，等到下一个宏任务再执行；此时设置isHostCallbackScheduled=true，标志着回调正在进行，任务调度中；</li>
<li>第二阶段：浏览器渲染完成，下一轮宏任务开始执行(通过channel.port1.onmessage回调)。执行回调函数flushWork，在时间片的范围内循环执行taskQueue中的任务，此时设置isHostCallbackScheduled=false，标志着第一阶段的任务调度结束，开始执行调度的更新任务了</li>
</ul>
<p><strong>2）宏任务触发机制</strong></p>
<p>浏览器一帧的执行顺序：<br>一个宏任务 =&gt; 队列中全部微任务 =&gt; requestAnimationFrame =&gt; 重排/重绘 =&gt; requestIdleCallback<br>其中，requestIdleCallback并不是每次都执行，而是在重绘重排之后，如果还有空闲时间，才会执行requestIdleCallback。</p>
<p>若js执行时间过长，会导致浏览器没时间绘制dom，造成丢帧和卡顿的现象。不影响浏览器重排/重绘最好的方式，是等浏览器渲染完之后，再执行js，即在requestIdleCallback中执行。由于requestIdleCallback存在兼容性和触发时机的问题，react并未采用requestIdleCallback，而是在每一帧分配一个时间片(5ms)给js执行，在这个时间片内，若是还没执行完，那就暂停js，把主线程交个浏览器去绘制，等下一帧继续执行js.</p>
<p>Scheduler的时间切片功能是通过task（宏任务）实现的，浏览器渲染完成之后，才会执行下一轮的宏任务。Scheduler会在宏任务开始时，执行react的更新任务。</p>
<p>浏览器中宏任务优先级排序：主代码块 &gt; setImmediate（node） &gt; MessageChannel &gt; setTimeout / setInterval。可以看出，宏任务中的MessageChannel优先级高于setTimeout / setInterval。</p>
<p>若当前宿主环境支持MessageChannel(浏览器环境)，则采用MessageChannel；不支持MessageChannel(非浏览器环境)，则采用setTimeout。</p>
<ul>
<li>支持MessageChannel</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line"><span class="keyword">var</span> port = channel.port2;</span><br><span class="line"><span class="comment">// 会在下一轮宏任务中执行（浏览器未渲染完成之前，不会执行下一轮的宏任务）</span></span><br><span class="line">channel.port1.onmessage = performWorkUntilDeadline;</span><br><span class="line"><span class="comment">// callback为flushWork</span></span><br><span class="line">requestHostCallback = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    scheduledHostCallback = callback;</span><br><span class="line">    port.postMessage(<span class="literal">null</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>不支持MessageChannel</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">requestHostCallback = <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Protect against re-entrancy.</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(requestHostCallback, <span class="number">0</span>, cb);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _callback = cb;</span><br><span class="line">      <span class="built_in">setTimeout</span>(_flushCallback, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Sheduler调度优先级"><a href="#Sheduler调度优先级" class="headerlink" title="Sheduler调度优先级"></a>Sheduler调度优先级</h4><ul>
<li>Immediate 立即执行优先级，需要同步执行的任务</li>
<li>UserBlocking 用户阻塞型优先级（250 ms 后过期），需要作为用户交互结果运行的任务（例如，按钮点击）</li>
<li>Normal 普通优先级（5 s 后过期），不必让用户立即感受到的更新</li>
<li>Low 低优先级（10 s 后过期），可以推迟但最终仍然需要完成的任务（例如，分析通知）</li>
<li>Idle 空闲优先级（永不过期），不必运行的任务（例如，隐藏界面以外的内容）</li>
</ul>
<p><strong>sheduler中的调度优先级</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> NoPriority = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> ImmediatePriority = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> UserBlockingPriority = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> NormalPriority = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> LowPriority = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> IdlePriority = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p><strong>sheduler调度优先级对应的过期时间</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> IMMEDIATE_PRIORITY_TIMEOUT = -<span class="number">1</span>; <span class="comment">// Eventually times out</span></span><br><span class="line"><span class="keyword">var</span> USER_BLOCKING_PRIORITY_TIMEOUT = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">var</span> NORMAL_PRIORITY_TIMEOUT = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span> LOW_PRIORITY_TIMEOUT = <span class="number">10000</span>; <span class="comment">// Never times out</span></span><br><span class="line"><span class="keyword">var</span> IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2 代码"></a>3.2 代码</h3><ul>
<li>isHostCallbackScheduled：表示当前是否有调度任务(第二阶段中宏任务里要执行的回调函数是否被执行了)。若是当前有下一轮宏任务需要执行的回调函数(flushWork)，设置isHostCallbackScheduled=true；若回调函数任务开始执行了，设置为isHostCallbackScheduled=false;（针对taskQueue任务的第一阶段）</li>
<li>isHostTimeoutScheduled: 表示当前是否有定时器任务。timerQueue中的任务设置定时器延时执行，此时isHostTimeoutScheduled=true；若是延时任务到了开始执行的时间，设置isHostTimeoutScheduled=false（针对timerQueue中的任务）</li>
<li>isPerformingWork：当前是否有正在执行的更新任务（针对taskQueue任务的第二阶段）</li>
</ul>
<h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><ul>
<li>计算任务的开始时间</li>
<li>根据任务优先级priorityLevel计算任务的过期时间</li>
<li>创建调度任务</li>
<li>任务还没到开始执行时间，存入timerQueue；否则，存入taskQueue</li>
<li>taskQueue不为空，调用requestHostCallback，port.postMessage(null)，等待下一个宏任务</li>
<li>taskQueue为空，timerQueue中首个任务开始定时器任务，直到任务开始时间，存入taskQueue中，调用requestHostCallback</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_scheduleCallback</span>(<span class="params">priorityLevel, callback, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// localPerformance.now(),获取当前时间</span></span><br><span class="line">  <span class="keyword">var</span> currentTime = <span class="built_in">exports</span>.unstable_now();</span><br><span class="line">  <span class="keyword">var</span> startTime;</span><br><span class="line">    <span class="comment">// 第一次更新，options为null（好像代码里没有options有值的情况）</span></span><br><span class="line">    <span class="comment">// 获取任务预期执行时间startTime，若是有延迟时间，当前时间需要加上延迟时间</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">&#x27;object&#x27;</span> &amp;&amp; options !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> delay = options.delay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> delay === <span class="string">&#x27;number&#x27;</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      startTime = currentTime + delay;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    startTime = currentTime;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据调度优先级，获取任务多长时间过期(timeout)</span></span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">      timeout = IMMEDIATE_PRIORITY_TIMEOUT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IdlePriority:</span><br><span class="line">      timeout = IDLE_PRIORITY_TIMEOUT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LowPriority:</span><br><span class="line">      timeout = LOW_PRIORITY_TIMEOUT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NormalPriority:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      timeout = NORMAL_PRIORITY_TIMEOUT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取当前任务的过期时间</span></span><br><span class="line">  <span class="keyword">var</span> expirationTime = startTime + timeout;</span><br><span class="line">  <span class="comment">// 创建调度任务</span></span><br><span class="line">  <span class="keyword">var</span> newTask = &#123;</span><br><span class="line">    id: taskIdCounter++, <span class="comment">// 任务节点的序号，创建任务时自增 1</span></span><br><span class="line">    callback: callback, <span class="comment">// 任务本体，即需要执行的更新任务</span></span><br><span class="line">    priorityLevel: priorityLevel, <span class="comment">// 任务的优先级。优先级按 ImmediatePriority、UserBlockingPriority、NormalPriority、LowPriority、IdlePriority 顺序依次越低</span></span><br><span class="line">    startTime: startTime, <span class="comment">// 任务预期执行时间，默认为当前时间，即同步任务。可通过 options.delay 设为异步延时任务</span></span><br><span class="line">    expirationTime: expirationTime, <span class="comment">// 过期时间</span></span><br><span class="line">    sortIndex: -<span class="number">1</span> <span class="comment">// 默认值为 -1。对于异步延时任务，该值将赋为startTime，否则为expirationTime</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// taskQueue 存放需要立即执行的任务；timerQueue 存放延时执行的任务</span></span><br><span class="line">  <span class="comment">// 说明当前任务是异步延时任务，将其放入timerQueue</span></span><br><span class="line">  <span class="keyword">if</span> (startTime &gt; currentTime) &#123;</span><br><span class="line">    <span class="comment">// This is a delayed task.</span></span><br><span class="line">    newTask.sortIndex = startTime;</span><br><span class="line">    push(timerQueue, newTask);</span><br><span class="line">    <span class="comment">// taskQueue中没有可执行的任务，newTask在timerQueue中优先级最高</span></span><br><span class="line">    <span class="keyword">if</span> (peek(taskQueue) === <span class="literal">null</span> &amp;&amp; newTask === peek(timerQueue)) &#123;</span><br><span class="line">      <span class="comment">// 说明之前有等待从timerQueue取出任务的定时器，需要取消先前的调度任务的定时器</span></span><br><span class="line">      <span class="keyword">if</span> (isHostTimeoutScheduled) &#123;</span><br><span class="line">        <span class="comment">// 清除定时器，clearTimeout</span></span><br><span class="line">        cancelHostTimeout();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明调度任务刚开始，设置为true</span></span><br><span class="line">        isHostTimeoutScheduled = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 延时执行timerQueue中的任务</span></span><br><span class="line">      <span class="comment">// 通过setTimeout(fn，startTime - currentTime)延时执行</span></span><br><span class="line">      requestHostTimeout(handleTimeout, startTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 准备就绪的任务，存放至taskQueue</span></span><br><span class="line">    newTask.sortIndex = expirationTime;</span><br><span class="line">    push(taskQueue, newTask);</span><br><span class="line">    <span class="comment">// isHostCallbackScheduled表示是否有任务被安排进去了</span></span><br><span class="line">    <span class="comment">// isPerformingWork有任务安排了，并且在持续循环安排中</span></span><br><span class="line">    <span class="comment">// 前者负责一开始的调度，后者负责调度开始了，在允许的时间范围内是否持续调度</span></span><br><span class="line">    <span class="keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// flushWork，真正执行任务的地方</span></span><br><span class="line">      requestHostCallback(flushWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTask; <span class="comment">// root.callbackNode=newTask</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>taskQueue中的任务操作：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// callback为flushWork</span></span><br><span class="line">requestHostCallback = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    scheduledHostCallback = callback;</span><br><span class="line">    <span class="comment">// isMessageLoopRunning=false，说明没有在循环处理的任务</span></span><br><span class="line">    <span class="comment">// 通过MessageChannel的port消息通知，进入到下一个宏任务中处理flushWork</span></span><br><span class="line">    <span class="keyword">if</span> (!isMessageLoopRunning) &#123;</span><br><span class="line">      isMessageLoopRunning = <span class="literal">true</span>; <span class="comment">// 标志当前有正在循环处理的任务</span></span><br><span class="line">      port.postMessage(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>timerQueue中的任务操作：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleTimeout</span>(<span class="params">currentTime</span>) </span>&#123;</span><br><span class="line">  isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 将timerQueue中已经到开始执行时间的任务放入taskQueue</span></span><br><span class="line">  advanceTimers(currentTime);</span><br><span class="line">  <span class="keyword">if</span> (!isHostCallbackScheduled) &#123;</span><br><span class="line">    <span class="comment">// taskQueue有任务，执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (peek(taskQueue) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 在调用requestHostCallback的回调函数flushWork之前，设置isHostCallbackScheduled=true</span></span><br><span class="line">      <span class="comment">// 标志有任务被调度了</span></span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      requestHostCallback(flushWork);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// taskQueue为null，即没有待执行的任务，那就等待timerQueue中的任务</span></span><br><span class="line">      <span class="keyword">var</span> firstTimer = peek(timerQueue);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从timerQueue中取出已经到开始执行时间的任务，取出来放入taskQueue，并设置sortedIndex为当前任务的expirationTime</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advanceTimers</span>(<span class="params">currentTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check for tasks that are no longer delayed and add them to the queue.</span></span><br><span class="line">  <span class="keyword">var</span> timer = peek(timerQueue);</span><br><span class="line">  <span class="comment">// 循环遍历timerQueue，找出已经到开始执行时间的任务，存入taskQueue</span></span><br><span class="line">  <span class="keyword">while</span> (timer !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer.callback === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Timer was cancelled.</span></span><br><span class="line">      pop(timerQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timer.startTime &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">// Timer fired. Transfer to the task queue.</span></span><br><span class="line">      pop(timerQueue);</span><br><span class="line">      timer.sortIndex = timer.expirationTime;</span><br><span class="line">      push(taskQueue, timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Remaining timers are pending.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer = peek(timerQueue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">requestHostTimeout = <span class="function"><span class="keyword">function</span> (<span class="params">callback, ms</span>) </span>&#123;</span><br><span class="line">    taskTimeoutID = _setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback(<span class="built_in">exports</span>.unstable_now());</span><br><span class="line">    &#125;, ms);</span><br><span class="line">&#125;;</span><br><span class="line">cancelHostTimeout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    _clearTimeout(taskTimeoutID);</span><br><span class="line">    taskTimeoutID = -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>在下一轮宏任务中执行更新任务。真正执行更新任务的入口：<strong>performWorkUntilDeadline</strong></p>
<ul>
<li>计算任务的暂停时间，当前时间加上时间片(5ms);</li>
<li>在时间片的范围内，循环执行taskQueue中的任务，并发模式是performConcurrentWorkOnRoot；block模式是performSyncWorkOnRoot；</li>
<li>时间片内，调度的任务taskQueue执行完毕，重置isMessageLoopRunning以及scheduledHostCallback，停止调度；从timerQueue找到优先级最高的任务，开启定时器任务，直到任务的开始时间</li>
<li>时间片结束，还有任务没有执行完成，继续port.postMessage(null)，通过宏任务进入下一轮performWorkUntilDeadlined，继续执行workLoop</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line"><span class="keyword">var</span> port = channel.port2;</span><br><span class="line"><span class="comment">// 会在下一轮宏任务中执行（浏览器未渲染完成之前，不会执行下一轮的宏任务）</span></span><br><span class="line">channel.port1.onmessage = performWorkUntilDeadline;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 任务的最大工作时长</span></span><br><span class="line"><span class="comment">   react此版并未精确的计算一个帧的剩余时间</span></span><br><span class="line"><span class="comment">   若是需要一个精确的帧剩余时间，需要通过requestAnimationFrame</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> yieldInterval = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">var</span> performWorkUntilDeadline = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduledHostCallback !== <span class="literal">null</span>) &#123; <span class="comment">// scheduledHostCallback，当前任务的回调函数</span></span><br><span class="line">      <span class="keyword">var</span> currentTime = <span class="built_in">exports</span>.unstable_now(); </span><br><span class="line">      <span class="comment">// 计算任务的暂停时间，一旦 workLoop 执行到 deadline 时间后，scheduler 会让出主线程以执行其他任务</span></span><br><span class="line">      deadline = currentTime + yieldInterval;</span><br><span class="line">      <span class="keyword">var</span> hasTimeRemaining = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// scheduledHostCallback=flushWork</span></span><br><span class="line">        <span class="keyword">var</span> hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);</span><br><span class="line">        <span class="keyword">if</span> (!hasMoreWork) &#123; <span class="comment">// 没有其他任务了，停止调度</span></span><br><span class="line">          isMessageLoopRunning = <span class="literal">false</span>;</span><br><span class="line">          scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明时间片用完，任务被打断，还有任务未执行完成，继续port.postMessage(null)通过宏任务进入下一轮performWorkUntilDeadlined</span></span><br><span class="line">          port.postMessage(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        port.postMessage(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      isMessageLoopRunning = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 设置 isHostCallbackScheduled=false，代表当前调度的回调函数任务开始执行了</span></span><br><span class="line"><span class="comment">// 保存当前任务优先级currentPriorityLevel</span></span><br><span class="line"><span class="comment">// 批量循环执行taskQueue中的任务 ，函数为workLoop</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushWork</span>(<span class="params">hasTimeRemaining, initialTime</span>) </span>&#123;</span><br><span class="line">  isHostCallbackScheduled = <span class="literal">false</span>; <span class="comment">// 代表当前调度的回调函数任务开始执行了</span></span><br><span class="line">  <span class="keyword">if</span> (isHostTimeoutScheduled) &#123; <span class="comment">// 当前有定时器任务，取消它</span></span><br><span class="line">    isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">    cancelHostTimeout();</span><br><span class="line">  &#125;</span><br><span class="line">  isPerformingWork = <span class="literal">true</span>; <span class="comment">// 表示调度的任务正在执行</span></span><br><span class="line">  <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel; <span class="comment">// 保存当前任务优先级currentPriorityLevel</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> workLoop(hasTimeRemaining, initialTime)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentTask = <span class="literal">null</span>;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    isPerformingWork = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  循环执行taskQueue中的更新任务</span></span><br><span class="line"><span class="comment">  hasTimeRemaining：每次执行workLoop都为true；initialTime：执行任务的开始时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">hasTimeRemaining, initialTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = initialTime;</span><br><span class="line">  advanceTimers(currentTime); <span class="comment">// 从timerQueue中取出已经到开始执行时间的任务，取出来放入taskQueue</span></span><br><span class="line">  currentTask = peek(taskQueue); <span class="comment">// 先取出优先级最高的任务</span></span><br><span class="line">  <span class="comment">// 循环执行taskQueue中的任务</span></span><br><span class="line">  <span class="keyword">while</span> (currentTask !== <span class="literal">null</span> &amp;&amp; !(enableSchedulerDebugging )) &#123;</span><br><span class="line">    <span class="comment">// 当前任务未过期，但已经到了时间片的末尾，需要中断循环</span></span><br><span class="line">    <span class="keyword">if</span> (currentTask.expirationTime &gt; currentTime &amp;&amp; (!hasTimeRemaining || shouldYieldToHost())) &#123; <span class="comment">// shouldYieldToHost =&gt; return getCurrentTime() &gt;= deadline</span></span><br><span class="line">      <span class="comment">// This currentTask hasn&#x27;t expired, and we&#x27;ve reached the deadline.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出当前任务的回调函数，并发模式是performConcurrentWorkOnRoot；block模式是performSyncWorkOnRoot</span></span><br><span class="line">    <span class="keyword">var</span> callback = currentTask.callback;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      currentTask.callback = <span class="literal">null</span>; <span class="comment">// 置空当前任务的回调</span></span><br><span class="line">      currentPriorityLevel = currentTask.priorityLevel;</span><br><span class="line">      <span class="keyword">var</span> didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime; <span class="comment">// 当前任务是否已过期</span></span><br><span class="line">      <span class="keyword">var</span> continuationCallback = callback(didUserCallbackTimeout);</span><br><span class="line">      currentTime = getCurrentTime();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="comment">// 若返回函数类型，说明任务尚未执行完成；作为新的任务回调函数放入当前的task上</span></span><br><span class="line">        currentTask.callback = continuationCallback;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentTask === peek(taskQueue)) &#123; <span class="comment">// 当前任务回调函数执行完成，从taskQueue出堆</span></span><br><span class="line">          pop(taskQueue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      advanceTimers(currentTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pop(taskQueue); <span class="comment">// 当前任务从taskQueue出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    currentTask = peek(taskQueue);</span><br><span class="line">  &#125; <span class="comment">// Return whether there&#x27;s additional work</span></span><br><span class="line">  <span class="keyword">if</span> (currentTask !== <span class="literal">null</span>) &#123; <span class="comment">// 时间片结束，还有任务没有执行完成，继续port.postMessage(null)，通过宏任务进入下一轮performWorkUntilDeadlined，继续执行workLoop</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// taskQueue中的任务已执行完成</span></span><br><span class="line">    <span class="comment">// 从timerQueue找到优先级最高的任务，开启定时器任务，直到任务的开始时间</span></span><br><span class="line">    <span class="keyword">var</span> firstTimer = peek(timerQueue);</span><br><span class="line">    <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>webcomponents实践</title>
    <url>/2021/01/03/webcomponents%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="web-Components能代替现下主流的框架么？"><a href="#web-Components能代替现下主流的框架么？" class="headerlink" title="web Components能代替现下主流的框架么？"></a>web Components能代替现下主流的框架么？</h1><p><a href="#%E5%90%89%E5%BE%B7%E6%9E%97%E6%B3%95%E5%88%99">吉德林法则</a></p>
<h2 id="keydown之前想的事情"><a href="#keydown之前想的事情" class="headerlink" title="keydown之前想的事情"></a>keydown之前想的事情</h2><blockquote>
<p><font color=#222 size=3>1. what 什么是web Components，有什么特点？</font> <br /><br><font color=#222 size=3>2. way 为什么要用web Components？</font> <br /><br><font color=#222 size=3>3. where web Components在那里用？</font> <br /><br><font color=#222 size=3>4. how web Components怎么用？</font> <br /><br><font color=#222 size=3>5. PS web Components使用注意事项</font></p>
</blockquote>
<h2 id="开始探索"><a href="#开始探索" class="headerlink" title="开始探索"></a>开始探索</h2><h4 id="什么是web-Components"><a href="#什么是web-Components" class="headerlink" title="什么是web Components"></a>什么是web Components</h4><blockquote>
<p><font color=#222 size=3>document.querySelector最开始被广泛的被浏览器支持——浏览器提供了一个原生的方法结束了无处不在的JQuery</font> <br /><br><font color=#222 size=3>React这钟前端框架可以帮助我们去做一些做不到的事情，比如创建可以复用的前端组件，同意的事情会不会出现在它们身上</font> <br /><br><font color=#222 size=3>现在它来了</font> <br /><br><font color=#222 size=3>不用加载任何外部模块 浏览器的原生组件</font> <br /></p>
</blockquote>
<p><a href="#%E5%9B%9B%E5%A4%A7web%E7%BB%84%E4%BB%B6%E6%A0%87%E5%87%86">四大web组件标准</a></p>
<h4 id="为什么要用webComponents"><a href="#为什么要用webComponents" class="headerlink" title="为什么要用webComponents"></a>为什么要用webComponents</h4><p><strong>实际上你已经在用了</strong></p>
<h5 id="我们来看一看浏览器利用-Shadow-DOM-实现的一个示例吧，那就是-video-标签："><a href="#我们来看一看浏览器利用-Shadow-DOM-实现的一个示例吧，那就是-video-标签：" class="headerlink" title="我们来看一看浏览器利用 Shadow DOM 实现的一个示例吧，那就是 video 标签："></a>我们来看一看浏览器利用 Shadow DOM 实现的一个示例吧，那就是 video 标签：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;video controls src=<span class="string">&quot;./music.mp3&quot;</span> width=<span class="string">&quot;400&quot;</span> height=<span class="string">&quot;300&quot;</span>&gt;&lt;/video&gt;</span><br></pre></td></tr></table></figure>

<h5 id="调整Shadow-DOM中的内容"><a href="#调整Shadow-DOM中的内容" class="headerlink" title="调整Shadow DOM中的内容"></a>调整Shadow DOM中的内容</h5><p>根据pseudo 这个属性，你就可以在外面编写 CSS 样式来控制对应的节点样式了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">video</span>::-webkit-media-controls &#123;</span><br><span class="line">  background-color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS: 由于 Shadow DOM 的隔离性，所以即便是你在外面写了个样式：div { background-color: red !important; }，Shadow DOM 内部的 div 也不会受到任何影响。</p>
</blockquote>
<h5 id="用webComponents的理由"><a href="#用webComponents的理由" class="headerlink" title="用webComponents的理由"></a>用webComponents的理由</h5><ol>
<li>原生不需要框架</li>
<li>在现代浏览器中运行，可与HTML一起使用的任何JavaScript库或框架一起使用。</li>
<li>易于继承，不需要编译</li>
<li>真正的局部CSS作用域</li>
<li>标准，只有HTML，CSS，JavaScript</li>
</ol>
<h4 id="web-Components怎么用？"><a href="#web-Components怎么用？" class="headerlink" title="web Components怎么用？"></a>web Components怎么用？</h4><p><strong>重点来了朋友们</strong></p>
<blockquote>
<p>Custom Elements 的核心，实际上就是利用 JavaScript 中的对象继承，去继承 HTML 原生的 HTMLElement 类</p>
</blockquote>
<h5 id="怎么检测是否能用"><a href="#怎么检测是否能用" class="headerlink" title="怎么检测是否能用"></a>怎么检测是否能用</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">customElements.whenDefined(<span class="string">&#x27;my-attr&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;my-attr defined&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> supportsCustomElementsV1 = <span class="string">&#x27;customElements&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span>;</span><br></pre></td></tr></table></figure>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><ul>
<li>constructor(): 构造函数，用于初始化 state、创建 Shadow DOM、监听事件之类。</li>
<li>connectedCallback(): 组件实例已被插入到 DOM 树中，用于进行一些展示相关的初始化操作。</li>
<li>attributeChangedCallback(attrName, oldVal, newVal): 组件属性发生变化，用于更新组件的状态</li>
<li>disconnectedCallback(): 组件被从 DOM 树中移除，用于进行一些清理操作。</li>
<li>adoptedCallback(): 组件实例从一个文档被移动到另一个文档。</li>
</ul>
<h5 id="可供外部调用的公共Api"><a href="#可供外部调用的公共Api" class="headerlink" title="可供外部调用的公共Api"></a>可供外部调用的公共Api</h5><blockquote>
<p>除了这些生命周期方法，你还可以定义可以从外部调用的方法，这对于使用React和Angular等框架目前是不可行的</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YYY</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="keyword">const</span> shadowRoot = <span class="built_in">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">doSomeThing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;========来自y-yy内部的 doSomeThing方法被调用=========&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;y-yy&#x27;</span>);</span><br><span class="line">element.doSomeThing();</span><br></pre></td></tr></table></figure>

<h5 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h5><h6 id="需求：-网页只要插入下面的代码，就会显示用户卡片。"><a href="#需求：-网页只要插入下面的代码，就会显示用户卡片。" class="headerlink" title="需求： 网页只要插入下面的代码，就会显示用户卡片。"></a>需求： 网页只要插入下面的代码，就会显示用户卡片。</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;user-card&gt;&lt;/user-card&gt;</span><br></pre></td></tr></table></figure>

<h6 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h6><p>branch 及作用</p>
<ul>
<li>page1 创建基础类，并将user-card元素与这个类关联</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user-card</span>&gt;</span><span class="tag">&lt;/<span class="name">user-card</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义元素需要使用 JavaScript 定义一个类，所有&lt;user-card&gt;都会是这个类的实例。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCard</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用浏览器原生的customElements.define()方法，告诉浏览器&lt;user-card&gt;元素与这个类关联。</span></span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">&#x27;user-card&#x27;</span>, UserCard);</span><br></pre></td></tr></table></figure>
<ul>
<li>page2 增加自定义元素DOM结构<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义元素需要使用 JavaScript 定义一个类，所有&lt;user-card&gt;都会是这个类的实例。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCard</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="keyword">var</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">        image.src = <span class="string">&#x27;https://semantic-ui.com/images/avatar2/large/kristy.png&#x27;</span>;</span><br><span class="line">        image.classList.add(<span class="string">&#x27;image&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> container = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        container.classList.add(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">        name.classList.add(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">        name.innerText = <span class="string">&#x27;User Name&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> email = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">        email.classList.add(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">        email.innerText = <span class="string">&#x27;yourmail@some-email.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">        button.classList.add(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">        button.innerText = <span class="string">&#x27;Follow&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        container.append(name, email, button);</span><br><span class="line">        <span class="comment">// 这里的this表示自定义元素实例</span></span><br><span class="line">        <span class="built_in">this</span>.append(image, container);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用浏览器原生的customElements.define()方法，告诉浏览器&lt;user-card&gt;元素与这个类关联。</span></span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">&#x27;user-card&#x27;</span>, UserCard);</span><br></pre></td></tr></table></figure></li>
<li>page3 使用template的形式定义DOM结构<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user-card</span>&gt;</span><span class="tag">&lt;/<span class="name">user-card</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用 JavaScript 写上一节的 DOM 结构很麻烦，Web Components API 提供了&lt;template&gt;标签，可以在它里面使用 HTML 定义 DOM。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;userCardTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://semantic-ui.com/images/avatar2/large/kristy.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>User Name<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;email&quot;</span>&gt;</span>yourmail@some-email.com<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Follow<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义元素需要使用 JavaScript 定义一个类，所有&lt;user-card&gt;都会是这个类的实例。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCard</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> templateElem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;userCardTemplate&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> content = templateElem.content.cloneNode(<span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.appendChild(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用浏览器原生的customElements.define()方法，告诉浏览器&lt;user-card&gt;元素与这个类关联。</span></span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">&#x27;user-card&#x27;</span>, UserCard);</span><br></pre></td></tr></table></figure></li>
<li>page4 为自定义元素添加样式<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 JavaScript 写上一节的 DOM 结构很麻烦，Web Components API 提供了&lt;template&gt;标签，可以在它里面使用 HTML 定义 DOM。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;userCardTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组件的样式应该与代码封装在一起，只对自定义元素生效，不影响外部的全局样式。所以，可以把样式写在&lt;template&gt;里面。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/* :host伪类，指代自定义元素本身 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-pseudo">:host</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">            <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">450px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">180px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#d4d4d4</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d5d5d5</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-family</span>: <span class="string">&#x27;Poppins&#x27;</span>, sans-serif;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .image &#123;</span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container &#123;</span><br><span class="line"><span class="css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">160px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container&gt;.name &#123;</span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-weight</span>: <span class="number">600</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container&gt;.email &#123;</span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">opacity</span>: <span class="number">0.75</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">15px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container&gt;.button &#123;</span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">25px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-transform</span>: uppercase;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://semantic-ui.com/images/avatar2/large/kristy.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>User Name<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;email&quot;</span>&gt;</span>yourmail@some-email.com<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Follow<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>page5 让自定义元素接收外部参数<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义元素的参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user-card</span> <span class="attr">image</span>=<span class="string">&quot;https://semantic-ui.com/images/avatar2/large/kristy.png&quot;</span> <span class="attr">name</span>=<span class="string">&quot;User Name&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">email</span>=<span class="string">&quot;yourmail@some-email.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">user-card</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用 JavaScript 写上一节的 DOM 结构很麻烦，Web Components API 提供了&lt;template&gt;标签，可以在它里面使用 HTML 定义 DOM。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;userCardTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组件的样式应该与代码封装在一起，只对自定义元素生效，不影响外部的全局样式。所以，可以把样式写在&lt;template&gt;里面。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/* :host伪类，指代自定义元素本身 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-pseudo">:host</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">            <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">450px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">180px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#d4d4d4</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d5d5d5</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-family</span>: <span class="string">&#x27;Poppins&#x27;</span>, sans-serif;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .image &#123;</span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container &#123;</span><br><span class="line"><span class="css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">160px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container&gt;.name &#123;</span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-weight</span>: <span class="number">600</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container&gt;.email &#123;</span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">opacity</span>: <span class="number">0.75</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">15px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container&gt;.button &#123;</span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">25px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-transform</span>: uppercase;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自定义元素的参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>page6 开启Shadow Dom 隐藏内部代码 （内部代码不会影响外部代码，保证了代码的纯净）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义元素需要使用 JavaScript 定义一个类，所有&lt;user-card&gt;都会是这个类的实例。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCard</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Web Component 允许内部代码隐藏起来，这叫做 Shadow DOM，即这部分 DOM 默认与外部 DOM 隔离，内部任何代码都无法影响外部。</span></span><br><span class="line">        <span class="keyword">var</span> shadow = <span class="built_in">this</span>.attachShadow( &#123; <span class="attr">mode</span>: <span class="string">&#x27;closed&#x27;</span> &#125; );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> templateElem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;userCardTemplate&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> content = templateElem.content.cloneNode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把参数加到自定义元素里面</span></span><br><span class="line">        content.querySelector(<span class="string">&#x27;img&#x27;</span>).setAttribute(<span class="string">&#x27;src&#x27;</span>, <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;image&#x27;</span>));</span><br><span class="line">        content.querySelector(<span class="string">&#x27;.container&gt;.name&#x27;</span>).innerText = <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">        content.querySelector(<span class="string">&#x27;.container&gt;.email&#x27;</span>).innerText = <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this.attachShadow()方法开启 Shadow DOM</span></span><br><span class="line">        shadow.appendChild(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用浏览器原生的customElements.define()方法，告诉浏览器&lt;user-card&gt;元素与这个类关联。</span></span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">&#x27;user-card&#x27;</span>, UserCard);</span><br></pre></td></tr></table></figure></li>
<li>page7 添加方法互动<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义元素需要使用 JavaScript 定义一个类，所有&lt;user-card&gt;都会是这个类的实例。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCard</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Web Component 允许内部代码隐藏起来，这叫做 Shadow DOM，即这部分 DOM 默认与外部 DOM 隔离，内部任何代码都无法影响外部。</span></span><br><span class="line">        <span class="keyword">var</span> shadow = <span class="built_in">this</span>.attachShadow(&#123;</span><br><span class="line">            mode: <span class="string">&#x27;closed&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> templateElem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;userCardTemplate&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> content = templateElem.content.cloneNode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把参数加到自定义元素里面</span></span><br><span class="line">        content.querySelector(<span class="string">&#x27;img&#x27;</span>).setAttribute(<span class="string">&#x27;src&#x27;</span>, <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;image&#x27;</span>));</span><br><span class="line">        content.querySelector(<span class="string">&#x27;.container&gt;.name&#x27;</span>).innerText = <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">        content.querySelector(<span class="string">&#x27;.container&gt;.email&#x27;</span>).innerText = <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在类里面监听各种事件</span></span><br><span class="line">        <span class="built_in">this</span>.$button = content.querySelector(<span class="string">&#x27;.container&gt;.button&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.$button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;i am&#x27;</span> + <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this.attachShadow()方法开启 Shadow DOM</span></span><br><span class="line">        shadow.appendChild(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用浏览器原生的customElements.define()方法，告诉浏览器&lt;user-card&gt;元素与这个类关联。</span></span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">&#x27;user-card&#x27;</span>, UserCard);</span><br></pre></td></tr></table></figure></li>
<li>page8 抽离样式为单独文件<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义元素的参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user-card</span> <span class="attr">image</span>=<span class="string">&quot;https://semantic-ui.com/images/avatar2/large/kristy.png&quot;</span> <span class="attr">name</span>=<span class="string">&quot;User Name&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">email</span>=<span class="string">&quot;yourmail@some-email.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">user-card</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用 JavaScript 写上一节的 DOM 结构很麻烦，Web Components API 提供了&lt;template&gt;标签，可以在它里面使用 HTML 定义 DOM。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;userCardTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义元素的参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>page9 CSS样式钩子<br>子组件中<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* :host伪类，指代自定义元素本身 */</span></span><br><span class="line"><span class="selector-pseudo">:host</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    all: initial;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">450px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">180px</span>;</span><br><span class="line">    <span class="comment">/* background-color: #d4d4d4; */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--fancy-tabs-bg,  <span class="number">#d4d4d4</span>);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d5d5d5</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Poppins&#x27;</span>, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
父组件中<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">user-card &#123;</span><br><span class="line">        --fancy-tabs-bg: blue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可继承样式（background、color、font 以及 line-height 等）可在 shadow DOM 中继续继承。 也就是说，默认情况下它们会突破 shadow DOM 边界。 如果您想从头开始，可在它们超出影子边界时，使用 all: initial; 将可继承样式重置为初始值。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:host</span> &#123;</span><br><span class="line">  all: initial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从外部定义在组件本身的样式优先于使用:host在Shadow DOM中定义的样式。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">user-card &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">:host</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="扩展标签"><a href="#扩展标签" class="headerlink" title="扩展标签"></a>扩展标签</h5><h6 id="需求：-创建一个漂亮的"><a href="#需求：-创建一个漂亮的" class="headerlink" title="需求： 创建一个漂亮的"></a>需求： 创建一个漂亮的<button></h6><h6 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h6><p>branch 及作用</p>
<ul>
<li>extend1 创建基础类，继承自HTMLButtonElement，并将button元素与这个类关联<ul>
<li><a href="https://html.spec.whatwg.org/multipage/indices.html#element-interfaces">其他标签基类</a></li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">&quot;fancy-button&quot;</span>&gt;</span>Fancy button!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要扩展元素，您需要创建继承自正确 DOM 接口的类定义。 例如，扩展 &lt;button&gt; 的自定义元素需要从 HTMLButtonElement 而不是 HTMLElement 继承。 同样，扩展 &lt;img&gt; 的元素需要扩展 HTMLImageElement。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyButton</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">customElements.define(<span class="string">&#x27;my-button&#x27;</span>,</span><br><span class="line">    FancyButton, &#123;</span><br><span class="line">        <span class="keyword">extends</span>: <span class="string">&#x27;button&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>extend2 为基类扩展方法<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要扩展元素，您需要创建继承自正确 DOM 接口的类定义。 例如，扩展 &lt;button&gt; 的自定义元素需要从 HTMLButtonElement 而不是 HTMLElement 继承。 同样，扩展 &lt;img&gt; 的元素需要扩展 HTMLImageElement。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyButton</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// always call super() first in the constructor.</span></span><br><span class="line">        <span class="built_in">this</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">this</span>.drawRipple(e.offsetX, e.offsetY));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Material design ripple animation.</span></span><br><span class="line">    <span class="function"><span class="title">drawRipple</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        div.classList.add(<span class="string">&#x27;ripple&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.appendChild(div);</span><br><span class="line">        div.style.top = <span class="string">`<span class="subst">$&#123;y - div.clientHeight/<span class="number">2</span>&#125;</span>px`</span>;</span><br><span class="line">        div.style.left = <span class="string">`<span class="subst">$&#123;x - div.clientWidth/<span class="number">2</span>&#125;</span>px`</span>;</span><br><span class="line">        div.style.backgroundColor = <span class="string">&#x27;currentColor&#x27;</span>;</span><br><span class="line">        div.classList.add(<span class="string">&#x27;run&#x27;</span>);</span><br><span class="line">        div.addEventListener(<span class="string">&#x27;transitionend&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> div.remove());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">&#x27;fancy-button&#x27;</span>, FancyButton, &#123;</span><br><span class="line">    <span class="keyword">extends</span>: <span class="string">&#x27;button&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>extend3 在 JavaScript 中创建实例<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要扩展元素，您需要创建继承自正确 DOM 接口的类定义。 例如，扩展 &lt;button&gt; 的自定义元素需要从 HTMLButtonElement 而不是 HTMLElement 继承。 同样，扩展 &lt;img&gt; 的元素需要扩展 HTMLImageElement。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyButton</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// always call super() first in the constructor.</span></span><br><span class="line">        <span class="built_in">this</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">this</span>.drawRipple(e.offsetX, e.offsetY));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Material design ripple animation.</span></span><br><span class="line">    <span class="function"><span class="title">drawRipple</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        div.classList.add(<span class="string">&#x27;ripple&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.appendChild(div);</span><br><span class="line">        div.style.top = <span class="string">`<span class="subst">$&#123;y - div.clientHeight/<span class="number">2</span>&#125;</span>px`</span>;</span><br><span class="line">        div.style.left = <span class="string">`<span class="subst">$&#123;x - div.clientWidth/<span class="number">2</span>&#125;</span>px`</span>;</span><br><span class="line">        div.style.backgroundColor = <span class="string">&#x27;currentColor&#x27;</span>;</span><br><span class="line">        div.classList.add(<span class="string">&#x27;run&#x27;</span>);</span><br><span class="line">        div.addEventListener(<span class="string">&#x27;transitionend&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> div.remove());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">&#x27;fancy-button&#x27;</span>, FancyButton, &#123;</span><br><span class="line">    <span class="keyword">extends</span>: <span class="string">&#x27;button&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> App = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> button = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>, &#123;</span><br><span class="line">        is: <span class="string">&#x27;fancy-button&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    button.textContent = <span class="string">&#x27;Fancy button!&#x27;</span>;</span><br><span class="line">    App.appendChild(button);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="实现slot插槽"><a href="#实现slot插槽" class="headerlink" title="实现slot插槽"></a>实现slot插槽</h5><h6 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h6><p>branch 及作用</p>
<ul>
<li>slot1 添加默认slot<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义元素的参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user-card</span> <span class="attr">image</span>=<span class="string">&quot;https://semantic-ui.com/images/avatar2/large/kristy.png&quot;</span> <span class="attr">name</span>=<span class="string">&quot;User Name&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">email</span>=<span class="string">&quot;yourmail@some-email.com&quot;</span>&gt;</span></span><br><span class="line">    this is slot data</span><br><span class="line"><span class="tag">&lt;/<span class="name">user-card</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用 JavaScript 写上一节的 DOM 结构很麻烦，Web Components API 提供了&lt;template&gt;标签，可以在它里面使用 HTML 定义 DOM。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;userCardTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组件的样式应该与代码封装在一起，只对自定义元素生效，不影响外部的全局样式。所以，可以把样式写在&lt;template&gt;里面。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/* :host伪类，指代自定义元素本身 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-pseudo">:host</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">            <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">450px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">180px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#d4d4d4</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d5d5d5</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-family</span>: <span class="string">&#x27;Poppins&#x27;</span>, sans-serif;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .image &#123;</span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container &#123;</span><br><span class="line"><span class="css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">160px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container&gt;.name &#123;</span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-weight</span>: <span class="number">600</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container&gt;.email &#123;</span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">opacity</span>: <span class="number">0.75</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">15px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container&gt;.button &#123;</span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">25px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-transform</span>: uppercase;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自定义元素的参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义元素需要使用 JavaScript 定义一个类，所有&lt;user-card&gt;都会是这个类的实例。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCard</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Web Component 允许内部代码隐藏起来，这叫做 Shadow DOM，即这部分 DOM 默认与外部 DOM 隔离，内部任何代码都无法影响外部。</span></span><br><span class="line">        <span class="keyword">var</span> shadow = <span class="built_in">this</span>.attachShadow(&#123;</span><br><span class="line">            mode: <span class="string">&#x27;closed&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> templateElem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;userCardTemplate&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> content = templateElem.content.cloneNode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把参数加到自定义元素里面</span></span><br><span class="line">        content.querySelector(<span class="string">&#x27;img&#x27;</span>).setAttribute(<span class="string">&#x27;src&#x27;</span>, <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;image&#x27;</span>));</span><br><span class="line">        content.querySelector(<span class="string">&#x27;.container&gt;.name&#x27;</span>).innerText = <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">        content.querySelector(<span class="string">&#x27;.container&gt;.email&#x27;</span>).innerText = <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在类里面监听各种事件</span></span><br><span class="line">        <span class="built_in">this</span>.$button = content.querySelector(<span class="string">&#x27;.container&gt;.button&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.$button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;i am&#x27;</span> + <span class="built_in">this</span>.getAttribute(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this.attachShadow()方法开启 Shadow DOM</span></span><br><span class="line">        shadow.appendChild(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用浏览器原生的customElements.define()方法，告诉浏览器&lt;user-card&gt;元素与这个类关联。</span></span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">&#x27;user-card&#x27;</span>, UserCard);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>slot2 添加具名slot<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义元素的参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user-card</span> <span class="attr">image</span>=<span class="string">&quot;https://semantic-ui.com/images/avatar2/large/kristy.png&quot;</span> <span class="attr">name</span>=<span class="string">&quot;User Name&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">email</span>=<span class="string">&quot;yourmail@some-email.com&quot;</span>&gt;</span></span><br><span class="line">    this is slot data</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">&quot;title&quot;</span>&gt;</span>I have a title<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user-card</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用 JavaScript 写上一节的 DOM 结构很麻烦，Web Components API 提供了&lt;template&gt;标签，可以在它里面使用 HTML 定义 DOM。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;userCardTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组件的样式应该与代码封装在一起，只对自定义元素生效，不影响外部的全局样式。所以，可以把样式写在&lt;template&gt;里面。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/* :host伪类，指代自定义元素本身 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-pseudo">:host</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">            <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">450px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">180px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#d4d4d4</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d5d5d5</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-family</span>: <span class="string">&#x27;Poppins&#x27;</span>, sans-serif;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .image &#123;</span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container &#123;</span><br><span class="line"><span class="css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">160px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container&gt;.name &#123;</span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-weight</span>: <span class="number">600</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container&gt;.email &#123;</span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">opacity</span>: <span class="number">0.75</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">15px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .container&gt;.button &#123;</span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">25px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-transform</span>: uppercase;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自定义元素的参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="web-Components使用注意事项"><a href="#web-Components使用注意事项" class="headerlink" title="web Components使用注意事项"></a>web Components使用注意事项</h4><ul>
<li>根据规范，自定义元素的名称必须包含连词线，用与区别原生的 HTML 元素。所以，<user-card>不能写成<usercard>。</li>
<li>不能重复注册同一标记 否则会报错: Uncaught DOMException: Failed to execute ‘define’ on ‘CustomElementRegistry’: the name “user-card” has already been used with this registry</li>
<li>自定义元素不能自我封闭，因为 HTML 仅允许少数元素自我封闭。必须编写封闭标记 (<app-drawer></app-drawer>)。</li>
<li>html 文档中的 Custom Elements 在 JavaScript 未执行时是处于一个默认的状态，浏览器默认会将其内容直接显示出来。为了避免这样的情况发生，Custom Elements 在被注册后都会有一个 :defined CSS 伪类而在注册前没有</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">my-element<span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:defined</span>) &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h5 id="吉德林法则"><a href="#吉德林法则" class="headerlink" title="吉德林法则"></a>吉德林法则</h5><blockquote>
<p>美国通用汽车公司管理顾问查尔斯·吉德林提出：把难题清清楚楚地写出来，便已经解决了一半。 只有先认清问题，才能很好地解决问题。 这种观点在管理学上被称为吉德林法则。</p>
</blockquote>
<p><a href="#keydown%E4%B9%8B%E5%89%8D%E6%83%B3%E7%9A%84%E4%BA%8B%E6%83%85">keydown之前想的事情</a></p>
<h5 id="四大web组件标准"><a href="#四大web组件标准" class="headerlink" title="四大web组件标准"></a>四大web组件标准</h5><p><strong>HTML Template</strong></p>
<blockquote>
<p>HTML5 中的 &lt;template&gt; 标签 它只是一个模版，只有到你用到它时，它才会变得有意义。</p>
</blockquote>
<p><strong>Shadow DOM</strong></p>
<blockquote>
<p>原生组件封装的基本工具，它可以实现组件与组件之间的独立性。利用 Shadow DOM 的隔离性，我们就可以创造原生的 HTML 组件了。</p>
</blockquote>
<p><strong>Custom Elements</strong></p>
<blockquote>
<p>用来包装原生组件的容器，通过它，你就只需要写一个标签，就能得到一个完整的组件。</p>
</blockquote>
<p><strong>HTML Imports</strong></p>
<blockquote>
<p>HTML 中类似于 ES6 Module 的一个东西，你可以直接 import 另一个 html 文件，然后使用其中的 DOM 节点。但是，由于 HTML Imports 和 ES6 Module 实在是太像了，并且除了 Chrome 以外没有浏览器愿意实现它，所以它已经被废弃并不推荐使用了。未来会使用 ES6 Module 来取代它，但是现在貌似还没有取代的方案，在新版的 Chrome 中这个功能已经被删除了，并且在使用的时候会在 Console 中给出警告。</p>
</blockquote>
<p><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8webComponents">为什么要用web Components</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2019/08/web_components.html">阮一峰-Web Components 入门实例教程</a></p>
<p><a href="https://juejin.im/post/6844903694891220999">深度介绍：💾 你听说过原生 HTML 组件吗？</a></p>
<p><a href="https://developers.google.com/web/fundamentals/web-components/customelements#intro">自定义元素 v1：可重用网络组件</a></p>
<h5 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h5><p>注入template<br>自定义事件 <a href="https://developers.google.com/web/fundamentals/web-components/shadowdom#customevents">https://developers.google.com/web/fundamentals/web-components/shadowdom#customevents</a><br>处理焦点 <a href="https://developers.google.com/web/fundamentals/web-components/shadowdom#focus">https://developers.google.com/web/fundamentals/web-components/shadowdom#focus</a></p>
]]></content>
      <tags>
        <tag>webcomponents</tag>
      </tags>
  </entry>
  <entry>
    <title>whistle使用实践（配置与基础篇）</title>
    <url>/2020/12/22/whistle%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5%EF%BC%88%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>whistle是基于Node实现的跨平台web调试代理工具，同类型的工具有Fiddler和Charles，主要用于查看、修改HTTP、HTTPS、Websocket的请求、响应，也可以作为HTTP代理服务器使用。</p>
<p>在使用了Fiddler、Charles以及whistle这三款代理工具之后，总结出来的whistle的优势有以下几点：</p>
<ol>
<li>配置简单：whistle的配置类似于系统hosts的配置，一切操作都可以通过配置实现，支持域名、路径、正则表达式、通配符、通配路径等多种匹配方式。</li>
<li>支持扩展：whistle提供了插件扩展能力，通过插件可以新增whistle的协议实现更复杂的操作、也可以用来存储或监控指定请求、集成业务本地开发调试环境等等，基本上可以做任何你想做的事情，且开发、发布及安装whistle插件也都很简单。</li>
<li>内置weinre：通过weinre可以修改调试移动端DOM结构、捕获页面异常等。</li>
<li>界面简单易懂：从界面来看，whistle的功能划分为了network（网络）、rules（规则）、values（数据）、pulgins（插件）四大模块，通过tab页签进行切换。</li>
<li>文档全面：whistle官网提供了详细的说明文档，工作中遇到的情况只要查阅文档都能解决。</li>
</ol>
<p>下图是whistle支持的功能:<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/avwo/whistle/master/docs/assets/whistle-en_US.png" alt="whistle功能"></p>
<p>本文将结合本人在使用whistle过程中遇到的问题，对whisle的安装启动、配置及基础知识做下梳理。在介绍安装、配置等步骤时，有时会杂糅一些遇到的问题，没有遇到的话可以直接跳过。另外需要说明的是，由于是结合使用体验做的梳理，许多平时用不到或使用频率较低的内容，会写的很简略，如果本文解决不了你的问题的话，还请到<a href="https://wproxy.org/whistle/">whsitle官网</a>去查看文档。</p>
<h1 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h1><h2 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h2><p>由于whistle是基于Node的，自然需要先安装Node环境，这里不再多做说明。下面是whistle官网对Node版本的建议：</p>
<blockquote>
<p>whistle支持v0.10.0以上版本的Node，为获取更好的性能，推荐安装最新版本的Node。</p>
</blockquote>
<h2 id="安装whistle"><a href="#安装whistle" class="headerlink" title="安装whistle"></a>安装whistle</h2><p>Node安装完成后，执行如下命令安装whistle：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm install -g whistle</span><br></pre></td></tr></table></figure>

<p>查看版本：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">whisle -V </span><br></pre></td></tr></table></figure>
<p>如果能正确输出whistle的版本信息，就表示安装成功了。之后可通过help命令查看帮助信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">whistle help</span><br></pre></td></tr></table></figure>
<h2 id="启动whistle"><a href="#启动whistle" class="headerlink" title="启动whistle"></a>启动whistle</h2><p>whistle支持三种等价的命令whistle、w2、wproxy，本文使用w2命令。下面是常用的命令：</p>
<p>启动whistle:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">w2 start</span><br></pre></td></tr></table></figure>

<p>whistle的默认端口是8899，如果要指定端口号，执行下面的命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">w2 start -p <span class="number">8888</span></span><br></pre></td></tr></table></figure>

<p>重启whistle（也支持指定端口）:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">w2 restart</span><br></pre></td></tr></table></figure>

<p>停止whistle:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">w2 stop</span><br></pre></td></tr></table></figure>

<h1 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h1><p>配置代理时有两个关键的参数：服务器IP和端口号。端口号比较简单，对应w2 start命令启动好的端口号即可。服务器IP的话需要分两种情况：一种是本地，对应127.0.0.1即可，另一种是远程，这时候需要填服务器的IP。配置所需要的信息在启动whistle时控制台会告诉我们，见下图：</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/154775/4/6340/81700/5fb50cb4Ec59755b9/5a2bed632ddd9f56.png" alt="whistle启动界面"></p>
<p>从上面的图片可以看出，端口号为8899，IP有127.0.0.1、10.1.2.30、192.168.137.1和192.168.191.1这四个，如果是本地代理的话，这四个IP都可以（如果不想每次IP更换都要重新配置，选127.0.0.1呀），如果是远程代理，除了127.0.0.1之外，其他都可以的（仍然不建议填10.1.2.30这个IP，理由同上）。</p>
<p>下面来说下配置代理的几种方式：</p>
<h2 id="浏览器代理"><a href="#浏览器代理" class="headerlink" title="浏览器代理"></a>浏览器代理</h2><p>浏览器代理的话要使用浏览器的代理插件，这里介绍chrome和firefox两种：</p>
<ol>
<li>chrome：使用<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif">SwitchOmega</a>插件。</li>
<li>firefox：地址栏输入访问 about:preferences，找到 Network Proxy，选择 手动代理配置(Manual proxy configuration)，输入代理服务器地址、端口，保存即可。</li>
</ol>
<h2 id="全局代理"><a href="#全局代理" class="headerlink" title="全局代理"></a>全局代理</h2><ol>
<li>Windows: 菜单 &gt; 设置 &gt; 网络和Internet &gt; 代理</li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/137254/31/16451/53934/5fb65e59E4d64895c/1dd7cde6d531b03e.png" alt="Windows全局代理"></p>
<ol start="2">
<li>Mac: 系统偏好设置 &gt; 网络 &gt; 高级 &gt; 代理 &gt; 网页代理(HTTP) 和 安全网页代理(HTTPS)</li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/154826/14/6517/443129/5fb65f54E171875cf/a966123ef2007a17.jpg" alt="Mac全局代理"></p>
<ol start="3">
<li>Linux: 工作中没有用过，此处略过。详见<a href="https://wproxy.org/whistle/install.html">whistle官网</a></li>
</ol>
<h2 id="手机代理"><a href="#手机代理" class="headerlink" title="手机代理"></a>手机代理</h2><p>手机端要配置代理的话，需要保证所连wifi和启动了代理的主机处在同一网络。以IOS为例：</p>
<ol>
<li><p>连接网络（公司手机和电脑连接的不是同一网络，这个网络为电脑开的热点）：<br><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/150209/33/15612/33983/5fbc6ac5E57083b51/25b8d9225152042f.jpg" alt="连接wifi"></p>
</li>
<li><p>点击配置代理，修改为手动：<br><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/150209/33/15612/33983/5fbc6ac5E57083b51/25b8d9225152042f.jpg" alt="配置代理"></p>
</li>
</ol>
<h1 id="访问whistle控制台"><a href="#访问whistle控制台" class="headerlink" title="访问whistle控制台"></a>访问whistle控制台</h1><p>配置完代理后，我们需要先验证下代理是否配置成功。不同于Fiddler和Charles，whistle需要用浏览器访问配置页面（即whistle控制台），有以下两种方式：</p>
<ol>
<li>域名访问：<a href="http://local.whistlejs.com/">http://local.whistlejs.com/</a></li>
<li>IP + 端口访问： 如http:192.168.191.1:8888</li>
</ol>
<blockquote>
<p>因为我们是要验证刚才配置的代理是否生效，所以访问控制台的IP应该和配置代理的IP保持一致。</p>
</blockquote>
<p>如果配置正确，我们就可以看到whistle的控制台了，如下图：<br><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/125525/19/19818/166034/5fbfa019E4b6928a9/355841e136dd3e81.jpg" alt="whistle页"></p>
<p>如果页面打不开，则可能是whistle所在的电脑防火墙限制了远程访问whistle的端口，需要关闭防火墙或者设置白名单。</p>
<p>设置白名单的步骤如下：</p>
<ol>
<li>控制面板 -&gt; 系统和安全 -&gt; Windows Defender防火墙 -&gt; 高级设置 -&gt; 入站规则 -&gt; 新建规则</li>
<li>选择端口<br><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/145577/24/15737/27592/5fbfa3f9Ee31d94d1/7a49a3b0c2f3786e.png" alt="选择端口"></li>
<li>输入wistle启动时设置的端口号<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/143009/14/15672/26988/5fbfa3f9E26bca6f3/7948166c78f175a0.png" alt="输入端口号"></li>
<li>选择允许连接<br><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/134197/24/17457/28670/5fbfa3f9Ed82a1b51/a3c1bd1db9bccd52.png" alt="允许连接"></li>
<li>输入设置的规格名称<br><img src= "/img/loading.gif" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/135720/28/17480/22628/5fbfa3f9Ef188fc6c/8d3854390d3657a8.png" alt="输入规则名称"></li>
<li>在入站规则列表中查看是否新建成功以及是否开启，开启之后whistle提供的服务就可以在局域网中访问了<br><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/148633/37/18944/99950/5fdc21c6E2d1652c8/a1ccf9c2dfae880f.png" alt="查看入栈规则"></li>
</ol>
<h1 id="安装https证书"><a href="#安装https证书" class="headerlink" title="安装https证书"></a>安装https证书</h1><p>关闭防火墙或者给whsitle设置了白名单之后，如果whistle的设置页面可以正常打开，这表示说我们可以代理http请求了。</p>
<p>如果你的页面和接口全部是http请求，就可以忽略安装https证书的这一步了。但现实是除了本地或者预发环境，我们很难找到不是https的了（很多预发环境也是https的），因此还是建议提前把证书装上。<br>如果你的环境中出现了以下情况（当然，没有装好证书的话这些情况基本都会出现的），就是https证书没有安装或者没装好：</p>
<ol>
<li>whisle的配置页面可以打开，但是网页不能打开或者只加载了一部分页面</li>
<li>京东App数据更新不了或展示不全，或者扫码提示“无法获取信息”</li>
<li>whistle配置页面中network中443端口的请求前面有小锁，或者抓不到请求</li>
<li>浏览器提示“您的连接不是私密连接”</li>
</ol>
<h2 id="下载证书"><a href="#下载证书" class="headerlink" title="下载证书"></a>下载证书</h2><p>我们可以通过下面的方式下载证书：</p>
<ol>
<li>在配置代理的设备上打开浏览器，在浏览器中输入rootca.pro即可下载，这种是最便捷的方式</li>
<li>在启动了whistle的机器上用浏览器打开配置页面，点击https，会弹出一个带二维码的界面，点击Download RootCA 或者扫二维码下载<br><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/149838/6/18808/18953/5fdc4c49Efff2123b/80e0a6e0522277e1.png" alt="https证书"></li>
</ol>
<h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><p>证书的安装是不依赖于代理工具的，也就是说我们无论用的是whistle还是Fiddler或者是Charles，步骤都是一样的。我把安装步骤单独做了汇总，详见<a href="https://yolkpie.github.io/2020/12/22/%E5%AE%89%E8%A3%85%E8%AF%81%E4%B9%A6/">【安装证书】</a></p>
<h2 id="开启拦截https"><a href="#开启拦截https" class="headerlink" title="开启拦截https"></a>开启拦截https</h2><p>安装好证书之后，必须开启https拦截功能之后，whistle才能看到HTTPS、Websocket的请求。开启https拦截和安装并信任证书，这两个条件缺一不可。<br>我们需要通过下面的步骤开启https拦截：在启动了whistle的机器上用浏览器打开配置页面，点击https，会弹出一个带二维码的界面，在这个界面勾选Capture HTTPS CONNECTs选项（是不是很熟悉，在下载证书的第2种方法里我们见过的）<br><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/149838/6/18808/18953/5fdc4c49Efff2123b/80e0a6e0522277e1.png" alt="开启https拦截"></p>
<blockquote>
<p>上面的配置完成之后，如果https的请求还是不能正常访问或者还是出现安全提醒，可以重新打开浏览器访问或者重启下whistle。whistle官网给出的解释是如果之前访问过该页面，导致长链接已建立，所以我们之后的配置是不生效的。</p>
</blockquote>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p> 虽然在[whistle使用实践（实例篇）]中我会按照具体的使用场景来详细介绍whistle的使用方法，但是在此之前，我们有必要对whistle控制台的功能划分和whisle的配置方式做一下简单的了解。</p>
<h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h2><p>whistle控制台的打开方式上文我们已经说过了，这里不再重复。<br>whistle控制台核心部分的分区如下（[whistle界面详细列表点这里]（<a href="http://wproxy.org/whistle/webui/%EF%BC%89%EF%BC%89%EF%BC%9A">http://wproxy.org/whistle/webui/））：</a><br><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/148002/26/19653/283807/5fe1ad39E16b9900c/30e8246cd6654f05.jpg" alt="控制台划分"></p>
<ol>
<li>NetWork: 查看请求响应的详细信息及请求列表的Timeline</li>
<li>Rules: 匹配规则，whistle核心，详见下一节配置方式</li>
<li>Values: 配置key-value的数据，在Rules里面配置可以通过{key}获取</li>
<li>Plugins: 显示所有已安装的插件列表，开启关闭插件功能</li>
</ol>
<h2 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h2><p>在文章的开头就说过，whistle的所有操作都可以通过配置实现，配置方式扩展于系统hosts配置方式(ip domain或组合方式ip domain1 domain2 domainN)，具有更丰富的匹配模式及更灵活的配置方式。</p>
<p>whistle默认的配置方式是将匹配模式(pattern)写在左边，操作uri(operatorURI)写在右边。这样，whistle会将请求的url与pattern进行匹配，如果匹配上就执行operatorURI对应的操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pattern operatorURI</span><br></pre></td></tr></table></figure>
<blockquote>
<p>pattern和operatorURI也可以左右互换（<a href="http://wproxy.org/whistle/mode.html">在这里</a>），为了行文的清晰，不造成新的混淆，这里只介绍我常用的配置方式，我认为只掌握一种就够了。</p>
</blockquote>
<p>我们配置hosts时，如果一个IP要对应多个域名，会这样子写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  www.domain1.com www.domain2.com www.domainN.com</span><br></pre></td></tr></table></figure>
<p>和系统hosts一样，如果一个pattern要对应多个操作，whsitle也支持组合方式的配置。使用组合方式时，whistle会按照从左到右的顺序执行operatorURI。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pattern operatorURI1 operatorURI2 operatorURIN</span><br></pre></td></tr></table></figure>

<p>在简单了解了配置方式之后，我们就可以按照<code>pattern operatorURI</code>的模式为whsitle添加规则了。<br>还是再回到whsitle控制台的界面，选中Rules。我们可以像使用SwitchHosts软件管理hosts一样对规则进行分组管理。默认情况下，whistle只有一个Default的分组，如下：<br><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/138559/4/19993/221408/5fe313e6Edf676254/32de4c9528b8bba0.jpg" alt="default分组"></p>
<p>我们可以点击Create按钮添加一个单品页的分组，在这个分组里可以加上所有与单品页相关的配置（如果要禁用某个配置，可以使用Ctrl + /的快捷键，或者直接在前面加#）<br><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/141428/28/19593/327919/5fe313f4E0b32f1ba/7e624a7cbb37d9bf.jpg" alt="添加分组"></p>
<p>如果要配置的分组生效，需要双击左侧单品页的tab，出现对号就表示生效了，没有在使用的分组是没有对号的，也可以同时使用多个分组。<br><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/155210/10/11166/324076/5fe313efE0b194f99/f694ed08e697dcb6.jpg" alt="分组生效"></p>
<h3 id="匹配模式pattern"><a href="#匹配模式pattern" class="headerlink" title="匹配模式pattern"></a>匹配模式pattern</h3><p>whistle的匹配模式分为以下几种：</p>
<ol>
<li>域名匹配：域名匹配不仅支持匹配某个域名，也可以限定端口号、协议</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配www.domain.com域名下的所有请求，包括http、https、ws、wss，tunnel</span></span><br><span class="line">www.domain.com operatorURI</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配www.domain.com域名下的http请求</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//www.domain.com operatorURI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配www.domain.com域名下81端口的请求(http请求默认为80端口，https请求默认为443端口)</span></span><br><span class="line">www.domain.com:<span class="number">81</span> operatorURI</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>路径匹配：指定匹配某个路径，也可以限定端口号、协议</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配www.domain.com:81/path路径及其子路径（如www.domain.com:81/path/child）的请求</span></span><br><span class="line">www.domain.com:<span class="number">81</span>/path operatorURI</span><br></pre></td></tr></table></figure>
</li>
<li><p>精确匹配：与上面的路径匹配不同，路径匹配不仅匹配对应的路径，而且还会匹配该路径下面的子路径，而精确匹配只能指定的路径，只要在路径前面加$即可变成精确匹配</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配www.domain.com:81/path的路径，不包含子路径</span></span><br><span class="line">$www.domain.com:<span class="number">81</span>/path operatorURI</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>正则匹配：正则的语法及写法跟js的正则表达式一致，支持两种模式：/reg/、/reg/i 忽略大小写，支持子匹配，但不支持/reg/g，且可以通过正则的子匹配把请求url里面的部分字符串传给operatorURI</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配所有请求</span></span><br><span class="line">* operatorURI</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配url中包含keyword的请求，且忽略大小写</span></span><br><span class="line">/keyword/i operatorURI</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用子匹配把url里面的参数带到匹配的操作uri</span></span><br><span class="line"><span class="comment">// 下面正则将把请求里面的文件名称，带到匹配的操作uri</span></span><br><span class="line"><span class="comment">// 最多支持10个子匹配 $0...9，其中$0表示整个请求url，其它跟正则的子匹配一样</span></span><br><span class="line">/[^?#]\/([^\/]+)\.html/ protocol:<span class="comment">//...$1...</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>通配符匹配：通常，域名匹配和路径匹配可以满足我们大部分的需要，不满足的部分也可以用正则匹配来补充，但正则对大部分人来说还是有门槛的，whistle<br>很贴心的为我们提供了更简单的通配符匹配方式。目前我还没用过通配符匹配，这里依然简单介绍下，完整通配符匹配：<a href="http://wproxy.org/whistle/pattern.html">在这里</a></li>
</ol>
<ul>
<li><p>通配符匹配</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以 ^ 开头</span></span><br><span class="line">^www.example.com/test<span class="comment">/*** protocol://...$1...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 限定结束位置</span></span><br><span class="line"><span class="comment">^www.example.com/test/***test$ protocol://...$1...</span></span><br></pre></td></tr></table></figure>
<p>如果请求url为 <a href="https://www.example.com/test/abc?123test%EF%BC%8C%E8%BF%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE">https://www.example.com/test/abc?123test，这第一个配置</a> $1 = abc?123&amp;test，第二个配置 $1 = abc?123，而 <a href="https://www.example.com/test/abc?123test2">https://www.example.com/test/abc?123test2</a> 只能匹配第一个。</p>
</li>
<li><p>通配域名匹配</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配以 .com 结尾的所有url，如: test.com, abc.com，但不包含 *.xxx.com</span></span><br><span class="line">*.com protocol:<span class="comment">//...$1...</span></span><br><span class="line"><span class="comment">// 匹配 test.com 的子域名，不包括 test.com</span></span><br><span class="line"><span class="comment">// 也不包括诸如 *.xxx.test.com 的四级域名，只能包含: a.test.com，www.test.com 等test.com的三级域名</span></span><br><span class="line">*.test.com protocol:<span class="comment">//...$1...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要配置所有子域名生效，可以使用 **</span></span><br><span class="line">**.com protocol:<span class="comment">//...$1...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>通配路径匹配</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对所有域名对应的路径 protocol://a.b.c/xxx[/yyy]都生效</span></span><br><span class="line">*/ <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<h3 id="操作值operatorURI"><a href="#操作值operatorURI" class="headerlink" title="操作值operatorURI"></a>操作值operatorURI</h3><p>whistle官网将whsitle的操作值分为字符串和JSON对象两种。本文按照配置方式的不同，将whislte的操作值分为两种：带空格的和不带空格的。</p>
<ul>
<li>带空格：带空格的字符串和保留缩进格式的JSON对象</li>
<li>不带空格：不带空格的字符串和序列化了的不带空格的JSON对象</li>
</ul>
<p>不带空格的操作值可以直接在operatorURI中写入，模式为<code>pattern opProtocol://(strValue)</code>，注意字符串必须要用括号包裹：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将符合pattern的url的返回内容用helloworld代替</span></span><br><span class="line">pattern resBody:<span class="comment">//(helloworld)</span></span><br></pre></td></tr></table></figure>

<p>带空格的操作值需要将操作值保存在Values或者本地文件中。</p>
<ol>
<li>保存在Values中<br>在whsitle控制台中打开Values标签，点击Create，增加名称为test.json的操作值，并在右侧编辑test.json的内容，可按照<code>pattern opProtocol://&#123;valueName&#125;</code>来使用，注意value名称是用打括号包裹的，如下：</li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/143992/4/19957/246593/5fe4336cEc5199118/8e955d43a329167f.jpg" alt="添加values"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将符合pattern的url的返回内容用test.json文件中的内容代替</span></span><br><span class="line">pattern resBody:<span class="comment">//&#123;test.json&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>增加的操作值的名称是按照自己的需求取的，后缀名也是非必填的。使用后缀名的话会按照对应的格式高亮展示，不使用的话默认文本格式展示</p>
</blockquote>
<ol start="2">
<li>保存在本地文件中<br>首先我们先在本地新建一个test1.json的文件，然后在whsitle控制台中点击Files标签<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/156829/15/1850/248324/5fe447e0E52edb3cb/b36938896694268c.jpg" alt="点击Files"></li>
</ol>
<p>按照步骤选中创建的test1.json文件，whsitle会生成一个path，我们可以按照这个路径来使用<br><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/150822/27/12260/330508/5fe4483eEab5a4da3/0d2527e32c231d94.jpg" alt="选中"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将符合pattern的url的返回内容用test.json文件中的内容代替</span></span><br><span class="line">pattern resBody:<span class="comment">///$whistle/test1.json</span></span><br></pre></td></tr></table></figure>










]]></content>
      <tags>
        <tag>whistle</tag>
      </tags>
  </entry>
  <entry>
    <title>中台系统设计规范（一）关于系统布局</title>
    <url>/2020/09/21/%E4%B8%AD%E5%8F%B0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%831/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着互联网行业的聚变式发展，业务模式从“信息透出” 到 “在线交易” 的过程中，网站 UI 构建也经历了“体验一致性”、“设计效率”、“UI系统构建/应用效率”、“多端适配” 等诸多问题。对此，构建一套设计系统（Design System）是解决用户体验规模化问题的关键。设计系统又包含页面框架布局、字体、按钮、表单等部分。首先，我们先来说一说系统的布局。</p>
<p>用户在操作系统时所看到的页面框架其实就是系统布局，它是一个产品最外层的框架结构，一般包含了顶部导航、侧边导航栏、面包屑、图文、卡片、内容等元素。系统布局是页面设计的基础，<strong>布局框架是整个产品的基础骨架</strong>，在骨架确定之后，才可进行下一步的设计，如统一的视觉表达元素，清晰的功能操作，流畅的交互表达。</p>
<h3 id="布局的原则"><a href="#布局的原则" class="headerlink" title="布局的原则"></a>布局的原则</h3><p>系统布局规范，需要通过统一的设计元素和间距规范去引导合作设计师，跨平台使用并且能够适配不同屏幕尺寸，目的是达到一致性，可适配、可控性原则。</p>
<p><strong>一致性：</strong>对于界面来讲，界面中视觉、结构、行为需要保持一致性。视觉统一：颜色、风格</p>
<p><strong>可适配：</strong>布局是可自适应的，跟据用不在不同的设计环境下能够通过交互动效、界面样式有效作出极致适配反应。用户操作后需给出即时反应。</p>
<p><strong>可控性：</strong>当用户看到界面时应直观有效传递内容，如界面中模块区域明确、内容组织明确、表意明确都能使得用户快速理解。界面需要简单直白，让用户快速识别，减少用户记忆负担。</p>
<p><img src= "/img/loading.gif" data-src="1-%E5%B8%83%E5%B1%80%E5%8E%9F%E5%88%99.jpeg" alt="1-布局原则"></p>
<h3 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h3><p>经过调研得出在中台系统中用户使用的电脑屏幕主流分辨率分别为：<strong>1440*900、1366*768、1920*1080、1280*800</strong>，而1280是主流分辨率中最小且最为保险的的一个尺寸，在设计页面时设计师如果能够在1280尺寸下，缩小宽度或拉升页面宽度都能保证没有遮挡或挤压问题，那么设计是合理的。在我们的规范中页面在小于1280时需要吊起系统的横向滚动条。在中台系统中考虑到用户效率问题很少做响应式，所以常规情况下设计师会限定界面的一个最小值。如果设计师把画板设置为1440或者1366时可能会存在其在画板中页面大小正好合适，但是页面上线以后缩小浏览器可能会发生遮挡或挤压的情况。所以我们建议设计师们使用1280宽度画板画图。</p>
<p><img src= "/img/loading.gif" data-src="%E5%B1%8F%E5%B9%95%E6%AF%94%E4%BE%8B.jpeg" alt="屏幕比例"></p>
<h3 id="页面框架"><a href="#页面框架" class="headerlink" title="页面框架"></a>页面框架</h3><p>首先先分析一下页面框架，我们将页面的用户操作行为进行层级区分。我们至下而上将元素进行层级分层，目的是把用户界面模块化。<strong>界面可分成背景区域、内容层、全局控制层、内容弹层，</strong>每一层都具备独特性，将界面中所有的信息层级提取分类并且按结构属性分层，目的是能够使得页面视觉和交互逻辑符合用户的习惯认知。之前我们有提到过视觉层次、格式塔理论和信息框架，设计师在创建这一步的时候可以用来指导搭建一套合理的页面信息层级，一个内容模块都属于一个容器，容器可以承载各种内容元素。</p>
<p><img src= "/img/loading.gif" data-src="%E6%A1%86%E6%9E%B6.jpeg" alt="框架"></p>
<h4 id="背景层"><a href="#背景层" class="headerlink" title="背景层"></a>背景层</h4><p><strong>背景层样式固定，在界面中永远置于界面底部，</strong>并且一般会给予背景层中性色，作用是方便突出内容层和全局控制层。</p>
<p><img src= "/img/loading.gif" data-src="%E8%83%8C%E6%99%AF%E5%B1%82.jpeg" alt="背景层"></p>
<h4 id="内容层"><a href="#内容层" class="headerlink" title="内容层"></a>内容层</h4><p><strong>视图结构中最核心和复杂的一层，</strong>它与业务强相关，内容层的容器承载了业务场景的用户需要获取的核心信息以及辅助核心任务的操作。容器承载了内容，从Material Design中的Elevation（海拔）概念中可以了解到，它属于第二层级内容，基本布局结构有平行结构或者父子结构。如下图卡片属于容器，卡片中承载了数据图表等内容，整个卡片+内容就属于内容层。</p>
<p><img src= "/img/loading.gif" data-src="%E5%86%85%E5%AE%B9%E5%B1%82.jpeg" alt="内容层"></p>
<h4 id="全局控制层"><a href="#全局控制层" class="headerlink" title="全局控制层"></a>全局控制层</h4><p><strong>全局控制层我们定义他在内容层之上，属于页面第三层级内容，</strong>一般在业务场景中对整个网站的控制以及导航功能如：Header menu、Sidebar menu组件，如下图中Header menu浮在内容层之上。</p>
<p><img src= "/img/loading.gif" data-src="%E5%85%A8%E5%B1%80%E6%8E%A7%E5%88%B6%E5%B1%82.jpeg" alt="全局控制层"></p>
<h4 id="内容弹层"><a href="#内容弹层" class="headerlink" title="内容弹层"></a>内容弹层</h4><p>当前任务或者内容相关的临时出现层，是界面设计中常见的交互方式，<strong>优先级高于内容层，</strong>一般承载当前需要临时处理的任务或者需要进行内容补充说明等功能。如：Modal（Dialog各个平台叫法不一致）、Tooltip提示条、Popover气泡弹窗框、Notification通知等组件 。其中Modal是以滑出或者弹出的形式展现给用户。Modal它包括两种类型，一种是模态内容层不可操控，会打断用户的操作行为，被蒙版遮罩禁用，比如在业务中需要较为聚焦的分支流程操作时使用，用于向用户传递信息或获取用户的反馈。另一种是非模态，吊起弹出层后不印象内容层操作。当然，Tooltip、Popover、Notification都属于非模态，反馈较轻，不干扰用户使用界面。如下图的页面中的内容弹层使用了Popover，在次页面它的功能就是加以补充说明。</p>
<p><img src= "/img/loading.gif" data-src="%E5%86%85%E5%AE%B9%E5%BC%B9%E5%B1%82.jpeg" alt="内容弹层"></p>
<h3 id="布局方法"><a href="#布局方法" class="headerlink" title="布局方法"></a>布局方法</h3><p>对于设计师而言，在设计页面时必须熟练掌握一些基本设计基础知识，并且将这些知识灵活运用到实际的工作当中。比如设计师在搭建系统布局时需要熟知页面布局、格式塔理论、视觉层次等知识才可创建合理的布局基础。当然布局框架只是整个产品的基础骨架，在骨架确定之后，设计师才可进行下一步的设计，如统一的视觉表达元素，清晰的功能操作，流畅的交互表达。</p>
<h4 id="定义布局模块"><a href="#定义布局模块" class="headerlink" title="定义布局模块"></a>定义布局模块</h4><p>一个产品的信息框架取决于其特有的业务，它与业务强相关并且需要了解用户群体目标。根据业务和用户目标将内容组织搭建信息框架，形成系统布局的骨架，方便用户在浏览或操作页面时能够快速找到重点内容，提升用户使用效率。界面框架内系统布局是页面所有模块的组合方式，我们定义一个页面框架中基础模块和内容模块的数量最好不超过3个。<strong>经过调研和归纳总结出3大布局类型，分别是上下布局、左右布局、T字型布局。</strong></p>
<p><strong>上下布局</strong></p>
<p>上下布局布局是Web端运用最广泛的布局方式之一，页面内容区以feed流形式展现，一般用在Web端官网首页。设计师普遍做法是对两边留白区域为内容区并进行最小值的定义一般定义值为1200较多（具体宽度要设计师如何设置栅格，后面会讲到如何设置栅格），当留白区域到达极小超过极限值之后需要对中间的内容区域进行动态缩放或遮挡，此逻辑需设计师根据业务所需而定。也有少部分设计师会设计成全屏布局，内容随浏览器宽度自适应。</p>
<p>其优点是页面结构清晰简单，强突出内容区，但缺点是布局的规矩呆板，变化少。设计师如果不注意合理的视觉元素和色彩细节变化，用户很容易感觉到乏味,此布局适用于层级较为简单页面。</p>
<p><strong>左右布局</strong></p>
<p>设计师在设计重内容，轻导航类型网站是常用左右布局作为基础框架进行页面设计。此布局把系统页面分为两大模块，其中设计师常见的做法是将左侧设置成导航栏模块并且固定，常常用来控制全局内容。而右侧区域设置成工作区域或内容区，内容区可进行动态缩放。</p>
<p><img src= "/img/loading.gif" data-src="%E5%B7%A6%E5%8F%B3.jpg" alt="左右"></p>
<p><strong>T字型布局</strong></p>
<p>T字型布局常用在Web端的中台系统中，因为中台系统业务结构复杂、层级多，而T字型布局能够解决复杂结构的问题。使用此结构能够把页面结构清晰化，主次更加分明。设计师常常的做法是将顶部作为一级导航栏方便控制全局，二左边设计成是二级导航并且固定导航栏固定，右边的内区域可进行动态缩放(一般会把其设计成栅格动态区域)，内容随浏览器宽度自适应。</p>
<p><img src= "/img/loading.gif" data-src="T.jpg" alt="T"></p>
<h4 id="格式塔理论"><a href="#格式塔理论" class="headerlink" title="格式塔理论"></a>格式塔理论</h4><p><strong>格式塔心理学诞生于1912年。</strong>由德国心理学家Max Wertheimer提出，其在德文对应的单词Gestalt，<strong>意为完形、整体</strong>。</p>
<p><strong>概括来说就是：在心理现象中，人们对客观对象的感受源于整体关系而非具体元素，也就是说知觉不是感觉元素的总和，而是一个统一的整体，部分之和不等于整体，因此整体不能分割</strong>。</p>
<p>在我们的现实的生活中有很多设计都遵守了格式塔原则，比如生活中一些logo设计，联合利华的logo：该品牌商标经过精心设计，将25个错综复杂且有丰富的内涵的图标都融合在一起，视觉上形成一个整体的 “U”。还有IBM的logo，我们的大脑通过眼睛审视时，结合了每个相邻的水平线组成的字母，他们彼此堆叠在一起，而不是8条水平线散布着的均匀的间隙。</p>
<p><img src= "/img/loading.gif" data-src="%E8%81%94%E5%90%88%E5%88%A9%E5%8D%8E%E7%9A%84logo.png" alt="联合利华的logo"></p>
<p>同样的原理也适用于数字产品。格式塔理论有助于我们以有效的方式组织UI元素，从而使内容易于理解并且令人愉悦。视觉元素的呈现对用户体验有很大影响。如果对组件进行了合理的组织，用户则可以轻松导航并与产品进行交互，并享受过程。</p>
<h4 id="格式塔原理主要包括以下几条原理："><a href="#格式塔原理主要包括以下几条原理：" class="headerlink" title="格式塔原理主要包括以下几条原理："></a>格式塔原理主要包括以下几条原理：</h4><p>-接近性</p>
<p>-相似性</p>
<p>-连续性</p>
<p>-封闭性</p>
<p>-对称性</p>
<h5 id="接近性"><a href="#接近性" class="headerlink" title="接近性"></a>接近性</h5><p>物体之间的相对距离会影响我们感知它们的关系。相互靠近的物体被认为比相互距离较远的物体更有关联性。</p>
<p><img src= "/img/loading.gif" data-src="%E6%8E%A5%E8%BF%91%E6%80%A7.png" alt="接近性"></p>
<h5 id="相似性"><a href="#相似性" class="headerlink" title="相似性"></a>相似性</h5><p>有共同视觉元素的物体看起来更有关联性。我们倾向于将看起来相似的对象视为一组或者一个模式，并且将它们与特定含义或者功能联系在一起。</p>
<p>那么相似性的视觉元素可以由哪几部分构成呢？比如颜色，形状，大小，方向，以及纹理等视觉元素，组成相近的样式。</p>
<p>UI 设计规范中的控件组合成的组件，大部分都会使用到相似性原则，统一视觉样式，来表达统一的功能性。</p>
<p><img src= "/img/loading.gif" data-src="%E7%9B%B8%E4%BC%BC%E6%80%A7.png" alt="相似性"></p>
<h5 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h5><p>我们的视觉倾向于感知连续的形式，而不是离散的碎片。并且能感知到整个物体的倾向。</p>
<p>连续性通过构图来帮助我们感知事物的形状和运动方向。界面中的设计元素，会引导眼镜在平面中的移动，提高界面的可阅读性。创建顺序并且指导用户浏览不同的内容分组。</p>
<p><img src= "/img/loading.gif" data-src="%E8%BF%9E%E7%BB%AD%E6%80%A7.gif" alt="连续性"></p>
<h5 id="封闭性"><a href="#封闭性" class="headerlink" title="封闭性"></a>封闭性</h5><p>人们在观察一个物体的时候，视觉系统倾向于把不完整的局部当作一个整体来感知。将不连续的，敞开的图形自动补充，从而感知到它为完整的物体，而不是分散的碎片。</p>
<p><img src= "/img/loading.gif" data-src="%E5%B0%81%E9%97%AD%E6%80%A7.png" alt="封闭性"></p>
<h5 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h5><p>对称的原则指出，当我们感知物体时，我们倾向于将他们视为围绕这个物体形成的对称形状。大多数物体可以被分为两个或者两个以上对称的部分。当我们看到两个对称的未连接元素时，我们无意识地将它们整合成一个连贯的对象（或感知）。对象越相似，它们就越倾向于分组。</p>
<h4 id="视觉层次"><a href="#视觉层次" class="headerlink" title="视觉层次"></a>视觉层次</h4><p>当UI元素被有序组合和结构化时，人们可以轻松的将元素应用在应用程序和网站，所以设计页面时需要结合视觉层次理论。视觉层次理论是设计过程的核心方法之一。最初是建立在格式塔原理的基础上，它观察到了用户对相互关联元素的视觉感知，并展示了人们如何将视觉元素归为一类。那么什么是视觉层次呢？它说起来并不难理解，但是在实际的运用当中，却是千变万化。</p>
<p>视觉层次结构致力于一种用户能够理解的方式呈现产品的内容，以便用户可以理解每个元素的重要性级别。它可以组织页面内容，以便大脑可以根据物理差异例如：大小，颜色，对比度，样式等区分对象。</p>
<p>网页或移动设计中，视觉层次一般分为三层：主层、副层和三层。其中主层一般是指头条标题等核心信息，也是要让用户第一眼就注意到的信息。副层可以是小标题等信息，展示出主要内容与提纲。最后的三层一般由正文或其他额外信息构成，展示全部的内容，可以用较小的字号。</p>
<h5 id="一个模块中的层次感"><a href="#一个模块中的层次感" class="headerlink" title="一个模块中的层次感"></a>一个模块中的层次感</h5><p>「模块」指的是什么呢？就是组成网页的一个个内容模块，可以是一张卡片里面的内容，也可以是一个信息列表等等，总而言之是一个信息组。当我们拿到需求的时候，应该理解每个信息组里面的每条信息的价值，并且给他们分一个类。</p>
<p>比如有时候，PM 同学跑过来说：「我想加个大按钮」，「不想让用户注意到删除功能，但是一定要有」 ，或者「这次就想试一试，展示了这条信息点击率会不会涨」 ，又或是「这条信息展不展示都行，你设计的时候自己看吧……」 需求都懂，那么该如何分类呢？</p>
<p>根据四象限法则，给每个信息组中的信息按「重要——不重要」「必要——不必要」来分个类。</p>
<p><img src= "/img/loading.gif" data-src="%E5%9B%9B%E8%B1%A1%E9%99%90.jpg" alt="四象限"></p>
<p>重要却不必要的信息，一般是从产品或流程本身来讲不是一定要有的信息，但是因为某种原因想要突显给用户，比如在信用卡的产品列表中加入每张卡的推荐理由，或者在餐厅列表中展示某某名人去过这家店……这些信息在列表中不是必须有的，但是对于引导用户判断又十分的重要，所以我们可以次一级的来展示，要让用户可以注意到，但也不能抢了风头。</p>
<p>哪种信息是必要但不重要的呢？比如一个活动弹窗的关闭按钮，一个订单的删除功能，一条免责声明等等，我们不希望用户注意到他们，但是这些功能又不得不存在，那么就要弱化展示这些信息。</p>
<p>不必要又不重要的信息，一般情况是要去掉的，除非在设计中信息太少了空荡荡的，为了排版美观才会把这种边缘信息留下占位。</p>
<p>接下来，当我们整理好信息层级之后，要靠什么手段来展示这些层级呢？答案是加大对比。</p>
<p><strong>大小 + 重量 + 颜色 = 对比</strong></p>
<p>**-大小 **对比的第一步就是大小的对比，在大家的认知中，大的东西比小的东西更显眼、更重要。</p>
<p><strong>-重量</strong> 有时候由于空间的限制，字号不能再大了？字号大了也没拉开层次？试试增加字重量。</p>
<p><strong>-颜色</strong> 颜色对于用户的感知有着巨大的影响。所以在进行视觉层次构建的时候，不同的颜色可以轻松构成层次结构，强烈的颜色比如红色、橙色都很容易引人注意。白色和浅灰通常可以用来作为大面积的背景色，和其他的颜色构成对比。在设计的时候可以运用主色和辅助色来拉开视觉层次。</p>
<p><strong>-对比</strong> 大小、重量、颜色的运用，归根结底就是制造对比，这也是创建层次结构依靠的核心。一个元素和另外一个元素构成对比，才能有层次的展示他们之间重要程度上的差异，让用户更加容易获取到信息。</p>
<h5 id="模块与模块之间的层次"><a href="#模块与模块之间的层次" class="headerlink" title="模块与模块之间的层次"></a>模块与模块之间的层次</h5><p>说到模块与模块之间的层次，就又要提到格式塔理论中的相近性。模块与模块之间的相对距离会影响我们感知它们的关系。相互靠近的模块被认为比相互距离较远的模块更有关联性。</p>
<h3 id="网格与栅格系统的应用"><a href="#网格与栅格系统的应用" class="headerlink" title="网格与栅格系统的应用"></a>网格与栅格系统的应用</h3><p>栅格就是规则的网格阵列来指导和规范网页中的版面布局以及信息分布，栅格系统最小的单元是网格。定义一个最小的单元格，栅格系统依照最小的单元格布局。日常设计工作中，栅格主要应用在界面设计中。而网格则主要应用在画册、海报等平面设计中。</p>
<h4 id="关于网格"><a href="#关于网格" class="headerlink" title="关于网格"></a>关于网格</h4><h5 id="1-网格线-Grid-Line"><a href="#1-网格线-Grid-Line" class="headerlink" title="(1)网格线(Grid Line)"></a>(1)网格线(Grid Line)</h5><p>网格线又称布局分割线，它是构成网格结构的分界线。一般在布局中它们是由行网格线和列网格线组成。如下图是模拟网格做了一个示意，其中橘黄色两根线分别是行网格线和列网格线。</p>
<p><img src= "/img/loading.gif" data-src="%E7%BD%91%E6%A0%BC%E7%BA%BF.jpeg" alt="网格线"></p>
<h5 id="2-网格轨道-Grid-Track"><a href="#2-网格轨道-Grid-Track" class="headerlink" title="(2)网格轨道(Grid Track)"></a>(2)网格轨道(Grid Track)</h5><p>两个相邻网格线之间的空间。你可以把它们想像成网格的行或列。如下图橘黄色的行网格线和列网格线之间的空间既是网格轨道。</p>
<p><img src= "/img/loading.gif" data-src="%E7%BD%91%E6%A0%BC%E8%BD%A8%E9%81%93.jpeg" alt="网格轨道"></p>
<h5 id="3-网格单元格-Grid-Cell"><a href="#3-网格单元格-Grid-Cell" class="headerlink" title="(3)网格单元格(Grid Cell)"></a>(3)网格单元格(Grid Cell)</h5><p>两个相邻的行网格线和两个相邻的列网格线之间的空间属于网格单元格。这是网格系统的一个“单元”。如下图橘黄色的行网格线和列网格线交叉处即是网格单元格。</p>
<p><img src= "/img/loading.gif" data-src="%E7%BD%91%E6%A0%BC%E5%8D%95%E5%85%83%E6%A0%BC.jpeg" alt="网格单元格"></p>
<h5 id="4-网格区域-Grid-Area"><a href="#4-网格区域-Grid-Area" class="headerlink" title="(4)网格区域(Grid Area)"></a>(4)网格区域(Grid Area)</h5><p>由单个或多个网格单元格组成，它是可以用来摆放页面元素。如下图所示，橘黄色的行网格线和列网格线交叉处即是网格区域。</p>
<p><img src= "/img/loading.gif" data-src="%E7%BD%91%E6%A0%BC%E5%8C%BA%E5%9F%9F.jpeg" alt="网格区域"></p>
<h5 id="5-网格设置"><a href="#5-网格设置" class="headerlink" title="(5)网格设置"></a>(5)网格设置</h5><p>在设计界面时可以通过网格定制能够<strong>使界面更加有序、整齐、规范，</strong>网格的主要用途之一是保持设计元素对齐和排序。通过建立一个网格系统，设计师可以为自己创建一个结构来适配不同的屏幕宽度。</p>
<p>在我制定的规范中一般会把网格的基数设置为4，它不仅符合偶数的思路同时也能够匹配多数主流的显示设备，如中台系统的用户主流分辨率用1440x900、1366x768、1280x800。我们可以通过设置网格规范帮助设计师快速搭建页面，使用有律可循的布局空间的设计给到开发减少沟通成本。下图所示设计布局网格由三个元素组成：1.列宽，2.间距，3.边距。</p>
<p><img src= "/img/loading.gif" data-src="%E7%BD%91%E6%A0%BC%E8%AE%BE%E7%BD%AE1.jpg" alt="网格设置1"></p>
<p>在Sketch中设置网格，在菜单栏中找【视图】-【画布】-【网格设置】-弹出浮层可设置网格大小，网格设置的基数设置成4，之后在设计界面时可按照网格基础的倍数作为组件的大小和页面元素间距分割，如下图：</p>
<p><img src= "/img/loading.gif" data-src="%E7%BD%91%E6%A0%BC%E8%AE%BE%E7%BD%AE2.jpg" alt="网格设置2"></p>
<p>我们放大页面局部大家可以看到，<strong>把网格基数设置成4，每个网格单元格为4*4大小。</strong>同理，如果把网格基数设置成8以后，每个网格单元格大小为8*8大小。</p>
<p><img src= "/img/loading.gif" data-src="%E7%BD%91%E6%A0%BC%E8%AE%BE%E7%BD%AE3.jpg" alt="网格设置3"></p>
<h4 id="关于栅格"><a href="#关于栅格" class="headerlink" title="关于栅格"></a>关于栅格</h4><h5 id="删格基础知识"><a href="#删格基础知识" class="headerlink" title="删格基础知识"></a>删格基础知识</h5><p>网页栅格也是大家口中常常提及的栅格系统。其实网页栅格系统是从平面栅格系统中发展而来，它延续了平面设计的方法与风格，在网页中使用栅格能够使得网页信息展现更加清晰明了、美观易读。</p>
<p>首先网页栅格系统基本由是栅格总宽度即页面总宽度（W）、一个栅格的宽度即列宽（a）、栅格与栅格之间的间隙即水槽（i）、一个单元的宽度（A）、外边距即最外侧的栏与屏幕之间的安全距离（M）组成。</p>
<h6 id="列宽"><a href="#列宽" class="headerlink" title="列宽"></a>列宽</h6><p>列是栅格的基本单位，通常说的12栅格就是12个列。24栅格就是24个列。一个栅格的宽度（a），我们称之为列宽，一个列宽包涵了N个网格单元格（Grid Cell）我们也可以把它看成一个网格区域(Grid Area)，列宽非固定值，这样可以使内容自由适配任何屏幕尺寸。在栅格中列宽由屏幕尺寸决定。</p>
<h6 id="水槽"><a href="#水槽" class="headerlink" title="水槽"></a>水槽</h6><p>栅格与栅格之间的间隙（i），我们称之为水槽，一个水槽宽度大于等于1个网格单元（Grid Cell）。在栅格中水槽为一个定值，宽度可以是N个网格单元，如网格单元格设置成4，那么水槽可以是4、8、12、16…N*4</p>
<h6 id="栅格单元"><a href="#栅格单元" class="headerlink" title="栅格单元"></a>栅格单元</h6><p>1个列宽+1个水槽宽度即一个单元的宽度，一个栅格总宽是由N个栅格单元组成，次宽度不固定，由屏幕尺寸决定。</p>
<p>此外也有去掉边距的布局，把N个列和N-1个槽作为栅格的宽度的。</p>
<h6 id="栅格总宽"><a href="#栅格总宽" class="headerlink" title="栅格总宽"></a>栅格总宽</h6><p>列宽+水槽再成以N即是一个栅格的总宽，<strong>公式为：W=(A*n)-i。</strong></p>
<p><img src= "/img/loading.gif" data-src="%E6%A0%85%E6%A0%BC%E5%AE%BD%E5%BA%A6.jpg" alt="栅格宽度"></p>
<h5 id="栅格设置"><a href="#栅格设置" class="headerlink" title="栅格设置"></a>栅格设置</h5><p>常见的栅格分为12列栅格系统和24列栅格系统。其中12列栅格系统在流行的前端开发开源工具库Bootstrap与Foundation中广泛使用，适用于业务信息分组较少、业务结构较简，单个盒子内信息体积较大的中后台页面设计。24等分的栅格系统适用于业务信息量大、信息分组较多、单个盒子内信息体积较小的中后台页面设计；相对12栅格系统，24栅格系统变化更加灵活，更适合内容比较多样复杂的场景。但栅格有时候也不是划分的越细越好，24栅格精细，但有时候也显得琐碎，如下图分别是12栅格系统（左）和24栅格系统（右）。</p>
<p><img src= "/img/loading.gif" data-src="%E5%B7%A6%E5%8F%B3%E7%BB%93%E6%9E%84.jpg" alt="左右结构"></p>
<p><img src= "/img/loading.gif" data-src="T%E5%AD%97%E7%BB%93%E6%9E%84.jpg" alt="T字结构"></p>
<p><img src= "/img/loading.gif" data-src="%E4%B8%8A%E4%B8%8B%E7%BB%93%E6%9E%84.jpg" alt="上下结构"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>不论哪种Web界面布局方式，其都是为信息展示服务的。无论是导航引导还是内容引导，无论是一栏还是多栏，无论是T型结构还是左右结构最终的落脚点，都是帮助用户尽快地看到最希望看到的内容。设计是为业务服务的，而不是设计本身。</p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>规范</tag>
        <tag>中台</tag>
      </tags>
  </entry>
  <entry>
    <title>从sgm-web指标来看页面加载速度优化</title>
    <url>/2021/03/23/%E4%BB%8Esgm-web%E6%8C%87%E6%A0%87%E6%9D%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>页面加载速度优化是提升用户体验、提高用户访问率和留存率的关键，因此，加载速度优化是前端开发必须掌握的技能。通常，我们会使用监控平台提供的 js 进行各种数据的上报，并依靠这些监控平台提供的各项数据来评估我们的页面，但对于这些数据的上报节点以及哪些资源或者操作会影响这些数据，我们却常常是不求甚解的。所以经常会出现这种情况，随着需求的累积，页面加载越来越慢。<br>这篇文章的目的很简单，就是弄清楚我们使用的监控平台的性能数据对应的时间节点是什么，在这些节点上，页面的加载状态是什么样子的。</p>
<h1 id="sgm-web-的统计指标"><a href="#sgm-web-的统计指标" class="headerlink" title="sgm-web 的统计指标"></a>sgm-web 的统计指标</h1><p>目前，我们的页面使用的是 sgm-web 平台来进行页面性能的监控，这个平台提供了白屏时间、页面加载完成时间和 HTML 加载完成时间这三个数据项作为衡量页面加载速度的依据。为了弄清楚这些数据项是按照什么方式统计的，我新建了一个 sgm 的应用，并且通过在 sgm.js 中打断点的方式，获取到了上报时的数据，如下：</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/165220/28/6892/627382/602f829cEcadc06b2/21d67416578abccf.jpg" alt="sgm.js断点"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cct: 0</span><br><span class="line">cot: 0</span><br><span class="line">dnt: 0</span><br><span class="line">dot: 492</span><br><span class="line">fbe: 15</span><br><span class="line">fpt: 16</span><br><span class="line">ldt: 1522</span><br><span class="line">rdc: 0</span><br><span class="line">rdt: 0</span><br><span class="line">ret: 1014</span><br><span class="line">rte: 508</span><br><span class="line">slt: 0</span><br><span class="line">tbt: 7</span><br><span class="line">tst: 1</span><br><span class="line">tte: 508</span><br><span class="line">typ: &quot;reload&quot;</span><br></pre></td></tr></table></figure>

<p>此时，sgm-web 后台统计出来的数据如下：</p>
<p><img src= "/img/loading.gif" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/158535/22/7215/96620/602f2a91Eb6020785/997b23c6f02a6baa.jpg" alt="sgm-web统计结果"></p>
<p>因为只有一次上报，我们可以很清楚的找到统计口径和上报数据的对应关系，而且通过 sgm.js，我们也可以知道各个上报数据是怎么计算出来的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">白屏时间 -&gt; fpt -&gt; responseEnd - startTime</span><br><span class="line">页面加载完成时间 -&gt; ldt -&gt; loadEventEnd - startTime</span><br><span class="line">HTML加载完成时间 -&gt; rte -&gt; domContentLoadedEventEnd - startTime</span><br></pre></td></tr></table></figure>

<p>对 Performance 稍微有了解的大概都会猜到，responseEnd/loadEventEnd/domContentLoadedEventEnd/startTime 等都是 Performance 中的属性（responseEnd/loadEventEnd/domContentLoadedEventEnd/navigationStart 为PerformanceTiming 中的属性， startTime 为 PerformanceNavigationTiming 中的属性， 这部分我们下节会讲）。下一步，我们要弄清楚这些属性的含义是什么。</p>
<h1 id="Performance-API"><a href="#Performance-API" class="headerlink" title="Performance API"></a>Performance API</h1><p>注意： Performance API 这节主要为了说明 Performance 的使用及兼容情况，如果你觉得枯燥，可以跳过这一节。</p>
<p>还是先从 sgm.js 中的一段代码说起（如下），这部分代码用于获取和性能相关的数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b 代表 window， e 为最终获取的性能的数据</span></span><br><span class="line"><span class="keyword">var</span> e, t = b.performance, r = t.timing, n = t.navigation, i = <span class="keyword">void</span> <span class="number">0</span> === n ? &#123;&#125; : n;</span><br><span class="line"><span class="keyword">if</span> (b.PerformanceNavigationTiming) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = b.performance.getEntriesByType(<span class="string">&quot;navigation&quot;</span>) || [];</span><br><span class="line">    e = a[<span class="number">0</span>] || &#123;&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> o = i.type</span><br><span class="line">        , s = i.redirectCount;</span><br><span class="line">    e = r || &#123;&#125;,</span><br><span class="line">    e.type = Mo(o),</span><br><span class="line">    e.redirectCount = s,</span><br><span class="line">    e.startTime = r.navigationStart</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我可以看到，是先判断了 window 下是否有 PerformanceNavigationTiming 对象， 如果有的话使用 window.performance.getEntriesByType(“navigation”) 方法获取，没有的话就使用 window.performance.timing 对象，并且追加window.performance.timing.navigationStart 、window.performance.navigation.type 、window.performance.navigation.redirectCount 属性。凭借经验，我们知道这可能和Performance 下不同类型的对象的兼容性有关系，那我们就从Performance 开始展开吧。</p>
<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>通过 window.performance 可以获取到 Performance 的对象。Performance 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Performance</span> <span class="keyword">extends</span> <span class="title">EventTarget</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">    readonly navigation: PerformanceNavigation;</span><br><span class="line">    onresourcetimingbufferfull: ((<span class="keyword">this</span>: Performance, ev: Event) =&gt; any) | <span class="keyword">null</span>;</span><br><span class="line">    readonly timeOrigin: number;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">    readonly timing: PerformanceTiming;</span><br><span class="line">    clearMarks(markName?: string): <span class="keyword">void</span>;</span><br><span class="line">    clearMeasures(measureName?: string): <span class="keyword">void</span>;</span><br><span class="line">    clearResourceTimings(): <span class="keyword">void</span>;</span><br><span class="line">    getEntries(): PerformanceEntryList;</span><br><span class="line">    getEntriesByName(name: string, type?: string): PerformanceEntryList;</span><br><span class="line">    getEntriesByType(type: string): PerformanceEntryList;</span><br><span class="line">    mark(markName: string): <span class="keyword">void</span>;</span><br><span class="line">    measure(measureName: string, startMark?: string, endMark?: string): <span class="keyword">void</span>;</span><br><span class="line">    now(): number;</span><br><span class="line">    setResourceTimingBufferSize(maxSize: number): <span class="keyword">void</span>;</span><br><span class="line">    toJSON(): any;</span><br><span class="line">    addEventListener&lt;K extends keyof PerformanceEventMap&gt;(type: K, listener: (<span class="keyword">this</span>: Performance, ev: PerformanceEventMap[K]) =&gt; any, options?: <span class="keyword">boolean</span> | AddEventListenerOptions): <span class="keyword">void</span>;</span><br><span class="line">    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: <span class="keyword">boolean</span> | AddEventListenerOptions): <span class="keyword">void</span>;</span><br><span class="line">    removeEventListener&lt;K extends keyof PerformanceEventMap&gt;(type: K, listener: (<span class="keyword">this</span>: Performance, ev: PerformanceEventMap[K]) =&gt; any, options?: <span class="keyword">boolean</span> | EventListenerOptions): <span class="keyword">void</span>;</span><br><span class="line">    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: <span class="keyword">boolean</span> | EventListenerOptions): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Performance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API。</p>
</blockquote>
<p>在这里，我们需要关注 Performance 中的 navigation 和 timing 属性，它们分别是 PerformanceNavigation 和 PerformanceTiming 的对象。<br>另外，在最新的 W3C 标准中（<a href="https://www.w3.org/TR/navigation-timing-2/#the-performancetiming-interface">点这里</a>），PerformanceTiming 和 PerformanceNavigation 被弃用了，推荐使用 PerformanceNavigationTiming。我们可以通过调用 Performance 中的 getEntriesByType(“navigation”)[0] 获取 PerformanceNavigationTiming 实例（PerformanceNavigationTiming 继承自PerformanceEntryList）。</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/157877/34/8369/127459/6034d531E017ca82c/e27ff52a52190a11.jpg" alt="PerformanceTiming 和 PerformanceNavigation 被弃用"></p>
<h2 id="PerformanceNavigation"><a href="#PerformanceNavigation" class="headerlink" title="PerformanceNavigation"></a>PerformanceNavigation</h2><p>PerformanceNavigation 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PerformanceNavigation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unsigned <span class="keyword">short</span> TYPE_NAVIGATE = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> unsigned <span class="keyword">short</span> TYPE_RELOAD = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> unsigned <span class="keyword">short</span> TYPE_BACK_FORWARD = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">const</span> unsigned <span class="keyword">short</span> TYPE_RESERVED = <span class="number">255</span>;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">short</span> type;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">short</span> redirectCount;</span><br><span class="line">  [Default] <span class="function">object <span class="title">toJSON</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PerformanceNavigation 中只有两个只读属性：type 和 redirectCount。</p>
<p>type 表示是如何导航到当前页面的，如下：</p>
<ul>
<li>TYPE_NAVIGATE (0)： 当前页面是通过点击链接，书签和表单提交，或者脚本操作，或者在url中直接输入地址，type值为0</li>
<li>TYPE_RELOAD (1)：点击刷新页面按钮或者通过Location.reload()方法显示的页面，type值为1</li>
<li>TYPE_BACK_FORWARD (2)：页面通过历史记录和前进后退访问时。type值为2</li>
<li>TYPE_RESERVED (255)：任何其他方式，type值为255</li>
</ul>
<p>redirectCount 表示在到达这个页面之前重定向了多少次。</p>
<h2 id="PerformanceTiming"><a href="#PerformanceTiming" class="headerlink" title="PerformanceTiming"></a>PerformanceTiming</h2><p>PerformanceTiming 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PerformanceTiming</span> </span>&#123;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> navigationStart;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> unloadEventStart;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> unloadEventEnd;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> redirectStart;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> redirectEnd;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> fetchStart;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> domainLookupStart;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> domainLookupEnd;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> connectStart;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> connectEnd;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> secureConnectionStart;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> requestStart;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> responseStart;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> responseEnd;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> domLoading;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> domInteractive;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> domContentLoadedEventStart;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> domContentLoadedEventEnd;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> domComplete;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> loadEventStart;</span><br><span class="line">  readonly attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span> loadEventEnd;</span><br><span class="line">  [Default] <span class="function">object <span class="title">toJSON</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>各个属性的定义如下：</p>
<ul>
<li>navigationStart：如果有前一个页面，则返回前一个页面卸载完的时间戳，如果没有上一个页面，返回当前页面创建时的时间</li>
<li>unloadEventStart：如果当前 url 与上一个 url 是同源，则返回的值是指上一个页面卸载开始的时间，如果与上一个不同域或者没有上一个 url，则返回 0</li>
<li>unloadEventEnd：如果当前 url 与上一个 url 是同源，则返回的值是指上一个页面卸载完成的时间，如果与上一个不同域或者没有上一个 url，则返回 0</li>
<li>redirectStart：如果来源于同源的 url 重定向，则该值返回的是开始重定向的时间，如果不同源或者无重定向，返回为 0</li>
<li>redirectEnd：如果来源于同源的 url 重定向，则该值返回的是重定向完成的时间，如果不同源或者无重定向，返回为 0</li>
<li>fetchStart：如果要使用“GET”请求方法获取新资源，fetchStart 返回的是浏览器发起请求到检测缓存前时间，否则直接返回浏览器请求时间</li>
<li>domainLookupStart：返回查询 DNS 开始时间，如果是持久连接或者是从缓存中获取资源，则这个值等于 fetchStart</li>
<li>domainLookupEnd：返回查询 DNS 结束时间，如果是持久连接或者是从缓存中获取资源，则这个值等于 fetchStart</li>
<li>connectStart：返回与服务端建立连接开始时间，如果是持久连接或者是从缓存中获取资源，则这个值等于 domainLookupEnd</li>
<li>connectEnd：返回与服务端建立连接完成时间，如果是持久连接或者是从缓存中获取资源，则这个值等于 domainLookupEnd</li>
<li>secureConnectionStart：如果是 https 请求并且这个属性是可获取的，则返回握手连接开始时间</li>
<li>requestStart：返回向服务器发送请求时（或者从本地缓存读取时）开始时间</li>
<li>responseStart：返回从服务器端（或者从本地缓存中）接收到第一个字节的时间</li>
<li>responseEnd：返回从服务器端（或者从本地缓存中）接收到最后一个字节的时间</li>
<li>domLoading：返回当前网页DOM结构开始解析时（即 Document.readyState属性变为“loading”、相应的 readystatechange事件触发时）的时间</li>
<li>domInteractive：返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为 interactive”、相应的readystatechange事件触发时）的时间，domInteractive并非DOMReady，它早于DOMReady触发，表示DOM文档解析完毕（即 DOM tree创建完成），但内嵌资源（比如css、js等）还未加载的时间</li>
<li>domContentLoadedEventStart：触发 DOMContentLoaded 事件开始时间</li>
<li>domContentLoadedEventEnd：DOMContentLoaded 事件结束时间</li>
<li>domComplete：返回当前文档解析完成，即 Document.readyState 变为 ‘complete’ 且相对应的readystatechange 被触发时的时间</li>
<li>loadEventStart：返回触发 onload 开始时间，当load事件尚未触发时，它返回零</li>
<li>loadEventEnd：返回 onload 完成时间，当load事件尚未触发时，它返回零</li>
</ul>
<p>这些属性对应的节点如下图：<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/161348/21/7710/62981/6034d887Ef700f9a8/93bc74c1fe77d248.png" alt="PerformanceTiming"></p>
<h2 id="PerformanceNavigationTiming"><a href="#PerformanceNavigationTiming" class="headerlink" title="PerformanceNavigationTiming"></a>PerformanceNavigationTiming</h2><p>PerformanceNavigationTiming 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interface PerformanceNavigationTiming : PerformanceResourceTiming &#123;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp unloadEventStart;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp unloadEventEnd;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp domInteractive;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp domContentLoadedEventStart;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp domContentLoadedEventEnd;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp domComplete;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp loadEventStart;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp loadEventEnd;</span><br><span class="line">    readonly        attribute NavigationType      type;</span><br><span class="line">    readonly        attribute unsigned <span class="keyword">short</span>      redirectCount;</span><br><span class="line">    [Default] <span class="function">object <span class="title">toJSON</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些属性对应的节点如下图：</p>
<p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/161861/15/7640/328340/6034dbb6Eb76a6896/512483da73d8865c.png" alt="PerformanceNavigationTiming"></p>
<p>上图中黄色区域是 PerformanceResourceTiming 的属性，我们计算时使用的 respondEnd 就是PerformanceResourceTiming 中的属性。</p>
<h2 id="PerformanceResourceTiming"><a href="#PerformanceResourceTiming" class="headerlink" title="PerformanceResourceTiming"></a>PerformanceResourceTiming</h2><p>PerformanceResourceTiming 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interface PerformanceResourceTiming : PerformanceEntry &#123;</span><br><span class="line">    readonly        attribute DOMString           initiatorType;</span><br><span class="line">    readonly        attribute DOMString           nextHopProtocol;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp workerStart;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp redirectStart;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp redirectEnd;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp fetchStart;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp domainLookupStart;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp domainLookupEnd;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp connectStart;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp connectEnd;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp secureConnectionStart;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp requestStart;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp responseStart;</span><br><span class="line">    readonly        attribute DOMHighResTimeStamp responseEnd;</span><br><span class="line">    readonly        attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span>  transferSize;</span><br><span class="line">    readonly        attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span>  encodedBodySize;</span><br><span class="line">    readonly        attribute unsigned <span class="keyword">long</span> <span class="keyword">long</span>  decodedBodySize;</span><br><span class="line">    [Default] <span class="function">object <span class="title">toJSON</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>各个属性的定义如下：</p>
<ul>
<li>initiatorType：返回值可能是 “css”、”xmlhttprequest”、”fetch”、”beacon”、”other” 等，initiator 类型</li>
<li>nextHopProtocol：返回网路资源协议，可能返回为 “”</li>
<li>workerStart：如果有 active worker，则返回 worker fetch 时间</li>
<li>redirectStart：如果来源于同源的 url 重定向，则该值返回的是初始化重定向开始时间，否则返回 0</li>
<li>redirectEnd：如果来源于同源的 url 重定向，则该值返回的是最后一个重定向接收最后一个字节时的时间，否则返回 0</li>
<li>fetchStart：返回请求这个资源开始时间</li>
<li>domainLookupStart：返回查询 DNS 开始时间，如果是持久连接或者是从缓存中获取资源，则这个值等于 fetchStart，如果请求这个资源失败，返回 0</li>
<li>domainLookupEnd：返回查询 DNS 结束时间，如果是持久连接或者是从缓存中获取资源，则这个值等于 fetchStart，如果请求这个资源失败，返回 0</li>
<li>connectStart：返回与服务端建立连接开始时间，如果是持久连接或者是从缓存中获取资源，则这个值等于 fetchStart，如果请求这个资源失败，返回 0</li>
<li>connectEnd：返回与服务端建立连接完成时间，如果是持久连接或者是从缓存中获取资源，则这个值等于 fetchStart，如果请求这个资源失败，返回 0</li>
<li>secureConnectionStart：如果没有使用 https 或者资源加载失败，返回 0，如果持久连接或者从缓存或本地读取，则与 - fetchStart 相同，否则指握手连接时间 说明</li>
<li>requestStart：返回向服务器发送请求时（或者从本地缓存读取时）开始时间</li>
<li>responseStart：返回从服务器端（或者从本地缓存中）接收到第一个字节的时间</li>
<li>responseEnd：返回从服务器端（或者从本地缓存中）接收到最后一个字节的时间</li>
<li>transferSize：响应头和响应体大小，当从缓存中读取时，该值为 0，与 chrome 中 devtool Network里的size一致，该值还可以用来判断是否从缓存中读取的，如果为 0，表示从缓存中读取的</li>
<li>encodedBodySize：返回响应体编码压缩后字节大小，该值减去 transferSize 等于响应头大小</li>
<li>decodedBodySize：返回响应体编码压缩前的字节大小，该值比 encodedBodySize 大很多</li>
<li>serverTiming：返回列表 PerformanceServerTiming，只有在 Web Workers 中有效</li>
</ul>
<p>上面罗列了 Performance 的各种 API，有两个目的，最直接的目的是为了说明Performance我们用到的几个属性在页面加载时处在哪个节点上，另外一个目的就是了解 Performance 的兼容性，如果我们要自己写性能监控的功能，可以作为参考。</p>
<p>我们知道如何获取各个节点上的数值之后，接下来要考虑的就是在什么时候获取这些值了。</p>
<h1 id="触发节点"><a href="#触发节点" class="headerlink" title="触发节点"></a>触发节点</h1><p>我们再来看下【sgm-web 的统计指标】指标计算方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">白屏时间 -&gt; fpt -&gt; responseEnd - startTime</span><br><span class="line">页面加载完成时间 -&gt; ldt -&gt; loadEventEnd - startTime</span><br><span class="line">HTML加载完成时间 -&gt; rte -&gt; domContentLoadedEventEnd - startTime</span><br></pre></td></tr></table></figure>

<p>再回顾下这张图：<br><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/161861/15/7640/328340/6034dbb6Eb76a6896/512483da73d8865c.png" alt="PerformanceNavigationTiming"></p>
<h2 id="白屏时间"><a href="#白屏时间" class="headerlink" title="白屏时间"></a>白屏时间</h2><p>白屏时间指首次渲染时间，指页面出现第一个文字或图像所花费的时间。</p>
<p>从上图中我们可以知道，在 respondEnd 之前，还有页面 unload、重定向、DNS、TCP 连接、发送/获取请求等阶段，这些阶段都是 Resource Timing 中的节点。</p>
<h2 id="HTML-加载完成时间"><a href="#HTML-加载完成时间" class="headerlink" title="HTML 加载完成时间"></a>HTML 加载完成时间</h2><p>HTML 加载完成时间对应 DOMContentLoaded 事件。我们来看下 MDN 对于 DOMContentLoaded 的解释：</p>
<blockquote>
<p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。</p>
</blockquote>
<p>DOMContentLoaded 需要使用 addEventListener 方法来捕获：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;DOMContentLoaded event&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>从上面 MDN 的解释，我们可以知道，DOMContentLoaded 触发的条件是 DOM 树解析完成。同样的，MDN 也提供了优化的建议：</p>
<p><img src= "/img/loading.gif" data-src="https://img10.360buyimg.com/imagetools/jfs/t1/157430/32/14734/152518/60580decE8b0c37a7/f48d8d86afd6c2d1.jpg" alt="DOMContentLoaded 优化"></p>
<ol>
<li>JavaScript 脚本：<br>浏览器解析DOM时，如果在文档中遇到 script 标签，因为脚本可能会修改 DOM，所以浏览器在这时就会停止构建 DOM，直到文件加载并执行完成。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;DOMContentLoaded&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;http://wechatfe.github.io/lib/vconsole/3.4.0/vconsole.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;script loaded and executed&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>因为 DOMContentLoaded 是在 script 加载并执行完成后才会触发，因此我们先看到 script loaded and executed, 等 vConsole.js 加载完成后才能看到 DOMContentLoaded 被触发。</p>
<p>如果有些不重要或者不影响页面渲染的脚本（比如分享脚本或者非首屏脚本），我们可以采用不阻塞 DOMContentLoaded 事件执行的方式加载：</p>
<ul>
<li>增加async 属性：具有 async 特性（attribute）的脚本不会阻塞 DOMContentLoaded，如下图：</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://pic4.zhimg.com/80/v2-59d63189e9fe4c165370d81512b4fe73_1440w.jpg" alt="async属性的script"></p>
<ul>
<li>动态添加：使用 document.createElement(‘script’) 动态生成并添加到网页的脚本也不会阻塞 DOMContentLoaded。</li>
</ul>
<ol start="2">
<li>样式表：</li>
</ol>
<p>因为 DOM 和 CSS 的解析是并行的，CSS 的加载不会影响 DOM 的解析。但是，由于脚本可能会操作之前的 DOM 节点和 CSS 样式，样式表会在后面的 js 执行前先加载，因此 css 会阻塞后面 js 的执行。所以，当 DOMContentLoaded 等待脚本时，它也在等待脚本前面的样式。<br>如果我们的 js 都在 css 的前面， css 的加载自然不会影响 DOMContentLoaded 的触发时间，但是使用这种方式的话， js 和 css 加载的过程中，页面都是没有样式的。</p>
<h2 id="页面加载完成时间"><a href="#页面加载完成时间" class="headerlink" title="页面加载完成时间"></a>页面加载完成时间</h2><p>页面加载完成时间指页面完全加载完所用的时间，这时候触发完成了 onload 事件。onload 事件触发时，浏览器不仅加载完成了 HTML，还加载完成了所有外部资源，如图片、样式等。这时候，外部资源已加载完成，样式已被应用，图片大小也已知了。</p>
<p>load 事件可以直接使用 window.onload 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function">() =&gt;</span> log(<span class="string">&#x27;onload&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>只有当所有资源被加载完了，load 事件才会被触发，所以除了 Resource Timing 中的网络要素外，所有的静态资源的加载、页面的渲染等都是影响页面加载完成性能数据的因素。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，这篇文章只是大致理清了各指标数据的统计口径及上报节点，以及这些节点与哪些资源或者事件相关。如果要详细了解 Performance 各阶段优化的细节，之后我会出一个系列慢慢讲。 </p>
]]></content>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>代码的22种坏味道</title>
    <url>/2021/03/06/%E4%BB%A3%E7%A0%81%E7%9A%8422%E7%A7%8D%E5%9D%8F%E5%91%B3%E9%81%93/</url>
    <content><![CDATA[<h2 id="类内味道"><a href="#类内味道" class="headerlink" title="类内味道"></a>类内味道</h2><h3 id="可度量的味道"><a href="#可度量的味道" class="headerlink" title="可度量的味道"></a>可度量的味道</h3><ol>
<li>过长方法</li>
</ol>
<blockquote>
<p>我们遵循这样一条原则：每当感觉须要写注释来说明代码的时候。我们就把须要说明的东西写进一个独立的方法中，并以其意图(而非实现手法)命名。</p>
</blockquote>
<ul>
<li><p>抽取方法 (解释能力、共享能力、选择能力)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        login()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">login</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;login&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">to </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        login()</span><br><span class="line">        speak()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">login</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;login&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将临时变量替换为查询 </p>
<blockquote>
<p>我们常做的是临时变量作为参数传递给提炼出来的对象，但这样对提升代码可读性并没有帮助</p>
</blockquote>
</li>
</ul>
<p>正确的做法是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> basePrice = _quantity * _itemPrice</span><br><span class="line">    <span class="keyword">return</span> basePrice &gt; <span class="number">1000</span> ? basePrice * <span class="number">0.8</span> : basePrice * <span class="number">0.9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">to</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice() &gt; <span class="number">1000</span> ? basePrice() * <span class="number">0.8</span> : basePrice() *<span class="number">0.9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basePrice</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _quantity * _itemPrice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将方法替换为方法对象 </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gamma</span>(<span class="params">inputVal, quantity, yearToDate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> importantValue1 = (inputVal * quantity) + delta();</span><br><span class="line">    <span class="keyword">const</span> importantValue2 = (inputVal * yearToDate) + <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> ((yearToDate - importantValue1) &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        importantValue2 -= <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> importantValue2 - <span class="number">2</span> * importantValue1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">to </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gamma</span>(<span class="params">inputVal, quantity, yearToDate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Gamma(inputVal, quantity, yearToDate).compute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gamma</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">inputVal, quantity, yearToDate</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inputVal = inputVal</span><br><span class="line">        <span class="built_in">this</span>.quantity = quantity</span><br><span class="line">        <span class="built_in">this</span>.yearToDate = yearToDate</span><br><span class="line">        <span class="built_in">this</span>.importantValue1 = (inputVal * quantity) + delta()</span><br><span class="line">        <span class="built_in">this</span>.importantValue2 = (inputVal * quantity) + <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">compute</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">this</span>.yearToDate - <span class="built_in">this</span>.importantValue1) &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.importantValue2 -= <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.importantValue2 - <span class="number">2</span> * <span class="built_in">this</span>.importantValue1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在我可以轻松地对compute()函数采取 Extract Method，不必担心引数（argument）传递</p>
</blockquote>
<ul>
<li>分解条件式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">ask</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(msg === <span class="string">&#x27;name&#x27;</span> || msg === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;msg&#125;</span>: <span class="subst">$&#123;<span class="built_in">this</span>[msg]&#125;</span>`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;error-nodata&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">to</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">ask</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.isValidQuestion(msg)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.speak(speak)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.nodata()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">isValidQuestion</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg === <span class="string">&#x27;name&#x27;</span> || msg === <span class="string">&#x27;age&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">speak</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;msg&#125;</span>: <span class="subst">$&#123;<span class="built_in">this</span>[msg]&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">nodata</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;error-nodata&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ol start="2">
<li>过大的类</li>
</ol>
<blockquote>
<p>说明这个类做太多事情。其内往往就会出现太多instance变量。一旦如此。Duplicated Code也就接踵而至了。</p>
</blockquote>
<ul>
<li>抽取类</li>
</ul>
<p>将「与电话号码相关」的行为分离到一个独立class中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">this</span>._officeAreaCode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">this</span>._officeNumber = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTelephoneNumber</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;(&quot;</span> + <span class="built_in">this</span>._officeAreaCode + <span class="string">&quot;) &quot;</span> + <span class="built_in">this</span>._officeNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getOfficeAreaCode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._officeAreaCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setOfficeAreaCode</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._officeAreaCode = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getOfficeNumber</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._officeNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setOfficeNumber</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._officeNumber = arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">to</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._name = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>._officeTelephone = <span class="keyword">new</span> TelephoneNumber()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTelephoneNumber</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._officeTelephone.getTelephoneNumber()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getOfficeTelephone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._officeTelephone</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelephoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._areaCode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">this</span>._number = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTelephoneNumber</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;(&quot;</span> + <span class="built_in">this</span>._areaCode + <span class="string">&quot;) &quot;</span> + <span class="built_in">this</span>._number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getAreaCode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._areaCode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setAreaCode</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._areaCode = arg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getNumber</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setNumber</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._number= arg</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽取子类<blockquote>
<p>class 中的某些行为只被一部分实体用到，其他实体不需要它们。</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobItem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">unitPrice, quantity, isLabor, employee</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._unitPrice = unitPrice;</span><br><span class="line">        <span class="built_in">this</span>._quantity = quantity;</span><br><span class="line">        <span class="built_in">this</span>._isLabor = isLabor;</span><br><span class="line">        <span class="built_in">this</span>._employee = employee || <span class="keyword">new</span> Employee();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTotalPrice</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getUnitPrice() * <span class="built_in">this</span>._quantity</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getUnitPrice</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._isLabor ? <span class="built_in">this</span>._employee.getRate() : <span class="built_in">this</span>._unitPrice</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getQuantity</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._quantity</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getEmployee</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._employee</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">rate</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._rate = rate</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getRate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._rate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kent = <span class="keyword">new</span> Employee(<span class="string">&#x27;rate&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> j1 = <span class="keyword">new</span> JobItem (<span class="number">0</span>, <span class="number">5</span>, <span class="literal">true</span>, kent)</span><br><span class="line"></span><br><span class="line">to</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobItem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">unitPrice, quantity</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._unitPrice = unitPrice;</span><br><span class="line">        <span class="built_in">this</span>._quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTotalPrice</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getUnitPrice() * <span class="built_in">this</span>._quantity</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getUnitPrice</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._unitPrice</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getQuantity</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._quantity</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getEmployee</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._employee</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">rate</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._rate = rate</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getRate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._rate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaborItem</span> <span class="keyword">extends</span> <span class="title">JobItem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">quantity, employee</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">0</span>, quantity)</span><br><span class="line">        <span class="built_in">this</span>._employee = employee</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getUnitPrice</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._employee.getRate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kent = <span class="keyword">new</span> Employee(<span class="string">&#x27;rate&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> j1 = <span class="keyword">new</span> LaborItem (<span class="number">5</span>, kent)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(j1.getQuantity())</span><br></pre></td></tr></table></figure>

<ul>
<li><p>抽取接口</p>
<blockquote>
<p>implements关键字 js中没有</p>
</blockquote>
</li>
<li><p>将数据值替换为对象</p>
<blockquote>
<p>一开始你可能会用一个字符串来表示「电话号码」概念，但是随后你就会发现，电话号码需要「格式化」、「抽取区号」之类的特殊行为。如果这样的数据项只有一二个</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">customer</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._customer = customer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getCustomer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._customer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setCustomer</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._customer = arg</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">to</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">customer</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._customer = <span class="keyword">new</span> Customer(customer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getCustomer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._customer.getName()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setCustomer</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._customer = <span class="keyword">new</span> Customer(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>过长的参数表</li>
</ol>
<ul>
<li>将参数替换为方法</li>
<li>引入参数对象</li>
<li>保持对象完整</li>
</ul>
<ol start="4">
<li>过多的注释<blockquote>
<p>经常会有这种情况：你看到一段代码有着长长的注释。然后发现，这些注释之所以存在乃是由于代码非常糟糕。这种情况的发生次数之多。实在令人惊讶。</p>
</blockquote>
</li>
</ol>
<ul>
<li>抽取方法</li>
<li>引入断言</li>
</ul>
<h3 id="不必要的复杂性"><a href="#不必要的复杂性" class="headerlink" title="不必要的复杂性"></a>不必要的复杂性</h3><p><strong>过分一般性</strong></p>
<ul>
<li><p>折叠继承体系</p>
<blockquote>
<p>继承体系很容易变得过分复杂。如果继承并不能带来该有的价值，尝试将两个类合并起来。</p>
</blockquote>
</li>
<li><p>内联类</p>
<blockquote>
<p>你的某个class没有做太多事情（没有承担足够责任）。将class的所有特性搬移到另一个class中，然后移除原class。</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._officeTelephone = <span class="keyword">new</span> TelephoneNumber()</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTelephoneNumber</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._officeTelephone.getTelephoneNumber();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getOfficeTelephone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._officeTelephone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelephoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">number, areaCode</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._number = number</span><br><span class="line">        <span class="built_in">this</span>._areaCode = areaCode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTelephoneNumber</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;(&quot;</span> + <span class="built_in">this</span>._areaCode + <span class="string">&quot;) &quot;</span> + <span class="built_in">this</span>._number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getAreaCode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._areaCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setAreaCode</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._areaCode = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getNumber</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setNumber</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._number = arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>移除参数</li>
<li>重命名方法</li>
</ul>
<h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><ol>
<li>重复性代码<blockquote>
<p>坏味道的首当其冲是重复的代码Duplicated Code。假设你在一个以上的地点看到同样的程序结构，那么当可肯定：设法将它们合而为一，程序会变得更好。</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>抽取方法<br>同上</p>
</li>
<li><p>抽取类<br>同上</p>
</li>
<li><p>上移方法</p>
<blockquote>
<p>有些函数，在各个subclass 中产生完全相同的结果。将该函数移至superclass。</p>
</blockquote>
</li>
<li><p>构建模板方法</p>
<blockquote>
<p>继承是「避免重复行为」的一个强大工具。无论何时，只要你看见两个subclasses 之中有类似的函数，就可以把它们提升到superclass 。但是如果这些函数并不完全相同呢？此时的你应该怎么办？我们仍有必要尽量避免重复，但又必须保持这些函 数之间的实质差异。</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">rentals</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._rentals = rentals</span><br><span class="line">        <span class="built_in">this</span>._name = <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTotalCharge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTotalFrequentRenterPoints</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">statement</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> rentals = <span class="built_in">this</span>._rentals.elements();</span><br><span class="line">        <span class="keyword">let</span> result = <span class="string">&quot;Rental Record for &quot;</span> + getName() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (rentals.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">const</span> each = rentals.nextElement();</span><br><span class="line">            <span class="comment">//show figures for this rental</span></span><br><span class="line">            result += <span class="string">&quot;\t&quot;</span> + each.getMovie().getTitle() + <span class="string">&quot;\t&quot;</span> +</span><br><span class="line">                <span class="built_in">String</span>.valueOf(each.getCharge()) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//add footer lines</span></span><br><span class="line">        result += <span class="string">&quot;Amount owed is &quot;</span> + <span class="built_in">String</span>.valueOf(getTotalCharge()) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        result += <span class="string">&quot;You earned &quot;</span> + <span class="built_in">String</span>.valueOf(getTotalFrequentRenterPoints()) +</span><br><span class="line">            <span class="string">&quot; frequent renter points&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">htmlStatement</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> rentals = _rentals.elements();</span><br><span class="line">        <span class="keyword">let</span> result = <span class="string">&quot;&lt;H1&gt;Rentals for &lt;EM&gt;&quot;</span> + getName() + <span class="string">&quot;&lt;/EM&gt;&lt;/H1&gt;&lt;P&gt;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (rentals.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">const</span> each = rentals.nextElement();</span><br><span class="line">            <span class="comment">//show figures for each rental</span></span><br><span class="line">            result += each.getMovie().getTitle() + <span class="string">&quot;: &quot;</span> +</span><br><span class="line">                <span class="built_in">String</span>.valueOf(each.getCharge()) + <span class="string">&quot;&lt;BR&gt;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//add footer lines</span></span><br><span class="line">        result += <span class="string">&quot;&lt;P&gt;You owe &lt;EM&gt;&quot;</span> + <span class="built_in">String</span>.valueOf(getTotalCharge()) + <span class="string">&quot;&lt;/EM&gt;&lt;P&gt;\n&quot;</span>;</span><br><span class="line">        result += <span class="string">&quot;On this rental you earned &lt;EM&gt;&quot;</span> +</span><br><span class="line">            <span class="built_in">String</span>.valueOf(getTotalFrequentRenterPoints()) +</span><br><span class="line">            <span class="string">&quot;&lt;/EM&gt; frequent renter points&lt;P&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接口不同的相似类<blockquote>
<p>假设两个方法做同一件事，却有着不同的签名式。基本也是java的</p>
</blockquote>
</li>
</ol>
<ul>
<li>重命名方法</li>
<li>搬移方法</li>
</ul>
<h3 id="条件逻辑"><a href="#条件逻辑" class="headerlink" title="条件逻辑"></a>条件逻辑</h3><p><strong>Switch惊悚现身</strong></p>
<ul>
<li>将条件式替换为多态</li>
</ul>
<blockquote>
<p>它根据对象型别的不同而选择不同的行为。<br>将这个条件式的每个分支放进一个subclass 内的覆写函数中，然后将原始函数声明为抽象函数</p>
</blockquote>
<ul>
<li>将类型码替换为子类</li>
<li>将类型码替换为状态/策略</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ENGINEER = <span class="number">0</span></span><br><span class="line">        <span class="built_in">this</span>.SALESMAN = <span class="number">1</span></span><br><span class="line">        <span class="built_in">this</span>.MANAGER = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setType</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">payAmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">this</span>.ENGINEER: <span class="comment">// 工程师</span></span><br><span class="line">                <span class="keyword">return</span> _monthlySalary;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">this</span>.SALESMAN: <span class="comment">// 销售员</span></span><br><span class="line">                <span class="keyword">return</span> _monthlySalary + _commission;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">this</span>.MANAGER: <span class="comment">// 经理</span></span><br><span class="line">                <span class="keyword">return</span> _monthlySalary + _bonus;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Incorrect Employee&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">to</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">setType</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">        EmployeeType.newType(arg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">payAmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> EmployeeType.ENGINEER: <span class="comment">// 工程师</span></span><br><span class="line">                <span class="keyword">return</span> _monthlySalary;</span><br><span class="line">            <span class="keyword">case</span> EmployeeType.SALESMAN: <span class="comment">// 销售员</span></span><br><span class="line">                <span class="keyword">return</span> _monthlySalary + _commission;</span><br><span class="line">            <span class="keyword">case</span> EmployeeType.MANAGER: <span class="comment">// 经理</span></span><br><span class="line">                <span class="keyword">return</span> _monthlySalary + _bonus;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Incorrect Employee&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">EmployeeType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ENGINEER = <span class="number">0</span></span><br><span class="line">        <span class="built_in">this</span>.SALESMAN = <span class="number">1</span></span><br><span class="line">        <span class="built_in">this</span>.MANAGER = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTypeCode</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">newType</span>(<span class="params">code</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">this</span>.ENGINEER: <span class="comment">// 工程师</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Engineer();</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">this</span>.SALESMAN: <span class="comment">// 销售员</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Salesman();</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">this</span>.MANAGER: <span class="comment">// 经理</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Manager();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Incorrect Employee&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">EmployeeType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getTypeCode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.ENGINEER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">EmployeeType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getTypeCode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.MANAGER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salesman</span> <span class="keyword">extends</span> <span class="title">EmployeeType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getTypeCode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.SALESMAN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">to</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">setType</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">        EmployeeType.newType(arg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">payAmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._type.payAmount(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">EmployeeType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ENGINEER = <span class="number">0</span></span><br><span class="line">        <span class="built_in">this</span>.SALESMAN = <span class="number">1</span></span><br><span class="line">        <span class="built_in">this</span>.MANAGER = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTypeCode</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">newType</span>(<span class="params">code</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">this</span>.ENGINEER: <span class="comment">// 工程师</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Engineer();</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">this</span>.SALESMAN: <span class="comment">// 销售员</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Salesman();</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">this</span>.MANAGER: <span class="comment">// 经理</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Manager();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Incorrect Employee&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">payAmount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">EmployeeType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">payAmount</span>(<span class="params">emp</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> emp.getMonthlySalary();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTypeCode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.ENGINEER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">EmployeeType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">payAmount</span>(<span class="params">emp</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> emp.getMonthlySalary() + emp.getCommission();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTypeCode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.MANAGER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salesman</span> <span class="keyword">extends</span> <span class="title">EmployeeType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">payAmount</span>(<span class="params">emp</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> emp.getMonthlySalary() + emp.getBonus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getTypeCode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.SALESMAN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>将参数替换为显式方法</li>
<li>引入Null对象<blockquote>
<p>出现于条件语句 每一个条件都判断了是否为null</p>
</blockquote>
</li>
</ul>
<h2 id="类间味道"><a href="#类间味道" class="headerlink" title="类间味道"></a>类间味道</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><ol>
<li>基本类型困扰<blockquote>
<p>单独存在的数值不易于理解，也不符合面向对象的思想。大多数开发初期基础类型可以满足需求，后期深入发现需要扩展</p>
</blockquote>
</li>
</ol>
<p><strong>使数值尽量用类代替，就像java中的基本类型那样。</strong></p>
<ul>
<li>将数据值替换为对象</li>
<li>抽取类</li>
<li>引入参数对象</li>
<li>将数组替换为对象</li>
<li>将类型码替换为类</li>
<li>将类型码替换为子类</li>
<li>将类型码替换为状态/策略</li>
</ul>
<ol start="2">
<li>数据类<blockquote>
<p>所谓Data Class是指：它们拥有一些字段，以及用于訪问这些字段的方法，除此之外一无长物。</p>
</blockquote>
</li>
</ol>
<ul>
<li>搬移方法</li>
<li>封装字段</li>
<li>封装集合</li>
</ul>
<ol start="3">
<li>数据泥团<blockquote>
<p>多个类中重复出现的字段，或多个函数(方法)中相同的入参<br>重复参数多，影响阅读和理解。<br>减少相同的字段及入参，缩短入参列，简化函数调用</p>
</blockquote>
</li>
</ol>
<ul>
<li>抽取类</li>
<li>引入参数对象</li>
<li>保持对象完整</li>
</ul>
<ol start="4">
<li>临时字段<blockquote>
<p>有时你会看到这种对象：其内某个instance 变量仅为某种特定情势而设。这种代码让人不易理解，</p>
</blockquote>
</li>
</ol>
<ul>
<li>抽取类</li>
<li>引入Null对象</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol>
<li>拒收的遗赠<blockquote>
<p>继承某个类的子类，并不需要父类的某些方法，属性或不需要实现父类实现的接口</p>
</blockquote>
</li>
</ol>
<ul>
<li>将继承替换为委托</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">isAndroid</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">isIOS</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> <span class="keyword">extends</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">push</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">        insertElementAt(element, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = firstElement();</span><br><span class="line">        removeElementAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">to</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">isAndroid</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">isIOS</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._vector = <span class="keyword">new</span> Vector()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._vector.size()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">push</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">        insertElementAt(element, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = firstElement();</span><br><span class="line">        removeElementAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不当的紧密性<blockquote>
<p>继承（inheritance）往往造成过度亲密</p>
</blockquote>
</li>
</ol>
<ul>
<li>搬移方法</li>
<li>搬移字段</li>
<li>将双向关联改为单向</li>
<li>将继承替换成委托</li>
</ul>
<blockquote>
<p>除非先有Customer对象，否则不会存在Order对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123; <span class="comment">// 订单</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._customer = <span class="keyword">new</span> Customer() <span class="comment">//译注：这是Order-to-Customer link也是本例的移除对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getCustomer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._customer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setCustomer</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_customer != <span class="literal">null</span>) &#123;</span><br><span class="line">            _customer.friendOrders().remove(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _customer = arg;</span><br><span class="line">        <span class="keyword">if</span> (_customer != <span class="literal">null</span>) &#123;</span><br><span class="line">            _customer.friendOrders().add(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123; <span class="comment">// 顾客</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._orders = <span class="keyword">new</span> HashSet()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">addOrder</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">        arg.setCustomer(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">friendOrders</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._orders</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>隐藏委托</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; <span class="comment">// 人</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._department = <span class="keyword">new</span> Department()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getDepartment</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._department;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setDepartment</span>(<span class="params">arg</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._department = arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123; <span class="comment">// 部门</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._chargeCode = <span class="number">12</span></span><br><span class="line">        <span class="built_in">this</span>._manager = <span class="string">&#x27;_manager&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">Department</span>(<span class="params">manager</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getManager</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 经理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> john = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">manager = john.getDepartment().getManager();</span><br><span class="line"></span><br><span class="line">to </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">getManager</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._department.getManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果客户希望知道某人的经理是谁，他必须先取得Department对象</p>
</blockquote>
<ol start="3">
<li>懒惰类<blockquote>
<p>如 果一个class的所得不值其身价，它就应该消失。项目中经常会出现这样的情况： 某个class原本对得起自己的身价，但重构使它身形缩水，不再做那么多工作</p>
</blockquote>
</li>
</ol>
<ul>
<li>内联类<br>同上</li>
<li>折叠继承体系</li>
</ul>
<h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><ol>
<li>依恋情结<blockquote>
<p>某个函数为了实现其功能，经常从另一个类中获取大量数据。比起自身所在的类来说，更加依赖于另一个类,代码结构混乱，类分功不明确</p>
</blockquote>
</li>
</ol>
<ul>
<li>搬移方法</li>
<li>搬移字段</li>
<li>抽取方法</li>
</ul>
<ol start="2">
<li>过渡耦合的消息链</li>
</ol>
<blockquote>
<p>如果一个对象依赖另一个对象，另一个对象又依赖其他对象……<br>代码中调用链过长,代码耦合度高，造成代码扩展或修改困难</p>
</blockquote>
<ul>
<li>隐藏委托</li>
</ul>
<ol start="3">
<li>中间人<blockquote>
<p>类中的函数存在过度委托给其他对象的情况,委托函数过多时，减少委托，让调用者直接访问目标类进行操作</p>
</blockquote>
</li>
</ol>
<ul>
<li>移除中间人</li>
<li>内联方法</li>
<li>将委托替换为继承</li>
</ul>
<h3 id="协调变化"><a href="#协调变化" class="headerlink" title="协调变化"></a>协调变化</h3><ol>
<li>发散式改变<blockquote>
<p>由于代码的各种修改或扩展，每次都要修改某个类,<br>可扩展性差，某个类干的事过多。<br>针对某一外界变化的所有相应修改，都只发生在单一类中。这个类内的所有内容都应该反应此变化。</p>
</blockquote>
</li>
</ol>
<ul>
<li>抽取类</li>
</ul>
<ol start="2">
<li>霰弹式修改<blockquote>
<p>牵一发而动全身,每次遇到某种变化，都必须在不同的类中做出小修改,<br>代码散步各处，不利于扩展和阅读，增加代码修改难度及工作量,<br>尽量使某类变化通过某个特定类来处理，避免修改过多类。提升代码可扩展性，减少不必要的工作量。</p>
</blockquote>
</li>
</ol>
<ul>
<li>搬移方法</li>
<li>搬移字段</li>
<li>内联类</li>
</ul>
<ol start="3">
<li>并行继承体系<blockquote>
<p>每当为一个类增加子类时，必须也为另一个类相应增加子类。<br>让其中一个继承体系的实例引用另一个继承体系的实例，减少平行继承的类。</p>
</blockquote>
</li>
</ol>
<ul>
<li>搬移方法</li>
<li>搬移字段</li>
</ul>
<h3 id="库类"><a href="#库类" class="headerlink" title="库类"></a>库类</h3><p><strong>不完备的库类</strong></p>
<blockquote>
<p>封装好的类库中功能不能满足实际需求</p>
</blockquote>
<ol>
<li>引入外来方法</li>
<li>引入本地扩展</li>
</ol>
<p><a href="https://www.kancloud.cn/sstd521/refactor/194212"></a></p>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://www.jianshu.com/p/80eec4147835">https://www.jianshu.com/p/80eec4147835</a></li>
<li><input disabled="" type="checkbox"> <a href="https://my.oschina.net/jtzen9/blog/1546821">https://my.oschina.net/jtzen9/blog/1546821</a></li>
<li><input disabled="" type="checkbox"> <a href="https://blog.csdn.net/lovelion/article/details/9889095">https://blog.csdn.net/lovelion/article/details/9889095</a></li>
<li><input disabled="" type="checkbox"> <a href="https://blog.csdn.net/lovelion/article/details/9301691">https://blog.csdn.net/lovelion/article/details/9301691</a></li>
</ul>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于HTTP和HTTPS的26问</title>
    <url>/2021/03/25/%E5%85%B3%E4%BA%8EHTTP%E5%92%8CHTTPS%E7%9A%8426%E9%97%AE/</url>
    <content><![CDATA[<p>Web前端就是当用户在浏览器地址栏中输入一行字母看到的页面结果。然而，从输入字母到看到页面中都发生了什么，数据是怎么得到的？这些都离不开HTTP/HTTPS。</p>
<h3 id="HTTP与HTTPS有什么联系？它们的端口号是多少？"><a href="#HTTP与HTTPS有什么联系？它们的端口号是多少？" class="headerlink" title="HTTP与HTTPS有什么联系？它们的端口号是多少？"></a>HTTP与HTTPS有什么联系？它们的端口号是多少？</h3><p>HTTP通常承载于TCP之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。HTTP默认的端口号为80，Https默认的端口号为443。</p>
<h3 id="为什么-HTTPS更安全？"><a href="#为什么-HTTPS更安全？" class="headerlink" title="为什么 HTTPS更安全？"></a>为什么 HTTPS更安全？</h3><p>在网络请求中，需要有很多服务器、路由器的转发。其中的节点都可能篡改信息，而如果使用HTTPS，密钥在终点站才有。HTTPS之所以比HTTP安全，是因为它利用 SSL/TLS协议传输。它包含证书、卸载、流量转发、负载均衡、页面适配、浏览器适配、 refer传递等技术，保障了传输过程的安全性。</p>
<h3 id="关于HTTP-2你知道多少？"><a href="#关于HTTP-2你知道多少？" class="headerlink" title="关于HTTP/2你知道多少？"></a>关于HTTP/2你知道多少？</h3><p>HTTP/2引入了“服务器端推送”（server  push）的概念，它允许服务器端在客户端需要数据之前主动将数据发送到客户端缓存中，从而提高性能。<br>HTTP/2提供更多的加密支持。<br>HTTP2使用多路技术，允许多个消息在一个连接上同时交差。<br>它增加了头压缩（ header compression），因此请求非常小，请求和响应的 header都只会占用很小的带宽比例。</p>
<h3 id="说出你知道的HTTP常见状态码。"><a href="#说出你知道的HTTP常见状态码。" class="headerlink" title="说出你知道的HTTP常见状态码。"></a>说出你知道的HTTP常见状态码。</h3><p>（1）100 Continue表示继续，一般在发送post请求时，已发送了 HTTP header之后，服务器端将返回此信息，表示确认，之后发送具体参数信息。<br>（2）200 OK表示正常返回信息<br>（3）201 Created表示请求成功并且服务器创建了新的资源。<br>（4）202 Accepted表示服务器已接受请求，但尚未处理。<br>（5）301 Moved Permanently表示请求的网页已永久移动到新位置。<br>（6）302 Found表示临时性重定向。<br>（7）303 See Other表示临时性重定向，且总是使用GET请求新的URI。<br>（8）304 Not Modified表示自从上次请求后，请求的网页未修改过，<br>（9）400 Bad Request表示服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>（10）401 Unauthorized表示请求未授权。<br>（11）403 Forbidden表示禁止访问。<br>（12）404 Not Found表示找不到如何与URI相匹配的资源。<br>（13）500 Internal Server error表示最常见的服务器端错误。<br>（14）503 Service Unavailable表示服务器端暂时无法处理请求（可能是过载或维护）。</p>
<h3 id="完整的HTTP事务流程是怎样的？"><a href="#完整的HTTP事务流程是怎样的？" class="headerlink" title="完整的HTTP事务流程是怎样的？"></a>完整的HTTP事务流程是怎样的？</h3><p>基本流程如下。<br>（1）域名解析。<br>（2）发起TCP的3次握手。<br>（3）建立TCP连接后发起HTTP请求。<br>（4）服务器端响应HTTP请求，浏览器得到HTML代码。<br>（5）浏览器解析HTML代码，并请求HTML代码中的资源。<br>（6）浏览器对页面进行渲染并呈现给用户。</p>
<h3 id="实现一个简单的HTTP服务器。"><a href="#实现一个简单的HTTP服务器。" class="headerlink" title="实现一个简单的HTTP服务器。"></a>实现一个简单的HTTP服务器。</h3><p>在Node.js中加载HTTP模块，并创建服务器，监听端口代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  http = <span class="built_in">require</span>（<span class="string">&#x27;http&#x27;</span>）；<span class="comment">//加载HTTP模块</span></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>) </span>&#123; </span><br><span class="line">  res.writeHead(<span class="number">200</span>，&#123;<span class="string">&#x27; Content-Type&#x27;</span>：<span class="string">&#x27;text/htm1&#x27;</span>&#125;)；</span><br><span class="line">  <span class="comment">//200代表状态成功，文档类型是</span></span><br><span class="line">  <span class="comment">//给浏览器识别用的</span></span><br><span class="line">  res.write（<span class="string">&#x27;&lt; meta charset=&quot;UTF-8&quot;&gt;&lt;h1&gt;有课前端网&lt;/h1&gt;1&#x27;</span>）；</span><br><span class="line">  <span class="comment">//返回给客户端的HTML数据</span></span><br><span class="line">  res.end ()；</span><br><span class="line">  <span class="comment">//结束输出流</span></span><br><span class="line">&#125;)</span><br><span class="line">http.listen（<span class="number">3000</span>）；<span class="comment">//绑定3000</span></span><br></pre></td></tr></table></figure>
<h3 id="什么是HTTP？"><a href="#什么是HTTP？" class="headerlink" title="什么是HTTP？"></a>什么是HTTP？</h3><p>HTTP是客户端和服务器端之间数据传输的格式规范，表示“超文本传输协议”。</p>
<h3 id="什么是HTTP无状态协议？如何克服HTTP无状态协议的缺陷？"><a href="#什么是HTTP无状态协议？如何克服HTTP无状态协议的缺陷？" class="headerlink" title="什么是HTTP无状态协议？如何克服HTTP无状态协议的缺陷？"></a>什么是HTTP无状态协议？如何克服HTTP无状态协议的缺陷？</h3><p>（1）无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续需要处理，需要前面提供的信息。<br>（2）克服无状态协议缺陷的办法是通过 cookie和会话保存信息。</p>
<h3 id="HTTP的请求报文和响应报文包含哪些部分？"><a href="#HTTP的请求报文和响应报文包含哪些部分？" class="headerlink" title="HTTP的请求报文和响应报文包含哪些部分？"></a>HTTP的请求报文和响应报文包含哪些部分？</h3><p>请求报文包含3部分。<br>（1）请求行，包含请求方法、URI、HTTP版本信息。<br>（2）请求首部字段。<br>（3）请求内容实体。<br>响应报文包含3部分。<br>（1）状态行，包含HTTP版本、状态码、状态码的原因短语。<br>（2）响应首部字段。<br>（3）响应内容实体。</p>
<h3 id="HTTP中有哪些请求方式？"><a href="#HTTP中有哪些请求方式？" class="headerlink" title="HTTP中有哪些请求方式？"></a>HTTP中有哪些请求方式？</h3><p>（1）GET：请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL，给服务器传递参数数据<br>（2）POST：传输信息给服务器，主要功能与GET方法类似，但传递的数据量通常不受限制。<br>（3）PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置。<br>（4）HEAD：获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。<br>（5） DELETE：删除文件，与PUT方法相反，删除对应URL位置的文件。<br>（6）OPTIONS：查询相应URI支持的HTTP方法。</p>
<h3 id="HTTP协议中1-0版本规范与1-1版本规范的区别是什么？"><a href="#HTTP协议中1-0版本规范与1-1版本规范的区别是什么？" class="headerlink" title="HTTP协议中1.0版本规范与1.1版本规范的区别是什么？"></a>HTTP协议中1.0版本规范与1.1版本规范的区别是什么？</h3><p>在HTTP1.0中，当建立连接后，客户端发送一个请求，服务器端返回一个信息后就关闭连接，当浏览器下次请求的时候又要建立连接。显然，这种不断建立连接的方式会造成很多问题。<br>在HTTP1.1中，引入了持续连接的概念。通过这种连接，浏览器可以在建立一个连接之后，发送请求并得到返回信息，然后继续发送请求再次等到返回信息。也就是说，客户端可以连续发送多个请求，而不用等待每一个响应的到来。</p>
<h3 id="HTTP的首部字段包括哪些类型？"><a href="#HTTP的首部字段包括哪些类型？" class="headerlink" title="HTTP的首部字段包括哪些类型？"></a>HTTP的首部字段包括哪些类型？</h3><p>（1）通用首部字段（请求报文与响应报文都会使用的首部字段）。</p>
<blockquote>
<p>Date：创建报文的时间<br>Connection：连接的管理<br>Cache-Control：缓存的控制<br>Transfer-Encoding：报文主体的传输编码方式</p>
</blockquote>
<p>（2）请求首部字段（请求报文会使用的首部字段）。</p>
<blockquote>
<p>Host：请求资源所在服务器。<br>Accept：可处理的媒体类型。<br>Accept-Charset：可接受的字符集。<br>Accept-Encoding：可接受的内容编码。<br>Accept-Language：可接受的自然语言。</p>
</blockquote>
<p>（3）响应首部字段（响应报文会使用的首部字段）。</p>
<blockquote>
<p>Accept-Ranges：可接受的字节范围。<br>Location：令客户端重新定向到的URL。<br>Server : HTTP服务器的安装信息</p>
</blockquote>
<p>（4）实体首部字段（请求报文与响应报文的实体部分使用的首部字段）。</p>
<blockquote>
<p>Allow：资源可支持的HTTP方法。<br>Content-Type：实体主体的类型。<br>Content-Encoding：实体主体使用的编码方式。<br>Content-Language：实体主体的自然语言。<br>Content-Length：实体主体的字节数。<br>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用。</p>
</blockquote>
<h3 id="与HTTPS相比，HTTP有什么缺点？"><a href="#与HTTPS相比，HTTP有什么缺点？" class="headerlink" title="与HTTPS相比，HTTP有什么缺点？"></a>与HTTPS相比，HTTP有什么缺点？</h3><p>HTTP的缺点如下。<br>（1）通信使用明文，不加密，内容可能被窃听，也就是被抓包分析。<br>（2）不验证通信方身份，可能遭到伪装。<br>（3）无法验证报文完整性，可能被篡改。<br>HTTPS就是HTTP+加密处理（一般是SSL安全通信线路）+认证+完整性保护。</p>
<h3 id="如何优化HTTP请求？"><a href="#如何优化HTTP请求？" class="headerlink" title="如何优化HTTP请求？"></a>如何优化HTTP请求？</h3><p>利用负载均衡优化和加速HTTP应用请求；利用HTTP缓存来优化网站请求。</p>
<h3 id="HTTP协议有哪些特征？"><a href="#HTTP协议有哪些特征？" class="headerlink" title="HTTP协议有哪些特征？"></a>HTTP协议有哪些特征？</h3><p>支持客户端/服务器模式，简单快速，灵活，无连接，无状态。</p>
<h3 id="HTTP1-1版本的新特性有哪些？"><a href="#HTTP1-1版本的新特性有哪些？" class="headerlink" title="HTTP1.1版本的新特性有哪些？"></a>HTTP1.1版本的新特性有哪些？</h3><p>新特性如下所示。<br>（1）默认持久连接，节省通信量，只要客户端服务端中任意一端没有明确指出断开TCP连接，就一直保持连接，可以多次发送HTTP请求。<br>（2）管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应。<br>（3）断点续传原理。</p>
<h3 id="说说TCP传输的三次握手、四次挥手策略。"><a href="#说说TCP传输的三次握手、四次挥手策略。" class="headerlink" title="说说TCP传输的三次握手、四次挥手策略。"></a>说说TCP传输的三次握手、四次挥手策略。</h3><p>为了准确无误地把数据送达目标处，TCP采用了三次握手策略。用TCP把数据包发送出去后，TCP不会对传送后的数据置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志，即SYN和ACK。<br>发送端首先给接收端发送一个带SYN标志的数据包。接收端收到后，回传一个带有SYN/ACK标志的数据包以表示正确传达，并确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结東。若在握手过程中的某个阶段莫名中断，TCP会再次以相同的顺序发送相同的数据包。<br>断开一个TCP连接则需要“四次握手”。<br>第一次握手：主动关闭方发送一个FIN，用来关闭主动关闭方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方，主动关闭方已经不会再给被动关闭方发送数据了（当然，在FIN包之前发送出去的数据，如果没有收到对应的ACK确认报文主动关闭方依然会重发这些数据），但是，此时主动关闭方还可以接收数据。<br>第二次握手：被动关闭方收到FIN包后，给对方发送一个ACK，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。<br>第三次握手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，被动关闭方的数据也发送完了，不会再给主动关闭方发送数据了。<br>第四次握手：主动关闭方收到FIN后，给被动关闭方发送一个ACK，确认序号为收到序号+1，至此，完成四次握手。</p>
<h3 id="说说TCP和UDP的区别。"><a href="#说说TCP和UDP的区别。" class="headerlink" title="说说TCP和UDP的区别。"></a>说说TCP和UDP的区别。</h3><p>TCP（ Transmission control protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过3次“对话”才能建立起来。<br>UDP（ User Datagram Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。UDP适用于次只传送少量数据、对可靠性要求不高的应用环境。</p>
<h3 id="一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？</h3><p>整个过程可分为4个步骤。</p>
<ul>
<li>当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上毎个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。</li>
<li>浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCPP连接。该握手包括一个同步报文、一个同步-应答报文和一个应答报文，这3个报文在浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，然后服务器应答并接受客户端的请求，最后由客户端发出已经接受该请求的报文。</li>
<li>一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态码表示一个正确的响应</li>
<li>此时web服务器提供资源服务，客户端开始下载资源。请求返回后，便进入了浏览器端模块。浏览器会解析HTML生成 DOM Tree，其次会根据CSS生成CSS规则树，而 JavaScript又可以根据 DOM API操作DOM。<h3 id="网络分层模型有哪七层？"><a href="#网络分层模型有哪七层？" class="headerlink" title="网络分层模型有哪七层？"></a>网络分层模型有哪七层？</h3>七层分别是<blockquote>
<p>应用（ Application）层: 允许访问OSI环境的手段。<br>表示（ Presentation）层: 对数据进行翻译、加密和压缩。<br>会话（ Session）层: 建立、管理和终止会话。<br>传输（ Transport）层: 提供端到端的可靠报文传递和错误恢复。<br>网络（ Network）层: 负责数据包从源到宿的传递和网际互联。<br>数据链路（Link）层: 将比特组装成帧并实现点到点的传递。<br>物理（ Physical）层: 通过媒介传输比特，确定机械及电气规范。</p>
</blockquote>
</li>
</ul>
<h3 id="网络七层模型中，你所熟知的协议有哪些？"><a href="#网络七层模型中，你所熟知的协议有哪些？" class="headerlink" title="网络七层模型中，你所熟知的协议有哪些？"></a>网络七层模型中，你所熟知的协议有哪些？</h3><p>有以下几种协议。</p>
<ul>
<li><p>ICMP，即因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</p>
</li>
<li><p>TFTP，即TCPP协议族中一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p>
</li>
<li><p>HTTP，即超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷快速的方式，适用于分布式超媒体信息系统。</p>
</li>
<li><p>DHCP，即动态主机配置协议，是一种让系统得以连接到网络并获取所需要配置参数的手段。</p>
</li>
</ul>
<h3 id="304缓存的原理。"><a href="#304缓存的原理。" class="headerlink" title="304缓存的原理。"></a>304缓存的原理。</h3><p>服务器首先为请求生成ETag，服务器可在稍后的请求中，使用它来判断页面是否已经修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）是否缓存。<br>304是HTTP状态码，服务器用它来标识这个文件没有修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件。<br>客户端请求页面A。服务器返回页面A，并给A加上一个ETag。客户端展现该页面，并将页面连同ETag一起缓存。<br>客户端再次请求页面A，并将上次请求时服务器返回的ETag起传递给服务器。<br>服务器检查该ETag，并判断岀该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改一 Not modified）和一个空的响应体。</p>
<h3 id="什么是Etag？"><a href="#什么是Etag？" class="headerlink" title="什么是Etag？"></a>什么是Etag？</h3><p>当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期若没有过期，则不向服务器发送请求，直接使用缓存中的结果。<br>此时，我们在浏览器控制台中可以看到200 OK（ from cache），这种情况就是完全使用缓存，浏览器和服务器没有任何交互。<br>若已过期，则向服务器发送请求。此时，请求中会带上文件修改时间和Etag，然后进行资源更新判断。<br>服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是否被修改过。根据Etag，判断文件内容自上一次请求之后，有没有发生变化。<br>若两种判断的结论都是文件没有被修改过，服务器就不给浏览器发送新的内容，而是直接告诉浏览器，文件没有被修改过，可以继续使用缓存—-304 Not Modified。<br>此时，浏览器就会从本地缓存中获取请求资源的内容，这种情况叫协议缓存，浏览器和服务器之间有一次请求交互。<br>若修改时间或文件内容判断中有任意一个没有通过，则服务器会受理此次请求，并返回新的数据注意，只有get请求会被缓存，post请求不会。</p>
<h3 id="ETag的应用。"><a href="#ETag的应用。" class="headerlink" title="ETag的应用。"></a>ETag的应用。</h3><p>Etag由服务器端生成，客户端通过 If-Match或者If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用I-None-Match。请求一个文件的流程如下。<br>第一次请求时，客户端发起 Http Get请求，以获取一个文件，服务器处理请求，返回文件内容和请求头（包括Eag），并返回状态码200第二次请求时，客户端发起 Http Get请求，以获取一个文件。<br>注意，这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag服务器判断发送过来的Etag和计算出来的Etag是否匹配。<br>如果If-None-Match为 False，不返回200，返回304，客户端继续使用本地缓存。<br>如果服务器设置了 Cache-Control:max-age和 Expires，服务器端在完全匹配 If-Modified-Since和 If-None-Match后，即检查完修改时间和Etag之后，才能返回304。</p>
<h3 id="Expires和-Cache-Control的作用是什么？"><a href="#Expires和-Cache-Control的作用是什么？" class="headerlink" title="Expires和 Cache-Control的作用是什么？"></a>Expires和 Cache-Control的作用是什么？</h3><p>Expires要求客户端和服务器端的时间严格同步。HTTP1.1引入Cache-Control来克服 Expires头的限制。如果max-age和 Expires同时出现，则max-age有更高的优先级。<br>具体代码如下所示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cache-Control:no-cache, private, max-age=<span class="number">0</span></span><br><span class="line">ETag：<span class="string">&quot;8b4c-55f16e2e30000&quot;</span></span><br><span class="line">Expires:Thu, <span class="number">02</span> Dec <span class="number">2027</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">56</span> GMT</span><br><span class="line">Last-Modified:Wed, <span class="number">29</span> Nov <span class="number">2017</span> <span class="number">03</span>:<span class="number">39</span>:<span class="number">44</span> GMT</span><br></pre></td></tr></table></figure>
<h3 id="什么是反向代理？"><a href="#什么是反向代理？" class="headerlink" title="什么是反向代理？"></a>什么是反向代理？</h3><p>反向代理（ Reverse Proxy）是指通过代理服务器来接收互联网上的连接请求，然后将请求转发给内部网络上的服务器，并把从服务器上得到的结果返回给互联网上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
]]></content>
      <tags>
        <tag>Q&amp;A</tag>
      </tags>
  </entry>
  <entry>
    <title>前端应用对比</title>
    <url>/2020/08/31/%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h1 id="大前端应用对比"><a href="#大前端应用对比" class="headerlink" title="大前端应用对比"></a>大前端应用对比</h1><p>现今的前端应用实现方案已经不仅仅只有H5这种形式了，各端小程序、RN、Flutter等相继都在各自领域散发着不同的光芒。本文将各种方案做一个简单的整理，便于方案选型是使用，大概内容如下：</p>
<table>
<thead>
<tr>
<th>平台</th>
<th>优势</th>
<th>劣势</th>
<th>适用场景</th>
<th>难易程度</th>
</tr>
</thead>
<tbody><tr>
<td>H5</td>
<td>1.跨平台<br/>2.开发成本低<br/>3.维护迭代方便<br/>4.推广成本低</td>
<td>1.联网要求高<br/>2.性能不够理想<br/>3.调用硬件困难<br/>4.复杂交互性能低</td>
<td>1.需要跨平台能力<br/>2.展示内容丰富<br/>3.互动性没有特别高<br/>4.性价比要求高</td>
<td>简单</td>
</tr>
<tr>
<td>微信小程序</td>
<td>1.即用即走<br/>2.跨平台<br/>3.使用微信提供原生能力<br/>4.倚靠微信流量/微信生态赋能</td>
<td>1.留存问题<br/>2.受控于微信<br/>3.适用性：只能微信端使用</td>
<td>1.只在微信环境使用<br />2.使用系统硬件能力<br />3.使用微信赋能</td>
<td>中等</td>
</tr>
<tr>
<td>京东小程序</td>
<td>1.倚靠京东APP流量<br />2.京东APP赋能</td>
<td>1.只能在京东APP运行(京东系后续可能会支持)<br />2.兴起时间较短，不完全成熟</td>
<td>1.只在京东APP内使用<br/>2.需要京东APP赋能的场景</td>
<td>中等</td>
</tr>
<tr>
<td>ReactNative</td>
<td>1.用户体验更好<br/>2.布局简便<br/>3.拓展性较强(调用原生)<br/>4.原生能力支持(动画、收拾等)<br/></td>
<td>1.扩展性稍弱<br/>2.开发体验不好<br/>3.对开发人员要求较高</td>
<td>1.需要跨平台能力<br/>2.需要性能较好的情况</td>
<td>中等偏难</td>
</tr>
<tr>
<td>Flutter</td>
<td>1.性能好<br/>2.动画交互实现简单<br/>3.开发体验较好</td>
<td>1.只有UI跨平台<br/>2.开发思想需要转换<br/>3.组件、社区不够完善</td>
<td>1.需要跨平台能力<br/>2.追求高性能场景<br/>3.有一定研究能力</td>
<td>困难</td>
</tr>
<tr>
<td>原生</td>
<td>1.性能超好<br/>2.可以充分使用硬件能力<br/>3.再次访问成本低、速度快</td>
<td>1.不跨端<br/>2.维护复杂<br/>3.首次访问成本高</td>
<td>1.开发时间充足<br/>2.需要百分百硬件性能<br/>3.需要充分调用硬件能力</td>
<td>难</td>
</tr>
</tbody></table>
<p>用户体验<br>性能<br>开发难度<br>开发成本<br>社区</p>
<h2 id="H5应用"><a href="#H5应用" class="headerlink" title="H5应用"></a>H5应用</h2><h3 id="H5应用的优势"><a href="#H5应用的优势" class="headerlink" title="H5应用的优势"></a>H5应用的优势</h3><p>1、跨平台。支持设备范围广，可以跨平台，编写的代码可以同时在Android、IOS、Windows上运行<br>2、开发成本低、周期短。移动互联网是一个快鱼吃慢鱼的时代，谁对用户的需求满足的更快，谁的试错成本更低，谁就拥有巨大的优势。互联网产品大多免费、且有网络效应，后入者抢夺用户的难度非常大。使用原生开发，从招聘、开发、上线各个环节的效率都慢一倍以上，而且参与的人越多，沟通效率往往拖慢不止一倍<br>3、维护迭代方便。用户可以直接使用最新版本（自动更新，不需用户手动更新）。很多人有这样的体会，一个原生应用上线Appstore，突然有一个大bug，只好连夜加班修复，然后静静等待2周或更长时间的Apple审核，这2个星期被用户的涂抹淹死，市场上一片差评，用户大量流失。等新应用被审核上线了，用户已经卸载了。但是，HTML5没有这些问题，你可以实时更新，有问题立即响应<br>4、推广成本低。HTML5应用导流非常容易，超级App(如微信朋友圈)、搜索引擎、应用市场、浏览器，到处都是HTML5的流量入口</p>
<h3 id="H5应用的劣势"><a href="#H5应用的劣势" class="headerlink" title="H5应用的劣势"></a>H5应用的劣势</h3><p>1、对联网要求高，离线基本不能做任何操作。而且H5如果图片等资源多，会拖累加载速度，耗费网速，用户体验不是很好。<br>2、H5应用在APP反应速度较慢，页面切换流畅性较差，用户体验感较差。H5运行需要调用更多的系统资源，造成H5的使用体验有一定影响<br>3、体验和性能上有很大的局限性，由于调用手机硬件（摄像头、麦克风等）困难，难以实现更多场景的需求。本身H5的技术还有着不完善，不完美的用户体验也很容易打击用户，造成留存不高，转化不高的情景。<br>4、多图处理和复杂交互动画性能不高，对硬件要求较高。复杂场景手机运行慢，手机内存饱和运行速度慢或者网速不给力，加载H5时候就会变慢</p>
<h3 id="适用的场景"><a href="#适用的场景" class="headerlink" title="适用的场景"></a>适用的场景</h3><p>1、需要跨平台能力：既可以在APP中使用，也可以到其他浏览器(微信/浏览器)环境使用的场景<br>2、展示内容丰富：适合展示有大段文字（如新闻、攻略等），且格式比较丰富（如加粗，字体多样）的页面<br>3、适合用户互动性没有特别高，视觉效果比较好的场景。可以提高流量转化，加快获客的效率和速度<br>4、性价比要求较高的场景：H5制作成本低，传播成本低，维护成本低，总体上而言，性价比非常高</p>
<p>难易程度：简单</p>
<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><h3 id="微信小程序优势"><a href="#微信小程序优势" class="headerlink" title="微信小程序优势"></a>微信小程序优势</h3><p>1、即用即走。——这个是从微信小程序上线就开始打的概念。即用即走使得小程序可以代替许多APP，或是做APP的整体嫁接，或是作为阉割版功能的承载体<br>2、倚靠微信流量。——相比APP，小程序一个突出的优点是完全嵌入了微信的聊天、公众号体系，完美进行微信体系内的流量引导。这一方面令小程序更加容易获客，另一方面也可以借助微信的成熟社交网络达到爆发式传播<br>3、连接线上线下。——连接线上线下场景也是微信小程序重要的一环，甚至最先开始为了推动线下习惯的养成，小程序在线上场景方面做了较强的限制。由于人们用微信扫描二维码的习惯培养得比较好，小程序相比APP更容易达成线上线下场景的连接与互动<br>4、使用微信原生提供的能力(需要用户授权)。微信提供了很多APP原生才有的能力，比如蓝牙/NFC等在小程序上使用便捷<br>5、微信赋能。包括微信为小程序提供的广告、直播流等API，相当于为传统的开发提供了一条高速路，使得开发这些能力有更简单的操作方式。还有微信体系能力的使用，包括登录、支付使用也是非常便捷</p>
<h3 id="微信小程序的劣势"><a href="#微信小程序的劣势" class="headerlink" title="微信小程序的劣势"></a>微信小程序的劣势</h3><p>1、留存问题。——虽然有部分小程序已经杀出重围，但是普遍来讲，主打“即用即走”的小程序在用户留存上仍存在很大的提升空间。阿拉丁发布的小程序白皮书中显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%。轻易拥有的也不在意失去，这大概是小程序目前的一个症结所在<br>2、受控于微信。——比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控，部分敏感内容还很容易遭受封禁威胁<br>3、适用性(原生)。–原生开发的微信小程序只能使用在微信客户端，无法在其他浏览器等环境运行</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>1、只在微信环境使用，微信小程序无法在其他环境运行<br>2、需要调用系统硬件能力，如摄像头、蓝牙、NFC等<br>3、需要使用微信赋能能力，如微信支付、微信登录、微信广告支持等</p>
<p>难易程度：中等</p>
<h2 id="京东小程序"><a href="#京东小程序" class="headerlink" title="京东小程序"></a>京东小程序</h2><p>京东小程序基本能力与微信小程序类似。赋能部分是京东APP对其进行赋能，可以便捷的使用京东体系能力、</p>
<h3 id="京东小程序优势"><a href="#京东小程序优势" class="headerlink" title="京东小程序优势"></a>京东小程序优势</h3><p>1、依靠京东APP流量：京东APP内入口，提供京东流量之上的用户量<br>2、京东APP赋能：便捷的使用京东APP提供的能力，包括京东登录、京东支付、手机号授权、位置信息等</p>
<h3 id="京东小程序劣势"><a href="#京东小程序劣势" class="headerlink" title="京东小程序劣势"></a>京东小程序劣势</h3><p>1、只能在京东APP内运行<br>2、京东小程序兴起时间不长，具体用户体验还需要更多的时间来证明</p>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>1、只需要在京东APP内部使用<br>2、需要京东APP赋能的能力：比如使用用户信息、唤起原生支付、调用扫码功能等</p>
<p>难易程度：中等</p>
<h2 id="ReactNative"><a href="#ReactNative" class="headerlink" title="ReactNative"></a>ReactNative</h2><h3 id="RN的优势"><a href="#RN的优势" class="headerlink" title="RN的优势"></a>RN的优势</h3><p>1、用户体验高于HTML，RN不用Webview，彻底摆脱了Webview让人不爽的交互和性能问题。虽然不能做到一处编码到处运行，但是基本上即使是两套代码，也是相同的jsx语法，使用js进行开发。用户体验，高于html，开发效率较高<br>2、全局采用flexbox布局。据说比native的自适应布局更加简单高效<br>3、有较强的扩展性。这是因为Native端提供的是基本控件，JS可以自由组合使用<br>4、可以直接使用Native原生的动画，例如iOS右滑返回等。用H5实现有很多问题<br>5、支持热更新。可以通过更新远端JS，直接更新app</p>
<h3 id="RN的劣势"><a href="#RN的劣势" class="headerlink" title="RN的劣势"></a>RN的劣势</h3><ol>
<li>扩展性不如H5，H5开发的应用有更强的拓展性。H5沉淀许久，各种拓展能力都比较强，且RN的拓展性同样不用原生写的拓展能力强</li>
<li>从Native到Web，要做很多概念转换，势必造成双方都要妥协。比如web要用一套CSS的阉割版，Native通过css-layout拿到最终样式再转换成native原生的表达方式（比如iOS的Constraint\origin\Center等属性），再比如动画。另外，若Android和iOS都要做相同的封装，概念转换就更复杂了。<br>1、对开发人员要求较高。不是懂点web技术就行的，当官方封装的控件、api无法满足需求时 就必然需要懂一些native的东西去扩展，扩展性仍然远远不如web，也远远不如直接写Native code<br>3、发展还不成熟，目前很多ui组件只有ios的实现，android的需要自己实现。从Native到Web，要做很多概念转换，势必造成双方都要妥协。比如web要用一套CSS的阉割版，Native通过css-layout拿到最终样式再转换成native原生的表达方式（比如iOS的Constraint\origin\Center等属性），再比如动画。另外，若Android和iOS都要做相同的封装，概念转换就更复杂 </li>
</ol>
<h3 id="RN的适用场景"><a href="#RN的适用场景" class="headerlink" title="RN的适用场景"></a>RN的适用场景</h3><p>难易程度：中等偏难</p>
<p>用过 React 会知道，React 的核心概念是「DOM Representation」，在开发者和 DOM 中间构建一个中间件，然后通过高效的算法来 diff 两次 Virtual DOM 渲染的差异，然后在最小范围内更新 DOM，在大部分情况下——注意是大部分不是所有——这种做法都是足够高效的，但是对于精细的需求、动画控制等——比如在移动设备上做一个跟随 touchmove 的元素，还要各种 transition 等等——场景 React 会显得力不从心，或者很笨拙。<br>但是抛开这些太过复杂的需求，React 是有能力满足大部分的业务场景的。再说 React Native，这几天不停看见媒体用「Web 开发要 XXX」一类的题目来发稿，真是吐槽无力。<br>React Native 根本都不算 Web 开发好不好——Webview 都没了还 Web 个 bird 啊…<br>React Native 继承了 React 在 JavaScript 的扩展语法 JSX 中直接以声明式的方式来描述 UI 结构的机制，并实现了一个 CSS 的子集，这把「DOM Representation」的概念外扩成了「UI Representation」，由于不是操作真实 UI，就可以放到非 UI 线程来进行 render——所有做客户端 UI 开发的都应该知道 UI 线程是永远的痛，无论你怎么 render，render 的多低效，这些 render 都不会直接影响 UI，而要借由 React Native 来将改变更新回 UI 线程。<br>由于目前没有任何示例代码，也看不到更细节的实现机制介绍，所以以下部分为猜测。如果 React Native 沿袭 React 的机制，就会同样是把两次 render 的 diff 结果算出来，然后把 diff 结果传递回主线程，在最小范围内更新 UI。<br>所以，核心是以下三点：</p>
<ol>
<li>在非 UI 线程渲染 UI Representation</li>
<li>高效的 diff 算法保证 UI update 的高效</li>
<li>没错，由于中间件的机制，React 很有可能成为一个跨平台的统一 UI 解决方案，可以理解为 UI 开发的虚拟机？声明式 UI 开发，简单快捷，必然大有作为。精细控制无力，复杂应用场景无法很好满足，必然受限。最后再说一句…不是能写 JavaScript 就叫 Web 开发…</li>
</ol>
<h2 id="flutter"><a href="#flutter" class="headerlink" title="flutter"></a>flutter</h2><h3 id="flutter的优势"><a href="#flutter的优势" class="headerlink" title="flutter的优势"></a>flutter的优势</h3><p>1、优势就是性能好使用流畅，跨平台：Flutter对比weex和react native相比，性能的强大是有目共睹的。基于dom树渲染原生组件，很难与直接在原生视图上绘图比肩性能，Google作为一个轮子大厂，直接在两个平台上重写了各自的UIKit，对接到平台底层，减少UI层的多层转换，UI性能可以比肩原生，这个优势在滑动和播放动画时尤为明显。<br>2、优秀的动画设计：Flutter的动画简单到不可思议，动画对象会根据屏幕刷新率每秒产生很多个（一般是60个）浮点数，只需要将一个组件属性通过补间（Tween）关联到动画对象上，Flutter会确保在每一帧渲染正确的组件，从而形成连贯的动画。这种十分暴力的操作在Flutter上却看不到明显的卡顿，这也是Flutter的一个魔力所在。相比之下其他跨平台框架几乎不能设计动画……往往会遭遇非常严重的性能问题。</p>
<p>对于开发来说<br>1、路由设计优秀：Flutter的路由传值非常方便，push一个路由，会返回一个Future对象（也就是Promise对象），使用await或者.then就可以在目标路由pop，回到当前页面时收到返回值。这个反向传值的设计基本是甩了微信小程序一条街了。弹出dialog等一些操作也是使用的路由方法，几乎不用担心出现传值困难<br>单例模式：Flutter支持单例模式，单例模式的实现也非常简单。单例模式很好的解决了一些问题。相比之下，js的单例则并不是一个真正的单例，或者说不是一个简单的单例，这也是受限于js所运行的环境。单例模式并不总是合理的，容易被滥用。但是在App的初期开发中，往往一个容易实现的单例可以帮助我们快速完成一些逻辑的搭建。<br>2、UI跨平台稳定：Google直接在两个平台上在底层重写了UIKit，不依赖于Css等外部解释器，几乎不存在UI表达不理想，渲染不正常的情况，可以获得非常稳定的UI表达效果。Css换个浏览器就有不同的表现，基于Css的跨平台框架很难获得稳定的UI表现。<br>3、可选静态的语言，语言特性优秀：Dart是一个静态语言，这也是相对于js的一个优势。Dart可以被编译成js，但是看起来更像java。静态语言可以避免错误，获得更多的编辑器提示词，极大的增加可维护性。很多js库也已经用ts重写了，Vue3.0的底层也将全部使用ts编写，静态语言的优势不言而喻。</p>
<h3 id="Flutter的劣势"><a href="#Flutter的劣势" class="headerlink" title="Flutter的劣势"></a>Flutter的劣势</h3><p>1、假装跨平台，躲不开原生代码：这是最大的问题，跨平台框架说白了就是UI跨平台，最后还是在原生平台运行，本来两个平台就有天壤之别，一套代码就想吃掉iOS和Android在实际应用之中其实根本就不现实。Flutter具有与原生代码互相调用的能力固然非常科学，但是问题反而显得更加明显——我一个前端工程师上哪里去知道什么是UIViewController，什么是Activity呢？我要是双端都熟悉，学习Flutter就显得很没有必要。这是一个很矛盾的点，如果有原生开发者，那就没必要搞Flutter了<br>2、组合而不是继承的思路：Flutter提倡“组合”，而不是“继承”。在传统的前端开发以及面向对象开发的思想中，基本上都是使用继承的思路进行工作的<br>3、Widget的类型难以选择：Flutter中属性都是final的，例如你继承了了一个Container，你是不能在它的生命周期中修改他的属性的。你始终需要嵌套组合几种Widget，例如Row，Container，ListView等Widget。这种方法非常不符合直觉，初学时很难想明白如何构建一个完整的组件。<br>4、糟糕的UI控件API：虽然google尽可能的让我们通过构造函数定制化Widget，但是也难免有遗漏的<br>5、使用Dart语言开发，有一定的学习成本<br>6、周边社区不够丰富。flutter作为19年火起来的新贵，社区资源、组件都都在进一步扩展当中，相对H5/RN来说，拓展资源相差还比较大</p>
<h3 id="适用的场景-1"><a href="#适用的场景-1" class="headerlink" title="适用的场景"></a>适用的场景</h3><p>1、需要跨平台能力：flutter平台一致性较强，一套代码可以运行在安卓/iOS两端，且还可以打包成H5运行在浏览器端<br>2、追求高性能场景：flutter的Skia框架绘制能力较强，性能相对于RN通过桥接方式调用原生组件有较大的提升<br>3、有一定的研究能力：因为现阶段的flutter应用并没有特别广泛，遇到问题时可能需要更多的精力来处理</p>
<p>难易程度：难</p>
<h2 id="原生开发"><a href="#原生开发" class="headerlink" title="原生开发"></a>原生开发</h2><h3 id="原生开发的优势"><a href="#原生开发的优势" class="headerlink" title="原生开发的优势"></a>原生开发的优势</h3><p>1、性能超好：不用运行额外的渲染框架、引擎等。对手机性能要求更低，运行性能更加流畅<br>2、硬件完全使用能力：原生APP是一个系统性的应用程序，可以类比于电脑上的软件。原生app可以调用移动终端的硬件设备， 比如：麦克风、摄像头、短信、GPS、蓝牙、重力感应等。实现功能丰富<br>3、再次访问成本低：原生的应用程序独立安装，可以访问本地资源、缓存，所以原生开发的APP可以节约宽带成本<br>4、再次访问速度快：原生APP由“云服务器数据+APP应用客户端”两部分构成，APP应用所有的UI元素、数据内容、逻辑框架均安装在手机终端上。访问的时候，不需要重新下载加载应用页面框架，只需要加载数据即可。所以加载速度更快，页面响应更快</p>
<h3 id="原生开发的劣势"><a href="#原生开发的劣势" class="headerlink" title="原生开发的劣势"></a>原生开发的劣势</h3><p>1、无法跨端使用： 每一种移动操作系统都需要独立的开发项目，iphone版本、Ipad版本、安卓版本。每种平台都需要独立的开发语言。需要使用各自的软件开发包，开发工具以及各自的控件。开发成本高、开发速度慢、维护成本高。三个平台（IOS、安卓、windows）的规则、推广、运营都不相同。官方应用商店对APP上线审核流程比较复杂而且很慢，会严重影响APP的发布上线。<br>2、需要维护不同版本：由于不同操作系统版本API等更改，需要维护不同的APP版本<br>3、首次访问成本高：需要下载APP访问，首次访问成本较高</p>
<h3 id="原生开发适用场景"><a href="#原生开发适用场景" class="headerlink" title="原生开发适用场景"></a>原生开发适用场景</h3><p>1、开发时间充分<br>2、需要百分百硬件性能<br>3、需要充分调用硬件能力</p>
<p>难易程度: 难</p>
<h2 id="引用文档"><a href="#引用文档" class="headerlink" title="引用文档"></a>引用文档</h2><ul>
<li><a href="https://segmentfault.com/a/1190000017164263">浅谈flutter的优点与缺点</a></li>
<li><a href="https://www.zhihu.com/question/263816362">微信小程序的优缺点是什么</a></li>
</ul>
]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>FE</tag>
      </tags>
  </entry>
  <entry>
    <title>前端异常处理</title>
    <url>/2021/01/28/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么要处理前端异常，有以下几方面的原因：</p>
<ol>
<li>提高代码健壮性：对于开发人员来说，这点很重要，代码的健壮性越好，系统越不容易崩溃；</li>
<li>提升系统稳定性：异常会导致正常流程无法进行、页面样式错乱、崩溃甚至白屏等问题，严重的会给业务造成损失；</li>
<li>增强用户体验：代码的错误不应该影响页面的正常显示和用户交互，出错时我们需要使用拖底方案或者给用户反馈；</li>
<li>便于定位问题：只有知道了如何处理异常，我们才能将异常正常上报给前端监控系统，及时发现并定位问题。</li>
</ol>
<p>本文分为以下三个部分：<br>第一部分：介绍 Error 对象及 Error 的类型；<br>第二部分：介绍捕获异常的方式有哪些，包含通用、Vue和React项目、iframe中的捕获以及页面崩溃异常的获取；<br>第三部分：结合工作中的场景，总结各自对应的异常处理方式。</p>
<p>这篇文章的前两部分我尽量都提供了对应的示例，希望这些示例对你们有用。另外，由于这篇文章是做汇总用的，会比较长，各位可以按自己的需要去看对应的部分。</p>
<h1 id="Error-及-Error-类型"><a href="#Error-及-Error-类型" class="headerlink" title="Error 及 Error 类型"></a>Error 及 Error 类型</h1><p>说到异常，我们需要先从 Error 对象讲起。当 JavaScript 运行时，如果发生了错误，浏览器就会抛出 Error 的实例对象。</p>
<h2 id="Error-对象"><a href="#Error-对象" class="headerlink" title="Error 对象"></a>Error 对象</h2><p>Error 是 JavaScript 中的错误类，它同时也是一个构造函数，可以用来创建一个错误对象。创建Error 实例对象的方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Error</span>([message[, fileName[,lineNumber]]]);</span><br></pre></td></tr></table></figure>

<p>此外，Error 可以像函数一样使用，如果没有 new，它将返回一个 Error 实例对象。所以， 仅仅调用 Error 产生的结果与通过 new 关键字构造 Error 实例对象生成的结果相同。</p>
<h2 id="Error类型"><a href="#Error类型" class="headerlink" title="Error类型"></a>Error类型</h2><p>参照<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">MDN的文档</a>, 还有以下错误类型都继承自 Error 对象：</p>
<ul>
<li>SyntaxError</li>
<li>RangeError</li>
<li>ReferenceError</li>
<li>TypeError</li>
<li>URIError</li>
<li>EvalError</li>
<li>InternalError</li>
<li>AggregateError</li>
</ul>
<p>接下来我将按顺序介绍上述错误类型的含义，并尽量举出对应的例子。</p>
<ol>
<li>SyntaxError</li>
</ol>
<p>SyntaxError 是代码不符合 Javascript 语法规范产生的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量名错误</span></span><br><span class="line"><span class="keyword">let</span> 1name <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺少括号</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;test&#x27;</span> <span class="comment">// Uncaught SyntaxError: missing ) after argument list</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串没有加引号</span></span><br><span class="line">a string <span class="comment">// Uncaught SyntaxError: Unexpected identifier</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>RangeError</li>
</ol>
<p>RangeError 是当一个值不在允许的范围或者集合中时的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传递一个不合法的length值作为Array构造器的参数创建数组</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(-<span class="number">1</span>) <span class="comment">// Uncaught RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递错误值到数值计算方法</span></span><br><span class="line"><span class="keyword">var</span> number = <span class="number">10</span></span><br><span class="line">number.toFixed(-<span class="number">1</span>) <span class="comment">// Uncaught RangeError: toFixed() digits argument must be between 0 and 100</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ReferenceError</li>
</ol>
<p>ReferenceError 是引用一个不存在的变量或者给不能赋值的对象赋值时发生的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量名未定义</span></span><br><span class="line">undefinedVariable <span class="comment">// Uncaught ReferenceError: unknowName is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法名未定义</span></span><br><span class="line">undefinedFunction() <span class="comment">// Uncaught ReferenceError: undefinedFunction is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等号左侧不能赋值 //todo: 为啥</span></span><br><span class="line"><span class="built_in">console</span>.log() = <span class="number">1</span> <span class="comment">// Uncaught SyntaxError: Invalid left-hand side in assignment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等号左侧不能赋值 //todo: 为啥</span></span><br><span class="line"><span class="keyword">if</span>(a === <span class="number">1</span> || b = <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a === 1 || b = 2&#x27;</span>)</span><br><span class="line">&#125; <span class="comment">// Invalid left-hand side in assignment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this对象不能手动赋值</span></span><br><span class="line"><span class="built_in">this</span> = <span class="number">1</span> <span class="comment">// Uncaught SyntaxError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>TypeError</li>
</ol>
<p>TypeError 是变量或参数的类型不是预期类型时发生的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new命令的参数不是构造函数</span></span><br><span class="line"><span class="keyword">new</span> <span class="number">123</span> <span class="comment">// Uncaught TypeError: 123 is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的方法不是function</span></span><br><span class="line"><span class="keyword">let</span> functionName = <span class="string">&#x27;functionName&#x27;</span></span><br><span class="line">functionName() <span class="comment">// Uncaught TypeError: functionName is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined或null没有对应的属性或方法</span></span><br><span class="line"><span class="literal">undefined</span>.value <span class="comment">// Uncaught TypeError: Cannot read property &#x27;value&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>URIError</li>
</ol>
<p>URIError 是 URI 相关函数的参数不正确时抛出的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">decodeURI</span>(<span class="string">&#x27;%&#x27;</span>) <span class="comment">// Uncaught URIError: URI malformed</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>EvalError</li>
</ol>
<p>EvalError 表示 eval 函数没有被正确执行时发生的错误。需要注意的是此异常不再会被JavaScript 抛出，但是 EvalError 对象仍然保持兼容性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有报EvalError而是对应执行js时的SyntaxError</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;a string&#x27;</span>) <span class="comment">// Uncaught SyntaxError: Unexpected identifier</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>永远不要使用 eval！<br>eval() 是一个危险的函数， 它使用与调用者相同的权限执行代码。如果你用 eval() 运行的字符串代码被恶意方（不怀好意的人）修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。<br>eval() 通常比其他替代方法更慢，因为它必须调用 JS 解释器，而许多其他结构则可被现代 JS 引擎进行优化。</p>
</blockquote>
<ol start="7">
<li>InternalError</li>
</ol>
<p>InternalError 表示出现在 JavaScript 引擎内部的错误。</p>
<blockquote>
<p>示例场景通常为某些成分过大，例如：</p>
<ul>
<li>“too many switch cases”（过多case子句）；</li>
<li>“too many parentheses in regular expression”（正则表达式中括号过多）；</li>
<li>“array initializer too large”（数组初始化器过大）；</li>
<li>“too much recursion”（递归过深）。</li>
</ul>
</blockquote>
<ol start="8">
<li>AggregateError</li>
</ol>
<p>AggregateError 是用于把多个错误集合在一起。需要注意的是这是一个实验中的功能，尚未被所有的浏览器支持（下面例子中用到的 Promise.any 也是实验中的功能）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;some error&quot;</span>))</span><br><span class="line">]) <span class="comment">// Uncaught (in promise) AggregateError: All promises were rejected</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.any() 接收一个 Promise 可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise 和 AggregateError 类型的实例。</p>
</blockquote>
<p>我们还可以基于 Error 自定义异常类型，或者用 throw 方法抛出任意类型的异常，但我们本文的目标在于捕获并处理浏览器抛出的异常，这里对自定义的异常和手动 throw 的异常不做过多说明。</p>
<h1 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h1><p>在了解了浏览器会抛出哪些异常后，我们现在来进一步了解在代码层面我们可以做些什么来捕获这些异常，从而协助我们提升代码的健壮性。</p>
<h2 id="通用方式"><a href="#通用方式" class="headerlink" title="通用方式"></a>通用方式</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><p>try-catch 语句标记要尝试的语句块，并指定一个出现异常时抛出的响应。try 语句包含了由一个或者多个语句组成的 try 块，catch 子句包含 try 块中抛出异常时要执行的语句。如果在 try 块中有任何一个语句（或者从 try 块中调用的函数）抛出异常，控制立即转向 catch 子句。如果在 try 块中没有异常抛出，会跳过 catch 子句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(person.info.name);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined at &lt;anonymous&gt;:3:27</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们试图获取一个 undefined 对象的属性值，这个异常被 catch 捕获并输出在控制台。</p>
<blockquote>
<p>任何给定的异常只会被离它最近的封闭 catch 块捕获一次。</p>
</blockquote>
<p>有时候，我们代码中也会出现 try-catch 嵌套的情况，如果内层没有 catch 事件，则会被外层 catch 捕获：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;finally&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;outer&#x27;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// finally</span></span><br><span class="line"><span class="comment">// VM1360:10 outer Error: error at &lt;anonymous&gt;:3:11</span></span><br></pre></td></tr></table></figure>

<p>如果在内层抛出新异常，这个新异常会被外层 catch 捕获：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;inner&#x27;</span>, err);</span><br><span class="line">    <span class="keyword">throw</span> err; <span class="comment">// 抛出新异常，没有被内层捕获过</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;outer&#x27;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inner Error: error at &lt;anonymous&gt;:3:11</span></span><br><span class="line"><span class="comment">// outer Error: error at &lt;anonymous&gt;:3:11</span></span><br></pre></td></tr></table></figure>

<p>try-catch 适用于知道某段代码可能出现问题的情况，只能捕获同步的运行时错误，不能捕获语法错误和异步错误：</p>
<ol>
<li>语法错误：语法错误，try-catch 没有正确执行。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> 1a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(1a);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch syntax error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. 异步错误：因为异步事件已经放入异步事件队列中，无法捕捉到。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> js</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch async error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Uncaught ReferenceError: a is not defined at &lt;anonymous&gt;:3:17</span></span><br></pre></td></tr></table></figure>

<h3 id="GlobalEventHandlers-onerror"><a href="#GlobalEventHandlers-onerror" class="headerlink" title="GlobalEventHandlers.onerror"></a>GlobalEventHandlers.onerror</h3><p>从 GlobalEventHandlers.onerror 字面本身就可以看出，这个 onerror 用于处理全局的错误。我们先来看下 MDN 上对它的解释：</p>
<p>混合事件 GlobalEventHandlers 的 onerror 属性用于处理 error 的事件。</p>
<ul>
<li>当 JavaScript 运行时错误（包括语法错误）发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。</li>
<li>当一项资源（图片或 JavaScript文件）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些 error 事件不会向上冒泡到 window，不过（至少在 Firefox 中）能被单一的 window.addEventListener 捕获。  </li>
</ul>
<p>从上面的文字，我们可以得出以下的结论：</p>
<ol>
<li>代码发生运行时错误（包括语法错误）时，会触发 window 的 error 事件，我们可以通 window.onerror 和 window.addEventListener(‘error’, function(event) { … })来捕获；</li>
<li>静态资源加载失败时，会触发加载资源的元素上的 onerror 事件，由于该事件不会冒泡到 winow，因此 window.onerror 是不会捕获到静态资源加载失败的错误的；</li>
<li>如果要使用全局方法捕获静态资源加载失败的错误，可以使用 window.addEventListener。</li>
</ol>
<p>我们还是来通过具体的例子来验证一下，先定义下 window.onerror 和 window.addEventListener 这两个方法（需要写在所有 JavaScript 脚本的前面，否则有可能捕获不到错误）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;window.onerror catch error:&#x27;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;window.addEventListener catch error:&#x27;</span>, event.message)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>语法错误</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 1a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(1a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// window.onerror catch error: Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="comment">// window.addEventListener catch error: Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>静态资源加载错误</li>
</ol>
<p>要捕获静态资源加载失败的错误，我们可以在静态资源上添加 onerror 事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://misc.360buyimg.com/jdf/lib/jquery-1.6.4.000.js&quot;</span> onerror=<span class="string">&quot;console.log(&#x27;script load onerror&#x27;)&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// script load onerror</span></span><br></pre></td></tr></table></figure>

<p>如果要全局捕获静态资源加载的错误，需要给 addEventListener 方法增加第三个参数，即设置useCapture 为 ture：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;window.addEventListener catch error:&#x27;</span>, event.message)</span><br><span class="line">&#125;, <span class="literal">true</span>); </span><br></pre></td></tr></table></figure>

<p>加载一个错误的JavaSctipt文件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://misc.360buyimg.com/jdf/lib/jquery-1.6.4.000.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// window.addEventListener catch error: &lt;script src=​&quot;https:​/​/​misc.360buyimg.com/​jdf/​lib/​jquery-1.6.4.000.js&quot;&gt;​&lt;/script&gt;​</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>异步错误</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// window.onerror catch error: Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">// window.addEventListener catch error: Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出，GlobalEventHandlers.onerror 适用于需要捕获全局的异常的情况。另外，同 try-catch 相比，window.onerror 和 window.addEventListener 可以捕获语法错误和异步错误，element.onerror 和 window.addEventListener 可以捕获静态资源加载失败的错误。</p>
<p>尽管 window.onerror 和 window.addEventListener 可以处理异步错误，但是对于 Promise 的异步错误，是捕获不到的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="promise-catch"><a href="#promise-catch" class="headerlink" title="promise-catch"></a>promise-catch</h3><p>Promise 的错误需要使用 promise-catch 来捕获，这些错误可以是代码运行时的错误，也可以是我们处理业务逻辑时 reject 的错误。</p>
<ol>
<li>代码错误</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise catch error:&#x27;</span>, err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise catch error: a is not defined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>reject的错误</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error rejected!&#x27;</span>))</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise catch error:&#x27;</span>, err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise catch error: error rejected!</span></span><br></pre></td></tr></table></figure>

<p>promise-catch 的适用范围很明确，就是处理 Promise 的异常。但是这里有例外，async/await 虽然本质上还是 Promise 语法，但是可以被 try-catch 捕获。（因此我们提倡使用 async/await 来代替纯 Promise，这样子可以更方便的被捕获，如果你还是使用 Promise，要记得添加 catch事件，或者依赖全局捕获错误的方法。）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> fn();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;try-catch error:&#x27;</span>, err.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// try-catch error: a is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="unhandledrejection"><a href="#unhandledrejection" class="headerlink" title="unhandledrejection"></a>unhandledrejection</h3><p>我们开发的时候，如果有些 Promise 异常没有被处理，可以使用全局的方法来捕获，这里用到了 unhandledrejection 事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;window.onunhandledrejection catch error:&#x27;</span>, err.reason);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unhandledrejection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;window.addEventListener unhandledrejection catch error:&#x27;</span>, event.reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// window.onunhandledrejection catch error: ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">// window.addEventListener unhandledrejection catch error: ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p>我们在写前端项目的时候一般都是使用框架的，除了上面的通用的捕获异常的方法，框架本身还提供了一些方法供我们使用。</p>
<h2 id="Vue-中捕获异常"><a href="#Vue-中捕获异常" class="headerlink" title="Vue 中捕获异常"></a>Vue 中捕获异常</h2><p>Vue 的官方文档没有专门的章节来介绍异常的处理。总的来说，在生产环境有以下几种方式（开发环境的错误通过控制台就可以看到，这里不再铺开，详见 Vue 官网中的 warnHandler 及 renderError）：</p>
<ul>
<li>errorHandler</li>
<li>errorCaptured</li>
</ul>
<h3 id="errorHandler"><a href="#errorHandler" class="headerlink" title="errorHandler"></a>errorHandler</h3><p>errorHandler 在 Vue 中用于捕获全局的错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.config.errorHandler = <span class="function"><span class="keyword">function</span> (<span class="params">err, vm, info</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;vue errorHandler: &#x27;</span> + err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>errorHandler 可以捕获的异常包含以下方面：</p>
<ol>
<li>组件的渲染和观察期间未捕获的错误</li>
</ol>
<p>需要注意的是 template 中如果引用一个不存在的变量的话是不会被 errorHandler 捕获的，这个错误需要使用 errorHandler 捕获。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  &lt;template&gt;</span><br><span class="line">      &lt;div&gt;&#123;&#123;currentTime&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">      name: <span class="string">&#x27;ErrorTest&#x27;</span>,</span><br><span class="line">      data () &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有捕获到异常</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">稍微修改一下，在 data 中加入 currentTime 变量，但是赋值错误：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> js</span><br><span class="line">  &lt;template&gt;</span><br><span class="line">      &lt;div&gt;&#123;&#123;currentTime&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">      name: <span class="string">&#x27;ErrorTest&#x27;</span>,</span><br><span class="line">      data () &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">              currentTime</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// vue errorHandler: ReferenceError: currentTime is not defined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>捕获组件生命周期钩子里的错误（版本&gt;=2.2.0）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;currentTime&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;ErrorTest&#x27;</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            currentTime: <span class="built_in">Date</span>.now()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(currentTime)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue errorHandler: ReferenceError: currentTime is not defined</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自定义事件处理函数内部的错误（版本&gt;=2.4.0）</li>
</ol>
<p>我们假设子组件使用 $emit 方法触发了 change 事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;child @change=<span class="string">&quot;changeHandler&quot;</span> /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">&#x27;./child&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;ErrorTest&#x27;</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        Child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeHandler () &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(changedValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue errorHandler: ReferenceError: changedValue is not defined</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>v-on DOM 监听器内部抛出的错误（版本&gt;=2.6.0）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button v-on:click=<span class="string">&quot;clickHandler&quot;</span>&gt;click here&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;ErrorTest&#x27;</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        clickHandler () &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(target)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue errorHandler: ReferenceError: target is not defined</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理。(版本&gt;=2.6.0)</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button v-on:click=<span class="string">&quot;clickHandler&quot;</span>&gt;click here&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;ErrorTest&#x27;</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        clickHandler () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(target)</span><br><span class="line">            &#125;) <span class="comment">// 必须要return，否则不会被捕获</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue errorHandler: ReferenceError: target is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a>errorCaptured</h3><p>errorCaptured 是 Vue 在 2.5.0 新增加的钩子函数，用于捕获来自子组件的错误。现在，我们依然假设子组件抛出了一个错误（这里依然保留上一节提到的 errorHandler 方法）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;child /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">&#x27;./child&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;ErrorTest&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            currentTime: <span class="built_in">Date</span>.now()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        Child</span><br><span class="line">    &#125;,</span><br><span class="line">    errorCaptured (err, vm, info) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;vue errorCaptured: &#x27;</span> + err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue errorCaptured: ReferenceError: current is not defined</span></span><br><span class="line"><span class="comment">// vue errorHandler: ReferenceError: current is not defined</span></span><br></pre></td></tr></table></figure>

<p>上面的例子显示，errorCaptured 先于 errorHandler 捕获了错误，如果不想再次被上级捕获，可以在钩子函数中返回 false 。附上Vue官网给出的<a href="https://cn.vuejs.org/v2/api/#errorCaptured">错误传播规则</a>：</p>
<ul>
<li>默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。</li>
<li>如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。</li>
<li>如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler。</li>
<li>一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler。</li>
</ul>
<h2 id="React-中捕获异常"><a href="#React-中捕获异常" class="headerlink" title="React 中捕获异常"></a>React 中捕获异常</h2><p>React官网中有专门的章节介绍异常的章节——<a href="https://react.docschina.org/docs/error-boundaries.html">错误边界</a>。</p>
<h3 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h3><p>错误边界的概念是 React 在 React 16 引入的概念，是为了解决部分 UI 的 JavaScript 错误引起的应用崩溃问题。</p>
<blockquote>
<p>错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。<br>如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。<br>只有 class 组件才可以成为错误边界组件。</p>
</blockquote>
<p>基于上面的说明，我们的错误边界的组件可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Default <span class="keyword">from</span> <span class="string">&#x27;/default&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; uploadError &#125; <span class="keyword">from</span> <span class="string">&#x27;../utils/error&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError (err) &#123;</span><br><span class="line">    <span class="comment">// 发生错误，显示降级后的UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch (err, info) &#123;</span><br><span class="line">    <span class="comment">// 可以将错误日志上报给服务器</span></span><br><span class="line">    uploadError(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Default</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.props.children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ErrorBoundary</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  &lt;Child /&gt;</span><br><span class="line">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></table></figure>

<p>错误边界的工作方式类似于 JavaScript 的 catch {}，不同的地方在于错误边界只针对 React 组件。错误边界无法捕获的错误有下面几个方面，这些异常需要使用 try-catch 等捕获：</p>
<ul>
<li>事件处理</li>
<li>异步代码</li>
<li>服务端渲染</li>
<li>它自身抛出来的错误（并非它的子组件）</li>
</ul>
<h2 id="iframe-异常"><a href="#iframe-异常" class="headerlink" title="iframe 异常"></a>iframe 异常</h2><p>当我们的页面引用了 iframe 的时候，也可以使用 onerror 方法捕获 iframe 的异常，但这种形式仅限于你自己的页面和 iframe 的页面同域名的情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">&quot;./iframe.html&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.frames[<span class="number">0</span>].onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;iframe error: &#x27;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iframe error: Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="页面崩溃"><a href="#页面崩溃" class="headerlink" title="页面崩溃"></a>页面崩溃</h2><p>页面崩溃和上面提到的异常捕获的情况是不一样的，页面崩溃时，JavaScript 代码已经不执行了。但还是有办法来监控到页面崩溃的，目前有两种：一个是load 和 beforeunload 结合， 另外一个是基于 Service Worker。</p>
<h3 id="load-和-beforeunload-事件"><a href="#load-和-beforeunload-事件" class="headerlink" title="load 和 beforeunload 事件"></a>load 和 beforeunload 事件</h3><p>我们先来看下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  sessionStorage.setItem(<span class="string">&#x27;good_exit&#x27;</span>, <span class="string">&#x27;pending&#x27;</span>);</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    sessionStorage.setItem(<span class="string">&#x27;time_before_crash&#x27;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().toString());</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  sessionStorage.setItem(<span class="string">&#x27;good_exit&#x27;</span>, <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sessionStorage.getItem(<span class="string">&#x27;good_exit&#x27;</span>) &amp;&amp;</span><br><span class="line">  sessionStorage.getItem(<span class="string">&#x27;good_exit&#x27;</span>) !== <span class="string">&#x27;true&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      insert crash logging code here</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  alert(<span class="string">&#x27;Hey, welcome back from your crash, looks like you crashed on: &#x27;</span> + sessionStorage.getItem(<span class="string">&#x27;time_before_crash&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码来看，这个方法其实是利用了页面崩溃时无法触发 beforeunload 事件来实现的。页面加载完成后，在 sessionStorage 中存储 good_exit 的值为 pending。如果页面正常关闭， 会触发 beforeunload 事件，在 beforeunload 事件中，我们将 good_exit 的值重置为 true。如果页面崩溃了，刷新页面时，从 sessionStorage 中读取到的值就是 pending 而不是 true。</p>
<p>用上面的方式处理有以下问题：</p>
<ol>
<li><p>由于是 sessionStorage 存储的值，页面崩溃后如果用户关闭页面或重新打开浏览器，sessionStorage 中存储的 good_exit 值我们是获取不到的；</p>
</li>
<li><p>如果前进或后退，页面会从缓存中加载，有时候是不会触发 load 事件的。</p>
<p>即使存在上面的问题，但这个方法对我们依然有借鉴意义。页面崩溃时，JavaScript 不会执了，DOM 也卸载了，我们对页面的渲染是无能为力的。但我们可以在用户再次刷新页面时捕获到上次的崩溃信息，并将崩溃上报到监控系统。如果监控系统收到大量的崩溃信息，就说明我们的页面出现了严重的问题了，这时候我们就需要想办法复现或者从代码逻辑层面找到崩溃原因了。</p>
</li>
</ol>
<h3 id="基于-Service-Worker"><a href="#基于-Service-Worker" class="headerlink" title="基于 Service Worker"></a>基于 Service Worker</h3><p>基于 Service Worker 的方案其实也是利用了页面崩溃时无法触发 beforeunload 事件来实现的，与 load 和 beforeunload 的区别是 Service Worker 相对于驱动应用的主 JavaScript 线程，它运行在其他线程中，即使网页崩溃了，Service Worker 一般情况下也不会崩溃。所以，我们不需要等到用户再次刷新页面才能获取上次的崩溃信息了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面 JavaScript 代码</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker.controller !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> HEARTBEAT_INTERVAL = <span class="number">5</span> * <span class="number">1000</span>; <span class="comment">// 每五秒发一次心跳</span></span><br><span class="line">  <span class="keyword">let</span> sessionId = uuid();</span><br><span class="line">  <span class="keyword">let</span> heartbeat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    navigator.serviceWorker.controller.postMessage(&#123;</span><br><span class="line">      type: <span class="string">&#x27;heartbeat&#x27;</span>,</span><br><span class="line">      id: sessionId,</span><br><span class="line">      data: &#123;&#125; <span class="comment">// 附加信息，如果页面 crash，上报的附加数据，比如页面地址等</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&quot;beforeunload&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    navigator.serviceWorker.controller.postMessage(&#123;</span><br><span class="line">      type: <span class="string">&#x27;unload&#x27;</span>,</span><br><span class="line">      id: sessionId</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">setInterval</span>(heartbeat, HEARTBEAT_INTERVAL);</span><br><span class="line">  heartbeat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service Worker</span></span><br><span class="line"><span class="keyword">const</span> CHECK_CRASH_INTERVAL = <span class="number">10</span> * <span class="number">1000</span>; <span class="comment">// 每 10s 检查一次</span></span><br><span class="line"><span class="keyword">const</span> CRASH_THRESHOLD = <span class="number">15</span> * <span class="number">1000</span>; <span class="comment">// 15s 超过15s没有心跳则认为已经 crash</span></span><br><span class="line"><span class="keyword">const</span> pages = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> timer</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCrash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> pages) &#123;</span><br><span class="line">    <span class="keyword">let</span> page = pages[id]</span><br><span class="line">    <span class="keyword">if</span> ((now - page.t) &gt; CRASH_THRESHOLD) &#123;</span><br><span class="line">      <span class="comment">// 上报 crash</span></span><br><span class="line">      <span class="keyword">delete</span> pages[id]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(pages).length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = e.data;</span><br><span class="line">  <span class="keyword">if</span> (data.type === <span class="string">&#x27;heartbeat&#x27;</span>) &#123;</span><br><span class="line">    pages[data.id] = &#123;</span><br><span class="line">      t: <span class="built_in">Date</span>.now()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        checkCrash()</span><br><span class="line">      &#125;, CHECK_CRASH_INTERVAL)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.type === <span class="string">&#x27;unload&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pages[data.id]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码的思路是：</p>
<ol>
<li>网页加载后，通过 postMessage API 每 5s 给 sw 发送一个心跳，表示自己的在线，sw 将在线的网页登记下来，更新登记时间；</li>
<li>网页在 beforeunload 时，通过 postMessage API 告知自己已经正常关闭，sw 将登记的网页清除；</li>
<li>如果网页在运行的过程中 crash 了，sw 中的 running 状态将不会被清除，更新时间停留在奔溃前的最后一次心跳；</li>
<li>Service Worker 每 10s 查看一遍登记中的网页，发现登记时间已经超出了一定时间（比如 15s）即可判定该网页 crash 了。</li>
</ol>
<p>同样的，Service Worker捕获的错误对前端监控是很有用的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>具体到实际工作中，我们要处理的异常分为以下几种：</p>
<ol>
<li>语法错误及代码异常：对可疑区域增加 try-catch，全局增加 window.onerror;</li>
<li>数据请求异常：使用 promise-catch 处理 Promise 异常，使用 unhandledrejection 处理未捕获的Promise异常，使用 try-catch 处理 async/await 异常;</li>
<li>静态资源加载异常：在元素上添加 onerror，全局增加 window.addEventListener；</li>
<li>白屏：Vue 使用 errorHandler， React 使用 componentDidCatch，渲染备用UI；</li>
<li>iframe异常：同域条件下使用 onerror。</li>
<li>页面崩溃：load 和 beforeunload 结合或者使用 Service Worker。</li>
</ol>
]]></content>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>如何监听容器高度变化（一）</title>
    <url>/2021/06/17/%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%AE%B9%E5%99%A8%E9%AB%98%E5%BA%A6%E5%8F%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>首先说一下场景：单品页详情模块有一个折叠展示的功能，如果内容超出指定高度只展示一部分并显示“查看全部”的按钮。因为详情部分除了文字、表格之外，还会有图片等异步加载的资源会影响内容整体的高度，所以需要获取内容部分的实时高度。</p>
<p>如果要实现上面的功能，有以下方式：</p>
<ol>
<li>变通一下，因为详情模块不会在首屏展示，可以修改成滚动到该模块的时候再获取高度。这纯粹是个懒办法，如果有相似功能的模块在首屏展示，这种方法不适用。</li>
<li>给异步加载的资源添加onload事件，加载完成后更新容器的高度。这种方式只有在添加了onload事件的资源加载完成后才会更新高度，如果有些异步资源没有绑定事件或者通过js改变了元素高度，最后获取的高度可能不准确。</li>
<li>使用setInterval定时获取容器高度。这种方式和上一种比较的话，实现方式简单，但是setInterval会占用内存，有一定的性能问题，而且在容器高度固定之后还会一直被执行，也不是理想的实现方式。</li>
<li>监听容器高度的动态变化。</li>
</ol>
<p>这篇文章要讲的是第3种方式。</p>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>提到高度变化，我们第一个想到的应该是resize事件，在window对象上添加resize事件，可以监听浏览器窗口变化引起的高度变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) =&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// resize事件回调</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;window resize&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>由于resize事件可以以较高的速率触发, 因此resize事件的回调不应该执行计算开销很大的操作 (如 DOM 修改)，最好使用requestAnimationFrame、setTimeout进行处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> resizeTimeout;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeThrottle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!resizeTimeout) &#123;</span><br><span class="line">    resizeTimeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resizeTimeout = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// resize事件真正的回调</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;window resize&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">  <span class="comment">// IE10 及以下</span></span><br><span class="line">  <span class="built_in">window</span>.attachEvent(<span class="string">&quot;onresize&quot;</span>, resizeThrottle);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, resizeThrottle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，普通dom对象是没有resize事件的，只有defaultView（即window）对象有（IE浏览器普通dom也可以使用resize），在普通dom上添加resize事件是不会触发的。</p>
<h2 id="使用iframe模拟"><a href="#使用iframe模拟" class="headerlink" title="使用iframe模拟"></a>使用iframe模拟</h2><p>在上节我们知道，只有window对象有resize事件。按照这个思路，我们可以用隐藏的 iframe 模拟 window 撑满要监听的容器，当容器尺寸变化时，iframe 尺寸也会改变，这样就可以通过监听iframe尺寸变化达到监听容器尺寸变化的目的。如下图：</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/177332/7/9360/15833/60c998c0E34497a33/6ed24b3ba778ebf5.png" alt="iframe模拟"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 要监听的容器position必须为relative --&gt;</span></span><br><span class="line">&lt;div</span><br><span class="line">  id=&quot;main&quot;</span><br><span class="line">  style=&quot;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: lightblue;</span><br><span class="line">  &quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> observeResize = <span class="function"><span class="keyword">function</span> (<span class="params">element, handler</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建iframe，定义样式，使iframe和要监听的容器大小一致</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> frame = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> frameStyle =</span></span><br><span class="line">      &quot;\</span><br><span class="line">        position:absolute;\</span><br><span class="line">        left:0;\</span><br><span class="line">        top:-100%;\</span><br><span class="line">        width: 100%;\</span><br><span class="line">        height: 100%;\</span><br><span class="line">        opacity:0;\</span><br><span class="line">        visibility:hidden;\</span><br><span class="line">        pointer-events:none;\</span><br><span class="line">    &quot;;</span><br><span class="line">    frame.style.cssText = frameStyle;</span><br><span class="line"><span class="javascript">    frame.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// iframe创建完成后，通过contentWindow获取到iframe的window对象并添加resize事件</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 因为iframe和要监听的容器大小是一样的，iframe的尺寸变化其实也就是监听容器的尺寸变化</span></span></span><br><span class="line"><span class="javascript">      frame.contentWindow.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 或者使用frame.contentDocument.defaultView.onresize</span></span></span><br><span class="line">        handler(element.clientWidth, element.clientHeight);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    element.appendChild(frame);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;main&quot;</span>);</span></span><br><span class="line"><span class="javascript">  observeResize(element, <span class="function"><span class="keyword">function</span> (<span class="params">width, height</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;width: &quot;</span> + width, <span class="string">&quot; height: &quot;</span> + height);</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 改变容器的高度，控制台输出：width: 100; height: 400</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    element.style.height = <span class="string">&quot;400px&quot;</span>;</span></span><br><span class="line">  &#125;, 2000);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：创建iframe比创建其他dom元素（包括style 和script）多耗费数十甚至数百倍的性能，而且还会阻塞页面onload事件的触发，因此这种方式需要谨慎使用。</p>
<h2 id="使用object模拟"><a href="#使用object模拟" class="headerlink" title="使用object模拟"></a>使用object模拟</h2><p>使用object模拟的原理和iframe是一样的。<br>在模拟iframe思路的基础上，我们来完善下功能：</p>
<ol>
<li>IE10及以下浏览器可以使用resize事件，其他浏览器使用object模拟</li>
<li>允许一个dom添加多个resize事件</li>
<li>节流</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 要监听的容器position必须为relative，这里可以不用必须指定，代码中会判断 --&gt;</span></span><br><span class="line">&lt;div</span><br><span class="line">  id=&quot;main&quot;</span><br><span class="line">  style=&quot;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: lightblue;</span><br><span class="line">  &quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span>    </span><br><span class="line"><span class="javascript">  <span class="comment">// 节流函数</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> requestFrame = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> raf =</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.requestAnimationFrame ||</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.mozRequestAnimationFrame ||</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">window</span>.setTimeout(fn, <span class="number">20</span>);</span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> raf(fn);</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 清除节流</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> cancelFrame = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// resize事件回调</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> handleResize = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取触发了resize事件的元素，IE 8 使用srcElement，其他的取target值</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> target = e.target || e.srcElement;</span></span><br><span class="line">    if (</span><br><span class="line">      target &amp;&amp;</span><br><span class="line">      target.__resizeTrigger__ &amp;&amp;</span><br><span class="line">      target.__resizeTrigger__.__resizeListeners__</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (target.__resizeRAF__) cancelFrame(target.__resizeRAF__);</span><br><span class="line"><span class="javascript">      target.__resizeRAF__ = requestFrame(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 遍历元素上已添加的事件，执行</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> handlers = target.__resizeTrigger__.__resizeListeners__;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; handlers.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> element = target.__resizeTrigger__;</span></span><br><span class="line">          handlers[i](element.clientWidth, element.clientHeight);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 为指定元素添加resize事件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> addResizeListener = <span class="function"><span class="keyword">function</span> (<span class="params">element, handler</span>) </span>&#123;</span></span><br><span class="line">    if (!element.__resizeListeners__) &#123;</span><br><span class="line">      element.__resizeListeners__ = [];</span><br><span class="line">      if (element.attachEvent) &#123;</span><br><span class="line">        element.__resizeTrigger__ = element;</span><br><span class="line"><span class="javascript">        element.attachEvent(<span class="string">&quot;onresize&quot;</span>, handleResize);</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建object 模拟元素大小</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> object = <span class="built_in">document</span>.createElement(<span class="string">&quot;object&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> objectStyle =</span></span><br><span class="line">          &quot;\</span><br><span class="line">        position:absolute;\</span><br><span class="line">        left:0;\</span><br><span class="line">        top:-100%;\</span><br><span class="line">        width: 100%;\</span><br><span class="line">        height: 100%;\</span><br><span class="line">        opacity:0;\</span><br><span class="line">        visibility:hidden;\</span><br><span class="line">        pointer-events:none;\</span><br><span class="line">    &quot;;</span><br><span class="line">        object.style.cssText = objectStyle;</span><br><span class="line"><span class="javascript">        object.type = <span class="string">&quot;text/html&quot;</span>;</span></span><br><span class="line"><span class="javascript">        object.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 指定__resizeTrigger__为实际要获取大小的元素</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.contentDocument.defaultView.__resizeTrigger__ = element;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 给object对应的window对象添加resize事件</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.contentDocument.defaultView.addEventListener(</span></span><br><span class="line"><span class="javascript">            <span class="string">&quot;resize&quot;</span>,</span></span><br><span class="line">            handleResize</span><br><span class="line">          );</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (getComputedStyle(element).position == <span class="string">&quot;static&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">          element.style.position = <span class="string">&quot;relative&quot;</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        element.appendChild(object);</span><br><span class="line"><span class="javascript">        object.data = <span class="string">&quot;about:blank&quot;</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    element.__resizeListeners__.push(handler);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 为指定元素移除resize事件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> removeResizeListener = <span class="function"><span class="keyword">function</span> (<span class="params">element, handler</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> handlers =</span></span><br><span class="line">      element &amp;&amp; element.__resizeListeners__</span><br><span class="line">        ? element.__resizeListeners__</span><br><span class="line">        : [];</span><br><span class="line">    handlers.splice(handlers.indexOf(handler), 1);</span><br><span class="line">    if (!handlers.length) &#123;</span><br><span class="line">      if (element.attachEvent) &#123;</span><br><span class="line"><span class="javascript">        element.detachEvent(<span class="string">&quot;onresize&quot;</span>, handleResize);</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">        element.__resizeTrigger__.contentDocument.defaultView.removeEventListener(</span><br><span class="line"><span class="javascript">          <span class="string">&quot;resize&quot;</span>,</span></span><br><span class="line">          handleResize</span><br><span class="line">        );</span><br><span class="line">        element.__resizeTrigger__ = !element.removeChild(</span><br><span class="line">          element.__resizeTrigger__</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;main&quot;</span>);</span></span><br><span class="line"><span class="javascript">  addResizeListener(element, <span class="function"><span class="keyword">function</span> (<span class="params">width, height</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;width:&quot;</span> + width, <span class="string">&quot; height:&quot;</span> + height);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  addResizeListener(element, <span class="function"><span class="keyword">function</span> (<span class="params">width, height</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;width111:&quot;</span> + width, <span class="string">&quot; height111:&quot;</span> + height);</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 改变容器的高度，控制台输出：width: 100; height: 400 和 width111: 100; height111: 400</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    element.style.height = <span class="string">&quot;400px&quot;</span>;</span></span><br><span class="line">  &#125;, 2000);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="监听scroll事件"><a href="#监听scroll事件" class="headerlink" title="监听scroll事件"></a>监听scroll事件</h2><p>要监听的容器我们是不能改变它的滚动状态的，但是我们可以和iframe或者object模拟一样，创建一个不可见的子元素，使这个子元素可以触发滚动，再通过事件冒泡，让容器捕捉到。</p>
<p>滚动事件可以被触发的条件是：当子元素大于其父级元素，且父级元素允许其滚动。当元素高度改变时，scrollTop或scrollLeft默认保持原状，如果scrollTop或scrollLeft不能保持原状必须变化时，就会触发scroll事件。我们可以利用这一点，通过修改scroolTop或scrollLeft的值，来触发滚动。下面我们来看下容器变大或变小时滚动的情况。</p>
<h3 id="容器变大"><a href="#容器变大" class="headerlink" title="容器变大"></a>容器变大</h3><p><img src= "/img/loading.gif" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/194655/40/8550/14062/60cab143E9e61fb5e/34bce83b1655b2f0.png" alt="容器变大"></p>
<p>上图中虚线表示子元素高度（均为110px），实线表示父元素高度。</p>
<ol>
<li>当父元素高度为80px时，滚动条滚动到页面最底部，scrollTop为30px；</li>
<li>当父元素高度由80px变为90px时，可滚动区域变小为20px，如果scrollTop保持30px不变，30 + 90 会大于页面高度110px，因此scrollTop必须为20px才能满足条件，此时滚动被触发；</li>
<li>当父元素高度变为70px时，可滚动区域变为40px，scrollTop保持20px不变，此时滚动不会被触发。</li>
</ol>
<p>因此，当滚动到底部时，如果父元素不断变大，scrollTop的值就会不断缩小，从而触发滚动事件。</p>
<h3 id="容器变小"><a href="#容器变小" class="headerlink" title="容器变小"></a>容器变小</h3><p>从上面第3条我们可以知道，父元素变小时，不会触发滚动事件。但是我们也知道，当可滚动区域的高度小于scrollTop的值的时候，scrollTop会变为可滚动区域的值，这时候滚动被触发。我们可以利用父元素来压缩可滚动区域的大小：</p>
<p><img src= "/img/loading.gif" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/172939/28/15195/10232/60cab749Eaf12e9c5/db447cc39e5733f6.png" alt="容器变小"></p>
<p>上图中虚线表示子元素，实线表示父元素，子元素高度始终是父元素高度的200%</p>
<ol>
<li>当父元素高度为60px时，子元素高度为120px，滚动条滚动到最底部，scrollTop为60px;</li>
<li>当父元素高度由60px变为50px时，子元素高度为100px，此时可滚动区域变小为50px，scrollTop由60px变为50px，滚动被触发。</li>
</ol>
<p>因此，当滚动到底部时，如果子元素随着父元素不断缩小且缩小的幅度大于父元素，scrollTop的值就会不断缩小，从而触发滚动事件。</p>
<p>有了对容器变大和变小时触发滚动的了解后，我们就可以通过触发模拟元素的滚动来触发监听容器的滚动了。我们创建一个和要监听的容器等大的模拟元素，再添加两个子元素分别监听容器变大和变小的情况，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 要监听的容器position必须为relative，这里可以不用必须指定，代码中会判断 --&gt;</span></span><br><span class="line">&lt;div</span><br><span class="line">  id=&quot;main&quot;</span><br><span class="line">  style=&quot;width: 100px; height: 100px; background-color: lightblue&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> stylesCreated = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 节流函数</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> requestFrame = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 清除节流</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> cancelFrame = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 处理滚动事件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> handleScroll = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (target.__resizeRAF__) cancelFrame(target.__resizeRAF__); <span class="comment">// 取消之前的回调</span></span></span><br><span class="line"><span class="javascript">    target.__resizeRAF__ = requestFrame(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">      if (target.attachEvent) &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; target.__resizeListeners__.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> handlers = target.__resizeListeners__;</span></span><br><span class="line">          handlers[i](target.clientWidth, target.clientHeight);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 设置新的函数</span></span></span><br><span class="line">        if (checkTriggers(target)) &#123;</span><br><span class="line"><span class="javascript">          <span class="comment">// 如果改变了大小</span></span></span><br><span class="line"><span class="javascript">          target.__resizeLast__.width = target.offsetWidth; <span class="comment">// 更新宽度</span></span></span><br><span class="line"><span class="javascript">          target.__resizeLast__.height = target.offsetHeight; <span class="comment">// 更新高度</span></span></span><br><span class="line"><span class="javascript">          target.__resizeListeners__.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span></span><br><span class="line">            fn(target.clientWidth, target.clientHeight);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 添加模拟元素的样式</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> createStyles = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (stylesCreated) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> css =</span></span><br><span class="line">      &#x27;\</span><br><span class="line">  .resize-triggers &#123;\</span><br><span class="line">      visibility: hidden;\</span><br><span class="line">      opacity: 0;\</span><br><span class="line">    &#125;\</span><br><span class="line">  .resize-triggers, .resize-triggers &gt; div, .contract-trigger:before &#123;\</span><br><span class="line"><span class="javascript">      content: <span class="string">&quot; &quot;</span>;\</span></span><br><span class="line">      display: block;\</span><br><span class="line">      position: absolute;\</span><br><span class="line">      top: 0;\</span><br><span class="line">      left: 0;\</span><br><span class="line">      height: 100%;\</span><br><span class="line">      width: 100%;\</span><br><span class="line">      overflow: hidden;\</span><br><span class="line">    &#125;\</span><br><span class="line">  .resize-triggers &gt; div &#123;\</span><br><span class="line">      background: #eee;\</span><br><span class="line">      overflow: auto;\</span><br><span class="line">    &#125;\</span><br><span class="line">  .contract-trigger:before &#123;\</span><br><span class="line">      width: 200%;\</span><br><span class="line">      height: 200%;\</span><br><span class="line">    &#125;&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> head = <span class="built_in">document</span>.head || <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>]; <span class="comment">// 后者兼容IE9以下</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">&quot;style&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    style.type = <span class="string">&quot;text/css&quot;</span>;</span></span><br><span class="line">    if (style.styleSheet) &#123;</span><br><span class="line">      style.styleSheet.cssText = css;</span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">      style.appendChild(<span class="built_in">document</span>.createTextNode(css));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    head.appendChild(style); <span class="comment">// 添加新的样式</span></span></span><br><span class="line"><span class="javascript">    stylesCreated = <span class="literal">true</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 检查是否发生滚动</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> checkTriggers = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 宽度或高度不一致就返回true</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> element.offsetWidth !== element.__resizeLast__.width ||</span></span><br><span class="line">          element.offsetHeight !== element.__resizeLast__.height;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 重置模拟元素的滚动位置</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> resetTrigger = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!element || !element.__resizeTrigger__) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> trigger = element.__resizeTrigger__;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> expand = trigger.firstElementChild; <span class="comment">// 用来监听变大</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> contract = trigger.lastElementChild; <span class="comment">// 用来监听变小</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> expandChild = expand.firstElementChild;</span></span><br><span class="line"></span><br><span class="line">    contract.scrollLeft = contract.scrollWidth;</span><br><span class="line">    contract.scrollTop = contract.scrollHeight;</span><br><span class="line"><span class="javascript">    <span class="comment">// 监听变大时，需要设置子元素比父元素大1像素，使容器可以滚动</span></span></span><br><span class="line"><span class="javascript">    expandChild.style.width = expand.offsetWidth + <span class="number">1</span> + <span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="javascript">    expandChild.style.height = expand.offsetHeight + <span class="number">1</span> + <span class="string">&quot;px&quot;</span>;</span></span><br><span class="line">    expand.scrollLeft = expand.scrollWidth;</span><br><span class="line">    expand.scrollTop = expand.scrollHeight;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 为指定元素添加resize事件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> addResizeListener = <span class="function"><span class="keyword">function</span> (<span class="params">element, handler</span>) </span>&#123;</span></span><br><span class="line">    if (!element.__resizeListeners__) &#123;</span><br><span class="line">      element.__resizeListeners__ = [];</span><br><span class="line"><span class="javascript">      <span class="comment">// IE10及以下可以直接绑定onresize事件</span></span></span><br><span class="line">      if (element.attachEvent) &#123;</span><br><span class="line"><span class="javascript">        element.attachEvent(<span class="string">&quot;onresize&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">          handleScroll(element);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">        createStyles();</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> resizeTrigger = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="javascript">        resizeTrigger.className = <span class="string">&quot;resize-triggers&quot;</span>;</span></span><br><span class="line">        resizeTrigger.innerHTML =</span><br><span class="line"><span class="handlebars"><span class="xml">          &#x27;<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;expand-trigger&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;contract-trigger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#x27;;</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (getComputedStyle(element).position == <span class="string">&quot;static&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">          element.style.position = <span class="string">&quot;relative&quot;</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        element.appendChild(resizeTrigger);</span><br><span class="line">        element.__resizeTrigger__ = resizeTrigger;</span><br><span class="line">        element.__resizeLast__ = &#123;&#125;;</span><br><span class="line">        resetTrigger(element);</span><br><span class="line"><span class="javascript">        <span class="comment">// 重要：addEventListener第三个参数设置为true，允许滚动事件冒泡</span></span></span><br><span class="line">        element.addEventListener(</span><br><span class="line"><span class="javascript">          <span class="string">&quot;scroll&quot;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            handleScroll(element);</span><br><span class="line">          &#125;,</span><br><span class="line"><span class="javascript">          <span class="literal">true</span></span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    element.__resizeListeners__.push(handler);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 为指定元素移除resize事件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> removeResizeListener = <span class="function"><span class="keyword">function</span> (<span class="params">element, handler</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> handlers =</span></span><br><span class="line">      element &amp;&amp; element.__resizeListeners__</span><br><span class="line">        ? element.__resizeListeners__</span><br><span class="line">        : [];</span><br><span class="line">    handlers.splice(handlers.indexOf(handler), 1);</span><br><span class="line">    if (!handlers.length) &#123;</span><br><span class="line">      if (element.detachEvent) &#123;</span><br><span class="line"><span class="javascript">        element.detachEvent(<span class="string">&quot;onresize&quot;</span>, handleResize);</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">        element.removeEventListener(</span><br><span class="line"><span class="javascript">          <span class="string">&quot;resize&quot;</span>,</span></span><br><span class="line">          handleResize</span><br><span class="line">        );</span><br><span class="line">        element.__resizeTrigger__ = !element.removeChild(</span><br><span class="line">          element.__resizeTrigger__</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;main&quot;</span>);</span></span><br><span class="line"><span class="javascript">  addResizeListener(element, <span class="function"><span class="keyword">function</span> (<span class="params">width, height</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;width:&quot;</span> + width, <span class="string">&quot; height:&quot;</span> + height);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  addResizeListener(element, <span class="function"><span class="keyword">function</span> (<span class="params">width, height</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;width111:&quot;</span> + width, <span class="string">&quot; height111:&quot;</span> + height);</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    element.style.height = <span class="string">&quot;400px&quot;</span>;</span></span><br><span class="line">  &#125;, 2000);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>以上介绍的四种方式均可兼容到IE8（因为我只测试到了IE8，大部分网站连IE9都不兼容了）。当然，我们做项目的时候可以使用现成的开源代码：</p>
<ol>
<li><a href="https://github.com/KyleAMathews/element-resize-event">element-resize-event</a>: 使用的是object模拟</li>
<li><a href="https://github.com/wnr/element-resize-detector">element-resize-detector</a>：使用object和scroll两种策略，默认object</li>
</ol>
<p>在使用object和scroll模拟的时候，对flex压缩和css动画造成的高度变化的情况进行了测试，本文代码中scroll的方式对动画造成的高度变化无效（需补充animation的适配），但element-resize-detector中scroll是正常的。</p>
]]></content>
      <tags>
        <tag>resize, object, iframe, scroll</tag>
      </tags>
  </entry>
  <entry>
    <title>微前端实践二</title>
    <url>/2021/06/21/%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="微前端架构之single-spa"><a href="#微前端架构之single-spa" class="headerlink" title="微前端架构之single-spa"></a>微前端架构之single-spa</h2><h3 id="single-spa是什么"><a href="#single-spa是什么" class="headerlink" title="single-spa是什么"></a>single-spa是什么</h3><p>Single-spa 是一个将多个单页面应用聚合为一个整体应用的 JavaScript 微前端框架。<br>好处：</p>
<ul>
<li>在同一页面上使用多个前端框架 而不用刷新页面 (React, AngularJS, Angular, Ember, 你正在使用的框架)</li>
<li>独立部署每一个单页面应用</li>
<li>新功能使用新框架，旧的单页应用不用重写可以共存</li>
<li>改善初始加载时间，迟加载代码</li>
</ul>
<h3 id="single-spa做了什么"><a href="#single-spa做了什么" class="headerlink" title="single-spa做了什么"></a>single-spa做了什么</h3><p>single-spa是一个顶层路由。当路由处于活动状态时，它将下载并执行该路由下的相关代码。</p>
<p>路由的代码被称为应用，每个代码都可以（可选）拥有自己的git仓库、CI进程，并且可以独立部署。这些应用即可以用相同框架实现，也可以用不同框架实现。</p>
<h3 id="single-spa包括些什么"><a href="#single-spa包括些什么" class="headerlink" title="single-spa包括些什么:"></a>single-spa包括些什么:</h3><ul>
<li>1、Applications，每个应用程序本身就是一个完整的 SPA (某种程度上)。 每个应用程序都可以响应 url 路由事件，并且必须知道如何从 DOM 中初始化、挂载和卸载自己。 传统 SPA 应用程序和 Single SPA 应用程序的主要区别在于，<code>它们必须能够与其他应用程序共存，而且它们没有各自的 html 页面</code>。<blockquote>
<p>例如，React 或 Vue spa 就是应用程序。 当激活时，它们监听 url 路由事件并将内容放在 DOM上。 当它们处于非活动状态时，它们不侦听 url 路由事件，并且完全从 DOM 中删除。</p>
</blockquote>
</li>
<li>一个 single-spa-config配置, 这是html页面和向Single SPA注册应用程序的JavaScript。每个应用程序都注册了三件东西<ul>
<li>A name (应用的标识)</li>
<li>A function (加载应用程序的代码)</li>
<li>A function (确定应用程序何时处于活动状态/非活动状态)</li>
</ul>
</li>
</ul>
<h3 id="single-spa的使用方式"><a href="#single-spa的使用方式" class="headerlink" title="single-spa的使用方式"></a>single-spa的使用方式</h3><p>Single-spa 适用于 ES5、 ES6 + 、 TypeScript、 Webpack、 SystemJS、 Gulp、 Grunt、 Bower、 ember-cli 或 任何可用的构建系统。 您可以 npm 安装它，jspm 安装它，如果您愿意，甚至可以使用 &lt;script&gt; 标签。</p>
<h3 id="新项目中使用single-spa"><a href="#新项目中使用single-spa" class="headerlink" title="新项目中使用single-spa"></a>新项目中使用single-spa</h3><h4 id="1、创建相当简单-create-single-spa-cli"><a href="#1、创建相当简单-create-single-spa-cli" class="headerlink" title="1、创建相当简单 create-single-spa cli"></a>1、创建相当简单 create-single-spa cli</h4><p><a href="https://github.com/single-spa/create-single-spa/">https://github.com/single-spa/create-single-spa/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局安装</span></span><br><span class="line">npm install --global create-single-spa</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn global add create-single-spa</span><br><span class="line"><span class="comment"># 之后执行</span></span><br><span class="line">create-single-spa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地安装</span></span><br><span class="line">npm init single-spa</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">npx create-single-spa</span><br><span class="line"><span class="comment"># or </span></span><br><span class="line">yarn create single-spa</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="推荐设置"><a href="#推荐设置" class="headerlink" title="推荐设置"></a>推荐设置</h4><p>我们建议使用浏览器内ES模块 + import maps (或者SystemJS填充这些，如果你需要更好的浏览器支持)的设置。这种设置有几个优点:</p>
<ul>
<li><ol>
<li>公共模块易于管理，并且只下载一次。如果使用SystemJS，也可以预加载它们来提高速度。</li>
</ol>
</li>
<li><ol start="2">
<li>共享代码/函数/变量就像导入/导出一样简单，就像在一个整体中设置一样。</li>
</ol>
</li>
<li><ol start="3">
<li>延迟加载应用程序很容易，这使您能够加速初始加载时间。</li>
</ol>
</li>
<li><ol start="4">
<li>每个应用程序(又名微服务，又名ES模块)都可以独立开发和部署。团队可以按照自己的进度工作、实验(在组织定义的合理范围内)、QA和部署。这通常也意味着发布周期可以缩短到几天，而不是几周或几个月。</li>
</ol>
</li>
<li><ol start="5">
<li>很棒的开发人员体验(DX):转到dev环境并添加一个导入映射，该映射将应用程序的url指向您的本地主机。请参阅下面的章节了解详细信息。</li>
</ol>
</li>
</ul>
<h4 id="single-spa中微前端的类型"><a href="#single-spa中微前端的类型" class="headerlink" title="single-spa中微前端的类型"></a>single-spa中微前端的类型</h4><ul>
<li><ol>
<li>single-spa applications:为一组特定路由渲染组件的微前端。</li>
</ol>
</li>
<li><ol start="2">
<li>single-spa parcels: 不受路由控制，渲染组件的微前端。</li>
</ol>
</li>
<li><ol start="3">
<li>utility modules: 非渲染组件，用于暴露共享javascript逻辑的微前端。</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>容器Root</th>
<th align="center">应用程序</th>
<th align="center">沙箱</th>
<th align="center">公共模块</th>
</tr>
</thead>
<tbody><tr>
<td>主路由</td>
<td align="center">有多个路由</td>
<td align="center">无路由</td>
<td align="center">无路由</td>
</tr>
<tr>
<td>API</td>
<td align="center">声明API</td>
<td align="center">必要的API</td>
<td align="center">没有single-spa API</td>
</tr>
<tr>
<td>渲染UI</td>
<td align="center">渲染UI</td>
<td align="center">渲染UI</td>
<td align="center">不直接渲染UI</td>
</tr>
<tr>
<td>生命周期</td>
<td align="center">single-spa管理生命周期</td>
<td align="center">自定义管理生命周期</td>
<td align="center">没有生命周期</td>
</tr>
<tr>
<td>什么时候用</td>
<td align="center">核心构建模块</td>
<td align="center">仅在多个框架中需要</td>
<td align="center">共享通用逻辑时使用</td>
</tr>
</tbody></table>
<h4 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h4><p>single-spa 提供 <code>registerApplication</code> API注册应用</p>
<h4 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h4><p>主要是让您在多个框架中编写应用程序时可以在应用程序之间重用UI。<br>管理parcels的生命周期<br><code>mountParcel</code> 或 <code>mountRootParcel</code> 将立即挂载parcel并返回这个parcel对象。 需要卸载需要手动调用 parcel的 <code>unmount</code>.</p>
<blockquote>
<p>Parcels 最适合在框架之间共享UI部分 ???<br>如： application1 用Vue编写，包含创建用户的所有UI和逻辑。 application2是用React编写的，需要创建一个用户。 使用single-spa parcels可以让您包装application2Vue组件。尽管框架不同，但它可以在`application2’内部运行。 将Parcels视为Web组件的single-spa特定实现。</p>
</blockquote>
<h4 id="公共模块"><a href="#公共模块" class="headerlink" title="公共模块"></a>公共模块</h4><p>共享通用逻辑，可以是一个普通的js对象<br>如： 登录授权、 读取数据fetch<br>1、每个应用都访问服务器，这会在每个应用中创建重复的工作；<br>2、使用公共模块，创建一个实现授权逻辑的模块，通过导出/导入的方式使用这些授权</p>
<h4 id="Root-Config"><a href="#Root-Config" class="headerlink" title="Root Config"></a>Root Config</h4><p>根目录下的两个配置，用于启动single-spa应用</p>
<ul>
<li>所有微前端应用共享的根Html页面 【index.ejs】</li>
<li>调用 <code>singleSpa.registerApplication()</code>的js 【study-root-config.js】</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// single-spa-config.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; registerApplication, start &#125; <span class="keyword">from</span> <span class="string">&#x27;single-spa&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// param1: 一个应用的标识</span></span><br><span class="line"><span class="comment">// param2: Function 一个应用要执行的代码</span></span><br><span class="line"><span class="comment">// param3: Function 何时激活这些应用：主路由</span></span><br><span class="line"><span class="comment">// param4: 可选的扩展参数</span></span><br><span class="line">registerApplication(</span><br><span class="line">  <span class="string">&#x27;app2&#x27;</span>, </span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">&#x27;src/app2/main.js&#x27;</span>), </span><br><span class="line">  (location) =&gt; location.pathname.startsWith(<span class="string">&#x27;/app2&#x27;</span>), </span><br><span class="line">  &#123; <span class="attr">some</span>: <span class="string">&#x27;value&#x27;</span> &#125; </span><br><span class="line">);</span><br><span class="line">registerApplication(&#123;</span><br><span class="line">  name: <span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">  app: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;src/app1/main.js&#x27;</span>),</span><br><span class="line">  activeWhen: <span class="string">&#x27;/app1&#x27;</span>,</span><br><span class="line">  customProps: &#123;</span><br><span class="line">    some: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<ul>
<li><p>name:<br>应用的标识，必须Sting</p>
</li>
<li><p>Loading Function or Application<br><code>registerApplication</code> 可以是一个Promise类型的 加载函数，也可以是一个已经被解析的应用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> application = &#123;</span><br><span class="line">  bootstrap: <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(), <span class="comment">//bootstrap function</span></span><br><span class="line">  mount: <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(), <span class="comment">//mount function</span></span><br><span class="line">  unmount: <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(), <span class="comment">//unmount function</span></span><br><span class="line">&#125;</span><br><span class="line">registerApplication(<span class="string">&#x27;applicationName&#x27;</span>, application, activityFunction)</span><br></pre></td></tr></table></figure></li>
<li><p>加载函数<br><code>registerApplication</code>的第二个参数必须是返回<code>promise</code>的函数(或”<code>async function</code>“方法)。这个函数没有入参，会在应用第一次被下载时调用。返回的<code>Promise resolve</code>之后的结果必须是一个可以被解析的应用。常见的实现方法是使用<code>import</code>加载：<code>() =&gt; import(&#39;/path/to/application.js&#39;)</code></p>
</li>
<li><p>激活函数<br>第3个参数要求是一个纯函数(只依赖参数，不产生副作用), 根据 location.path决定哪个应用被激活。<br>single-spa根据顶级路由查找应用，每个应用自己处理自身的子路由。<br>支持通配符方式配置：’/users/:userId/profile’<br>支持多路径方式配置：[‘/pathname/#/hash’, ‘/app1’]</p>
<p>包含以下情况</p>
<blockquote>
<p>1、<code>hashchange or popstate</code>事件触发时<br>  2、<code>pushState or replaceState</code>被调用时<br>  3、在single-spa上手动调用[<code>triggerAppChange</code>] 方法<br>  4、<code>checkActivityFunctions</code>方法被调用时</p>
</blockquote>
</li>
<li><p>自定义属性<br>第4个参数：参数会传给single-spa的 <code>lifecycle</code>函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">singleSpa.registerApplication(&#123;</span><br><span class="line">  name: <span class="string">&#x27;myApp&#x27;</span>,</span><br><span class="line">  app: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;src/myApp/main.js&#x27;</span>),</span><br><span class="line">  activeWhen: [<span class="string">&#x27;/myApp&#x27;</span>, <span class="function">(<span class="params">location</span>) =&gt;</span> location.pathname.startsWith(<span class="string">&#x27;/some/other/path&#x27;</span>)],</span><br><span class="line">  customProps: &#123;</span><br><span class="line">    some: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">singleSpa.registerApplication(&#123;</span><br><span class="line">  name: <span class="string">&#x27;myApp&#x27;</span>,</span><br><span class="line">  app: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;src/myApp/main.js&#x27;</span>),</span><br><span class="line">  activeWhen: [<span class="string">&#x27;/myApp&#x27;</span>, <span class="function">(<span class="params">location</span>) =&gt;</span> location.pathname.startsWith(<span class="string">&#x27;/some/other/path&#x27;</span>)],</span><br><span class="line">  <span class="comment">// 函数时，参数1：应用名：myapp， 参数2： window.location</span></span><br><span class="line">  customProps: <span class="function">(<span class="params">name, location</span>) =&gt;</span> (&#123;</span><br><span class="line">    some: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>最后调用 <code>singleSpa.start()</code><br><code>start()</code> 方法，必须被single-spa的配置文件调用, 这样应用才会真的被挂载。 在start被调用之前，应用先被下载，但不会初始化/挂载/卸载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; start &#125; <span class="keyword">from</span> <span class="string">&#x27;single-spa&#x27;</span>;</span><br><span class="line"><span class="comment">/*在注册应用之前调用start意味着single-spa可以立即安装应用，无需等待单页应用的任何初始设置。*/</span></span><br><span class="line">start();</span><br><span class="line"><span class="comment">// 注册应用。。。。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同时注册两个路由<br>一个path的变动，同时两个应用被激活?? 可以。</p>
</li>
</ul>
<div>需要一个id，这个id的以single-spa-application前缀开头，后面接着你的应用的名字。比如，如果你的应用名字叫做app-name，就创建一个id为 single-spa-application:app-name的div。

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;single-spa-application:app-name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;single-spa-application:other-app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="构建应用"><a href="#构建应用" class="headerlink" title="构建应用"></a>构建应用</h3><p>single-spa 应用与普通的单页面是一样的，只不过它没有HTML页面。在一个single-spa中，有N多被注册的应用，这些应用可以框架不同，自己维护自己的路由，只需要挂载便可以渲染自己的页面及功能。<br>“挂载”(mounted)的概念指的是被注册的应用内容是否已展示在DOM上。我们可通过应用的activity function来判断其是否已被挂载。未挂载前，一直休眠。</p>
<p><strong>创建并注册应用</strong><br>要添加一个应用，首先需要注册该应用。一旦应用被注册后，必须在其入口文件(entry point)实现下面提到的各个生命周期函数。</p>
<p><strong>生命周期</strong></p>
<ul>
<li><strong>下载(loaded)</strong>: 注册的应用在第1次 activity时开始下载，下载过程中尽可能执行少的操作，如果需要下载时执行的操作，可以放到子应用入口文件中。</li>
<li>**初始化(bootstrap/initialized)**：required 第1次被挂载前执行一次</li>
<li><strong>被挂载(mounted)</strong> required 应用被激活时执行，会根据当前url激活主路由，创建dom,监听事件，render等，子路由的改变（如:hashchange 或 popstate）不会再触发，需要应用自己处理</li>
<li><strong>卸载(unmounted)</strong> required 应用由激活变为未激活时触发，会清理挂载应用的dom,event,内存，全局变量，消息订阅等</li>
<li><strong>被移除（unloaded）</strong> 可选 无代表应用无需被移除，移除的应用，下次激活时，会重新初始化。可以实现 热下载。</li>
</ul>
<blockquote>
<p>注：<br>1、bootstrap, mount, and unmount的实现是必须的，unload则是可选的<br>2、生命周期函数必须有返回值，可以是Promise或者async函数<br>3、如果导出的是函数数组而不是单个函数，这些函数会被依次调用，对于promise函数，会等到resolve之后再调用下一个函数<br>4、如果 single-spa 未启动，各个应用会被下载，但不会被初始化、挂载或卸载。</p>
</blockquote>
<p><strong>超时配置</strong><br>millis: 最终控制台输出的警告毫秒数<br>warningMillis: 警告每隔多少毫秒输出一次</p>
<p><strong>切换应用时的过渡</strong><br>在生命周期函数中自己实现过滤效果<br>demo:<br><a href="https://github.com/frehner/singlespa-transitions">https://github.com/frehner/singlespa-transitions</a><br><a href="https://github.com/reactjs/react-transition-group">https://github.com/reactjs/react-transition-group</a></p>
<h3 id="旧项目迁移至single-spa"><a href="#旧项目迁移至single-spa" class="headerlink" title="旧项目迁移至single-spa"></a>旧项目迁移至single-spa</h3><h4 id="拆分应用"><a href="#拆分应用" class="headerlink" title="拆分应用"></a>拆分应用</h4><p>前端系统应用</p>
<ul>
<li><strong>1、一个代码仓库, 一个build包</strong><br>优点：容易部署，有单一版本控制的优点（monorepo）<br>不足：项目越大时，打包越慢；构建部署在捆绑在一起，不能临时发版</li>
<li><strong>2、NPM包</strong><br>优点：开发熟悉，易实现；发布到npm前可以分别打包<br>不足：父应用必须重装子应用重新构建部署</li>
<li><strong>2、动态加载模块</strong><br>优点：灵活，代码独立<br>不足：搭建难度稍大<br>实现：<ol>
<li>web服务器，创建动态脚本加载子应用正确版本；</li>
<li>使用模块加载,如： systemJs在浏览器动态下载并执行js</li>
</ol>
</li>
</ul>
<h4 id="迁移现在应用"><a href="#迁移现在应用" class="headerlink" title="迁移现在应用"></a>迁移现在应用</h4><blockquote>
<p>三步<br>  1、创建一个single-spa配置<br>  2、将spa应用转为注册应用<br>  3、调整html，使用single-spa配置生效</p>
</blockquote>
<p><strong>1、实现生命周期</strong><br>single-spa 生态系统 包含了single-spa对大部分框架的支持<br><a href="https://single-spa.js.org/docs/ecosystem/">https://single-spa.js.org/docs/ecosystem/</a><br>自己实现，就需要在 <code>unmount</code> 中，能够清理其 DOM 节点，DOM 事件侦听（所有的事件侦听，尤其是 hashchange 和 popstate）以及释放内存。</p>
<p><strong>2、解决css、font、script依赖问题</strong><br>现有spa应用转为无html应用后，这些资源依赖问题都需要解决：一种方案全部打包到js中; 其他方案呢？</p>
<h4 id="沙箱-Parcels"><a href="#沙箱-Parcels" class="headerlink" title="沙箱 Parcels"></a>沙箱 Parcels</h4><p>single-spa的一个高级特性，与框架无关，api与注册应用一致，不同的是：parcel组件需要手动挂载，而不是通过 activity 方法被动激活。在不熟悉它之前，尽量不要用。</p>
<p><strong>示例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parcel 的实现</span></span><br><span class="line"><span class="keyword">const</span> parcelConfig = &#123;</span><br><span class="line">  <span class="function"><span class="title">bootstrap</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用某个框架来创建和初始化dom</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">unmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用某个框架卸载dom，做其他的清理工作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如何挂载parcel</span></span><br><span class="line"><span class="keyword">const</span> domElement = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;place-in-dom-to-mount-parcel&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> parcelProps = &#123;domElement, <span class="attr">customProp1</span>: <span class="string">&#x27;foo&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> parcel = singleSpa.mountRootParcel(parcelConfig, parcelProps)</span><br><span class="line"><span class="comment">// parcel 被挂载，在mountPromise中结束挂载</span></span><br><span class="line">parcel.mountPromise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;finished mounting parcel!&#x27;</span>)</span><br><span class="line">  <span class="comment">// 如果我们想重新渲染parcel，可以调用update生命周期方法，其返回值是一个 promise</span></span><br><span class="line">  parcelProps.customProp1 = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> parcel.update(parcelProps)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在此处调用unmount生命周期方法来卸载parcel. 返回promise</span></span><br><span class="line">  <span class="keyword">return</span> parcel.unmount()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>Pacel配置</strong><br>一个parcel只是一个由3到4个方法组成的对象。每个方法返回的都是一个prmise。 生命周期与应用基本一致。</p>
<ul>
<li>初始化(Bootstrap) 在parcel第一次挂载前调用一次</li>
<li>挂载(mount) 在mountParcel方法被调用且parcel未挂载时触发，一般会创建DOM元素、初始化事件监听等，从而为用户提供展示内容。</li>
<li>卸载(unmount) parcel已经被挂载，且满足下列某个条件：1、unmount()被调用; 2、父parcel或者应用被卸载</li>
<li>更新(Update) 可选  调用parcel.update()时触发，使用者调用前需确认parcel已实现</li>
</ul>
<h3 id="single-spa的API"><a href="#single-spa的API" class="headerlink" title="single-spa的API"></a>single-spa的API</h3><p>参考文档: <a href="https://zh-hans.single-spa.js.org/docs/api">https://zh-hans.single-spa.js.org/docs/api</a></p>
<h3 id="single-spa的扩展"><a href="#single-spa的扩展" class="headerlink" title="single-spa的扩展"></a>single-spa的扩展</h3><p>一般来说，微前端需要解决的问题分为两大类：</p>
<p><strong>1、应用的加载与切换</strong><br><strong>2、应用的隔离与通信</strong></p>
<p>应用的加载与切换需要解决的问题包括：<strong>路由问题、应用入口、应用加载</strong>；应用的隔离与通信需要解决的问题包括：<strong>js隔离、css样式隔离、应用间通信。</strong></p>
<p>single-spa很好地解决了路由和应用入口两个问题，但并没有解决应用加载问题，而是将该问题暴露出来由使用者实现（一般可以用system.js或原生script标签来实现）；qiankun在此基础上封装了一个应用加载方案（即<strong>import-html-entry</strong>），并给出了js隔离、css样式隔离和应用间通信三个问题的解决方案，同时提供了预加载功能。</p>
<h4 id="single-spa原理"><a href="#single-spa原理" class="headerlink" title="single-spa原理"></a>single-spa原理</h4><p><img src= "/img/loading.gif" data-src="single-spa%E5%8E%9F%E7%90%86.png" alt="single-spa原理"></p>
<p><strong>应用入口</strong><br>single-spa采用的是协议入口，即只要实现了single-spa的入口协议规范，它就是可加载的应用。single-spa的规范要求应用入口必须暴露出以下三个生命周期钩子函数，且必须返回Promise，以保证single-spa可以注册回调函数：<br><img src= "/img/loading.gif" data-src="single-spa%E5%BA%94%E7%94%A8%E5%85%A5%E5%8F%A3.png" alt="single-spa应用入口"></p>
<p><strong>应用加载</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;systemjs-importmap&quot;</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;imports&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;app1&quot;</span>: <span class="string">&quot;http://localhost:8080/app1.js&quot;</span>,</span><br><span class="line">      <span class="string">&quot;app2&quot;</span>: <span class="string">&quot;http://localhost:8081/app2.js&quot;</span>,</span><br><span class="line">      <span class="string">&quot;single-spa&quot;</span>: <span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/single-spa/4.3.7/system/single-spa.min.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">... <span class="comment">// system.js的相关依赖文件</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 加载single-spa</span></span><br><span class="line">  System.import(<span class="string">&#x27;single-spa&#x27;</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> singleSpa = res;</span><br><span class="line">    <span class="comment">// 注册子应用</span></span><br><span class="line">    singleSpa.registerApplication(<span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">      () =&gt; System.import(<span class="string">&#x27;app1&#x27;</span>),</span><br><span class="line">      location =&gt; location.hash.startsWith(<span class="string">`#/app1`</span>);</span><br><span class="line">    );</span><br><span class="line">    singleSpa.registerApplication(<span class="string">&#x27;app2&#x27;</span>,</span><br><span class="line">      () =&gt; System.import(<span class="string">&#x27;app2&#x27;</span>),</span><br><span class="line">      location =&gt; location.hash.startsWith(<span class="string">`#/app2`</span>);</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 启动single-spa</span></span><br><span class="line">    singleSpa.start();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// single-spa 的start方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  started = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (opts &amp;&amp; opts.urlRerouteOnly) &#123;</span><br><span class="line">    setUrlRerouteOnly(opts.urlRerouteOnly);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isInBrowser) &#123;</span><br><span class="line">    reroute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>single-spa的弊端:<br>首先我们必须手动实现应用加载逻辑，挨个罗列子应用需要加载的资源，这在大型项目里是十分困难的（特别是使用了文件名hash时）；另外它只能以js文件为入口，无法直接以html为入口，这使得嵌入子应用变得很困难，也正因此，single-spa不能直接加载jQuery应用。<br>single-spa只是负责把应用加载到一个页面中，至于应用能否协同工作，是很难保证的</p>
<h4 id="qiankun解决方案"><a href="#qiankun解决方案" class="headerlink" title="qiankun解决方案"></a>qiankun解决方案</h4><p><a href="https://github.com/umijs/qiankun">https://github.com/umijs/qiankun</a></p>
<p><strong>1、应用加载</strong><br>使用npm插件  import-html-entry</p>
<blockquote>
<p>主要方法：importHTML(url, opts = {})<br>简单点说：importHtml 通过fetch获取远程的脚本、样式文件内容， 然后通过正则表达式，把js,css提取出来，放到各自的数组里，js能过eval执行，并导出供其他模块调用<br><img src= "/img/loading.gif" data-src="import-html.png" alt="import-html"></p>
</blockquote>
<p><strong>2、css,js隔离</strong></p>
<ul>
<li>通过importHtml 加载html并把外部样式转为内部样式(使用类个shandow dom 或 vue scope)方式， 实现样式隔离</li>
<li>execScripts方法: 为应用生成一个window的代理对象，作为参数传入，以保证不影响全局window; 在ie11通过快照方式实现隔离<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正常实现js隔离</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span>, <span class="built_in">arguments</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// execScripts</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span>, <span class="built_in">arguments</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>.proxy)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4、应用通信</strong><br><img src= "/img/loading.gif" data-src="%E5%BA%94%E7%94%A8%E9%80%9A%E4%BF%A1.png" alt="应用通信"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基座中</span></span><br><span class="line"><span class="keyword">import</span> &#123; initGlobalState, MicroAppStateActions &#125; <span class="keyword">from</span> <span class="string">&#x27;qiankun&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> actions: MicroAppStateActions = initGlobalState(initialState);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> actions;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子应用中监听</span></span><br><span class="line">actions.onGlobalStateChange (globalState, oldGlobalState) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子应用中修改</span></span><br><span class="line">actions.setGlobalState(...);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="webpack5-模块联邦-VS-single-spa"><a href="#webpack5-模块联邦-VS-single-spa" class="headerlink" title="webpack5 模块联邦 VS single-spa"></a>webpack5 模块联邦 VS single-spa</h3><p>模块联邦: webpack 受打包工具 和 生态的限制，<br><img src= "/img/loading.gif" data-src="%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6.png" alt="模块联邦"><br>single-spa: 已经有一些成熟的解决方案：qiankun &amp; 京东的MicroApp<br><img src= "/img/loading.gif" data-src="single-spa.png" alt="single-spa"></p>
<p>京东出品微前端框架MicroApp介绍与落地实践<br><a href="https://mp.weixin.qq.com/s/6A6TqQpWgN1_KoxUMx3FFw">https://mp.weixin.qq.com/s/6A6TqQpWgN1_KoxUMx3FFw</a><br>QA:</p>
<h4 id="如何在应用程序间共享状态"><a href="#如何在应用程序间共享状态" class="headerlink" title="如何在应用程序间共享状态"></a>如何在应用程序间共享状态</h4><p>1、建议尽量避免应用共享状态，如果出现，可以优先考虑重新划分应用的边界<br>2、实现方案：</p>
<ol>
<li>创建可以缓存请求及其响应的共享API请求库。如果同一个API被多个应用重复命中，则使用缓存数据。 </li>
<li>将共享状态公开为导出，其他的库可以导入它。可观测值(如：RxJS) 在这里很有用，因为他们能够将新值流式传输给订阅服务器。 </li>
<li>使用custom browser events来交流。 </li>
<li>使用cookies， local/session storage或其他能够存取状态的工具。</li>
</ol>
<p>参考文档：<br><a href="https://single-spa.js.org/">https://single-spa.js.org/</a><br><a href="https://single-spa.js.org/docs/examples/">https://single-spa.js.org/docs/examples/</a></p>
<p><a href="https://github.com/systemjs/systemjs">https://github.com/systemjs/systemjs</a><br>SystemJS &gt;=3 已实现IE11的polyfill 目前已到 6.10.1</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>微前端</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端地图技术</title>
    <url>/2021/03/30/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9C%B0%E5%9B%BE%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>介绍地图之前我们首先了解它的基本组成。相信大家都了解拼图游戏的原理，把一张大图切割成若干小块，然后按照一定的规则拼接起来。地图的原理也是一样。我搜罗的目前移动端比较常见的绘制地图的方法，与大家分享。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>互联网地图服务商的在线地图都通过瓦片的方式提供，称为瓦片地图服务。最常见的地图瓦片是图片格式的，现在有的地图服务商也提供了矢量的瓦片数据，然后在用户端使用Canvas渲染成图片，如node-canvas实现百度地图个性化底图绘制。<br>在进行地图开发时，为获取特定经纬度所在区域的瓦片和获取瓦片上像素点对应的经纬度，经常需要进行经纬度坐标与瓦片坐标、像素坐标的相互转换。</p>
<h3 id="主要经纬度坐标系"><a href="#主要经纬度坐标系" class="headerlink" title="主要经纬度坐标系"></a>主要经纬度坐标系</h3><p>地球本身是个椭球体, 要把它以平面的方式绘制在一个矩形上也真的不好办, 现在有不少绘制的方式但是都有各自的优缺点, 感兴趣的朋友可以查查看具体的细节, 我这里就简单介绍下比较常见的方式；</p>
<ol>
<li><p><strong>经纬度EPSG：4326</strong><br>也就是地图的默认坐标；现在球体上定义好经纬度, 然后在正方形纸上画出刻度, 对应的绘制；</p>
</li>
<li><p><strong>墨卡托投影(EPSG：3785 )</strong><br>把地球放在一个圆筒里面, 假设地球内部有个光源, 那么地球在圆柱上的投影就是地图</p>
</li>
<li><p><strong>WGS84坐标</strong><br>WGS-84 坐标是一个国际的标准，一般卫星导航，原始的 GPS 设备中的数据都是采用这一坐标系。国外的 GoogleMap、OpenStreetMap、MapBox、OpenLayer 等采用的都是这一坐标。</p>
</li>
<li><p><strong>火星坐标系</strong><br>火星坐标是国家测绘局为了国家安全在原始坐标的基础上（国际标准的经纬度坐标是WGS84）进行偏移得到的坐标，基本国内的电子地图、导航设备都是采用的这一坐标系或在这一坐标的基础上进行二次加密得到的。<br>火星坐标的真实名称应该是 GCJ-02 坐标，基本上所有的国内的电子地图采用的都是火星坐标系甚至 Google 地图中国部分都特意为中国政府做了偏移。</p>
</li>
<li><p><strong>百度坐标</strong><br>由于国内的电子地图都要至少使用火星坐标进行一次加密，百度直接就任性一些，直接自己又研究了一套加密算法，来了个 二次加密，这就是我们所熟知的百度坐标 BD-09，当然只有百度地图使用的是百度坐标。</p>
</li>
</ol>
<p>国际标准的经纬度坐标是WGS84，Open Street Map、外国版的Google Map都是采用WGS84；高德地图使用的坐标系是GCJ-02；百度地图使用的坐标系是BD-09。高德地图和百度地图都提供了在线的单向坐标转换接口，将其他坐标系换化到自己的坐标系，但这种转换受限于http url请求字段长度和网络请求延迟，批量处理并不实用。离线相互转换可以通过开源JavaScript库coordtransform实现，误差在10米左右。<br>虽然各地图服务商经纬度坐标系不同，但某一互联网地图的经纬度坐标与瓦片坐标相互转换只与该地图商的墨卡托投影和瓦片编号的定义有关，跟地图商采用的大地坐标系标准无关。</p>
<h3 id="WEB墨卡托投影介绍"><a href="#WEB墨卡托投影介绍" class="headerlink" title="WEB墨卡托投影介绍"></a>WEB墨卡托投影介绍</h3><p>墨卡托投影是正轴等角圆柱投影，由荷兰地图学家墨卡托于1596年创立。其投影方式为：假想一个与地轴方向一致的圆柱切或割于地球，按等角条件，将经纬网投影到圆柱上，按圆柱面展开为平面后，即得本投影。WEB墨卡托辅助球投影(EPSG: 3857)是将球面墨卡托投影公式运用于椭球面坐标的投影计算，为计算简单和实现方便，WEB墨卡托投影假设地球为球体，其半径取为WGS84椭球的长半轴半径6,378,137.0米，这样理论上精度可以控制在0.33%之内。该投影坐标原点位于赤道和本初子午线的交点，经线和经线之间相互平行且间隔相等，对应的经度±180度其范围是±20,037,508.34米。其投影纬线和纬线之间也相互平行，间隔从赤道开始向两级逐渐增大，为便于计算机处理，提高显示效率，取地球纬度范围也是±20,037,508.34米，使地图呈正方形，经过反算可得其对应的纬度范围是±85.05度 。</p>
<p>WEB墨卡托投影在2005年发布的谷歌地图中首次使用，考虑到相互之间的平台兼容，随后跟进的微软BING MAPS、在线地图服务公司的MAPQUEST MAPS、雅虎公司的YAHOO MAPS均采用了谷歌地图的WEB墨卡托地图投影方式。</p>
<h3 id="瓦片切割和瓦片坐标"><a href="#瓦片切割和瓦片坐标" class="headerlink" title="瓦片切割和瓦片坐标"></a>瓦片切割和瓦片坐标</h3><p>用户通过浏览器使用谷歌地图时，看到的是一张铺面整个窗口的地图图片。但是实际上，这张大的地图图片是由多个尺寸相同(通常是256 × 256像素)的小图片按照既定规则无缝拼接而成的。这些小图片就是栅格瓦片(简称瓦片)，瓦片按照如图2所示的金字塔结构组织，每张瓦片都可以通过细节等级LOD级别、列号、行号三个要素唯一标记。瓦片地图金子塔模型是一种多分辨率层次模型，从瓦片金字塔的顶层开始，分辨率越来越高，瓦片数量越来越多，但每个层次表示的地理范围不变,例如当LOD级别为0时，整个地图就只有一个256 × 256像素的瓦片组成，当LOD级别为1时，地图分裂为4个瓦片，这4个瓦片排列成两列两行，依此类推，每放大一倍，每一块小瓦片都分裂为四块。因此当缩放等级为n时，地图分裂为2n × 2n个瓦片，这些瓦片排列成2n行2n列，按照从左到右，从上到下的顺序给瓦片编号，即可以通过瓦片LOD级别、列号、行号定位瓦片。目前基本上所有的在线栅格地图均采用了瓦片地图的存储方式 。</p>
<p>*** 地图瓦片具有以下特点：**</p>
<ul>
<li><ol>
<li>具有唯一的瓦片等级（Level）和瓦片坐标编号（tileX, tileY）。</li>
</ol>
</li>
<li><ol start="2">
<li>瓦片分辨率为256$\times$256。</li>
</ol>
</li>
<li><ol start="3">
<li>最小的地图等级是0，此时世界地图只由一张瓦片组成。</li>
</ol>
</li>
<li><ol start="4">
<li>瓦片等级越高，组成世界地图的瓦片数越多，可以展示的地图越详细。</li>
</ol>
</li>
<li><ol start="5">
<li>某一瓦片等级地图的瓦片是由低一级的各瓦片切割成的4个瓦片组成，形成了瓦片金字塔。</li>
</ol>
</li>
</ul>
<p>瓦片坐标和经纬度坐标之间存在关系，而这层关系是通过后端接口加密处理并且一一映射后的，有自己的计算公式</p>
<ul>
<li>坐标转换图解<br><img src= "/img/loading.gif" data-src="66.png" alt="示例"></li>
</ul>
<h3 id="瓦片地图等级范围"><a href="#瓦片地图等级范围" class="headerlink" title="瓦片地图等级范围"></a>瓦片地图等级范围</h3><p>瓦片地图等级范围反映了地图可缩放的程度。<br>虽然最小的瓦片等级是0，但是部分地图并不提供0级或其他较小瓦片等级的地图，因为此时的世界地图将会很小，不能铺满用户设备窗口。<br>经过实际测试，各地图服务商的瓦片等级和测试链接如下：</p>
<ul>
<li><p>百度图片瓦片的层级是[3~18] <a href="http://online1.map.bdimg.com/onlinelabel/?qt=tile&amp;x=49310&amp;y=10242&amp;z=18">http://online1.map.bdimg.com/onlinelabel/?qt=tile&amp;x=49310&amp;y=10242&amp;z=18</a></p>
</li>
<li><p>百度主页的层级是[3~19] <a href="http://map.baidu.com/">http://map.baidu.com/</a></p>
</li>
<li><p>高德图片瓦片的层级是[1~19] <a href="http://wprd03.is.autonavi.com/appmaptile?style=7&amp;x=427289&amp;y=227618&amp;z=19">http://wprd03.is.autonavi.com/appmaptile?style=7&amp;x=427289&amp;y=227618&amp;z=19</a></p>
</li>
<li><p>高德地图官网介绍的高德地图层级：</p>
</li>
<li><p>获取当前地图缩放级别,在PC上，默认取值范围为[3,18]；在移动设备上，默认取值范围为[3-19]</p>
</li>
<li><p>谷歌地图瓦片层级是[0~21] <a href="http://mt2.google.cn/vt/lyrs=m@167000000&amp;hl=zh-CN&amp;gl=cn&amp;x=1709157&amp;y=910472&amp;z=21&amp;s=Galil">http://mt2.google.cn/vt/lyrs=m@167000000&amp;hl=zh-CN&amp;gl=cn&amp;x=1709157&amp;y=910472&amp;z=21&amp;s=Galil</a></p>
</li>
</ul>
<p>下图是百度地图的一个瓦片图片展示：</p>
<p><img src= "/img/loading.gif" data-src="44.png" alt="示例"></p>
<ul>
<li>瓦片等级由2的次方来划分的，即1到4，4到16，16到<br>如图示意：<br><img src= "/img/loading.gif" data-src="33.jpg" alt="示例"></li>
</ul>
<p><strong>需要注意的问题</strong></p>
<ul>
<li>瓦片像素坐标的起始点</li>
</ul>
<ol>
<li>高德地图、谷歌地图的瓦片坐标起点在左上角，像素坐标（pixelX, pixelY）在瓦片中的起点为左上角。</li>
<li>百度地图中，像素坐标（pixelX, pixelY）的起点为左下角。</li>
</ol>
<h3 id="地图控件设计和实现"><a href="#地图控件设计和实现" class="headerlink" title="地图控件设计和实现"></a>地图控件设计和实现</h3><p>离线的、实时的二维电子地图需要首先获取地图的栅格瓦片数据，然后按照地图的投影方式和瓦片的组织规则，在OpenGL图形渲染环境中根据用户交互信息读取和渲染瓦片，以多个瓦片进行无缝拼接成为用户可见的电子地图。二维电子地图从结构组成上需要包括用户交互处理模块、栅格瓦片读取模块、地图渲染绘制模块以及为进行瓦片数据处理的瓦片处理工具。</p>
<ol>
<li><p>交互处理模块负责响应用户的地图平移、缩放、测距等交互操作，这些操作将被封装成地图显示信息(地图显示范围、LOD等级等)用于驱动地图渲染模块进行地图的更新显示；</p>
</li>
<li><p>地图渲染绘制模块首先根据当前地图显示范围、LOD等级等信息计算需要加载显示的瓦片单元，并且将瓦片单元加入到一个瓦片队列用于驱动栅格瓦片读取模块加载栅格瓦片，然后从带索引标识的加载完毕的瓦片集合中获取瓦片信息并以OpenGL图形渲染技术绘制和显示地图瓦片。由于实时性要求，地图渲染绘制模块工作在一个单独的渲染线程中；</p>
</li>
<li><p>栅格瓦片读取模块依次读取需要加载的瓦片单元信息，从地图数据包中读取对应的瓦片数据，然后将结果加入到已加载瓦片集合供地图渲染绘制模块使用。为避免读取仿真数据拖慢地图渲染绘制的速度，瓦片读取模块也工作在一个独立的线程中；</p>
</li>
<li><p>瓦片处理工具功能是将根据指定的地图覆盖范围、细节等级LOD级别范围等参数，对分散在不同目录下的地图栅格瓦片进行处理，最终生成一个单一文件的地图数据包。</p>
</li>
</ol>
<h4 id="地图数据包的文件格式"><a href="#地图数据包的文件格式" class="headerlink" title="地图数据包的文件格式"></a>地图数据包的文件格式</h4><p>通过地图批量下载工具下载的电子地图瓦片是JPG或PNG格式的图片，其中第一级目录表示瓦片的LOD等级，第二级目录名称表示瓦片所在的列号，第三级文件名称是瓦片所在的行号，由于瓦片文件分散在不同的目录下，在渲染和绘制时如果用户进行了缩放、平移等操作，则程序将需要频繁的进行瓦片数据加载和卸载，如果每次加载瓦片都需要进行一次比较耗时的文件打开或关闭操作，则会影响整个地图控件渲染绘制和交互响应的实时性。</p>
<p>为此可以将所有的地图瓦片打包到一个文件中，形成一个单一文件的地图数据包，然后在地图控件启动时打开地图数据包文件，之后每次需要加载瓦片时都从地图数据包中读取，就可以大大加快地图瓦片加载的速度，提高地图交互响应的实时性。根据需求，地图数据包的文件格式由三个部分组成，分别是文件头、瓦片数据和索引数据。</p>
<ol>
<li><p>文件头：包括地图数据包的文件版本、瓦片数据缩放范围(即对应地图瓦片的LOD级别的最小值和最大值)、瓦片索引数据起始位置在地图数据包文件中的偏移量、瓦片索引数据的长度以及地图边界(分别用经度和纬度的最小值、最大值表示)。</p>
</li>
<li><p>瓦片数据：即将一定覆盖范围和LOD级别内的所有栅格瓦片文件依次集中存放的地图瓦片数据，其存储方法为：依次读取代表地图瓦片的JPG或PNG格式图片文件的内容，然后依次写入到地图数据包的瓦片数据块中。</p>
</li>
<li><p>索引数据：为加载瓦片时快速定位瓦片地址而设计，其内容包括两部分：瓦片ID和瓦片信息，瓦片ID的内容包括瓦片的LOD级别、列号、行号、类型(普通地图、卫星地图或者地形图)，瓦片信息的内容包括瓦片数据在地图数据包中的偏移量和长度。</p>
</li>
</ol>
<p>通过上述定义，控件加载在地图数据包时，可以首先根据文件头中的索引数据偏移量确定在索引数据在地图数据包文件中位置，然后依次读取索引数据并将其存储起来作为加载地图瓦片的索引。</p>
<h4 id="栅格瓦片读取"><a href="#栅格瓦片读取" class="headerlink" title="栅格瓦片读取"></a>栅格瓦片读取</h4><p>栅格瓦片数据经过瓦片处理工具的处理，分散的瓦片地图数据集被打包成单一的地图数据包文件，当二维电子地图控件启动时，栅格瓦片读取线程随之启动。之后在该线程的每一次循环中程序都按照以下流程进行处理，直至线程随二维电子地图控件关闭而结束：</p>
<ol>
<li><p>在线程循环开始时，首先检查需要加载的瓦片队列是否为空，如果为空，则延迟1毫秒后重新进入线程循环，否则进行步骤2。</p>
</li>
<li><p>从队列中取出一个瓦片，然后依据瓦片标识(包括LOD级别、列号、行号)等信息在索引数据中二分法查找瓦片信息，然后根据瓦片数据在地图数据包中的偏移量和长度，从地图数据包文件中加载指定的瓦片数据。</p>
</li>
<li><p>瓦片数据加载完毕后，将瓦片数据(即栅格图像数据)添加到瓦片集合供地图渲染绘制模块使用，然后再次跳转到步骤1，直至需要加载的瓦片队列处理完毕。</p>
</li>
</ol>
<h4 id="地图渲染绘制"><a href="#地图渲染绘制" class="headerlink" title="地图渲染绘制"></a>地图渲染绘制</h4><p>为保证实时性，地图的渲染绘制也在一个独立的渲染线程中完成，渲染线程的主体是一个渲染循环，在每一次循环中程序均要完成绘制准备、瓦片绘制、瓦片清理等工作：</p>
<p><strong>1. 绘制准备</strong></p>
<p>在绘制准备阶段，首先需要获取控件客户区的大小(即地图显示区域的大小)、当前的LOD级别、窗口中心对应的地图位置等信息，然后计算得到需要参与绘制的瓦片数组。</p>
<ol>
<li><p>首先，已知当前LOD级别n，可以计算瓦片在WEB墨卡托投影坐标下的瓦片的宽度和高度均为T = 2 * 20,037,508.34/2n，由于瓦片像素尺寸为256 × 256，所以可以计算每个像素对应的WEB墨卡托投影坐标下的宽高为L = T/256。</p>
</li>
<li><p>然后，根据窗口中心的WEB墨卡托投影坐标(lon,lat)和控件客户区域的宽度W和高度H，可以计算客户区左上角和右下角对应的地图WEB墨卡托投影下的坐标分别为(wmX_LT, wmY_LT)和(wmX_BR, wmY_BR)，计算代码如下：</p>
</li>
</ol>
<p>double wmX_LT=lon-W*L/2；</p>
<p>double wmY_LT=lat+H*L/2；</p>
<p>double wmX_BR=lon+W*L/2；</p>
<p>double wmY_BR=lat-H*L/2。</p>
<p>最后，分别计算客户区左上角和右下角对应的瓦片列号、行号，部分计算代码如下：</p>
<p>int C1=(int)floor((20037508.34+wmX_LT)/T)；</p>
<p>int L1=(int)floor((20037508.34-wmY_LT)/T)；</p>
<p>int C2=(int)ceil((20037508.34+wmX_BR)/T)；</p>
<p>int L2=(int)ceil((20037508.34-wmY_BR)/T)。</p>
<p>计算完毕后，所有处于C1到C2列、L1到L2行中间的瓦片都需要参与绘制。</p>
<p><strong>2. 瓦片绘制</strong><br>在瓦片绘制阶段，需要依次遍历步骤1计算所得的需要参与显示绘制的瓦片数组，然后对每个瓦片按如下步骤进行绘制显：</p>
<ol>
<li><p>计算瓦片在OpenGL中绘制显示必需的位置信息。</p>
</li>
<li><p>根据瓦片标识从瓦片集合中查找瓦片，如果查找成功，则继续步骤3，否则跳转到步骤4。</p>
</li>
<li><p>根据步骤2查找所得的瓦片像素数据，生成并绑定对应的纹理，然后使用OpenGL绘制在指定位置绘制瓦片，然后跳转到步骤1继续遍历。</p>
</li>
<li><p>将瓦片标识添加到需要加载的瓦片队列，驱动瓦片加载线程进行瓦片数据加载。然后跳转到步骤1继续遍历。</p>
</li>
</ol>
<p><strong>3. 瓦片清理</strong></p>
<p>在瓦片清理阶段，程序需要再次遍历瓦片集合，检查瓦片集合中的瓦片是否需要参与当前的显示绘制(即判断瓦片是否在需要参与显示绘制的瓦片数组中)，如果瓦片不需要参与显示绘制，则释放瓦片纹理和图像数据，并从集合中删除瓦片。</p>
<h3 id="百度地图技术介绍"><a href="#百度地图技术介绍" class="headerlink" title="百度地图技术介绍"></a>百度地图技术介绍</h3><p>简单介绍一个地图的底图的相关知识吧，我们眼中看到的丰富的地图信息，其中组成地图的主要元素，莫过于地图的一张张底图瓦片了。如下图所示，</p>
<p>一般我们打开了一个地图，其实际上可能会像上图一样，由一堆瓦片组成。1，2，3，4表示不同的瓦片。 而某一张瓦片如下图所示<br>在线地址：<a href="http://developer.baidu.com/map/custom/">http://developer.baidu.com/map/custom/</a> </p>
<h3 id="百度地图底图绘制技术现状"><a href="#百度地图底图绘制技术现状" class="headerlink" title="百度地图底图绘制技术现状"></a>百度地图底图绘制技术现状</h3><p>要想绘制上面所示的底图，目前现在主要有两类技术</p>
<ul>
<li><p><strong>栅格：</strong> 也就是传意义的图片技术，在server端把图片画好。浏览器使用node-canvas实现百度地图个性化底图绘制标签拼出来</p>
</li>
<li><p><strong>矢量：</strong>在浏览器使用canvas技术，将矢量的数据，在浏览器完成渲染。它最大的问题在于：只支持高端浏览器</p>
</li>
</ul>
<p>百度地图，目前两种技术都已经实现，如果大家使用的是mapapi,在高端浏览器下打开，你会发现，他是使用canvas绘制的。<br>其中的地图底图在IE678等浏览器下，就是使用node-canvas在后端绘制出来的,获取当前绘制经纬度，之后通过接口调用瓦片，<br>经纬度坐标与瓦片坐标、像素坐标的相互转换，以平面坐标为中间量进行转换。主要代码为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bmap为百度JavaScript API V2.0的地图对象</span></span><br><span class="line">  <span class="function"><span class="title">lnglatToPoint</span>(<span class="params">longitude, latitude</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> projection = <span class="keyword">new</span> BMap.MercatorProjection();</span><br><span class="line">    <span class="keyword">let</span> lnglat = <span class="keyword">new</span> BMap.Point(longitude, latitude);</span><br><span class="line">    <span class="keyword">let</span> point = projection.lngLatToPoint(lnglat);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      pointX: point.x,</span><br><span class="line">      pointY: point.y</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">pointToLnglat</span>(<span class="params">pointX, pointY</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> projection = <span class="keyword">new</span> BMap.MercatorProjection();</span><br><span class="line">    <span class="keyword">let</span> point = <span class="keyword">new</span> BMap.Pixel(pointX, pointY);</span><br><span class="line">    <span class="keyword">let</span> lnglat = projection.pointToLngLat(point);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      lng: lnglat.lng,</span><br><span class="line">      lat: lnglat.lat</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://developer.baidu.com/map/jsdemo.htm#a1_2">http://developer.baidu.com/map/jsdemo.htm#a1_2</a></p>
<p>有兴趣可以使用不同的浏览器打开看看就可以看出来。</p>
<p>如图所示</p>
<p><img src= "/img/loading.gif" data-src="55.jpg" alt="示例"></p>
<h3 id="canvas绘制图片的优点"><a href="#canvas绘制图片的优点" class="headerlink" title="canvas绘制图片的优点"></a>canvas绘制图片的优点</h3><ul>
<li>1.它允许我们使用canvas的语法和接口写成的js代码，放在server跑。</li>
<li>2.减少大量的DOM操作可以大大提升性能。</li>
</ul>
<p>如介绍</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Canvas = <span class="built_in">require</span>(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line">  , canvas = <span class="keyword">new</span> Canvas(<span class="number">200</span>,<span class="number">200</span>)</span><br><span class="line">  , ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.font = <span class="string">&#x27;30px Impact&#x27;</span>;</span><br><span class="line">ctx.rotate(<span class="number">.1</span>);</span><br><span class="line">ctx.fillText(<span class="string">&quot;Awesome!&quot;</span>, <span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> te = ctx.measureText(<span class="string">&#x27;Awesome!&#x27;</span>);</span><br><span class="line">ctx.strokeStyle = <span class="string">&#x27;rgba(0,0,0,0.5)&#x27;</span>;</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.lineTo(<span class="number">50</span>, <span class="number">102</span>);</span><br><span class="line">ctx.lineTo(<span class="number">50</span> + te.width, <span class="number">102</span>);</span><br><span class="line">ctx.stroke();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;node-canvas实现百度地图个性化底图绘制&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>目前使用canvas的原因有以下几点：</p>
<ol>
<li>百度地图已经很好的实现使用canvas技术在浏览器完成渲染。</li>
</ol>
<p>　　并有不错的展现效果和性能，在移动端体验更好。因为矢量的数据比请求图片的体积要小的多</p>
<ol start="2">
<li>在canvas的方案下，已经实现个性化底图的绘制效果</li>
</ol>
<p>　　底图绘制由样式+矢量数据组成。只要修改替换样式文件，就可以实现个性化地图的渲染。</p>
<ol start="3">
<li>低端浏览器如IE6-8等浏览器，是不支持canvas功能的。</li>
</ol>
<p>　　展现地图底图，必须使用栅格图实现。需要有后端技术来生成底图</p>
<ol start="4">
<li>由于不样的样式要求得到不同的底图。就需要图片是实时绘制的，而且要求性能必须好</li>
</ol>
<p>在线地址：<a href="http://api.map.baidu.com/customimage/tile?x=788&amp;y=293&amp;z=12&amp;customid=midnight">http://api.map.baidu.com/customimage/tile?x=788&amp;y=293&amp;z=12&amp;customid=midnight</a><br>可以看的出来，速度是很快的。<br><img src= "/img/loading.gif" data-src="22.png" alt="示例"><br>(9个瓦片生成的大图)  </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://en.wikipedia.org/wiki/Tile_Map_Service">瓦片地图服务</a></li>
<li><a href="http://www.cnblogs.com/well1010/articles/baidu-map-node-canvas.html">node-canvas实现百度地图个性化底图绘制</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_517eed9f0102w4rm.html">地图投影的N种姿势</a></li>
<li><a href="http://www.cnblogs.com/jz1108/archive/2011/07/02/2095376.html">百度地图API详解之地图坐标系统</a></li>
<li><a href="http://lbs.amap.com/api/javascript-api/reference/map/">高德地图层级</a></li>
</ol>
]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title>组件封装概论</title>
    <url>/2021/01/27/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<p>大家好，今天我们来谈谈前端每个人都在写的东西，组件。</p>
<p>在当下react和vue这么流行的大环境下，相信你一定写过组件。如果你感觉你是职场小白，只从github或者npm下载过一些组件使用，自己没有写过，那么你就错了，你一定写过。因为往大一点说，一个页面可以是一个组件，往小了说，一个按钮也是一个组件，你写的区别只在于它的扩展性是不是好，通用性是不是强。所以，首先不要畏惧，我们每个人其实都在写组件，今天的分享，就是如何让我们更好的写组件</p>
<h3 id="一、需求分析-构思组件"><a href="#一、需求分析-构思组件" class="headerlink" title="一、需求分析-构思组件"></a>一、需求分析-构思组件</h3><p>从接手项目，带你开启组件封装第一步：</p>
<h4 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a><strong>1. 需求分析</strong></h4><p>拿到项目之后，这里以一个新项目为例，首先，全局概览。看一下这个页面总共分几部分。各个部分之间有什么相同之处，这里举例（边距：考虑封装一个共有的盒子、色系：考虑用父元素继承的方式获取、title、排列方式、图文规划、功能区块等）；初步划分功能，列出几个可能要封装的组件。<br><img src= "/img/loading.gif" data-src="1.png" alt="示例"></p>
<h4 id="2-综合考虑"><a href="#2-综合考虑" class="headerlink" title="2. 综合考虑"></a><strong>2. 综合考虑</strong></h4><p>联系其他页面，再次分类，调整组件的分类，尽可能做到组件公用，扩张组件的可配置项（例如，title文案前可能有icon图标，尾部可能有更多箭头，文案等，尽可能完善这个组件）。</p>
<h4 id="3-归置组件"><a href="#3-归置组件" class="headerlink" title="3. 归置组件"></a><strong>3. 归置组件</strong></h4><p>综合页面需求及过往经验，将组件划分为<strong>基础组件</strong>和<strong>业务组件</strong>。</p>
<p>针对不同类型组件，有不同的封装要求。公共类组件，可配置项一定要多，即要活，放哪里都可以用。业务类组件，可以适当地写死一些东西，因为确定这个组件是轻易不会变动的，例如（流程说明、提示楼层、价格楼层等）<br><img src= "/img/loading.gif" data-src="2.png" alt="示例"></p>
<h4 id="4-使用说明"><a href="#4-使用说明" class="headerlink" title="4. 使用说明"></a><strong>4. 使用说明</strong></h4><p>封装好的组件，最好有使用说明，有使用demo最好，使小白只要粘贴代码，就可以跑起来，首先增加使用者的自信心，可以轻易看到组件（默认样式及功能可以展示与使用）。</p>
<h3 id="二、组件封装要求"><a href="#二、组件封装要求" class="headerlink" title="二、组件封装要求"></a>二、组件封装要求</h3><p>组件封装，需要有一些强制的要求，才能保证我们的组件库在日益壮大的同时，不会因为各种不统一和零散化，导致组件库越来越难维护。</p>
<h4 id="1-关于组件规模"><a href="#1-关于组件规模" class="headerlink" title="1. 关于组件规模"></a><strong>1. 关于组件规模</strong></h4><ul>
<li><strong>基础组件：</strong>被拆解的很零散的组件；例如一个按钮、一个input框、一个title、一个盒子</li>
</ul>
<p>一般而言，一些基础的、使用频率比较高的组件，适合做成‘零散型’组件，即一个小的单位，例如，一个toast,一个input，一个btn一个置顶按钮等。但是越是‘零散’的组件，其可配置项越要灵活，功能性越要完善；包括样式、入参等。<br><strong>优点：</strong>可使用范围广，通用性、扩展性强。<br><strong>缺点：</strong>组件很小，只能局部使用，需要和页面其他元素联动使用。</p>
<ul>
<li><strong>模块组件：</strong>归整的很完善的组件；例如一个完整的轮播图、一个完整的筛选项、一个分页list。</li>
</ul>
<p>相对于基础组件，为了更高效的开发，我们有时候会把业务性比较强，功能比较统一的一些‘大型模块’封装为一个组件。例如整个筛选功能，整个分页加载。整个图文混排等‘模块’，封装为一个组件。</p>
<p><strong>优点：</strong>组件功能完善，不需要组装配合，直接可以构建成完整的页面，开发效率高。<br><strong>缺点：</strong>业务定制化程度高，相对来说，可配置项少。</p>
<h4 id="2-关于class命名"><a href="#2-关于class命名" class="headerlink" title="2. 关于class命名"></a><strong>2. 关于class命名</strong></h4><ol>
<li><p> <strong>语义化</strong><br>命名一定要语义化，让使用的人看到类名，就知道这个是组件的那个元素。（例如title_icon  title_more_btn）<br>禁止使用中文拼写，要求英文翻译。</p>
</li>
<li><p><strong>风格统一</strong><br>同一个组件，命名一定要风格一致。（下划线、短横杠、驼峰式）</p>
</li>
<li><p><strong>业务分类</strong><br>业务性强的组件，class命名的时候paimai_button_small</p>
</li>
<li><p><strong>功能分类</strong><br>组件公用性强的，使用公用class命名，例如confim_submit_button</p>
</li>
</ol>
<h4 id="3-关于样式书写"><a href="#3-关于样式书写" class="headerlink" title="3. 关于样式书写"></a><strong>3. 关于样式书写</strong></h4><ol>
<li><p><strong>百分比</strong><br>内部样式用100%来处理，外部套一个父盒子，父盒子的宽高使用传入样式</p>
</li>
<li><p><strong>作用域</strong><br>样式书写最好使用父套子的方式，给类名加权重和作用域，以保证绝对的样式‘内部性’。</p>
</li>
<li><p><strong>容错</strong><br>样式也要有容错，不能差几像素，就乱了，这里指用flex布局，不要写死宽高。</p>
</li>
<li><p><strong>禁忌写死</strong><br>样式避免使用！important写死样式。</p>
</li>
<li><p><strong>范围</strong><br>必要时使用最大限制max或者min，防止外部没有定义，宽高超出组件内部。</p>
</li>
<li><p><strong>托底</strong><br>书写托底的默认样式，且风格保持一致。<br>我们定义页面一级父盒子，padding的留白统一为25像素。</p>
</li>
<li><p><strong>语言</strong><br>建议统一使用scss书写，虽然目前组件库内部webpack配置会处理好几种css语言，但是，为统一代码，目前建议使用scss。</p>
</li>
</ol>
<h4 id="4-关于mock数据结构"><a href="#4-关于mock数据结构" class="headerlink" title="4. 关于mock数据结构"></a><strong>4. 关于mock数据结构</strong></h4><ol>
<li><p><strong>大众化</strong><br>数据结构大众化。即数据类型符合一般渲染逻辑；例如：轮播图使用数组结构、基本信息使用对象、图片地址使用字符串等</p>
</li>
<li><p><strong>容错处理</strong><br>内部数据结构要紧凑、稳固，接收外部传入参数时，做各种格式化处理，此处包括（托底，容错，类型判断，防止因外部输入格式不对导致组件内部报错）。<br>例如：入参是数组的要求，就需要判断来源数据类型，不是数组的，格式化为数组，不可以格式化的，直接走托底。</p>
</li>
<li><p><strong>可扩展</strong><br>为后续组件扩展留余地，不把数据结构写的太死。例如二位数组处理，数据分组格式化等。</p>
</li>
</ol>
<h4 id="5-关于变量参数"><a href="#5-关于变量参数" class="headerlink" title="5. 关于变量参数"></a><strong>5. 关于变量参数</strong></h4><ol>
<li><p><strong>语义化</strong><br>例如：size，表示组件的大小）<br><img src= "/img/loading.gif" data-src="4.png" alt="示例"></p>
</li>
<li><p><strong>多参</strong><br>只供组件内部使用的变量，可以内部定义。尽可能多的由外部传入参数，因为这样可以尽可能的做到可配置。</p>
</li>
<li><p><strong>托底值</strong><br>不管是内部定义参数，还是外部传参都必须有默认值，即托底逻辑处理，不要存在必传参数，必要时做提示处理。</p>
</li>
</ol>
<h4 id="6-关于方法暴露"><a href="#6-关于方法暴露" class="headerlink" title="6. 关于方法暴露"></a><strong>6. 关于方法暴露</strong></h4><ol>
<li><p><strong>内部方法暴露</strong><br>尽可能多的暴露方法，关于内部的一些方法定义，如果可以使组件更具灵活性，可以考虑将内部方法暴露出来。例如：功能强大的swiper组件，就暴露了很多内部定义的方法，供用户灵活的定制自己的组件。<br><img src= "/img/loading.gif" data-src="5.png" alt="示例"></p>
</li>
<li><p><strong>业务逻辑不要有</strong><br>在方法中，一切业务逻辑不要有，尽可能的、可配置的透传参数，以便父级元素做数据处理。</p>
</li>
<li><p><strong>命名</strong><br>方法名称命名标准：<br>点击事件  **Click<br>格式化方法  **Format<br>初始化方法  **Init<br>方法名称不怕长，就怕看不懂功能，分不清你我</p>
</li>
</ol>
<h3 id="三、示例解析"><a href="#三、示例解析" class="headerlink" title="三、示例解析"></a>三、示例解析</h3><h4 id="1-放大镜组件（vue）"><a href="#1-放大镜组件（vue）" class="headerlink" title="1.放大镜组件（vue）"></a>1.放大镜组件（vue）</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/yanghongmeiwang/imgcart/master/piczoom/piczoom.png" alt="组件示例"></p>
<ul>
<li>组件内部代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;magnifier-box&quot;</span> :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;vertical?&#x27;vertical&#x27;:&#x27;&#x27;&quot;</span> :ref=<span class="string">&quot;id&quot;</span> @mousemove=<span class="string">&quot;mousemove&quot;</span> @mouseover=<span class="string">&quot;mouseover&quot;</span> @mouseleave=<span class="string">&quot;mouseleave&quot;</span>&gt;</span><br><span class="line">    &lt;img v-show=<span class="string">&quot;showImg&quot;</span> :src=<span class="string">&quot;imgUrl&quot;</span> alt=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;mouse-cover&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>


<ul>
<li>组件变量定义</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    scale: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    scalebox: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    url: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    bigUrl: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    scroll: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      id: <span class="literal">null</span>,</span><br><span class="line">      cover: <span class="literal">null</span>,</span><br><span class="line">      imgbox: <span class="literal">null</span>,</span><br><span class="line">      imgwrap: <span class="literal">null</span>,</span><br><span class="line">      orginUrl: <span class="literal">null</span>,</span><br><span class="line">      bigImgUrl: <span class="literal">null</span>,</span><br><span class="line">      bigOrginUrl: <span class="literal">null</span>,</span><br><span class="line">      imgUrl: <span class="literal">null</span>,</span><br><span class="line">      img: <span class="literal">null</span>,</span><br><span class="line">      canvas: <span class="literal">null</span>,</span><br><span class="line">      ctx: <span class="literal">null</span>,</span><br><span class="line">      rectTimesX: <span class="number">0</span>,</span><br><span class="line">      rectTimesY: <span class="number">0</span>,</span><br><span class="line">      imgTimesX: <span class="number">0</span>,</span><br><span class="line">      imgTimesY: <span class="number">0</span>,</span><br><span class="line">      init: <span class="literal">false</span>,</span><br><span class="line">      step: <span class="number">0</span>,</span><br><span class="line">      bigStep: <span class="number">0</span>,</span><br><span class="line">      vertical: <span class="literal">false</span>,</span><br><span class="line">      showImg: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">var</span> $chars = <span class="string">&#x27;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&#x27;</span>;    <span class="comment">/****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/</span></span><br><span class="line">    <span class="keyword">var</span> maxPos = $chars.length</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      str += $chars.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * maxPos));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.id = str</span><br><span class="line">    <span class="built_in">this</span>.imgUrl = <span class="built_in">this</span>.url</span><br><span class="line">    <span class="built_in">this</span>.orginUrl = <span class="built_in">this</span>.url</span><br><span class="line">    <span class="built_in">this</span>.bigImgUrl = <span class="built_in">this</span>.bigUrl</span><br><span class="line">    <span class="built_in">this</span>.bigOrginUrl = <span class="built_in">this</span>.bigUrl</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    url: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.imgUrl = val</span><br><span class="line">      <span class="built_in">this</span>.orginUrl = val</span><br><span class="line">      <span class="built_in">this</span>.initTime()</span><br><span class="line">    &#125;,</span><br><span class="line">    bigUrl: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.bigImgUrl = bigUrl</span><br><span class="line">      <span class="built_in">this</span>.bigOrginUrl = bigUrl</span><br><span class="line">      <span class="built_in">this</span>.initTime()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.initTime()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    initTime () &#123;</span><br><span class="line">      <span class="built_in">this</span>.init = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">let</span> box = <span class="built_in">this</span>.$refs[<span class="built_in">this</span>.id]</span><br><span class="line">      <span class="built_in">this</span>.imgbox = box</span><br><span class="line">      <span class="built_in">this</span>.cover = box.querySelector(<span class="string">&#x27;.mouse-cover&#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.cover.style.width = (<span class="built_in">this</span>.imgbox.offsetWidth / <span class="built_in">this</span>.scale) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.cover.style.height = (<span class="built_in">this</span>.imgbox.offsetHeight / <span class="built_in">this</span>.scale) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.cover.style.left = <span class="string">&#x27;-100%&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.cover.style.top = <span class="string">&#x27;-100%&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.imgwrap = box.querySelector(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">      <span class="keyword">let</span> imgsrc;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.bigImgUrl) &#123;</span><br><span class="line">        imgsrc = <span class="built_in">this</span>.bigImgUrl</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        imgsrc = <span class="built_in">this</span>.imgUrl</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.img = <span class="keyword">new</span> Image()</span><br><span class="line">      <span class="built_in">this</span>.img.src = imgsrc</span><br><span class="line">      <span class="built_in">this</span>.img.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertical = <span class="built_in">this</span>.img.width &lt; <span class="built_in">this</span>.img.height</span><br><span class="line">        <span class="built_in">this</span>.init = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.canvas) &#123;</span><br><span class="line">        <span class="built_in">this</span>.canvas.parentNode.removeChild(<span class="built_in">this</span>.canvas)</span><br><span class="line">        <span class="built_in">this</span>.canvas = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.canvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.canvas.className = <span class="string">&#x27;mouse-cover-canvas&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.canvas.style.position = <span class="string">&#x27;absolute&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.canvas.style.left = <span class="built_in">this</span>.imgbox.offsetLeft + <span class="built_in">this</span>.imgbox.offsetWidth + <span class="number">10</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.canvas.style.top = <span class="built_in">this</span>.imgbox.offsetTop + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.canvas.style.border = <span class="string">&#x27;1px solid #eee&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.canvas.style.zIndex = <span class="string">&#x27;99999&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.canvas.height = <span class="built_in">this</span>.imgbox.offsetHeight * <span class="built_in">this</span>.scalebox</span><br><span class="line">      <span class="built_in">this</span>.canvas.width = <span class="built_in">this</span>.imgbox.offsetWidth * <span class="built_in">this</span>.scalebox</span><br><span class="line">      <span class="built_in">this</span>.canvas.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.imgbox.parentNode.append(<span class="built_in">this</span>.canvas)</span><br><span class="line">      <span class="built_in">this</span>.ctx = <span class="built_in">this</span>.canvas.getContext(<span class="string">&quot;2d&quot;</span>)</span><br><span class="line">      <span class="built_in">this</span>.ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">this</span>.canvas.width, <span class="built_in">this</span>.canvas.height)</span><br><span class="line">    &#125;,</span><br><span class="line">    mousemove (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.init) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> _this = <span class="built_in">this</span></span><br><span class="line">      <span class="comment">//获取实际的offset</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">offset</span> (<span class="params">curEle</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> totalLeft = <span class="literal">null</span>, totalTop = <span class="literal">null</span>, par = curEle.offsetParent;</span><br><span class="line">        <span class="comment">//首先加自己本身的左偏移和上偏移</span></span><br><span class="line">        totalLeft += curEle.offsetLeft;</span><br><span class="line">        totalTop += curEle.offsetTop</span><br><span class="line">        <span class="comment">//只要没有找到body，我们就把父级参照物的边框和偏移也进行累加</span></span><br><span class="line">        <span class="keyword">while</span> (par) &#123;</span><br><span class="line">          <span class="keyword">if</span> (navigator.userAgent.indexOf(<span class="string">&quot;MSIE 8.0&quot;</span>)===-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//累加父级参照物的边框</span></span><br><span class="line">            totalLeft += par.clientLeft;</span><br><span class="line">            totalTop += par.clientTop</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//累加父级参照物本身的偏移</span></span><br><span class="line">          totalLeft += par.offsetLeft;</span><br><span class="line">          totalTop += par.offsetTop</span><br><span class="line">          par = par.offsetParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          left: totalLeft,</span><br><span class="line">          top: totalTop</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">getXY</span> (<span class="params">eve</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          x: eve.clientX - (_this.cover.offsetWidth / <span class="number">2</span>),</span><br><span class="line">          y: eve.clientY - (_this.cover.offsetHeight / <span class="number">2</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> oEvent = e || event;</span><br><span class="line">      <span class="keyword">let</span> pos = getXY(oEvent);</span><br><span class="line">      <span class="keyword">let</span> imgwrap = offset(<span class="built_in">this</span>.imgwrap)</span><br><span class="line">      <span class="keyword">let</span> range = &#123;</span><br><span class="line">        minX: imgwrap.left,</span><br><span class="line">        maxX: imgwrap.left + <span class="built_in">this</span>.imgwrap.offsetWidth - <span class="built_in">this</span>.cover.offsetWidth,</span><br><span class="line">        minY: imgwrap.top - <span class="built_in">document</span>.documentElement.scrollTop,</span><br><span class="line">        maxY: imgwrap.top - <span class="built_in">document</span>.documentElement.scrollTop + <span class="built_in">this</span>.imgwrap.offsetHeight - <span class="built_in">this</span>.cover.offsetHeight,</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (pos.x &gt; range.maxX) &#123;</span><br><span class="line">        pos.x = range.maxX</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (pos.x &lt; range.minX) &#123;</span><br><span class="line">        pos.x = range.minX</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (pos.y &gt; range.maxY) &#123;</span><br><span class="line">        pos.y = range.maxY</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (pos.y &lt; range.minY) &#123;</span><br><span class="line">        pos.y = range.minY</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.cover.style.left = pos.x + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.cover.style.top = pos.y + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">this</span>.imgwrap.offsetWidth, <span class="built_in">this</span>.imgwrap.offsetHeight);</span><br><span class="line">      <span class="keyword">let</span> startX = pos.x - (imgwrap.left - <span class="built_in">document</span>.documentElement.scrollLeft),</span><br><span class="line">        startY = pos.y - (imgwrap.top - <span class="built_in">document</span>.documentElement.scrollTop)</span><br><span class="line">      <span class="comment">// 重新初始化图片的宽高</span></span><br><span class="line">      <span class="built_in">this</span>.rectTimesX = (<span class="built_in">this</span>.imgbox.offsetWidth / <span class="built_in">this</span>.scale) / <span class="built_in">this</span>.imgwrap.offsetWidth,</span><br><span class="line">      <span class="built_in">this</span>.rectTimesY = (<span class="built_in">this</span>.imgbox.offsetHeight / <span class="built_in">this</span>.scale) / <span class="built_in">this</span>.imgwrap.offsetHeight</span><br><span class="line">      <span class="built_in">this</span>.imgTimesX = <span class="built_in">this</span>.img.width / <span class="built_in">this</span>.imgwrap.offsetWidth,</span><br><span class="line">      <span class="built_in">this</span>.imgTimesY = <span class="built_in">this</span>.img.height / <span class="built_in">this</span>.imgwrap.offsetHeight</span><br><span class="line">      <span class="built_in">this</span>.ctx.drawImage(</span><br><span class="line">        <span class="built_in">this</span>.img,</span><br><span class="line">        startX * <span class="built_in">this</span>.imgTimesX,</span><br><span class="line">        startY * <span class="built_in">this</span>.imgTimesY,</span><br><span class="line">        <span class="built_in">this</span>.img.width * <span class="built_in">this</span>.rectTimesX,</span><br><span class="line">        <span class="built_in">this</span>.img.height * <span class="built_in">this</span>.rectTimesY,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="built_in">this</span>.canvas.width,</span><br><span class="line">        <span class="built_in">this</span>.canvas.height</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">    mouseover (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.init) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      e = e || event</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.scroll) &#123;</span><br><span class="line">        e.currentTarget.addEventListener(<span class="string">&#x27;mousewheel&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">          ev.preventDefault()</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">        e.currentTarget.addEventListener(<span class="string">&#x27;DOMMouseScroll&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">          ev.preventDefault()</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.cover.style.display = <span class="string">&#x27;block&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.canvas.style.display = <span class="string">&#x27;block&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mouseleave () &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.init) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.cover.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.canvas.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>组件样式书写</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;style lang=<span class="string">&quot;scss&quot;</span> scoped&gt;</span><br><span class="line">  .magnifier-box&#123;</span><br><span class="line">    width: <span class="number">100</span>%;</span><br><span class="line">    height: <span class="number">100</span>%;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    position: relative;</span><br><span class="line">    img&#123;</span><br><span class="line">      width: <span class="number">100</span>%;</span><br><span class="line">      <span class="comment">/*height: 100%;*/</span></span><br><span class="line">    &#125;;</span><br><span class="line">    .mouse-cover&#123;</span><br><span class="line">      position: fixed;</span><br><span class="line">      background-color: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.5</span>);</span><br><span class="line">      cursor:move</span><br><span class="line">    &#125;;</span><br><span class="line">    .mouse-cover-canvas&#123;</span><br><span class="line">      position:fixed;</span><br><span class="line">      left:<span class="number">100</span>%;</span><br><span class="line">      top:<span class="number">0</span>;</span><br><span class="line">      width:<span class="number">100</span>%;</span><br><span class="line">      height:<span class="number">100</span>%;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;.vertical&#123;</span><br><span class="line">      img&#123;</span><br><span class="line">        height: <span class="number">100</span>%;</span><br><span class="line">        width: auto</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-消息框组件（eleemnt-ui）"><a href="#2-消息框组件（eleemnt-ui）" class="headerlink" title="2.消息框组件（eleemnt-ui）"></a>2.消息框组件（eleemnt-ui）</h4><ul>
<li>组件Dom</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;transition name=<span class="string">&quot;msgbox-fade&quot;</span>&gt;</span><br><span class="line">    &lt;div</span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;el-message-box__wrapper&quot;</span></span><br><span class="line">      tabindex=<span class="string">&quot;-1&quot;</span></span><br><span class="line">      v-show=<span class="string">&quot;visible&quot;</span></span><br><span class="line">      @click.self=<span class="string">&quot;handleWrapperClick&quot;</span></span><br><span class="line">      role=<span class="string">&quot;dialog&quot;</span></span><br><span class="line">      aria-modal=<span class="string">&quot;true&quot;</span></span><br><span class="line">      :aria-label=<span class="string">&quot;title || &#x27;dialog&#x27;&quot;</span>&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;el-message-box&quot;</span> :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;[customClass, center &amp;&amp; &#x27;el-message-box--center&#x27;]&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;el-message-box__header&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;title !== null &amp;&amp;title&quot;</span>&gt;</span><br><span class="line">          &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;el-message-box__title&quot;</span>&gt;</span><br><span class="line">            &lt;div</span><br><span class="line">              :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;[&#x27;el-message-box__status&#x27;, icon]&quot;</span></span><br><span class="line">              v-<span class="keyword">if</span>=<span class="string">&quot;icon &amp;&amp; center&quot;</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;el-message-box__content&quot;</span>&gt;</span><br><span class="line">          &lt;div</span><br><span class="line">            :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;[&#x27;el-message-box__status&#x27;, icon]&quot;</span></span><br><span class="line">            v-<span class="keyword">if</span>=<span class="string">&quot;icon &amp;&amp; !center &amp;&amp; message !== &#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;el-message-box__message&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;message !== &#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">            &lt;slot&gt;</span><br><span class="line">              &lt;div v-<span class="keyword">if</span>=<span class="string">&quot;!dangerouslyUseHTMLString&quot;</span>&gt;</span><br><span class="line">                &lt;em&gt;&#123;&#123; mainMessage &#125;&#125;&lt;/em&gt;</span><br><span class="line">                &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">              &lt;p v-<span class="keyword">else</span> v-html=<span class="string">&quot;message&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">            &lt;/slot&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;el-message-box__input&quot;</span> v-show=<span class="string">&quot;showInput&quot;</span>&gt;</span><br><span class="line">            &lt;el-input</span><br><span class="line">              v-model=<span class="string">&quot;inputValue&quot;</span></span><br><span class="line">              :type=<span class="string">&quot;inputType&quot;</span></span><br><span class="line">              @keydown.enter.native=<span class="string">&quot;handleInputEnter&quot;</span></span><br><span class="line">              :placeholder=<span class="string">&quot;inputPlaceholder&quot;</span></span><br><span class="line">              ref=<span class="string">&quot;input&quot;</span>&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;el-message-box__errormsg&quot;</span> :style=<span class="string">&quot;&#123; visibility: !!editorErrorMessage ? &#x27;visible&#x27; : &#x27;hidden&#x27; &#125;&quot;</span>&gt;&#123;&#123; editorErrorMessage &#125;&#125;&lt;/div&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;el-message-box__btns&quot;</span>&gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            :loading=<span class="string">&quot;cancelButtonLoading&quot;</span></span><br><span class="line">            :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;[ cancelButtonClasses ]&quot;</span></span><br><span class="line">            v-<span class="keyword">if</span>=<span class="string">&quot;showCancelButton&quot;</span></span><br><span class="line">            :round=<span class="string">&quot;roundButton&quot;</span></span><br><span class="line">            size=<span class="string">&quot;small&quot;</span></span><br><span class="line">            @click.native=<span class="string">&quot;handleAction(&#x27;cancel&#x27;)&quot;</span></span><br><span class="line">            @keydown.enter=<span class="string">&quot;handleAction(&#x27;cancel&#x27;)&quot;</span>&gt;</span><br><span class="line">            &#123;&#123; cancelButtonText || t(<span class="string">&#x27;el.messagebox.cancel&#x27;</span>) &#125;&#125;</span><br><span class="line">          &lt;/el-button&gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            :loading=<span class="string">&quot;confirmButtonLoading&quot;</span></span><br><span class="line">            ref=<span class="string">&quot;confirm&quot;</span></span><br><span class="line">            :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;[ confirmButtonClasses ]&quot;</span></span><br><span class="line">            v-show=<span class="string">&quot;showConfirmButton&quot;</span></span><br><span class="line">            :round=<span class="string">&quot;roundButton&quot;</span></span><br><span class="line">            size=<span class="string">&quot;small&quot;</span></span><br><span class="line">            @click.native=<span class="string">&quot;handleAction(&#x27;confirm&#x27;)&quot;</span></span><br><span class="line">            @keydown.enter=<span class="string">&quot;handleAction(&#x27;confirm&#x27;)&quot;</span>&gt;</span><br><span class="line">            &#123;&#123; confirmButtonText || t(<span class="string">&#x27;el.messagebox.confirm&#x27;</span>) &#125;&#125;</span><br><span class="line">          &lt;/el-button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>组件变量定义</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">     modal: &#123;</span><br><span class="line">       <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">     &#125;,</span><br><span class="line">     lockScroll: &#123;</span><br><span class="line">       <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">     &#125;,</span><br><span class="line">     showClose: &#123;</span><br><span class="line">       type: <span class="built_in">Boolean</span>,</span><br><span class="line">       <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">     &#125;,</span><br><span class="line">     closeOnClickModal: &#123;</span><br><span class="line">       <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">     &#125;,</span><br><span class="line">     closeOnPressEscape: &#123;</span><br><span class="line">       <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">     &#125;,</span><br><span class="line">     closeOnHashChange: &#123;</span><br><span class="line">       <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">     &#125;,</span><br><span class="line">     center: &#123;</span><br><span class="line">       <span class="keyword">default</span>: <span class="literal">false</span>,</span><br><span class="line">       type: <span class="built_in">Boolean</span></span><br><span class="line">     &#125;,</span><br><span class="line">     roundButton: &#123;</span><br><span class="line">       <span class="keyword">default</span>: <span class="literal">false</span>,</span><br><span class="line">       type: <span class="built_in">Boolean</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   components: &#123;</span><br><span class="line">     ElInput</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   computed: &#123;</span><br><span class="line">     <span class="function"><span class="title">icon</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; type, iconClass &#125; = <span class="built_in">this</span>;</span><br><span class="line">       <span class="keyword">return</span> iconClass || (type &amp;&amp; typeMap[type] ? <span class="string">`el-icon-<span class="subst">$&#123; typeMap[type] &#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">     &#125;,</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="title">confirmButtonClasses</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">`el-button--primary <span class="subst">$&#123; <span class="built_in">this</span>.confirmButtonClass &#125;</span>`</span>;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="function"><span class="title">cancelButtonClasses</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123; <span class="built_in">this</span>.cancelButtonClass &#125;</span>`</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   methods: &#123;</span><br><span class="line">     <span class="function"><span class="title">doClose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="built_in">this</span>.visible) <span class="keyword">return</span>;</span><br><span class="line">       <span class="built_in">this</span>.visible = <span class="literal">false</span>;</span><br><span class="line">       <span class="built_in">this</span>._closing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">this</span>.onClose &amp;&amp; <span class="built_in">this</span>.onClose();</span><br><span class="line">       messageBox.closeDialog(); <span class="comment">// 解绑</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">this</span>.opened = <span class="literal">false</span>;</span><br><span class="line">       <span class="built_in">this</span>.doAfterClose();</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span>.action) <span class="built_in">this</span>.callback(<span class="built_in">this</span>.action, <span class="built_in">this</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;,</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="title">handleWrapperClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">this</span>.closeOnClickModal) &#123;</span><br><span class="line">         <span class="built_in">this</span>.handleAction(<span class="built_in">this</span>.distinguishCancelAndClose ? <span class="string">&#x27;close&#x27;</span> : <span class="string">&#x27;cancel&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="title">handleInputEnter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">this</span>.inputType !== <span class="string">&#x27;textarea&#x27;</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">this</span>.handleAction(<span class="string">&#x27;confirm&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="title">handleAction</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">this</span>.$type === <span class="string">&#x27;prompt&#x27;</span> &amp;&amp; action === <span class="string">&#x27;confirm&#x27;</span> &amp;&amp; !<span class="built_in">this</span>.validate()) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">this</span>.action = action;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span>.beforeClose === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">         <span class="built_in">this</span>.close = <span class="built_in">this</span>.getSafeClose();</span><br><span class="line">         <span class="built_in">this</span>.beforeClose(action, <span class="built_in">this</span>, <span class="built_in">this</span>.close);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.doClose();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="title">getFirstFocus</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> btn = <span class="built_in">this</span>.$el.querySelector(<span class="string">&#x27;.el-message-box__btns .el-button&#x27;</span>);</span><br><span class="line">       <span class="keyword">const</span> title = <span class="built_in">this</span>.$el.querySelector(<span class="string">&#x27;.el-message-box__btns .el-message-box__title&#x27;</span>);</span><br><span class="line">       <span class="keyword">return</span> btn || title;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="function"><span class="title">getInputElement</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> inputRefs = <span class="built_in">this</span>.$refs.input.$refs;</span><br><span class="line">       <span class="keyword">return</span> inputRefs.input || inputRefs.textarea;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   watch: &#123;</span><br><span class="line">     inputValue: &#123;</span><br><span class="line">       immediate: <span class="literal">true</span>,</span><br><span class="line">       <span class="function"><span class="title">handler</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.$nextTick(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">this</span>.$type === <span class="string">&#x27;prompt&#x27;</span> &amp;&amp; val !== <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="built_in">this</span>.validate();</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;   </span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">       uid: <span class="number">1</span>,</span><br><span class="line">       title: <span class="literal">undefined</span>,</span><br><span class="line">       mainMessage: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       message: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       type: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       iconClass: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       customClass: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       showInput: <span class="literal">false</span>,</span><br><span class="line">       inputValue: <span class="literal">null</span>,</span><br><span class="line">       inputPlaceholder: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       inputType: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">       inputPattern: <span class="literal">null</span>,</span><br><span class="line">       inputValidator: <span class="literal">null</span>,</span><br><span class="line">       inputErrorMessage: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       showConfirmButton: <span class="literal">true</span>,</span><br><span class="line">       showCancelButton: <span class="literal">false</span>,</span><br><span class="line">       action: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       confirmButtonText: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       cancelButtonText: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       confirmButtonLoading: <span class="literal">false</span>,</span><br><span class="line">       cancelButtonLoading: <span class="literal">false</span>,</span><br><span class="line">       confirmButtonClass: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       confirmButtonDisabled: <span class="literal">false</span>,</span><br><span class="line">       cancelButtonClass: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       editorErrorMessage: <span class="literal">null</span>,</span><br><span class="line">       callback: <span class="literal">null</span>,</span><br><span class="line">       dangerouslyUseHTMLString: <span class="literal">false</span>,</span><br><span class="line">       focusAfterClosed: <span class="literal">null</span>,</span><br><span class="line">       isOnComposition: <span class="literal">false</span>,</span><br><span class="line">       distinguishCancelAndClose: <span class="literal">false</span></span><br><span class="line">     &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>组件样式书写参考</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.el-message-box&#123;</span><br><span class="line">    border-radius: 2px;</span><br><span class="line">    em&#123;</span><br><span class="line">      font-size: 14px;</span><br><span class="line">      color: $color-title;</span><br><span class="line">      line-height: 15px;</span><br><span class="line">    &#125;</span><br><span class="line">    p&#123;</span><br><span class="line">      font-size: 12px;</span><br><span class="line">      color: $color-<span class="keyword">default</span>;</span><br><span class="line">      line-height: 15px;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;__title&#123;</span><br><span class="line">      font-size: 14px;</span><br><span class="line">      color: $color-title;</span><br><span class="line">      line-height: 20px;</span><br><span class="line">      font-weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;__header&#123;</span><br><span class="line">      padding: 9px 15px;</span><br><span class="line">      background: $color-bg;</span><br><span class="line">      border-bottom: 1px solid $color-border;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;__headerbtn&#123;</span><br><span class="line">      top: 12px;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;__content&#123;</span><br><span class="line">      padding: 28px 30px;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;__status&#123;</span><br><span class="line">      font-size: 30px;</span><br><span class="line">      margin-right: 10px;</span><br><span class="line">      &amp;.el-icon-warning&#123;</span><br><span class="line">        color: $color-warning;</span><br><span class="line">      &#125;</span><br><span class="line">      &amp;.el-icon-success&#123;</span><br><span class="line">        color: $color-success;</span><br><span class="line">      &#125;</span><br><span class="line">      &amp;.el-icon-info&#123;</span><br><span class="line">        color: $color-info;</span><br><span class="line">      &#125;</span><br><span class="line">      &amp;.el-icon-error&#123;</span><br><span class="line">        color: $color-error;</span><br><span class="line">      &#125;</span><br><span class="line">      &amp;+.el-message-box__message&#123;</span><br><span class="line">        padding-left: 40px;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;__btns&#123;</span><br><span class="line">      margin-top: 12px;</span><br><span class="line">      margin-bottom: 5px;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>




<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>相信任何一个好的组件，都是经过实践历练，调试出来的，开始封装的组件没有那么多功能，没有那么完善不要灰心，坚持用，不好的地方我们可以在使用中改，经过多次使用的组件，一定会慢慢丰富和强健起来。最终可能经过3,5年时间，我们做的的组件库，可以达到项目的70%利用率，同时，我们的开发效率也会大大提高。代码更强健。<br>最后，本文档作为前端组件基本标准，我们会越来越细化它的要求。希望大家一起献计献策，完善我们的组件封装标准。</p>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>组件封装细则</title>
    <url>/2021/03/31/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E7%BB%86%E5%88%99/</url>
    <content><![CDATA[<p>前端组件人人都在用，人人都在封装。目前已知的几个大型开源组件库也并没有给出具体的封装规范。但是根据其开放的组件样式、使用规则等我们也可以参考出一些具体的封装要求。延伸到业务和组件的使用场景，其要求可能又不完全一样。<br>本文章旨在以StoryBook为展示背景条件下，规范出一套基本的前端组件封装要求，提供一套更加适合大众使用的前端组件封装细则，供大家参考。</p>
<h2 id="组件的分类、命名、文件结构"><a href="#组件的分类、命名、文件结构" class="headerlink" title="组件的分类、命名、文件结构"></a>组件的分类、命名、文件结构</h2><h3 id="组件的分类"><a href="#组件的分类" class="headerlink" title="组件的分类"></a><strong>组件的分类</strong></h3><h4 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h4><pre><code> 基础组件可以供多个项目使用，可配置项更多，展示形式及功能更灵活、丰富。
 作为基础组件，可以是业务组件封装的基础，默认的UI可能不能够直接用于项目，但是其功能及提供的配置参数，可以满足我们在此基础组件上封装业务组件。
</code></pre>
<ul>
<li><p><strong>展示组件</strong><br>SrollView、盒子模型、Swiper、提示语等</p>
</li>
<li><p><strong>功能组件</strong><br>confirm弹窗、toast弹窗、全页面蒙层、滚动至顶部、tips、tab、swiper等</p>
</li>
</ul>
<h4 id="业务组件"><a href="#业务组件" class="headerlink" title="业务组件"></a>业务组件</h4><pre><code>业务组件主要是为了能在更少时间更少配置的情况下，快速搭建同一业务条线下相同风格的的页面。减少开发成本，组件的利用率可能不会很高，但是使用成本却大大降低，因为它更贴近业务，包括接口数据格式和字段名称、UI样式等，都可以不单独配置。
</code></pre>
<ul>
<li><p><strong>后台页面组件</strong><br> 后台组件一般设计风格都高度统一，对业务条线区分不细致。封装的组件利用率更高。但是，一般而言，目前开源的组件库，例如element-UI就已经很大部分基础组件可以支持后台系统使用。<br><strong>封装主要针对具有业务特性的组件</strong><br>例如：类目选择、图片上传、视频上传、toast提示、confirm提示等组件</p>
</li>
<li><p><strong>ToC页面组件</strong></p>
<p> <strong>首页组件</strong> 金刚区、瀑布流、公告位、轮播图等<br> <strong>单品页组件</strong> 图片缩放、楼层盒子、流程图、推荐位、详情、视频、倒计时等<br> <strong>列表页组件</strong> 搜索项、地址、多选、单选、价格滑块、地址回填、卡片列表、分页加载等<br> <strong>其他页面</strong>  信息填写、表单提交、地址选择等<br> <strong>公共业务组件</strong> 搜索框、底部tab、空提示、错误提示d等</p>
</li>
</ul>
<h3 id="组件的命名"><a href="#组件的命名" class="headerlink" title="组件的命名"></a><strong>组件的命名</strong></h3><ul>
<li><p><strong>凸显作用</strong></p>
<p>如果作为<strong>基础组件</strong>，命名可以大众，例如：Button、 Toast、Confirm、 Tips、 srollView等<br>如果作为<strong>业务组件</strong>，命名需要有特定开头，例如 ：</p>
<ol>
<li>首页组件-IndexConfirm、IndexSwiper等</li>
<li>单品页组件-ItemSwiper、ItemRecommend、ItemVideo等</li>
<li>如果组件不通用，又分了特定的业务条线，则需要增加业务前缀；例如：PMItemSwiper、PMItemRecommend、PMItemVideo、FangItemSwiper等</li>
</ol>
</li>
<li><p><strong>首字母大些</strong><br>组件的命名需要统一风格，都以大些英文开头</p>
</li>
</ul>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a><strong>文件结构</strong></h3><p>   基于组件的分类和功能，文件结构清晰可以大大提高组件的查找及定位成本。所以，基本的文件结构需要构建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── .storybook                     # 入口文件</span><br><span class="line">├── bin                            # 安装的依赖</span><br><span class="line">├── storybook-static               # 打包后静态资源文件夹</span><br><span class="line">└── src</span><br><span class="line">    ├── api                        # 接口</span><br><span class="line">    ├── assets                     # 静态资源</span><br><span class="line">    ├── components                 # 组件文件夹</span><br><span class="line">        ├── BaseComponent          # 基础组件文件夹</span><br><span class="line">        ├── PMComponent            # 业务组件文件夹1</span><br><span class="line">             ├── CommonComponent   # 业务-公共组件</span><br><span class="line">             ├── IdexComponent     # 业务-首页组件</span><br><span class="line">             ├── ItemComponent     # 业务-单品页组件</span><br><span class="line">             ├── ListComponent     # 业务-列表组件</span><br><span class="line">             ├── OtherComponent    # 业务-其他组件</span><br><span class="line">        ├── FangComponents         # 业务组件文件夹2</span><br><span class="line">    ├── utils                      # 工具文件</span><br><span class="line">    ├── index                      # 入口文件</span><br></pre></td></tr></table></figure>

<h2 id="ClassName命名"><a href="#ClassName命名" class="headerlink" title="ClassName命名"></a>ClassName命名</h2><p>CSS 命名使用 BEM 命名规范，BEM 代表 “块（block）,元素（element）,修饰符（modifier）”</p>
<h3 id="命名模式"><a href="#命名模式" class="headerlink" title="命名模式"></a>命名模式</h3><p>BEM 约定的命名模式为：</p>
<blockquote>
<p>namespace-block__element–modifier</p>
</blockquote>
<ul>
<li> 中划线：    仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号；</li>
<li>__ 双下划线：用来连接块和块的子元素；</li>
<li>– 双中划线：用来描述一个块或者块的子元素的一种状态；<h4 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h4></li>
</ul>
<p>命名空间用来区分组件类别：</p>
<ul>
<li>yp: yolkpie缩写，表示通用组件；</li>
<li>pm: 拍卖业务组件（太长了，要不要换个短点的）；</li>
<li>fang： 房产业务组件（更长…）；<br>…</li>
</ul>
<h4 id="块（block）"><a href="#块（block）" class="headerlink" title="块（block）"></a>块（block）</h4><p>一个块就是一个组件。 块的命名规则如下：</p>
<p>块的名称使用类名，不能是 ID；<br>块的名称与组件类名一致，小写，多个英文单词用小驼峰（如 topSwiper）；<br>块的命名要语义化，如果不是通用的组件，尽量不要占用通用命名（如 list、 item等）；<br>…</p>
<h4 id="元素（element）"><a href="#元素（element）" class="headerlink" title="元素（element）"></a>元素（element）</h4><p>块中的子元素是块的子元素，并且<b>子元素的子元素在 BEM 里也被认为是块的直接子元素</b><br>元素的命名规则如下：</p>
<p>使用 js 控制的元素要以 js 开头；<br>元素的命名也要语义化（比如按钮，要尽量说明功能，推荐使用confirmBtn 而不是 btn）<br>小写，多个英文单词用小驼峰（如 confirmBtn、jsCountdown）<br>…</p>
<p>常见元素命名约定如下：</p>
<p>wrap / container: 包裹容器<br>header: 头部<br>footer: 底部<br>content: 内容<br>title: 标题<br>label: 标签<br>btn: 按钮<br>text: 文本<br>img: 图片<br>icon: 图标<br>input: 输入框<br>…</p>
<h4 id="修饰符（modifier）"><a href="#修饰符（modifier）" class="headerlink" title="修饰符（modifier）"></a>修饰符（modifier）</h4><p>一个修饰符可以理解为一个块的特定状态，标识着它持有一个特定的属性，如按钮的大小及选中状态等<br>修饰符的命名规则如下：</p>
<p>修饰符尽量使用形容词<br>…<br>常见状态命名约定如下：</p>
<ul>
<li>尺寸：small / normal / big</li>
<li>选中状态：selected</li>
<li>激活状态：active / focus</li>
<li>禁用状态：disabled<br>…</li>
</ul>
<h3 id="书写原则"><a href="#书写原则" class="headerlink" title="书写原则"></a>书写原则</h3><p>原则上不要出现两层以上选择器嵌套<br>出现多层嵌套时，有两种处理办法，一种是用命名来解耦，所有类名都为一层，另一种是检查下是否需要创建新块</p>
<p>（1）用命名来解耦</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;yp-block&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;yp-block__header&quot;</span>&gt;</span><br><span class="line">        &lt;h2 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;yp-block__header__title&quot;</span>&gt;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;yp-block__content&quot;</span>&gt;</span><br><span class="line">        &lt;img <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;yp-block__content__img&quot;</span> src=<span class="string">&quot;&quot;</span> /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐（将title和img命名提升到block下）</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;yp-block&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;yp-block__header&quot;</span>&gt;</span><br><span class="line">        &lt;h2 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;yp-block__title&quot;</span>&gt;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;yp-block__content&quot;</span>&gt;</span><br><span class="line">        &lt;img <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;yp-block__img&quot;</span> src=<span class="string">&quot;&quot;</span> /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>（2）创建新块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comments&quot;</span>&gt;</span><br><span class="line">    &lt;h2 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comments__title&quot;</span>&gt;&lt;/h2&gt;</span><br><span class="line">    &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comments__comment&quot;</span>&gt;</span><br><span class="line">        &lt;h3 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comments__comment__title&quot;</span>&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">    &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comments__comment&quot;</span>&gt;</span><br><span class="line">        &lt;h3 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comments__comment__title&quot;</span>&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐（将comment提取为新块）</span></span><br><span class="line">&lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comments&quot;</span>&gt;</span><br><span class="line">    &lt;h2 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comments__title&quot;</span>&gt;&lt;/h2&gt;</span><br><span class="line">    &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comment&quot;</span>&gt;</span><br><span class="line">        &lt;h3 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comment__title&quot;</span>&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">    &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comment&quot;</span>&gt;</span><br><span class="line">        &lt;h3 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comment__title&quot;</span>&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>组件与组件嵌套时通过在子组件上增加 BEM 类名控制子组件样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">&lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comments&quot;</span>&gt;</span><br><span class="line">    &lt;h2 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comments__title&quot;</span>&gt;&lt;/h2&gt;</span><br><span class="line">    &lt;comment <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comments__comment&quot;</span> /&gt;</span><br><span class="line">    &lt;comment <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;paimai-comments__comment&quot;</span> /&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="样式书写"><a href="#样式书写" class="headerlink" title="样式书写"></a>样式书写</h2><ul>
<li><strong>最外层盒子不写宽高，使用自适应 （自适应）</strong></li>
<li>使用父套子的方式，给类名加权重和作用域，以保证绝对的样式‘内部性’</li>
<li>尽可能使用flex布局，不要写死宽高</li>
<li><strong>避免使用！important写死样式</strong></li>
<li>必要时限制max或者min</li>
<li>避免使用标签选择器</li>
<li><strong>有暴露外部的样式书写入口</strong></li>
<li>统一使用scss书写</li>
<li>遵循先盒子主体样式，后渲染样式，即遵循先定位、宽高、display等，再font-size、color、缩进，边框，背景色等书写顺序</li>
<li>可以做适配，例如IPhoneX</li>
<li>避免为0值制定单位，例如用 margin: 0; 而避免使用 margin: 0 px;</li>
<li>对于小于1的值，省略前面的0，例如  .5 代替  0.5</li>
<li>避免过量的使用简写，防止样式覆盖，例如 使用 background-color: red; 代替 background: red; </li>
<li>对于 z-index 的值，在可控范围内，尽量写的小一点，分层级时区分数量级，同一层级，使用同一数量级值,<strong>(除弹窗外，不高于100；弹窗类最高999)</strong></li>
<li>所有的声明都要以分号结尾，最后一个是可选项，但是也要书写，避免出错</li>
<li>每条声明之后，都要有一个空格</li>
<li>声明的花括号应该单独成行，单行声明除外</li>
<li>分区块增加注释分割，<strong>书写顺序符合文档流顺序</strong></li>
<li>书写托底的默认样式</li>
</ul>
<h2 id="外部传参数"><a href="#外部传参数" class="headerlink" title="外部传参数"></a>外部传参数</h2><ul>
<li><strong>1. 数据结构标准化</strong><br>即数据类型符合一般渲染逻辑；例如：轮播图使用数组结构、基本信息使用对象、图片地址使用字符串等</li>
<li><strong>2. 容错处理</strong><br>内部数据结构要紧凑、稳固，接收外部传入参数时，做各种格式化处理，此处包括（托底，容错，类型判断，防止因外部输入格式不对导致组件内部报错），</li>
<li><strong>3. 可扩展</strong><br>为后续组件扩展留余地，不把数据结构写的太死。例如二位数组处理，数据分组格式化等</li>
<li><strong>4. props需要指定类型</strong><br>视情况添加默认值及必填</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">props: [&#39;name&#39;, &#39;style&#39;]</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">props: &#123;</span><br><span class="line"></span><br><span class="line">   name: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#39;&#39;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   style: &#123;</span><br><span class="line">       type: Object,</span><br><span class="line">       require: true</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>5. 避免出现不同属性控制相同功能、样式</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">props: &#123;</span><br><span class="line">   pageCount: Number,</span><br><span class="line">   pageSize: Number,</span><br><span class="line">   total: Number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line"></span><br><span class="line">props: &#123;</span><br><span class="line">   pageSize: Number,</span><br><span class="line">   total: Number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line"></span><br><span class="line">   pageCount() &#123;</span><br><span class="line">       return Math.cell(this.total/this.pageSize) || 0</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>6. 以Object代替基础类型传参数</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">my-button</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span> <span class="attr">bgColor</span>=<span class="string">&quot;green&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">my-button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line"></span><br><span class="line">const style = &#123;</span><br><span class="line"></span><br><span class="line">   color: &#x27;red&#x27;,</span><br><span class="line">    bgColor: &#x27;green&#x27;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">my-button</span> <span class="attr">:style</span>=<span class="string">&quot;style&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">my-button</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h2><ul>
<li><p>语意化（例如：size，表示组件的大小）</p>
</li>
<li><p>建议以_开头 变量名用小驼峰命名法； 如_tabList</p>
</li>
<li><p>要有默认值，需要外部必传的变量可以无默认值，但使用前必须做校验，且给出必要提示：如vue的el属性</p>
</li>
<li><p>组件内使用的定义组件级变量，function 内使用变量只定义在function内</p>
</li>
<li><p>常量 以const 定义，可变变量以 let定义，尽量少用var，防止变量提升引起的问题</p>
</li>
<li><p>对同一变量的操作，逻辑尽量放到一起，易读易理解</p>
</li>
</ul>
<h2 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h2><p><strong>遵从 动-谓-宾 原则</strong></p>
<p>常用动词</p>
<table>
<thead>
<tr>
<th>单词</th>
<th>含义</th>
<th>单词</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>get</td>
<td>获取</td>
<td>set</td>
<td>设置,</td>
</tr>
<tr>
<td>add</td>
<td>增加</td>
<td>remove</td>
<td>删除</td>
</tr>
<tr>
<td>create</td>
<td>创建</td>
<td>destory</td>
<td>移除</td>
</tr>
<tr>
<td>start</td>
<td>启动</td>
<td>stop</td>
<td>停止</td>
</tr>
<tr>
<td>open</td>
<td>打开</td>
<td>close</td>
<td>关闭,</td>
</tr>
<tr>
<td>read</td>
<td>读取</td>
<td>write</td>
<td>写入</td>
</tr>
<tr>
<td>load</td>
<td>载入</td>
<td>save</td>
<td>保存,</td>
</tr>
<tr>
<td>create</td>
<td>创建</td>
<td>destroy</td>
<td>销毁</td>
</tr>
<tr>
<td>begin</td>
<td>开始</td>
<td>end</td>
<td>结束,</td>
</tr>
<tr>
<td>backup</td>
<td>备份</td>
<td>restore</td>
<td>恢复</td>
</tr>
<tr>
<td>import</td>
<td>导入</td>
<td>export</td>
<td>导出,</td>
</tr>
<tr>
<td>split</td>
<td>分割</td>
<td>merge</td>
<td>合并</td>
</tr>
<tr>
<td>inject</td>
<td>注入</td>
<td>extract</td>
<td>提取,</td>
</tr>
<tr>
<td>attach</td>
<td>附着</td>
<td>detach</td>
<td>脱离</td>
</tr>
<tr>
<td>bind</td>
<td>绑定</td>
<td>separate</td>
<td>分离,</td>
</tr>
<tr>
<td>view</td>
<td>查看</td>
<td>browse</td>
<td>浏览</td>
</tr>
<tr>
<td>edit</td>
<td>编辑</td>
<td>modify</td>
<td>修改,</td>
</tr>
<tr>
<td>select</td>
<td>选取</td>
<td>mark</td>
<td>标记</td>
</tr>
<tr>
<td>copy</td>
<td>复制</td>
<td>paste</td>
<td>粘贴,</td>
</tr>
<tr>
<td>undo</td>
<td>撤销</td>
<td>redo</td>
<td>重做</td>
</tr>
<tr>
<td>insert</td>
<td>插入</td>
<td>delete</td>
<td>移除,</td>
</tr>
<tr>
<td>add</td>
<td>加入</td>
<td>append</td>
<td>添加</td>
</tr>
<tr>
<td>clean</td>
<td>清理</td>
<td>clear</td>
<td>清除,</td>
</tr>
<tr>
<td>index</td>
<td>索引</td>
<td>sort</td>
<td>排序</td>
</tr>
<tr>
<td>find</td>
<td>查找</td>
<td>search</td>
<td>搜索,</td>
</tr>
<tr>
<td>increase</td>
<td>增加</td>
<td>decrease</td>
<td>减少</td>
</tr>
<tr>
<td>play</td>
<td>播放</td>
<td>pause</td>
<td>暂停,</td>
</tr>
<tr>
<td>launch</td>
<td>启动</td>
<td>run</td>
<td>运行</td>
</tr>
<tr>
<td>compile</td>
<td>编译</td>
<td>execute</td>
<td>执行,</td>
</tr>
<tr>
<td>debug</td>
<td>调试</td>
<td>trace</td>
<td>跟踪</td>
</tr>
<tr>
<td>observe</td>
<td>观察</td>
<td>listen</td>
<td>监听,</td>
</tr>
<tr>
<td>build</td>
<td>构建</td>
<td>publish</td>
<td>发布</td>
</tr>
<tr>
<td>input</td>
<td>输入</td>
<td>output</td>
<td>输出,</td>
</tr>
<tr>
<td>encode</td>
<td>编码</td>
<td>decode</td>
<td>解码</td>
</tr>
<tr>
<td>encrypt</td>
<td>加密</td>
<td>decrypt</td>
<td>解密,</td>
</tr>
<tr>
<td>compress</td>
<td>压缩</td>
<td>decompress</td>
<td>解压缩</td>
</tr>
<tr>
<td>pack</td>
<td>打包</td>
<td>unpack</td>
<td>解包,</td>
</tr>
<tr>
<td>parse</td>
<td>解析</td>
<td>emit</td>
<td>生成</td>
</tr>
<tr>
<td>connect</td>
<td>连接</td>
<td>disconnect</td>
<td>断开,</td>
</tr>
<tr>
<td>send</td>
<td>发送</td>
<td>receive</td>
<td>接收</td>
</tr>
<tr>
<td>download</td>
<td>下载</td>
<td>upload</td>
<td>上传,</td>
</tr>
<tr>
<td>refresh</td>
<td>刷新</td>
<td>synchronize</td>
<td>同步</td>
</tr>
<tr>
<td>update</td>
<td>更新</td>
<td>revert</td>
<td>复原,</td>
</tr>
<tr>
<td>lock</td>
<td>锁定</td>
<td>unlock</td>
<td>解锁</td>
</tr>
<tr>
<td>check out</td>
<td>签出</td>
<td>check in</td>
<td>签入,</td>
</tr>
<tr>
<td>submit</td>
<td>提交</td>
<td>commit</td>
<td>交付</td>
</tr>
<tr>
<td>push</td>
<td>推</td>
<td>pull</td>
<td>拉,</td>
</tr>
<tr>
<td>expand</td>
<td>展开</td>
<td>collapse</td>
<td>折叠</td>
</tr>
<tr>
<td>begin</td>
<td>起始</td>
<td>end</td>
<td>结束,</td>
</tr>
<tr>
<td>start</td>
<td>开始</td>
<td>finish</td>
<td>完成</td>
</tr>
<tr>
<td>enter</td>
<td>进入</td>
<td>exit</td>
<td>退出,</td>
</tr>
<tr>
<td>abort</td>
<td>放弃</td>
<td>quit</td>
<td>离开</td>
</tr>
<tr>
<td>obsolete</td>
<td>废弃</td>
<td>depreciate</td>
<td>废旧,</td>
</tr>
<tr>
<td>collect</td>
<td>收集</td>
<td>aggregate</td>
<td>聚集</td>
</tr>
</tbody></table>
<ul>
<li><p>驼峰式命名</p>
</li>
<li><p>使用英文拼写</p>
</li>
<li><p>不要自创缩写，不会可以全拼上去，不怕名字长</p>
</li>
<li><p>避免误导，同一组件中不要使用过于相似的命名</p>
</li>
</ul>
<h2 id="方法暴露"><a href="#方法暴露" class="headerlink" title="方法暴露"></a>方法暴露</h2><ol>
<li><p>尽可能多的暴露方法，关于内部的一些方法定义，如果可以使组件更具灵活性，可以考虑将内部方法暴露出来。例如：功能强大的swiper组件，就暴露了很多内部定义的方法，供用户灵活的定制自己的组件</p>
</li>
<li><p>暴露的方法如果接收多个入参，就将入参以对象的方式进行传入，方便扩展</p>
</li>
<li><p>暴露的方法名最好不要与公共方法名重复了，以免混淆</p>
</li>
<li><p>readme里面，写明使用方法</p>
</li>
</ol>
<h2 id="公共资源"><a href="#公共资源" class="headerlink" title="公共资源"></a>公共资源</h2><p>工具类库的方法，使用统一引入方式，即安装引入</p>
<p>公共样式也使用统一引入，不再单独书写</p>
<h3 id="使用工具类库的两种方案"><a href="#使用工具类库的两种方案" class="headerlink" title="使用工具类库的两种方案"></a>使用工具类库的两种方案</h3><h4 id="使用目前已有的-yolkpie-utils-npm包安装到组件库"><a href="#使用目前已有的-yolkpie-utils-npm包安装到组件库" class="headerlink" title="使用目前已有的 @yolkpie/utils npm包安装到组件库"></a>使用目前已有的 @yolkpie/utils npm包安装到组件库</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装依赖包</span></span><br><span class="line">npm i @yolkpie/utils</span><br><span class="line"><span class="comment">// 在项目中引用</span></span><br><span class="line"><span class="keyword">import</span> &#123; addClass &#125; <span class="keyword">from</span> <span class="string">&#x27;@yolkpie/utils&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可能产生的问题是，由于是将各个类型的公共类方法统一打包到utils里面（通过Rollup 将小块代码编译成大块复杂的代码），可读性不高</p>
<h4 id="直接在组件库里建立utils文件，阴影各个类型的公共方法"><a href="#直接在组件库里建立utils文件，阴影各个类型的公共方法" class="headerlink" title="直接在组件库里建立utils文件，阴影各个类型的公共方法"></a>直接在组件库里建立utils文件，阴影各个类型的公共方法</h4><h3 id="工具类库方法介绍"><a href="#工具类库方法介绍" class="headerlink" title="工具类库方法介绍"></a>工具类库方法介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">utils</span><br><span class="line">├── array.js                   # 数组</span><br><span class="line">├── axios-jsonp.js             # axios jsonp跨域</span><br><span class="line">├── bom.js                     # 浏览器对象</span><br><span class="line">├── cache.js                   # 缓存</span><br><span class="line">├── cookies.js                 # cookie</span><br><span class="line">├── dom.js                     # 文档对象</span><br><span class="line">├── event.js                   # 事件</span><br><span class="line">├── fixMask.js                 # 显示弹层时固定背景</span><br><span class="line">├── floatCalculate.js          # 浮点数</span><br><span class="line">├── formatDate.js              # 格式化日期</span><br><span class="line">├── functional.js              # 函数式编程</span><br><span class="line">├── global.js                  # 全局</span><br><span class="line">├── math.js                    # 数值</span><br><span class="line">├── rem.js                     # 移动端适配</span><br><span class="line">├── string.js                  # 字符串</span><br><span class="line">├── tools.js                   # 工具</span><br><span class="line">└── url.js                     # 链接</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1）array.js 数组相关处理函数</p>
<p>2）axios-jsonp.js jsonp跨域数据请求方法</p>
<p>3）bom.js浏览器或系统相关处理函数包含isIphoneX、isSupportWebp、getEnv(获取环境信息)等方法</p>
<p>4）cache.js，缓存，本地存储处理操作封装（sessionStorage和localStorage</p>
<p>5）cookies.js，获取cookie、设置cookie和删除cookie</p>
<p>6）dom.js，dom相关处理函数</p>
<p>7）event.js，包括事件监听器、绑定事件等</p>
<p>8）fixMask.js，移动端浮层内滚动窗体不滚动的JS处理</p>
<p>9）floatCalculate.js ，浮点数计算</p>
<p>10）formatDate.js 日期格式化</p>
<p>11）functional.js 函数式编程相关函数</p>
<p>12）global.js 对象相关处理函数，包括根据键值获取键名、深拷贝等</p>
<p>13）math.js 数字相关处理函数</p>
<p>14）rem.js  移动端尺寸适配</p>
<p>15）string.js 字符串相关处理函数</p>
<p>16）tools.js 一些公共方法，包括throttle和debounce</p>
<p>17）url.js 链接相关处理函数，包括获取链接参数方法等</p>
<h3 id="公共样式"><a href="#公共样式" class="headerlink" title="公共样式"></a>公共样式</h3><p>1）base.scss，一些基础样式</p>
<p>2）flex.scss，flex布局相关样式</p>
<p>3）border.scss，1px像素问题方案</p>
<p>4）font.scss，字体的引入</p>
<p>5）animation，动画</p>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>色彩理论与搭配</title>
    <url>/2020/05/21/%E8%89%B2%E5%BD%A9%E7%90%86%E8%AE%BA%E4%B8%8E%E6%90%AD%E9%85%8D/</url>
    <content><![CDATA[<h1 id="一、色彩的基础理论"><a href="#一、色彩的基础理论" class="headerlink" title="一、色彩的基础理论"></a>一、色彩的基础理论</h1><h2 id="1-色彩是什么"><a href="#1-色彩是什么" class="headerlink" title="1.色彩是什么"></a>1.色彩是什么</h2><p>​        色彩是人脑识别反射光的强弱和不同波长所产生的差异的感觉，与形状同为最基本的视觉反应之一。物体被光线照射，反射光被人脑接受，形成的色彩。总之，没有光照就不存在色彩，而且我们的日常生活中看到的所有色彩都不是物体本身的颜色。颜色本质上并不是物体本身固有的属性，或者更大胆地说，任何事物都是没有颜色的。我们之所以看到一个苹果是红色的，是因为它反射的光线进入我们眼睛，刺激我们的视觉神经，使我们产生了“红色”的知觉。</p>
<p>​        光波是电磁波的一种，电磁波包括X射线、紫外线等很多种，其中人类能够看到的称之为“可见光”。根据可见光的电磁波波长由短到长的顺序，我们可以识别蓝紫色、紫色、青绿色、绿色、黄绿色、黄色、橙色、红色等色彩。光线中包含很多种色彩，但光线本身却是无色的。</p>
<p>​        电磁波中人类肉眼可感知的波长范围被称为”可见光”，可见光的波长约为360-400nm，长波长约为760至830nm，如果波长超过可见光的波长范围（更长或者更短），就超出了人眼所能感知的范围了。</p>
<p><img src= "/img/loading.gif" data-src="%E5%8F%AF%E8%A7%81%E5%85%89.jpg" alt="可见光"></p>
<h2 id="2-色彩的三属性"><a href="#2-色彩的三属性" class="headerlink" title="2.色彩的三属性"></a>2.色彩的三属性</h2><p>色彩有三个属性：色相、明度、纯度。</p>
<p>色相：色相是指色彩的相貌，就是我们通常说的各种颜色，如红、橙、黄、绿、青、蓝、紫等。色相是区别不同彩色的最佳标准，它和色彩的强弱及明暗都没有关系，只是纯粹表示色相相貌的差异。色相是色彩的首要特征，人眼区分色彩的方式就是通过色相区分。</p>
<p><img src= "/img/loading.gif" data-src="%E8%89%B2%E7%9B%B8%E7%8E%AF.png" alt="色相环"></p>
<p>明度：明度是指色彩的明亮程度，在任何一种色彩中添加白色，其明度都会升高。添加黑色，则其明度下降。因此，色彩中明度最高的是白色，明度最低的是黑色，白色-黑色的灰度，则是明度差异的表现。</p>
<p>纯度：是指色彩的鲜艳程度，如新鲜水果的那种鲜艳，艳丽的色彩代表“高纯度”，树枝、泥土等天然染料的那种朴素、淡雅的色彩代表低纯度，同一色相中，纯度最高的色彩被称为纯色。在实际的配色过程中，通过调整纯度，可以使相同的色相形成不同的印象，一般来讲，色彩的纯度越高，越容易形成强劲有力、充满朝气的印象。而纯度越低，越容易形成成熟、稳重的印象。</p>
<p><img src= "/img/loading.gif" data-src="HSB.png" alt="HSB"></p>
<h2 id="3-有彩色和无彩色"><a href="#3-有彩色和无彩色" class="headerlink" title="3.有彩色和无彩色"></a>3.有彩色和无彩色</h2><p>​        色彩大体上可以分为“有彩色”和“无彩色”两类。无彩色是指白色、黑色、灰色中性色，这 三种色彩没有色相属性和纯度属性，只有明度一个属性的色彩。有彩色指的是拥有色彩三属性的全部色彩。</p>
<p>​       无彩色中明度最高的色彩是白色，最低的是黑色。无彩色不含纯度属性，所以在和其他任何色彩搭配时都很和谐，合理恰当地运用无彩色，可以营造时尚和稳重的印象。但是也要注意避免陷入单调、乏味、呆板的印象。</p>
<h2 id="4-色调"><a href="#4-色调" class="headerlink" title="4.色调"></a>4.色调</h2><p>色调是指色彩的浓淡、强弱程度，是通过色彩的明度和纯度综合表现色彩状态的概念。同一色调或者相近色调的色彩搭配，集中了纯度相近的色彩，呈现自然、和谐的效果。色调有很多种，常见的有接近唇色的鲜艳色调、接近白色的浅色调、接近黑色的暗色调等。即使色相不统一，只要色调保持一致的话，画面也能展现统一的配色效果。</p>
<h2 id="5-色彩的情绪"><a href="#5-色彩的情绪" class="headerlink" title="5.色彩的情绪"></a>5.色彩的情绪</h2><p>冷暖色</p>
<p><img src= "/img/loading.gif" data-src="%E5%86%B7%E6%9A%96%E8%89%B2.png" alt="冷暖色"></p>
<p>​       暖色系的色彩可以使人感到温暖，冷色系的色彩可以使人感到寒冷。这一规律在哪儿都适用。但是具体色彩所代表的含义并不是全世界共通的，会因为文化、传统和风土人情而异。但是人类遗传基因中总是存在一些共通的物质，色彩带给人的感觉也不例外。</p>
<p>​       色彩本身是没有情绪的，只是因为不同波长的光通过人的眼睛传到大脑，引起了人们不同的心理感受，所以色彩才有了情绪。每种颜色都会给人独特的心理感受，引起我们不同的情绪，因此在设计过程中色彩情绪是必须要考虑的一个重要元素。</p>
<p>​       比如现在的一些知名品牌。人对于品牌商品的快速印象有90％来仅仅是来自于其色彩，品牌或者品牌商品的颜色是人们接触品牌最直接的视觉呈现，从某种意义上来说意义上来说，色彩是品牌在人们心中整合品牌识别度的第一步。</p>
<p>​       从Hermès标志性的橙到Tiffany蓝，再到Supreme的红白，香奈儿的黑白，Christian Louboutin经典的红底高跟鞋，星巴克的绿色。色彩是品牌独特的DNA。再比如现在互联网中的京东红、淘宝橙。</p>
<p>（1）黑色：沉稳、品质感、收敛、沉默、静寂、悲哀</p>
<p>​        单独使用时黑色可以很容易吸引用户的注意力。和其他颜色搭配使用时可以很好地搭配组合，使用黑色的背景可以非常好的突出页面中的内容，容易出效果，应用场景非常广泛。</p>
<p>​        除了白色之外，黑色是艺术中使用的第一种记录色，即旧石器时代所使用的颜色，它们使用木炭，烧过的骨头或各种粉碎的矿物质。纵观大部分历史，黑色一直是邪恶的象征（如希腊神话地狱），哀悼，悲伤和黑暗。然而，在古埃及，颜色具有保护和生育的积极象征。</p>
<p>​       在不同的时代和不同的文化上，黑色在应用和观念上经历了许多变化。最终这种颜色被革命化，在时尚界占据显着不可替代的地位，迅速成为优雅和简约的象征。</p>
<p><img src= "/img/loading.gif" data-src="%E9%BB%91%E8%89%B2.png" alt="黑色"></p>
<p>（2）白色：干净、纯洁、简洁。</p>
<p>白色是无色的，意思是没有色调的颜色。它已成为许多时代的艺术，历史和文化。事实上，它被记录为艺术中使用的第一种颜色，旧石器时代的艺术家使用白色方解石和粉笔作画。纵观大部分历史，白色已被选为善良、灵性、纯洁、虔诚和神圣的象征。古埃及诸神，希腊诸神，罗马女神都被描绘为身穿白色象征着他们的神圣。</p>
<p>白色被认为是黑色的象征性的反面，两种颜色一起形成善恶的象征，日夜，明暗等。在西方文化中，白色是婚纱礼服的典型色彩，象征着纯真和纯洁，而在许多亚洲文化中，白色是哀悼，悲伤和失落的颜色。 白色也是和平的象征，在战争中白道色旗帜是投降的标志。</p>
<p><img src= "/img/loading.gif" data-src="%E7%99%BD%E8%89%B2.png" alt="白色"></p>
<p>（3）红色：红色是彰显热情的色彩，给人留下强烈的印象，刺激人的情感。红色的特点：热情、躁动、危险、警告。页    面设计中可以在删除提醒、禁止操作功能时使用。</p>
<p>​        信号灯的红色、唇膏的红色、广告传单标题价格的红色以及交通标示的红色等都是纯度最高，色彩鲜明的红色，是最能刺激人类情感的色彩，具有使人兴奋、脉搏跳动加快的功能。（心脏不好的人最好不要使用红色的窗帘或者壁纸）高纯度红色的特征基本不受形状、材质的影响。面积越大、视觉冲击效果越强。红色作为暖色调，也代表了食材的新鲜和美味可口：比如草莓、樱桃等。</p>
<p><img src= "/img/loading.gif" data-src="%E7%BA%A2%E8%89%B2.png" alt="红色"></p>
<p>（4）橙色：温暖、活泼、年轻。</p>
<p>​       红色和黄色之间的颜色就是橙色。既不会像红色那样躁动，又不会像黄色那么灿烂。橙色是欢快活泼的光辉色彩，是暖色系中最温暖的色，它使人联想到金色的秋天，丰硕的果实，是一种富足、快乐而幸福的颜色。</p>
<p>​     橙色稍稍混入黑色或白色，会变成一种稳重、含蓄又明快的暖色，但混入较多的黑色，就成为一种烧焦的色；橙色中加入较多的白色会带来一种甜腻的感觉。</p>
<p>​     橙色明视度高，在工业安全用色中，橙色即是警戒色，如火车头，登山服装，背包，救生衣等。橙色可作餐厅的布置色，据说在餐厅里多用橙色可以增加食欲。</p>
<p>​     橙色与浅绿色和浅蓝色相配，可以构成最响亮、最欢乐的色彩。橙色与淡黄色相配有一种很舒服的过渡感。橙色一般不能与紫色或深蓝色相配，这将给人一种不干净、晦涩的感觉。橙色有不同的色调和深浅，每种都有不同的含义和效果。例如，轻柔的橙色色被认为是甜美，善良和友好的，而更强烈，充满活力的橙色被视为活力，能量和鼓励的代表。比如k12教育中，经常被用作主色调或者辅助色。</p>
<p><img src= "/img/loading.gif" data-src="%E6%A9%99%E8%89%B2.png" alt="橙色"></p>
<p>（5）黄色：阳光、辉煌、醒目、高贵。</p>
<p>​       由于与黄金密切相关，颜色被认为是永恒的和坚不可摧的。黄色与艺术世界有着悠久的关系，梵高等艺术家将其作为标志性的颜色来表达温暖与快乐。黄色是一种能根据色彩和应用而体现出许多想法的颜色。如前所述，它可以象征幸福，阳光，正能量和喜悦。但是，它也可以代表懦弱，背叛，恐怖和疾病。例如有毒有害的标示、医院的垃圾桶。此外，由于黄色是光谱中最明显的颜色，通常用于紧急和警示标志，服装和应用，如交通标志上的黄灯，工程用的大型机器，学生用雨衣，雨鞋等，都使用黄色。如果你需要快速引起注意，可以使用一些黄色。在日本，黄色被认为代表勇气，在墨西哥的某些地区，某些色调可以被认为代表死亡。</p>
<p>当涉及到品牌，黄色可以用来表示一系列的想法。例如，它常常用来表示速度和效率，正如我们可以看到在法拉利和斯普林特这样的品牌中体现的。</p>
<p><img src= "/img/loading.gif" data-src="%E9%BB%84%E8%89%B2.png" alt="黄色"></p>
<p>（6）绿色：健康、大自然、清新、环保、安全。</p>
<p>​       绿色是一种与自然，环境和与大自然有关的所有事物的紧密联系而又独特的色彩。现在非常提倡的环保生活都是采用绿色为主色调，健康无污染。代表着春天，在策划设计春天相关事物活动，可以使用绿色为主色进行设计。绿色是有着安全属性的，在支付、保障方面通常是应用很多的，与红色正好是相反的作用。</p>
<p>在西方国家，绿色被看作是运气、新鲜、嫉妒和贪婪。在中国和日本，绿色被视为新生，青春和希望的颜色。</p>
<p>​       绿色中渗入黄色为黄绿色，它单纯、年轻；绿色中渗入蓝色为蓝绿色，它清秀、豁达。含灰的绿色，仍是一种宁静、平和的色彩，就像暮色中的森林或晨雾中的田野。深绿色和浅绿色相配有一种和谐、安宁的感觉；绿色与白色相配，显得很年轻；浅绿色与黑色相配，显得美丽、大方。绿色与浅红色相配，象征着春天的到来。</p>
<p>（7）蓝色：科技、纯净、清爽、深邃、放松、忧郁</p>
<p>​       蓝色是三原色之一。提到蓝色，往往想到的都是天空和大海。蓝色是永恒的象征，它是最冷的色彩，另外，蓝色也是科技宇宙领域的专属颜色，是理智、效率的代名词，随处可见的企业官网、VI、软件、宣传物料等。像是心理治疗室都是使用蓝色系的环境，就是给用户提供一个放松的环境。</p>
<ul>
<li><p>天蓝：天蓝最浅的蓝，几乎不含有红的痕迹，好像天空的清冷。代表”初始”的颜色，是生物在年轻时的代表(成熟色是绿色)。在心理暗示来说，天蓝和粉红色一 样，都是”安抚色”，是令人安静并放松的颜色。</p>
</li>
<li><p>湖蓝：湖蓝深邃的蓝色，却又带着跳脱的亮光，美丽的像是沉浸在无尽的静谧中的湖水。代表着”等待” 。在颜色的暗示来说，是禁语的颜色，通常在充斥这样颜色的地方，人们的对话都会减少。</p>
</li>
<li><p>宝石蓝(宝蓝)：在传说中希望女神的原型就是一颗蓝色的钻石。所以宝石一样的靓丽幽蓝就成了”希望”的代名词。在心理上，宝石蓝和紫色一样，都会给人高贵的感觉，并且引起人们的注意。右图便是著名的宝蓝海洋。</p>
</li>
<li><p>孔雀蓝：是蓝色中最神秘的一种，几乎没有人能确定它正确的色值所在，是模糊色的一种，不同的人会对它有不同的诠释，代表的意义是”隐匿” 。在印刷领域里，这种颜色会和设想分开很大的误差。在精神领域里，这个颜色是遥不可攀的神界的颜色，是除了金银以外的一个特殊色。</p>
</li>
<li><p>蓝(正蓝)：是”忧郁”的代名词。平分蓝色系列的青色和红色在这里完美的统一了数值，展现出夜空的微微紫色的深蓝。在心理学上，深蓝会给一些容易接受暗示的人以压迫感，但是有会让保有乐观态度的人产生放松的心态。</p>
</li>
<li><p>蓝紫：就是蓝莓的那种颜色，喜欢浆果的人看到这个颜色就会想到森林的掩映中一个个小蓝莓的酸甜味道。这个颜色的意思也和蓝莓一样是”神秘”。在美容领域里，这个颜色会给人安静的诱惑的感觉，而在一般的运用上，这个颜色太过于扩张化而给人骄傲的感觉。</p>
<p><img src= "/img/loading.gif" data-src="%E8%93%9D%E8%89%B2.png" alt="蓝色"></p>
</li>
</ul>
<p>（8）紫色：神秘、富贵、压抑。</p>
<p>​       紫色是一个非常刺激性的颜色。单独使用容易给用户造成心理上的压力，通常会搭配其他颜色使用，紫色和蓝色搭配使用时可以创造出既理智又有些梦幻的色彩，紫色和粉色配合使用时，可以创造出非常美丽的女性化的色彩。</p>
<p>​       在红色和蓝色之间的色谱是紫色的。紫色在色彩方面历史悠久。由于生产紫色颜料昂贵且困难的事实，在拜占庭帝国和神圣罗马帝国以及日本的贵族统治下，这种颜色常常被高贵和皇室血统所穿戴。从这时开始一直到1856年，紫色始终是象征着皇族和贵族的颜色。到了19世纪中期，每个人都变得更容易获得颜色。但是，紫色仍然是英国王室使用的颜色，并将永远保持皇室使用色的地位。</p>
<p>​      紫色在色谱上的一个有趣的地方，正好在暖色系的红色和冷色系的蓝色之间，使它成为一种独特的颜色，根据具体的色调，它可以既凉爽又温暖。</p>
<p>​      由此，不同的紫色可以有不同的效果。在光谱的最底端是淡紫色。这种苍白，柔和的色调代表女性气质，怀旧，浪漫和温柔。更生动的紫色代表皇室，贵族，奢侈和奢侈品。而深紫色的深色，如淡紫色，可以给人带来严肃性，专业性以及忧郁和悲伤的想法。</p>
<p>紫色也是一种可以促进趣味，创造力和娱乐的颜色。正因为如此，它经常被用于一些糖果、巧克力这样的儿童品牌。</p>
<p><img src= "/img/loading.gif" data-src="%E7%B4%AB%E8%89%B2.png" alt="紫色"></p>
<p>（9）粉色：恋爱、可爱、温馨、浪漫。</p>
<p>​        粉红色以同名花朵命名，是一种充满活力的女性色彩，有着悠久的历史。粉红色在艺术和文化方面没有其他颜色那样多产，因为红色和深红色的深浅往往是优选的。然而，在文艺复兴时期，粉红色颜料开始被更多地应用，从那里开始，颜色进入了时尚，艺术和设计的世界。</p>
<p>​        粉红色在西方世界被广泛认为是女性的色彩。正因为如此，它被用来提高对乳腺癌的认识，应用于许多女性的产品，并被认为是女性主要使用和穿着的颜色。但是，情况并非总是如此。最初它被认为是适合小男孩的颜色，因为红色是男性的颜色，粉红色是妹妹的颜色。同样，在日本，粉红色是与男性气质相关的颜色，粉红色的樱花树被认为是战死的武士的象征。当谈到粉色，它柔和纯净，往往会代表少女时期、成长、爱情和温柔，而这些柔和的色调实际上被认为是增加女性的力量。</p>
<p>​        粉色是一种恋爱的颜色。通常和爱情、浪漫相关，像是情人节七夕节等，都会使用粉色来设计。不同纯度明度的粉色适用于不同的场景，纯度较低，明度较高的浅粉色可以传达出娇嫩、甜美的感觉。和红色、橙色、黄色暖色调搭配，蓝色冷色调搭配都可以结合出很多不同的色彩效果。粉红色以各种方式被使用在品牌上。可以说，最常见的是主要迎合女性的品牌。</p>
<p>（10）棕褐色：</p>
<p>​       褐色不是一种容易被忽略的颜色，曾有研究表明是“公众最不喜欢的颜色”。褐色长期以来一直是下层阶级的象征，这种联系源自古罗马，当时只有野蛮人和社会底层的人才穿这种颜色。这也是方济会的僧侣所穿的颜色，作为贫穷和谦卑的象征。然而在现代文化中，褐色开始慢慢被应用起来。现在它象征着有机、自然、健康和品质，它是一种有许多积极联想的颜色。</p>
<p>​       褐色不像其他色调一样在品牌中被广泛应用，但是在使用时，它能带来一些独特的效果。由于褐色是自然界常见的颜色，它已成为所有事物的象征，有机、真实或自然。我们可以看到这个品牌如Ugg和棉花品牌。路易威登标志性的棕色和霍利斯特（Hollister）经常使用浓郁的深棕色，表现出高品质和奢华的风格。深褐色的标志就是最好的例子。</p>
<h1 id="二、色彩的搭配"><a href="#二、色彩的搭配" class="headerlink" title="二、色彩的搭配"></a>二、色彩的搭配</h1><h2 id="1-色相之间的关系"><a href="#1-色相之间的关系" class="headerlink" title="1.色相之间的关系"></a>1.色相之间的关系</h2><p>五大色相关系：同类色、邻近色、类似色、互补色、对比色</p>
<p><img src= "/img/loading.gif" data-src="%E5%90%8C%E7%B1%BB%E8%89%B2.png" alt="同类色"></p>
<p><img src= "/img/loading.gif" data-src="%E4%B8%B4%E8%BF%91%E8%89%B2.png" alt="临近色"></p>
<p><img src= "/img/loading.gif" data-src="%E7%B1%BB%E4%BC%BC%E8%89%B2.png" alt="类似色"></p>
<p><img src= "/img/loading.gif" data-src="%E4%BA%92%E8%A1%A5%E8%89%B2.png" alt="互补色"></p>
<p><img src= "/img/loading.gif" data-src="%E5%AF%B9%E6%AF%94%E8%89%B2.png" alt="对比色"></p>
<h2 id="2-从服装搭配看色彩搭配"><a href="#2-从服装搭配看色彩搭配" class="headerlink" title="2.从服装搭配看色彩搭配"></a>2.从服装搭配看色彩搭配</h2><p><img src= "/img/loading.gif" data-src="42166d224f4a20a4c46b6a68252c3824730ed0a9.jpeg" alt="42166d224f4a20a4c46b6a68252c3824730ed0a9"></p>
<p><img src= "/img/loading.gif" data-src="2fdda3cc7cd98d10322ac806974118087aec9094.jpeg" alt="2fdda3cc7cd98d10322ac806974118087aec9094"></p>
<p><img src= "/img/loading.gif" data-src="8ad4b31c8701a18b8c8f92f42a51a70e2938feae.jpeg" alt="8ad4b31c8701a18b8c8f92f42a51a70e2938feae"></p>
<p><img src= "/img/loading.gif" data-src="9c16fdfaaf51f3de3da53e60229050193a297920.jpeg" alt="9c16fdfaaf51f3de3da53e60229050193a297920"></p>
<p><img src= "/img/loading.gif" data-src="%E7%B2%89%E8%89%B2%E7%B3%BB.jpeg" alt="粉色系"></p>
<p><img src= "/img/loading.gif" data-src="d31b0ef41bd5ad6efba20acb34b599ddb6fd3c38.jpeg" alt="d31b0ef41bd5ad6efba20acb34b599ddb6fd3c38"></p>
<p><img src= "/img/loading.gif" data-src="f2deb48f8c5494ee7a8b8d3f5e7400fa98257ef5.jpeg" alt="f2deb48f8c5494ee7a8b8d3f5e7400fa98257ef5"></p>
<p><img src= "/img/loading.gif" data-src="%E5%9B%BE3.jpg" alt="图3"></p>
<p><img src= "/img/loading.gif" data-src="%E5%9B%BE5.jpg" alt="图5"></p>
<h2 id="3-从大自然学习色彩搭配"><a href="#3-从大自然学习色彩搭配" class="headerlink" title="3.从大自然学习色彩搭配"></a>3.从大自然学习色彩搭配</h2><p><img src= "/img/loading.gif" data-src="%E5%A4%A7%E8%87%AA%E7%84%B6%E4%B8%AD%E5%AD%A6%E4%B9%A0%E9%85%8D%E8%89%B2_1.jpg" alt="写给新手的色彩搭配快速入门指南  优设网 - UISDC"></p>
<p><img src= "/img/loading.gif" data-src="%E5%A4%A7%E8%87%AA%E7%84%B6%E4%B8%AD%E5%AD%A6%E4%B9%A0%E9%85%8D%E8%89%B2_2.jpg" alt="写给新手的色彩搭配快速入门指南  优设网 - UISDC"></p>
<p><img src= "/img/loading.gif" data-src="%E5%A4%A7%E8%87%AA%E7%84%B6%E4%B8%AD%E5%AD%A6%E4%B9%A0%E9%85%8D%E8%89%B2_3.jpg" alt="写给新手的色彩搭配快速入门指南  优设网 - UISDC"></p>
<p><img src= "/img/loading.gif" data-src="%E5%A4%A7%E8%87%AA%E7%84%B6%E4%B8%AD%E5%AD%A6%E4%B9%A0%E9%85%8D%E8%89%B2_4.jpg" alt="写给新手的色彩搭配快速入门指南  优设网 - UISDC"></p>
<p><img src= "/img/loading.gif" data-src="%E5%A4%A7%E8%87%AA%E7%84%B6%E4%B8%AD%E5%AD%A6%E4%B9%A0%E9%85%8D%E8%89%B2_5.jpg" alt="写给新手的色彩搭配快速入门指南  优设网 - UISDC"></p>
<h1 id="三、挑战眼力训练"><a href="#三、挑战眼力训练" class="headerlink" title="三、挑战眼力训练"></a>三、挑战眼力训练</h1><p><a href="http://game.ioxapp.com/eye-test/">http://game.ioxapp.com/eye-test/</a></p>
<h1 id="四、服装类型"><a href="#四、服装类型" class="headerlink" title="四、服装类型"></a>四、服装类型</h1><p><img src= "/img/loading.gif" data-src="%E7%94%B7%E7%94%9F%E6%90%AD%E9%85%8D.png" alt="男生搭配"></p>
<p><img src= "/img/loading.gif" data-src="%E9%A3%8E%E6%A0%BC.png" alt="风格"></p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>色彩</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-提高代码质量</title>
    <url>/2020/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/</url>
    <content><![CDATA[<h1 id="代码质量-与-设计模式应用"><a href="#代码质量-与-设计模式应用" class="headerlink" title="代码质量 与 设计模式应用"></a>代码质量 与 设计模式应用</h1><h2 id="一、代码指标"><a href="#一、代码指标" class="headerlink" title="一、代码指标"></a>一、代码指标</h2><h3 id="1、健壮性"><a href="#1、健壮性" class="headerlink" title="1、健壮性"></a>1、健壮性</h3><blockquote>
<p>什么意思呢？ 百度：在异常和危险情况下系统生存的能力。<br>用人的健壮性做个比方：</p>
<blockquote>
<p>如果一个人很健壮，那一般的小病小灾打不倒他，如感冒、咳嗽<br>对比过来，一个程序很健壮，那在出现预期之外的错误(eg:文件不存在)，减少找bug的难度和影响程度。</p>
</blockquote>
</blockquote>
<p><strong>健壮性好的代码有哪些特点</strong></p>
<blockquote>
<p><strong>减少找bug的难度</strong><br>    <em>很多同学可能有这么一个问题：发现自己每天写代码 2小时，改bug 6小时， 一天8个小时就这么过去了</em><br><strong>降低对程序的影响程度</strong><br>    <em>如果程序出现了问题，不至于这一个问题让我们整个系统跑不起来了</em></p>
</blockquote>
<p><strong>保证健壮性的手段</strong></p>
<blockquote>
<p>健壮性不同其他性能，没有多抽象的概念，也没有多深的思维，主要就是个人的习惯</p>
</blockquote>
<p><strong>1、参数层面</strong></p>
<ul>
<li>基础类型判断<blockquote>
<p>先来看下面一个例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常入参 没什么问题</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 少传一个参数时</span></span><br><span class="line">add(<span class="number">1</span>) <span class="comment">// ==&gt; NaN  这里是不会报错的哦！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时如果这个返回值是通过 axios.get()传到后台会是什么情况？</span></span><br><span class="line">axios.get(<span class="string">&#x27;url&#x27;</span>,&#123; <span class="attr">num</span>: add(<span class="number">1</span>) &#125;) <span class="comment">// ==&gt; 400 bad request</span></span><br><span class="line"><span class="comment">// 试想：如果你的代码量比较大时，要定位到这个问题是不是要花很长时间，还要debug之类的</span></span><br></pre></td></tr></table></figure>
这就是典型的参数类型引起的问题<br>[如何解决?]<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 1、基础参数类型判断</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">&#x27;number&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;a or b is not a number&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br></li>
<li>参数是配置对象 <font color="#fff">选项合并</font><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以Vue为例：</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;&#125;);</span><br><span class="line"><span class="comment">// 有哪些必传参数？</span></span><br><span class="line"><span class="comment">// 如何保证这些必传参数都传了？</span></span><br></pre></td></tr></table></figure>
[看Vue是怎么做的?]<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 必传参数：  el template</span></span><br><span class="line"><span class="comment">// 如何保证必传值不为空： 提供一个默认配置，把new时的入参与默认配置做合并</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _default = &#123;</span><br><span class="line">    el: <span class="built_in">document</span>, </span><br><span class="line">    template:<span class="string">&#x27;&lt;div&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> config)&#123;</span><br><span class="line">    _default[key] = config[key] || _default[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br></li>
<li>参数是某个类的实例<blockquote>
<p>这种情况，一般是我们在造轮子的时候会用到</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class1 是一个类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里有个方法fn 参数要求是Class1的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
[看这种情况怎么保证健壮性]<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class1 是一个类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里有个方法fn 参数要求是Class1的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Class1)&#123;</span><br><span class="line">    <span class="comment">// dosomthing</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;obj 必须是 Class1的实例&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>这种情况在实际开发中可能用到的比较少，<br>但在自己造轮子的时候，这种情况就会非常多</p>
</blockquote>
<ul>
<li><p>js中特有的一个问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function 除了可能是一个方法，还可能代表一个什么东东？</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>[如何保证？]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">this</span> <span class="keyword">instanceof</span> vue)&#123; <span class="comment">// 通过instanceof vue 判断this 是不是vue实例</span></span><br><span class="line">    <span class="comment">// 类实例</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当作一个方法调用</span></span><br><span class="line">    <span class="comment">// return new vue(); // 这样即使当一个方法调用 ，拿到的还是一个vue的实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 像一些框架之类的都会有这种措施  vue是这样</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;vue is a constructor and should be called with the `new` keyword &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vue(); <span class="comment">// 直接调用时，this ---&gt; window</span></span><br><span class="line"><span class="keyword">new</span> vue(); <span class="comment">// new 操作符调用时， this 指向vue实例 通过instanceof vue 可以判断</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>易错代码</strong></p>
<blockquote>
<p>代码错了就是错了，什么叫易错代码?</p>
</blockquote>
<ul>
<li><p>不由自己控制的出错代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如: 前端请求某个接口，接口返回的数据结构</span></span><br><span class="line"><span class="comment">// 预期结构是下面这样的：</span></span><br><span class="line"><span class="keyword">let</span> res = &#123;</span><br><span class="line">  list:[</span><br><span class="line">    &#123;</span><br><span class="line">      attrA: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是这样取值的</span></span><br><span class="line"><span class="keyword">let</span> attrA = res.list[<span class="number">0</span>].attrA;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 list 为空或[] 时，我们取值就会报错  Cannot read property &#x27;attrA&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p>[怎么解决呢？]<br>一般有两种方法: </p>
<ul>
<li>模拟一个这样的数据结构<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> item = (res.list || [])[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> attrA = (item || &#123;&#125;).attrA;</span><br></pre></td></tr></table></figure></li>
<li>用&amp;&amp;操作符 先判断为空的情况<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> item = res.list &amp;&amp; res.list[<span class="number">0</span>]  <span class="comment">// 使用与操作符 判断为空的情况</span></span><br><span class="line"><span class="keyword">let</span> attrA = item &amp;&amp; item.attrA;</span><br></pre></td></tr></table></figure>
<br>

</li>
</ul>
<blockquote>
<p>前端易错性代码出现可能会少些，后端就非常多</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在下载某个文件时，</span></span><br><span class="line"><span class="comment">// 1、文件存在，正常下载</span></span><br><span class="line"><span class="comment">// 2、文件不存在，就会出错了</span></span><br><span class="line"><span class="comment">// 如果不处理出错，后端服务可能就停了，那这样影响就非常严重了，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以后端经常会看到这样的代码段</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 易错代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">  <span class="comment">// 记录日志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先把出错的信息记录下来，保证程序不会挂掉，</span></span><br><span class="line"><span class="comment">// 再通过日志分析出错原因</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>变量权限</strong> 这个就有点抽象了</p>
<blockquote>
<p>变量应该不应该被篡改，能不能够被篡改<br>变量应不应该被读取，能不能够被读取，在哪里能被读取<br>这就是变量的权限</p>
</blockquote>
<blockquote>
<p>变量权限跟健壮性有什么关系呢？<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还以Vue为例：</span></span><br><span class="line"><span class="comment">// 在使用vue-router的时候，有没有留意这样一个问题：</span></span><br><span class="line"><span class="built_in">this</span>.$router = &#123;&#125;; <span class="comment">// 给$router赋值，但 this.$router的值不会变</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  [vue-router是怎么做的呢？]<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue-router install 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">Vue</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _router = &#123;&#125;; <span class="comment">// 局部变量</span></span><br><span class="line">  <span class="comment">// 屏蔽了set方法，使你给$router赋值时无效</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">&#x27;$router&#x27;</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">get</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">      <span class="comment">// return this._routerRoot._router // 源码是这样的</span></span><br><span class="line">      <span class="keyword">return</span> _router;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="2、可读性"><a href="#2、可读性" class="headerlink" title="2、可读性"></a>2、可读性</h3><blockquote>
<p>看到变量或方法就知道这个变量，这段代码是做什么用的</p>
</blockquote>
<p>  <strong>语义化</strong></p>
<blockquote>
<p>定义有意义的名字:  描述某个变量或方法在业务中的作用</p>
</blockquote>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些都是没有意义, 大量的这种命名，在后期阅读代码时，简直是个灾难</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何命名呢？<br>可以按这个思路来： 在业务中的作用 –&gt; 用中文描述它的作用 –&gt; 翻译成英文<br>尽量做到见名知义</p>
</blockquote>
<p>  <strong>命名规范</strong></p>
<blockquote>
<p>这个不多说了，</p>
</blockquote>
<pre><code>比如：js可以这样命名：
  1、类命名：首字母大写
  2、普通方法变量，小驼峰命名
  3、常量： 全大写，
  4、局部变量：_开头
</code></pre>
<p>  <strong>结构清晰</strong></p>
<ul>
<li><p>if-else 问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>回调函数问题</p>
<blockquote>
<p>需求：一个操作需要调三个接口A，B，C，B依赖A的返回结果，C依赖B的返回结果</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用jquery 实现就是这种样式</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url:<span class="string">&#x27;urlA&#x27;</span>,</span><br><span class="line">  params:&#123;&#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">resA</span>)</span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url:<span class="string">&#x27;urlB&#x27;</span>,</span><br><span class="line">      params: resA,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">resB</span>)</span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">          url:<span class="string">&#x27;urlC&#x27;</span>,</span><br><span class="line">          params: resB,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span>(<span class="params">resC</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(resC)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ES6 之后引用了 promise async 主要就是为了解决回调问题 避免回调地狱</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise then 方式解决</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url, params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url:url,</span><br><span class="line">      params: params,</span><br><span class="line">      success:<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        resolve(res);</span><br><span class="line">      &#125;,</span><br><span class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">request(<span class="string">&#x27;urlA&#x27;</span>, &#123;&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> request(<span class="string">&#x27;urlB&#x27;</span>, res))</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> request(<span class="string">&#x27;urlC&#x27;</span>, res))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// async</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url, params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.post(url, params);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">let</span> resA = <span class="keyword">await</span> getData(<span class="string">&#x27;urlA&#x27;</span>, &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> resB = <span class="keyword">await</span> getData(<span class="string">&#x27;urlB&#x27;</span>, resA);</span><br><span class="line"><span class="keyword">let</span> resC = <span class="keyword">await</span> getData(<span class="string">&#x27;urlC&#x27;</span>, resB);</span><br></pre></td></tr></table></figure>

<h3 id="3、可复用性"><a href="#3、可复用性" class="headerlink" title="3、可复用性"></a>3、可复用性</h3></li>
</ul>
<p><strong>DRY原则</strong>  Don’t Repeat Yourself</p>
<blockquote>
<p>写过一遍的操作，就不重复第二遍了<br>  尽量不去写重复代码， 这可能带来一些维护上的负作用，这个就要把握一个度了<br>  要看某段代码有没有提取的必要，比如重复了多少次，使用量大不大</p>
</blockquote>
<p><strong>逻辑复用，提取代码</strong></p>
<blockquote>
<p>针对局部某个操作，某个功能而言<br>  重复的部分提取成一个公用的方法</p>
</blockquote>
<p><strong>创建公用模板</strong></p>
<blockquote>
<p>针对全局性的，创建公用模块：<br>layout | header | footer | common.css | util.js</p>
</blockquote>
<h3 id="4、可扩展性"><a href="#4、可扩展性" class="headerlink" title="4、可扩展性"></a>4、可扩展性</h3><blockquote>
<p>程序上的一个终极难题<br>对开发人员的架构思维，模块思维要求是非常高的</p>
</blockquote>
<blockquote>
<p>产品经理不可能不修改他的需求，就像程序员不可能不写bug一样<br>如果在写代码的时候预先考虑到后期需求可能的变化，那在需求变化时，你就会非常舒服了</p>
</blockquote>
<ul>
<li><p>模块分明</p>
<blockquote>
<p>积木式编程，随时可以插入、移除某个模块</p>
</blockquote>
</li>
<li><p>耦合度低</p>
<blockquote>
<p>划分低耦合的模块，并高效设计模块间的沟通 (架构层面讲)<br>比如你要开个饭店，你需要怎么设置你的组织架构？</p>
<blockquote>
<p>厨师模块，服务员模块，收银员模块（老板）</p>
</blockquote>
</blockquote>
</li>
<li><p>合适的扩展技巧</p>
<blockquote>
<p>应用设计模式</p>
</blockquote>
</li>
</ul>
<h2 id="二、设计模式概论"><a href="#二、设计模式概论" class="headerlink" title="二、设计模式概论"></a>二、设计模式概论</h2><h3 id="1、创建型设计模式"><a href="#1、创建型设计模式" class="headerlink" title="1、创建型设计模式"></a>1、创建型设计模式</h3><blockquote>
<p>帮助我们优雅的创建对象</p>
</blockquote>
<ul>
<li><p>工厂模式</p>
<blockquote>
<p>大量创建对象</p>
</blockquote>
<p>  Jquery时代，我们需要大量频繁的操作dom</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $就是一个工厂，他批量生产jquery对象， 根据你传入的选择器，生成一批jquery对象</span></span><br><span class="line">$(<span class="string">&#x27;.className&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>  [如何实现一个工厂模式呢？]<br>  <strong>球类工厂</strong></p>
<blockquote>
<p>需求：我们要生产不同类型的球：basketball  footerball tennis(网球)…</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 球类工厂</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ballFactory</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;football&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> football();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;basketball&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> basketball();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;tennis&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> tennis();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 可以在局部 </span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">football</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">basketball</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tennis</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在原型链上</span></span><br><span class="line">ball.prototype.football = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">ball.prototype.basketball = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">ball.prototype.tennis = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  [再看看jquery是如何实现的]<br>  <strong>Jquery如何实现工厂模式的</strong></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态函数 jquery的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jquery</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> jquery.fn.init(params);</span><br><span class="line">&#125;</span><br><span class="line">jquery.fn = &#123;&#125;;</span><br><span class="line">jquery.fn.init = <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">window</span>.$ = jquery;</span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;.className&#x27;</span>);<span class="comment">// 实际是通过new jquery静态属性fn上的init方法</span></span><br></pre></td></tr></table></figure>
<p>jquery是通过挂载一个静态属性实现的</p>
  <br>
</blockquote>
</li>
<li><p>建造者模式</p>
<blockquote>
<p>精细化组合一个对象：类似建房子<br>盖房子明, 先把砖，门，窗这些材料都准备好，再把这些材料搭在一起，就建成了.</p>
</blockquote>
<p><b>关键思想 就是先把相关的模块提前独立开发好，再把各个模块拼装集成到一起</b></p>
<blockquote>
<p>明显的标识就是 传入了一大堆的配置信息</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建造者模式： 一般实现方案</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键思想 先把相关的模块放一边开发好，再把各模块集成到一起</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 直接绑定</span></span><br><span class="line">  <span class="built_in">this</span>.model1 = <span class="keyword">new</span> Model1(&#123;&#125;);</span><br><span class="line">  <span class="built_in">this</span>.model2 = <span class="keyword">new</span> Model2(&#123;&#125;);</span><br><span class="line">  <span class="built_in">this</span>.model3 = <span class="keyword">new</span> Model3(&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Model1</span>(<span class="params">params</span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Model2</span>(<span class="params">params</span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Model3</span>(<span class="params">params</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>vue 也是用建造者模式实现的， 但双是跟一般的方案又不太一样<br><b>混入方式</b></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 明显的标识就是 传入了一大堆的配置信息</span></span><br><span class="line"><span class="comment">// 方法2 Vue 是怎么做的 </span></span><br><span class="line"><span class="comment">// 先把各个模块独立开发好，之后再混合进实例里</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 健壮性校验</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._init(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面就是各个模块的混入Vue原型上</span></span><br><span class="line">initMixin(Vue);</span><br><span class="line">stateMixin(Vue);</span><br><span class="line">eventsMixin(Vue);</span><br><span class="line">lifecycleMixin(Vue);</span><br><span class="line">renderMixin(Vue);</span><br></pre></td></tr></table></figure>
</li>
<li><p>单例模式</p>
<blockquote>
<p>全局只有一个，对象只能被创建一次</p>
</blockquote>
<p>如何实现 单例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规类：靠挂在这个类上面的一个静态属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class1</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Class1.instance)&#123; <span class="comment">// 查检有没有实现，有则直接返回该实例，无则创建实例，并增加标识</span></span><br><span class="line">    <span class="keyword">return</span> Class1.instance;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name =<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.attr = <span class="string">&#x27;bbbb&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    Class1.instance = <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个new 是同一个实例</span></span><br><span class="line"><span class="keyword">let</span> class11 = <span class="keyword">new</span> Class1();</span><br><span class="line"><span class="keyword">let</span> class12 = <span class="keyword">new</span> Class1();</span><br><span class="line"><span class="built_in">console</span>.log(class11 == class12)</span><br></pre></td></tr></table></figure>
<p>再看vuex vue-router<br>vuex: 全局只有一个，如果有多个，那页面的状态从哪个取也是问题<br>vue-router:全局中有一个，如果有多个的话，页面跳转的时候，选用哪个就是一个问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以vue-router为例子</span></span><br><span class="line"><span class="comment">// vue插件时如何保证单例的 以vue-router为例</span></span><br><span class="line"><span class="comment">// 通过一个参数，变量，静态属性去标识这个类是否被new 过，已经new过的，不再去new</span></span><br><span class="line">Vue.use(vueRouter); </span><br><span class="line"><span class="comment">// Vue.use 实际上是调用了插件的install方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vue-router</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> _vue; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">vue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_vue === vue &amp;&amp; install.installed) </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    _vue = vue;</span><br><span class="line">    install.installed = <span class="literal">true</span>;<span class="comment">// 静态属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>问题：</p>
<blockquote>
<p>需求1：实现一个消息提示弹框插件，[用什么模式？]<br><strong>弹框提示插件</strong><br>分析： 因为一个页面的消息提示可能会很多，添加成功，添加失败，网络出错<br>会需要频繁创建对象，所以考虑用工厂模式实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂模式实现 调用如下</span></span><br><span class="line">pop(<span class="string">&#x27;message&#x27;</span>)</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line">pop.confirm(<span class="string">&#x27;message&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建造者模式实现，调用如下</span></span><br><span class="line">pop(<span class="string">&#x27;message&#x27;</span>)</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="keyword">let</span> popObj = <span class="keyword">new</span> pop(<span class="string">&#x27;message&#x27;</span>)</span><br><span class="line">popObj.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哪个用起来更方便， 虽然看起来只少了一个new</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需求2： 实现一个编辑器插件：有前进，后退，改变字体，大小，颜色功能，[用什么模式？]<br><strong>编辑器插件</strong><br>需求: 有前进，后退，改变字体，大小，颜色功能</p>
</blockquote>
<blockquote>
<p>分析：<br>1、一般一个页面只有一个，不需要频繁创建<br>2、编辑器可能还要涉及到复杂的配置，需要精细化创建</p>
</blockquote>
<blockquote>
<p>建造者模式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html 初始化--&gt; 事件绑定 --&gt; 前进后退模块 --&gt;数据记录模块 --&gt; 字体控制模块 --&gt; 数据渲染模块</span></span><br><span class="line"><span class="comment">// 前进后退： 一般都是数据驱动思维，</span></span><br><span class="line">[&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>, <span class="attr">content</span>:<span class="string">&#x27;hello&#x27;</span>&#125;, &#123;<span class="attr">color</span>:<span class="string">&#x27;green&#x27;</span>, <span class="attr">content</span>:<span class="string">&#x27;hello&#x27;</span>&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、结构型设计模式"><a href="#2、结构型设计模式" class="headerlink" title="2、结构型设计模式"></a>2、结构型设计模式</h3><blockquote>
<p>帮助我们更优雅的设计代码结构： 策略，享元</p>
</blockquote>
<p>还以一个具体的需求为例：</p>
<blockquote>
<p>需求：写一个表单验证工具，给我要验证的input 值 value 变化时，应用对应的规则，自动验证<br>分析：<br>  1、首先是包含的模块：dom初始化模块 –&gt; 事件绑定模块 –&gt; 验证模块 –&gt; 消息提示模块<br>  2、一个页面上可能有多个需要验证的dom，所以适合工厂模式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、防JQuery实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">dom, msgDom</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> t.init(dom, msgDom);</span><br><span class="line">&#125;</span><br><span class="line">t.init = <span class="function"><span class="keyword">function</span>(<span class="params">dom, msgDom</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.dom = dom;</span><br><span class="line">  <span class="built_in">this</span>.msgDom = msgDom;</span><br><span class="line">  <span class="built_in">this</span>.validateArr = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 事件绑定</span></span><br><span class="line">t.init.prototype.initBind = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="built_in">this</span>.dom.onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    self.run(<span class="built_in">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 验证模块 </span></span><br><span class="line"><span class="comment">// 变化可能性最大，需要细化</span></span><br><span class="line"><span class="comment">// 考虑验证模块在以后的需求中可能需要扩展，</span></span><br><span class="line"><span class="comment">// 所以可以提前预留好自定义扩展方法，预置一些基础的验证规则，减少代码重复</span></span><br><span class="line"><span class="comment">// 以队列的形式存放验证规则，方便扩展</span></span><br><span class="line">dt.init.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.validateArr.push(fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> fn === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">// 预置的验证规则 下面这样写，可读性差，代码不清楚</span></span><br><span class="line">    <span class="keyword">if</span>(fn === <span class="string">&#x27;isPhone&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.validateArr.push(<span class="function">()=&gt;</span>&#123;<span class="comment">/*手机号验证*/</span>&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fn === <span class="string">&#x27;isNumber&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.validateArr.push(<span class="function">()=&gt;</span>&#123;<span class="comment">/**是否是数字*/</span>&#125;) </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fn === <span class="string">&#x27;isEmail&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">t.init.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">this</span>.validateArr.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// _result 是约定好的验证结果的数据结构</span></span><br><span class="line">    <span class="comment">// &#123;success: true|false, msg:&#x27;&#x27;&#125;</span></span><br><span class="line">    <span class="keyword">let</span> _result = <span class="built_in">this</span>.validateArr.shift().run(value);</span><br><span class="line">    <span class="keyword">if</span>(!_result.success)&#123;</span><br><span class="line">      <span class="built_in">this</span>.sendMsg(_result.msg);</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">// 一个验证失败就停止验证，减少不必要的循环</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息提示模块</span></span><br><span class="line">t.init.prototype.sendMsg = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.msgDom.innerHtml = msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后期的使用   职责链模式</span></span><br><span class="line">t(<span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;errorMsg&#x27;</span>)</span><br><span class="line">  .add(<span class="string">&#x27;isPhone&#x27;</span>)</span><br><span class="line">  .add(<span class="function">() =&gt;</span> &#123;<span class="comment">/**自定义验证1 */</span>&#125;)</span><br><span class="line">  .add(<span class="function">() =&gt;</span> &#123;<span class="comment">/**自定义验证2 */</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>[优化后的验证工具]<br><strong>表单验证工具</strong></p>
<blockquote>
<p>需求：写一个表单验证工具，给我要验证的input 值 value 变化时，应用对应的规则，自动验证<br>分析：<br>  1、首先是包含的模块：dom初始化模块 –&gt; 事件绑定模块 –&gt; 验证模块 –&gt; 消息提示模块<br>  2、一个页面上可能有多个需要验证的dom，所以适合工厂模式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、防JQuery</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">dom, msgDom</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> t.init(dom, msgDom);</span><br><span class="line">&#125;</span><br><span class="line">t.init = <span class="function"><span class="keyword">function</span>(<span class="params">dom, msgDom</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.dom = dom;</span><br><span class="line">  <span class="built_in">this</span>.msgDom = msgDom;</span><br><span class="line">  <span class="built_in">this</span>.validateArr = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、思考以后的扩展性，想想模块是否需要细化， 模块越细，扩展越方便</span></span><br><span class="line"><span class="comment">// 验证模块变化最大，细化</span></span><br><span class="line"><span class="comment">// 开启验证模块，验证队列模块</span></span><br><span class="line">t.init.prototype.initBind = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="built_in">this</span>.dom.onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    self.run(<span class="built_in">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.init.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.validateArr.push(fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> fn === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">// 预置的验证规则 下面这样写，可读性差，代码不清楚</span></span><br><span class="line">    <span class="comment">// 引入设计模式解决</span></span><br><span class="line">    <span class="comment">// if(fn === &#x27;isPhone&#x27;)&#123;</span></span><br><span class="line">    <span class="comment">//   this.validateArr.push(()=&gt;&#123;/*手机号验证*/&#125;)</span></span><br><span class="line">    <span class="comment">// &#125; else if(fn === &#x27;isNumber&#x27;)&#123;</span></span><br><span class="line">    <span class="comment">//   this.validateArr.push(()=&gt;&#123;/**是否是数字*/&#125;) </span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略模式解决 </span></span><br><span class="line">    <span class="comment">// 简单if-else可以很好解决</span></span><br><span class="line">    <span class="keyword">let</span> strage = &#123;</span><br><span class="line">      isPhone:<span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;&#125;,</span><br><span class="line">      isNumber: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;&#125;,</span><br><span class="line">      <span class="comment">// 更多验证规则</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.validateArr.push(strage[fn]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里涉及的逻辑比较简单，如果逻辑更复杂一点，可能这一个简单的策略就无法解决</span></span><br><span class="line">    <span class="comment">// 比如：由单一的条件变化，变成几个组合条件变化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态模式</span></span><br><span class="line">    <span class="comment">// 核心：根据对象不同的状态，让对象展示不同的行为， 相当于加了状态管理的策略模式</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.init.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">this</span>.validateArr.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// _result 是约定好的验证结果的数据结构</span></span><br><span class="line">    <span class="comment">// &#123;success: true|false, msg:&#x27;&#x27;&#125;</span></span><br><span class="line">    <span class="keyword">let</span> _result = <span class="built_in">this</span>.validateArr.shift().run(value);</span><br><span class="line">    <span class="keyword">if</span>(!_result.success)&#123;</span><br><span class="line">      <span class="built_in">this</span>.sendMsg(_result.msg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.init.prototype.sendMsg = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.msgDom.innerHtml = msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后期的使用   职责链模式</span></span><br><span class="line">t(<span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;errorMsg&#x27;</span>)</span><br><span class="line">  .add(<span class="string">&#x27;isPhone&#x27;</span>)</span><br><span class="line">  .add(<span class="function">() =&gt;</span> &#123;<span class="comment">/**自定义验证1 */</span>&#125;)</span><br><span class="line">  .add(<span class="function">() =&gt;</span> &#123;<span class="comment">/**自定义验证2 */</span>&#125;)</span><br></pre></td></tr></table></figure>
<br>

<blockquote>
<p>需求2：一个div 实现 上、下、左、右、左上、左下、….这样移动<br>  moveDiv(‘left’) // 左移<br>  moveDiv(‘left’,’top’) // 左上移</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveDiv</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 可以用策略模式</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">0</span>] == <span class="string">&#x27;left&#x27;</span>)&#123;</span><br><span class="line">      moveLeft();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">0</span>] === <span class="string">&#x27;right&#x27;</span>)&#123;</span><br><span class="line">      moveRight();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 这里简单的策略模式就不容易了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">0</span>] == <span class="string">&#x27;left&#x27;</span> &amp;&amp; <span class="built_in">arguments</span>[<span class="number">1</span>] == <span class="string">&#x27;top&#x27;</span>)&#123;</span><br><span class="line">      moveLeft();</span><br><span class="line">      moveTop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[状态模式实现moveDiv]<br><strong>移动Div</strong></p>
<blockquote>
<p>需求2：一个div 实现 上、下、左、右、左上、左下、….这样移动<br>  moveDiv(‘left’) // 左移<br>  moveDiv(‘left’,’top’) // 左上移</p>
</blockquote>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用状态模式实现</span></span><br><span class="line"><span class="comment">// 这时候moveDiv就成了一个类了，不是一个方法了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveDiv</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.stateArr = [];<span class="comment">//因为存在复合运动的行为，所以需要一个数组去存储数据</span></span><br><span class="line">&#125;</span><br><span class="line">moveDiv.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// arguments 类数组  将类数组转成真正数组</span></span><br><span class="line">  <span class="comment">// 这里有几种方法把类数组转成数组？</span></span><br><span class="line">  <span class="built_in">this</span>.stateArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 策略模式</span></span><br><span class="line">  <span class="keyword">let</span> strage = &#123;</span><br><span class="line">    left: moveLeft,</span><br><span class="line">    right:moveRight,</span><br><span class="line">    top:moveTop</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.stateArr.forEach(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    strage[state]();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> moveObj = <span class="keyword">new</span> moveDiv();</span><br><span class="line">moveObj.run(<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;top&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>  使用设计模式之后，这个模块的代码更简洁更易读了<br><br><br><strong>享元模式</strong></p>
<blockquote>
<p>存在类似对象和类似代码块时，用于减少类似代码块<br>这个享元是提取 相同的内容，还是不同的内容？<br><font color="#eee">享元模式里的享无是 代码中的不同点<br>把不同的提出来，剩下的就是相同的，这样代码块就由多化一了<br>与平时提取公共代码不是一个意思</font></p>
</blockquote>
<blockquote>
<p>以jquery.extend方法为例<br>extend实现的功能：<br>  $.extend({a:1}) // 会把对象扩展到$对象上$.a = 1; 为jquery对象扩展方法属性使用<br>  $.extend({a:1},{b:2}) // ==&gt; {a:1,b:2}</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不用设计模式时，是这样实现的</span></span><br><span class="line">$.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> <span class="built_in">arguments</span>[<span class="number">0</span>])&#123;</span><br><span class="line">      <span class="built_in">this</span>[item] = <span class="built_in">arguments</span>[<span class="number">0</span>][item]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> <span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">      <span class="built_in">arguments</span>[<span class="number">0</span>][item] = <span class="built_in">arguments</span>[<span class="number">1</span>][item];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[jquery的extend 享元模式实现]<br><strong>jquery.extend 享元模式实现</strong></p>
<blockquote>
<p>extend实现的功能：<br>  $.extend({a:1}) // 会把对象扩展到$对象上$.a = 1; 为jquery对象扩展方法属性使用<br>  $.extend({a:1},{b:2}) // ==&gt; {a:1,b:2}</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不用设计模式时，是这样实现的</span></span><br><span class="line">$.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 享元模式，提取不同点：</span></span><br><span class="line">  <span class="comment">// 1、for in 的对象不同，</span></span><br><span class="line">  <span class="comment">// 2、接收的对象不同</span></span><br><span class="line">  <span class="keyword">let</span> source = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> target = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">2</span>)&#123;</span><br><span class="line">    source = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">    target = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> source)&#123;</span><br><span class="line">    target[item] = source[item]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结应用场景： 两个if else 分支中，两段代码块非常相似时，就可以用享元模式了</strong></p>
<h3 id="3、行为型设计模式"><a href="#3、行为型设计模式" class="headerlink" title="3、行为型设计模式"></a>3、行为型设计模式</h3><blockquote>
<p>模块间的行为模式的总结，帮助组织模块的沟通：装饰者 观察者</p>
</blockquote>
<p><strong>装饰者模式</strong></p>
<blockquote>
<p>目的：不重写方法的扩展方法<br>应用场景：当一个方法需要扩展，但又不方便或不能去修改方法时 是公共的方法 或他人的方法 或原生方法 或第三方模块的方法<br>简单理解 在不去修改原方法的情况下，扩展方法的功能</p>
</blockquote>
<blockquote>
<p>需求： 删除按钮–&gt; 点击可以删除 —&gt; 但没有提示  —&gt; 好多删除按钮都是这样实现，产品需求是要给出删除提示<br>分析：在原来的删除功能基础上，扩展出提示功能</p>
<blockquote>
<p>1、全部改写  2、找到原来定义，修改原方法，增加提示</p>
</blockquote>
</blockquote>
<p>[你会选哪种方式实现？]<br><strong>装饰者模式</strong></p>
<blockquote>
<p>目的：不重写方法的扩展方法<br>应用场景：当一个方法需要扩展，但又不方便或不能去修改方法时 是公共的方法 或他人的方法 或原生方法 或第三方模块的方法<br>简单理解 在不去修改原方法的情况下，扩展方法的功能</p>
</blockquote>
<blockquote>
<p>需求： 删除按钮–&gt; 点击可以删除 —&gt; 但没有提示  —&gt; 好多删除按钮都是这样实现，产品需求是要给出删除提示<br>分析：在原来的删除功能基础上，扩展出提示功能</p>
<blockquote>
<p>1、全部改写  2、找到原来定义，修改原方法，增加提示</p>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorate</span>(<span class="params">dom, fn</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 健壮性校验</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> dom.onClick === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">// 装饰者 三步走</span></span><br><span class="line">    <span class="comment">// 1、重写原方法，或定义新方法;</span></span><br><span class="line">    <span class="comment">// 2、提取老方法，并调用</span></span><br><span class="line">    <span class="comment">// 3、加入新方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _oldFn = dom.onClick; <span class="comment">// 在方法被重写前提取</span></span><br><span class="line">    dom.onClick = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">      _oldFn.call(<span class="built_in">this</span>);</span><br><span class="line">      fn.call(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">decorate(<span class="string">&#x27;btnDel&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;删除成功&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<br>

<blockquote>
<p>vue2 的双向数据绑定</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue的双向绑定  非数组属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(vue,<span class="string">&#x27;dataKey&#x27;</span>,&#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 是对象里的属性变了，会触发， 它没办法用到数组上，那Vue对数组是怎么实现双向绑定的</span></span><br></pre></td></tr></table></figure>
<p>[vue2 对数组属性实现双向绑定]<br><strong>Vue2 数组的双向绑定</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组：利用装饰者模式，给数组的 push pop </span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> arrProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">let</span> arrCopy = <span class="built_in">Object</span>.create(arrProto); <span class="comment">// 为了不污染旧原型链，提前拷贝一份出来</span></span><br><span class="line">arr.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  arrCopy[method] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _ref = arrProto[method].apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    dep.notify();<span class="comment">// 触发更新</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 把data里的所有数组，都变成这里的这个arrCopy</span></span><br><span class="line"><span class="comment">// 主要是一些技巧</span></span><br></pre></td></tr></table></figure>
<br>
**观察者模式**
> 应用场景：
> 1、异步模块沟通
>>a 异步模块；b 同步模块; b需要a处理完成后a的消息  观察者 类似事件监听

<blockquote>
<p>2、方便加入新的模块， 本来没有想到某个模块会突然要加入的情况</p>
<blockquote>
<p>例如：聊天室的沟通：我和你在聊天室的沟通（聊天室就是观察者),这样别人加入更容易<br>根本没有考虑过你要加入时，你非要加入，实在没办法了，才会引入观察者模式；<br>虽然使用观察者容易做到某件事儿，但它也确实要花费一些开销</p>
</blockquote>
</blockquote>
<p>看这样一个抽奖的需求</p>
<blockquote>
<p>需求：抽奖转盘，特点是越转越快，<br>模块分析： 奖品初始化html –&gt; 最终结果选定 –&gt; 转动控制 –&gt; 转动效果 </p>
<blockquote>
<p>转动控制模块 调用 转动效果模块，<br>转动效果只负责转动效果; 转完之后，询问控制模块接下来怎么转;<br>转动效果模块接收消息体{moveTime: 10, speed: 200} 多长时间内转动几个奖品 –&gt; setInterval 异步了，<br>转动控制与转动效果的沟通问题在于：转动控制不知道什么时候转动效果结束，因为转动速度是不恒定的</p>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先定义好几个模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化模块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlInit</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽奖结果模块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getResult</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转动控制模块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveControll</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画效果：1，2，3，4，5...10 依次高亮显示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 转完一个周期后需要向控制块请求接下来怎么转</span></span><br><span class="line">      <span class="comment">// 不用设计模式时，就直接通过callback访问</span></span><br><span class="line">      <span class="comment">// 要使用设计模式的话，应该用什么模式？</span></span><br><span class="line">  &#125;, config.speed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[抽奖转盘 观察者模式]<br><strong>观察者模式</strong></p>
<blockquote>
<p>需求：抽奖转盘，特点是越转越快，<br>模块分析： 奖品初始化html –&gt; 最终结果选定 –&gt; 转动控制 –&gt; 转动效果 </p>
<blockquote>
<p>转动控制模块 调用 转动效果模块，<br>转动效果只负责转动效果; 转完之后，询问控制模块接下来怎么转;<br>转动效果模块接收消息体{moveTime: 10, speed: 200} 多长时间内转动几个奖品 –&gt; setInterval 异步了，<br>转动控制与转动效果的沟通问题在于：转动控制不知道什么时候转动效果结束，因为转动速度是不恒定的</p>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察者三要素：队列，注册，触发</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 1、队列</span></span><br><span class="line">  <span class="built_in">this</span>.message = &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、注册</span></span><br><span class="line">observer.prototype.regist = <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.message[key] = fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3、触发</span></span><br><span class="line">observer.prototype.fire = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.message[key]();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observerObj = <span class="keyword">new</span> observer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _domArr = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlInt</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">    _domArr.push(<span class="built_in">document</span>.body.append(<span class="string">`&lt;div&gt;<span class="subst">$&#123;i&#125;</span>&lt;/div&gt;`</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getResult</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _num = <span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">40</span>; <span class="comment">// 40是基础动画圈数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(_num, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveControll</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = getResult();</span><br><span class="line">  <span class="keyword">let</span> _circle = <span class="built_in">Math</span>.floor(result/<span class="number">10</span>, <span class="number">0</span>);<span class="comment">// 基础动画圈</span></span><br><span class="line">  <span class="keyword">let</span> _runCircle = <span class="number">0</span>; <span class="comment">// 已经转了多少圈</span></span><br><span class="line">  <span class="keyword">let</span> stopNum = result%<span class="number">10</span>; <span class="comment">// 最终停留的奖品数</span></span><br><span class="line">  <span class="keyword">let</span> _speed = <span class="number">200</span>; <span class="comment">// 转速</span></span><br><span class="line">  observerObj.regist(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> _time = <span class="number">0</span>; <span class="comment">// 应该转几个数</span></span><br><span class="line">    _speed -=<span class="number">50</span>; <span class="comment">// 转一圈 速度加快50</span></span><br><span class="line">    _runCircle++; <span class="comment">// 已转的圈数</span></span><br><span class="line">    <span class="keyword">if</span>(_runCircle &lt;= _circle)&#123; <span class="comment">// 未达到指定的圈数</span></span><br><span class="line">      _time = <span class="number">10</span>; <span class="comment">// 继续转10个数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _time = stopNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    move(&#123;<span class="attr">moveTime</span>: _time, <span class="attr">speed</span>: _speed&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 动画效果：1，2，3，4，5...10 依次高亮显示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nowIn = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> rmNum = <span class="number">9</span>; <span class="comment">// 移除效果的索引</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 单独处理第10个跳第1个的情况</span></span><br><span class="line">    <span class="keyword">if</span>(nowIn == <span class="number">0</span>)&#123;  <span class="comment">// 代码相似了，可以优化了</span></span><br><span class="line">      _domArr[<span class="number">9</span>].setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;item&#x27;</span>);</span><br><span class="line">      _domArr[nowIn].setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;item item-on&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      _domArr[nowIn-<span class="number">1</span>].setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;item&#x27;</span>);</span><br><span class="line">      _domArr[nowIn].setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;item item-on&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 享元模式 </span></span><br><span class="line">    <span class="comment">// if(nowIn != 9)&#123;</span></span><br><span class="line">    <span class="comment">//   rmNum = nowIn--</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// _domArr[rmNum].setAttribute(&#x27;class&#x27;, &#x27;item&#x27;);</span></span><br><span class="line">    <span class="comment">// _domArr[nowIn].setAttribute(&#x27;class&#x27;, &#x27;item item-on&#x27;);</span></span><br><span class="line"></span><br><span class="line">    nowIn++;</span><br><span class="line">    <span class="keyword">if</span>(nowIn == config.moveTime)&#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">      observerObj.fire(<span class="string">&#x27;finish&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, config.speed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<blockquote>
<p>创建型设计模式 –&gt; 创建对象阶段使用<br>结构型设计模式 –&gt; 用在一个对象内部代码优化<br>行为型设计模式 –&gt; 模块之间的沟通交互</p>
</blockquote>
</blockquote>
<h2 id="三、设计模式解决问题"><a href="#三、设计模式解决问题" class="headerlink" title="三、设计模式解决问题"></a>三、设计模式解决问题</h2><ul>
<li>1、if-else模式</li>
<li>2、减少重复代码</li>
<li>3、更好的扩展方法</li>
<li>4、解耦模块</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Build Your Own React</title>
    <url>/2021/05/12/Build-Your-Own-React/</url>
    <content><![CDATA[<h1 id="Build-Your-Own-React"><a href="#Build-Your-Own-React" class="headerlink" title="Build Your Own React"></a>Build Your Own React</h1><ol>
<li>Step I: The createElement Function（createElement 函数）</li>
<li>Step II: The render Function （render 函数）</li>
<li>Step III: Concurrent Mode（并发模式）</li>
<li>Step IV: Fibers</li>
<li>Step V: Render and Commit Phases</li>
<li>Step VI: Reconciliation</li>
<li>Step VII: Function Components</li>
<li>Step VIII: Hooks</li>
</ol>
<h2 id="Step-Zero-Review"><a href="#Step-Zero-Review" class="headerlink" title="Step Zero: Review"></a>Step Zero: Review</h2><p>在正式开始之前，首先先回顾一下一些基本的概念。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">title</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">ReactDOM.render(element, container)</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&quot;foo&quot;</span> &#125;,</span><br><span class="line">  <span class="string">&quot;Hello&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一行使用jsx定义元素，React.createElement从传入的参数创建一个对象。</p>
<p>通过类似于babel的构建工具转换为js。转换通常很简单:将标记内的代码替换为对createElement的调用，将 tag name, props and the children作为参数传递。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 React.createElement 创建的element对象如下：</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  type: <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    children: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于element,它是一个对象，其中有一些属性(type, key, ref, self, source, owner, props)，这里我们只关注 type和props。</p>
<p>type是一个字符串，它的值是我们想要创建的DOM元素的标签名，也是传递给文档的标签名。当你想要创建一个HTML元素时，可以使用createElement，它也可以是一个函数。</p>
<p>props也是一个对象，它拥有来自JSX属性的所有键和值。它还有一个特殊的属性：children。</p>
<p>我们需要替换的另一段React代码是对ReactDOM.render的调用。render是React更改DOM的地方，所以由我们自己进行更新。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Render</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(element.type)</span><br><span class="line">node[<span class="string">&quot;title&quot;</span>] = element.props.title</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">text[<span class="string">&quot;nodeValue&quot;</span>] = element.props.children</span><br><span class="line">​</span><br><span class="line">node.appendChild(text)</span><br><span class="line">container.appendChild(node)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>首先，我们使用 element 的 type 创建一个节点，在本例中为<code>h1</code>.</li>
<li>然后我们将 props 分配给节点，本例中为 <code>title</code>（比较熟悉的为class 和 id，可查看<a href="https://www.w3school.com.cn/tags/html_ref_standardattributes.asp">HTML全局属性</a>）。为了避免混淆，使用element来引用React元素，使用node来引用DOM元素。</li>
<li>接下来为 children 创建节点，这里children是一个string，为其创建一个text节点。使用textNode而不是设置innerText将允许我们以后以相同的方式处理所有元素。还请注意是如何设置nodeValue的，就像在h1标题中设置的一样，它几乎就像字符串的props一样:{nodeValue: “hello”}。</li>
<li>最后我们增加这个 textNode 到 h1 中，并将h1附加到 container 中。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  type: <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    children: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(element.type)</span><br><span class="line">node[<span class="string">&quot;title&quot;</span>] = element.props.title</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">text[<span class="string">&quot;nodeValue&quot;</span>] = element.props.children</span><br><span class="line">​</span><br><span class="line">node.appendChild(text)</span><br><span class="line">container.appendChild(node)</span><br></pre></td></tr></table></figure>

<p>以上为使用js完成创建元素到渲染元素的代码实现。</p>
<h2 id="Step-I-The-createElement-Function"><a href="#Step-I-The-createElement-Function" class="headerlink" title="Step I: The createElement Function"></a>Step I: The createElement Function</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div id=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line">    &lt;a&gt;bar&lt;/a&gt;</span><br><span class="line">    &lt;b /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">ReactDOM.render(element, container)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;foo&quot;</span> &#125;,</span><br><span class="line">  React.createElement(<span class="string">&quot;a&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;bar&quot;</span>),</span><br><span class="line">  React.createElement(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">ReactDOM.render(element, container)</span><br></pre></td></tr></table></figure>

<p>现在开始写一个我们自己版本的React来代替React的版本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children: children.map(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span></span><br><span class="line">          ? child</span><br><span class="line">          : createTextElement(child)</span><br><span class="line">      ),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextElement</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      nodeValue: text,</span><br><span class="line">      children: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子数组也可以包含字符串或数字等基本值。因此，我们将把所有不是对象的东西都包装在它自己的元素中，并为它们创建一个特殊类型:TEXT元素。当没有子元素时，React不会包装原始值或创建空数组，这么做的目的是简化代码。</p>
<p>接下来，我们自定义一个名字来代替React</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const element = Didact.createElement(</span></span><br><span class="line"><span class="comment">//   &quot;div&quot;,</span></span><br><span class="line"><span class="comment">//   &#123; id: &quot;foo&quot; &#125;,</span></span><br><span class="line"><span class="comment">//   Didact.createElement(&quot;a&quot;, null, &quot;bar&quot;),</span></span><br><span class="line"><span class="comment">//   Didact.createElement(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line">​<span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div id=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line">    &lt;a&gt;bar&lt;/a&gt;</span><br><span class="line">    &lt;b /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">ReactDOM.render(element, container)</span><br></pre></td></tr></table></figure>

<p>但是我们仍然想在这里使用JSX的语法。我们如何告诉babel使用Didact的createElement而不是React的。</p>
<p>可以通过 <code>/** @jsx Didact.createElement */</code>注释来告诉babel。当babel编译JSX时，它将使用我们定义的函数。</p>
<h2 id="Step-II-The-render-Function"><a href="#Step-II-The-render-Function" class="headerlink" title="Step II: The render Function"></a>Step II: The render Function</h2><p>目前，我们只关心向DOM添加内容。稍后我们将处理更新和删除。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO create dom nodes</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">  render,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Didact.render(element, container)</span><br></pre></td></tr></table></figure>

<p>我们首先使用元素类型创建DOM节点，然后将新节点附加到容器中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom = <span class="built_in">document</span>.createElement(element.type)</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 2. 递归</span></span><br><span class="line">  element.props.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">    render(child, dom)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  container.appendChild(dom)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果元素类型是文本元素，我们将创建一个文本节点而不是常规节点。</p>
<p>render函数不支持的一件事是文本节点。首先，我们需要定义文本元素的外观。例如，<span>Foo</span>在React中描述的元素如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reactElement = &#123;</span><br><span class="line">  type: <span class="string">&quot;span&quot;</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    children: <span class="string">&quot;Foo&quot;</span> <span class="comment">// 是孩子, 但也只是一个字符串</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以注意到，这里文本节点的children值是一个String，这里其实违背了我们最初的定义 ‘props可能有一个 children 属性，它应该是一个 Didact Elements 数组。’</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">const</span> dom =</span><br><span class="line">   element.type == <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">     ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">     : <span class="built_in">document</span>.createElement(element.type)</span><br></pre></td></tr></table></figure>

<p>这里我们需要做的最后一件事是将props分配给节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 当节点没有子元素的时候执行 props的分配</span></span><br><span class="line"><span class="comment">// 这里的key和下面forEach的name本质上是一样的</span></span><br><span class="line"><span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.keys(element.props)</span><br><span class="line">  .filter(isProperty)</span><br><span class="line">  .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的name为对象中的属性名</span></span><br><span class="line">    <span class="comment">// dom节点上的id值就等于element.props[&#x27;id&#x27;]的值</span></span><br><span class="line">    <span class="comment">// dom[&#x27;id&#x27;] = element.props[&#x27;id&#x27;]</span></span><br><span class="line">    dom[name] = element.props[name]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>以下为完整版的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children: children.map(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span></span><br><span class="line">          ? child</span><br><span class="line">          : createTextElement(child)</span><br><span class="line">      ),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextElement</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      nodeValue: text,</span><br><span class="line">      children: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    element.type == <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="built_in">document</span>.createElement(element.type)</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(element.props)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = element.props[name]</span><br><span class="line">    &#125;)</span><br><span class="line">​</span><br><span class="line">  element.props.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">    render(child, dom)</span><br><span class="line">  )</span><br><span class="line">​</span><br><span class="line">  container.appendChild(dom)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">  render,</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div id=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line">    &lt;a&gt;bar&lt;/a&gt;</span><br><span class="line">    &lt;b /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">Didact.render(element, container)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Step-III-Concurrent-Mode"><a href="#Step-III-Concurrent-Mode" class="headerlink" title="Step III: Concurrent Mode"></a>Step III: Concurrent Mode</h2><p>在添加更多的代码之前，我们需要对刚才所写的进行重构。</p>
<p>这是因为我们刚刚在render函数里写的一个递归调用。一旦我们开始执行渲染函数的时候，在渲染完成之前我们都不能停止，如果需要渲染的元素过多的话，这个渲染函数可能会执行太长时间。如果浏览器需要做高优先级的事情，比如处理用户输入或者保持动画流畅，就不得不等待渲染完成。</p>
<p>所以我们要把这个过程分成小的单元，当我们完成每个单元后，如果还有其他需要做的事情，我们会让浏览器中断渲染。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = performUnitOfWork(</span><br><span class="line">      nextUnitOfWork</span><br><span class="line">    )</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  requestIdleCallback(workLoop)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">requestIdleCallback(workLoop)</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">nextUnitOfWork</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback">requestIdleCallback</a>来做一个循环。您可以将requestIdleCallback视为setTimeout，但是我们不会告诉它何时运行，而是在主线程空闲时，浏览器将运行回调。</p>
<p>React不再使用requestIdleCallback。现在它使用 scheduler package。但是对于这个用例，它在概念上是相同的。</p>
<p>requestIdleCallback还为我们提供了一个deadline参数。我们可以用它来检查我们有多少时间，直到浏览器需要再次采取控制。</p>
<p>截至2019年11月，React中的并发模式还不稳定。循环的稳定版本看起来更像这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (nextUnitOfWork) &#123;    </span><br><span class="line">  nextUnitOfWork = performUnitOfWork(   </span><br><span class="line">    nextUnitOfWork  </span><br><span class="line">  ) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要开始使用循环，我们需要设置第一个工作单元，然后编写performUnitOfWork函数，该函数不仅执行工作，而且还返回下一个工作单元。</p>
<h2 id="Step-IV-Fibers"><a href="#Step-IV-Fibers" class="headerlink" title="Step IV: Fibers"></a>Step IV: Fibers</h2><p>Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进行增量式渲染</p>
<p>Fiber是怎么样的？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fiber = &#123;</span><br><span class="line">  tag: HOST_COMPONENT,</span><br><span class="line">  type: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  parent: parentFiber,</span><br><span class="line">  child: childFiber,</span><br><span class="line">  sibling: <span class="literal">null</span>,</span><br><span class="line">  alternate: currentFiber,</span><br><span class="line">  stateNode: <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>),</span><br><span class="line">  props: &#123; <span class="attr">children</span>: [], <span class="attr">className</span>: <span class="string">&quot;foo&quot;</span>&#125;,</span><br><span class="line">  partialState: <span class="literal">null</span>,</span><br><span class="line">  effectTag: PLACEMENT,</span><br><span class="line">  effects: []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了组织工作单元，我们需要一个数据结构: 一个 Fibers（纤程） 树。</p>
<ol>
<li>nextUnitOfWork将是对下一个工作 Fiber 的参考.</li>
<li>performUnitOfWork拿到 Fiber,并在其上工作, 并返回一个新的 Fiber 用于下一次 - 直到所有工作完成.</li>
</ol>
<p>每个元素都有一个fiber，每个fiber都是一个工作单元</p>
<p>假设我们现在想渲染一个像下面这样的 element tree</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Didact.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      &lt;p /&gt;</span><br><span class="line">      &lt;a /&gt;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">    &lt;h2 /&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  container</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p>在渲染中，我们将创建root fiber并将其设置为 nextUnitOfWork。剩下的工作将在performUnitOfWork函数上进行，在那里我们将为每一个 fiber做三件事：</p>
<ol>
<li>增加一个元素到DOM中</li>
<li>为元素的子元素 创建 fibers </li>
<li>选择下一个单元进行工作</li>
</ol>
<p>这种数据结构的目标之一是使查找下一个工作单元变得容易。这就是为什么每个 fiber都与它的第一个子元素、下一个兄弟元素和父元素相连。</p>
<p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gdjv84aj13j30ma0oo74u.jpg"></p>
<p>当我们完成对一个 fiber 的工作时，如果它有一个子元素，那么这个子元素将是下一个工作单元。在我们的示例中，当我们完成对div fiber 的工作时，下一个工作单元将是h1 fiber。</p>
<p>如果 fiber既没有子元素也没有兄弟元素，我们就去找叔叔:父母的兄弟姐妹。比如例子中的a和h2 fiber</p>
<p>同样，如果父结点没有兄弟结点，我们继续通过父结点，直到找到有兄弟结点的父结点，或者到达根结点。如果我们已经到达了根节点，这意味着我们已经完成了渲染的所有工作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是之前 的render</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    element.type == <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="built_in">document</span>.createElement(element.type)</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(element.props)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = element.props[name]</span><br><span class="line">    &#125;)</span><br><span class="line">​</span><br><span class="line">  element.props.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">    render(child, dom)</span><br><span class="line">  )</span><br><span class="line">​</span><br><span class="line">  container.appendChild(dom)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>现在先让我们将render从以上的代码中移除。我们将创建DOM节点的部分保留在它自己的函数中，稍后我们将使用它</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDom</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    fiber.type == <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="built_in">document</span>.createElement(fiber.type)</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(fiber.props)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = fiber.props[name]</span><br><span class="line">    &#125;)</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> dom</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO set next unit of work</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>在渲染函数中，我们将nextUnitOfWork设置为光纤树的根。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  nextUnitOfWork = &#123;</span><br><span class="line">    dom: container,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>然后，当浏览器准备好了，它将调用我们的 workLoop，我们将从root开始进行render</p>
<p>首先，我们创建一个新节点并将其附加到DOM。我们跟踪fiber.dom 属性中 的dom节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. TODO add element to Dom</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber)</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">if</span> (fiber.parent) &#123;</span><br><span class="line">    fiber.parent.dom.appendChild(fiber.dom)</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 2. TODO create new fibers</span></span><br><span class="line">  <span class="comment">// 3. TODO return next unit of work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们为每一个child 创建一个新的 fiber, 我们把它添加到Fibers中把它设置成子结点或者兄弟结点，这取决于它是不是第一个子结点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 2. create new fibers</span></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span></span><br><span class="line">​</span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">const</span> newFiber = &#123;</span><br><span class="line">      type: element.type,</span><br><span class="line">      props: element.props,</span><br><span class="line">      parent: fiber,</span><br><span class="line">      dom: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">    fiber.child = newFiber</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    prevSibling.sibling = newFiber</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  prevSibling = newFiber</span><br><span class="line">  index++</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure>

<p>最后，我们寻找下一个工作单元。我们首先对子元素进行测试，然后对兄弟元素进行测试，然后对父元素的兄弟元素进行测试，等等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. return next unit of work</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.sibling</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.parent</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这就是 performUnitOfWork 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. TODO add element to Dom</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber)</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">if</span> (fiber.parent) &#123;</span><br><span class="line">    fiber.parent.dom.appendChild(fiber.dom)</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 2. create new fibers</span></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span></span><br><span class="line">​</span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">const</span> newFiber = &#123;</span><br><span class="line">      type: element.type,</span><br><span class="line">      props: element.props,</span><br><span class="line">      parent: fiber,</span><br><span class="line">      dom: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prevSibling.sibling = newFiber</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    prevSibling = newFiber</span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 3. return next unit of work</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.sibling</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.parent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure>

<h2 id="Step-V-Render-and-Commit-Phases"><a href="#Step-V-Render-and-Commit-Phases" class="headerlink" title="Step V: Render and Commit Phases"></a>Step V: Render and Commit Phases</h2><p>我们这里还有另一个问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fiber.parent) &#123;</span><br><span class="line">  fiber.parent.dom.appendChild(fiber.dom)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每次处理元素时，我们都会向DOM添加一个新节点。 而且，请记住，在完成渲染整个树之前，浏览器可能会中断我们的工作。 在这种情况下，用户将看到不完整的UI。 而且我们不想要那样。</p>
<p>因此，我们需要从此处删除更改DOM的部分。</p>
<p>相反，我们将跟踪 Fibers 的根。我们称它为“正在进行的工作”</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    dom: container,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  nextUnitOfWork = wipRoot</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>一旦我们完成了所有的工作(我们知道它是因为没有下一个工作单元)，我们将整个Fibers提交到DOM。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = performUnitOfWork(</span><br><span class="line">      nextUnitOfWork</span><br><span class="line">    )</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> 判断是否将整个Fibers提交到DOM</span></span><br><span class="line">  <span class="keyword">if</span> (!nextUnitOfWork &amp;&amp; wipRoot) &#123;</span><br><span class="line">    commitRoot()</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  requestIdleCallback(workLoop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在commitRoot函数中做到这一点。 在这里，我们将所有节点递归附加到dom。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  commitWork(wipRoot.child)</span><br><span class="line">  wipRoot = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom</span><br><span class="line">  domParent.appendChild(fiber.dom)</span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Step-VI-Reconciliation"><a href="#Step-VI-Reconciliation" class="headerlink" title="Step VI: Reconciliation"></a>Step VI: Reconciliation</h2><p>到目前为止，我们只向DOM添加了一些东西，但是更新或删除节点又该如何操作呢？</p>
<p>这就是我们现在要做的，我们需要将渲染函数（render）上接收到的元素与提交给DOM的最后一个Fibers进行比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  commitWork(wipRoot.child)</span><br><span class="line">  currentRoot = wipRoot</span><br><span class="line">  wipRoot = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    dom: container,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">    alternate: currentRoot,</span><br><span class="line">  &#125;</span><br><span class="line">  nextUnitOfWork = wipRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentRoot = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>因此，我们需要保存对提交完成后提交到DOM的最后一个Fibers的引用。我们称之为currentRoot。</p>
<p>我们还为每个 fiber 添加了 alternate 属性。此属性链接到旧的 fiber，即我们在前一个提交阶段提交到DOM的 fiber。</p>
<p>现在让我们从创建新 fiber 的 performUnitOfWork 中提取代码，到一个新的reconcileChildren函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber)</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children</span><br><span class="line">  reconcileChildren(fiber, elements)</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.sibling</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.parent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在reconcileChildren函数中，我们将调和旧的 fiber 和新的元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">wipFiber, elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> 旧的Fiber</span></span><br><span class="line">  <span class="keyword">let</span> oldFiber = wipFiber.alternate &amp;&amp; wipFiber.alternate.child</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span></span><br><span class="line">  <span class="comment">//<span class="doctag">NOTE:</span> ​while ( index &lt; elements.length || oldFiber != null) &#123;...</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">while</span> ( index &lt; elements.length || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line">    <span class="keyword">let</span> newFiber = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 比较</span></span><br><span class="line">    <span class="keyword">const</span> sameType =</span><br><span class="line">      oldFiber &amp;&amp;</span><br><span class="line">      element &amp;&amp;</span><br><span class="line">      element.type == oldFiber.type</span><br><span class="line">  ​</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      <span class="comment">// ①. update the node</span></span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        type: oldFiber.type,</span><br><span class="line">        props: element.props,</span><br><span class="line">        dom: oldFiber.dom,</span><br><span class="line">        parent: wipFiber,</span><br><span class="line">        alternate: oldFiber,</span><br><span class="line">        effectTag: <span class="string">&quot;UPDATE&quot;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      <span class="comment">// ② add this node</span></span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        type: element.type,</span><br><span class="line">        props: element.props,</span><br><span class="line">        dom: <span class="literal">null</span>,</span><br><span class="line">        parent: wipFiber,</span><br><span class="line">        alternate: <span class="literal">null</span>,</span><br><span class="line">        effectTag: <span class="string">&quot;PLACEMENT&quot;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      <span class="comment">// ③ delete the oldFiber&#x27;s node</span></span><br><span class="line">      oldFiber.effectTag = <span class="string">&quot;DELETION&quot;</span></span><br><span class="line">      deletions.push(oldFiber)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们同时对旧fiber (wipFiber.alternate)的子元素和我们想要协调的元素数组进行迭代。</p>
<p>如果我们忽略同时遍历一个数组和一个链表所需的所有样板文件，那么在while中最重要的部分就剩下了:oldFiber和element。元素是我们想要呈现给DOM的东西，而oldFiber是我们上次呈现的东西。我们需要对它们进行比较，看看是否需要对DOM进行任何更改。</p>
<p>我们需要对它们进行比较，看看是否需要对DOM进行任何更改。</p>
<p>我们用类型来比较它们：</p>
<ol>
<li>如果旧的 Fiber 和新的 element 具有相同的类型，我们可以保留DOM节点并 使用新的 props 进行更新</li>
<li>如果类型不同并且有一个新元素，这意味着我们需要创建一个新的DOM节点</li>
<li>如果类型不同，有一个旧的 fiber，我们需要删除旧的节点</li>
</ol>
<p>在这里React也会使用 keys，这使得 reconciliation 更好。例如，它检测子元素在元素数组中的位置何时改变。</p>
<p>①. 当旧的 fiber 和元素具有相同的类型时，我们创建一个新 fiber，以保持DOM节点不受旧 fiber 的影响，而props不受元素的影响。我们还为 fiber 添加了一个新属性:effectTag，值为 ‘UPDATE’。稍后，在提交阶段，我们将使用此属性。</p>
<p>②. 然后，对于元素需要新的DOM节点的情况，我们使用 effectTag 为 ‘PLACEMENT’ 标记标记新的fiber。</p>
<p>③. 对于需要删除节点的情况，我们没有新的fiber，所以我们将effect标签添加到旧的fiber中。</p>
<p>但是，当我们将fiber tree提交到DOM时，我们从正在进行的工作根中执行，根中没有旧的fibers。因此，我们需要一个数组来跟踪要删除的节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  deletions = []</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">let</span> deletions = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>然后，当我们将更改提交到DOM时，我们还将使用来自该数组的 fiber。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  deletions.forEach(commitWork)</span><br><span class="line">  commitWork(wipRoot.child)</span><br><span class="line">  currentRoot = wipRoot</span><br><span class="line">  wipRoot = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们更改commitWork函数来处理新的 effectTags</p>
<p>如果fiber具有以一个 ‘PLACEMENT’ 的 effect tag，我们将执行与前面相同的操作，将DOM节点追加到来自父 fiber 的节点。如果是’DELETION’，则相反，删除子节点。如果是 UPDATE，则需要使用 props 更新现有的DOM节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (</span><br><span class="line">    fiber.effectTag === <span class="string">&quot;PLACEMENT&quot;</span> &amp;&amp;</span><br><span class="line">    fiber.dom != <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    domParent.appendChild(fiber.dom)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    fiber.effectTag === <span class="string">&quot;UPDATE&quot;</span> &amp;&amp;</span><br><span class="line">    fiber.dom != <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    updateDom(</span><br><span class="line">      fiber.dom,</span><br><span class="line">      fiber.alternate.props,</span><br><span class="line">      fiber.props</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>增加一个 updateDom 函数，我们将旧Fiber的props和新Fiber的props进行对比，去掉已经消失的props，设置新的或者更改过的props。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span></span><br><span class="line"><span class="keyword">const</span> isNew = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function"><span class="params">key</span> =&gt;</span> prev[key] !== next[key]</span><br><span class="line"><span class="keyword">const</span> isGone = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function"><span class="params">key</span> =&gt;</span> !(key <span class="keyword">in</span> next)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. Remove old properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isGone(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 2. Set new or changed properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = nextProps[name]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure>

<p>我们需要更新的一种特殊类型的 props 是事件监听器，因此如果 props 名称以on前缀开头，我们将以不同的方式处理它们。</p>
<p>如果事件处理程序发生更改，则将其从节点中删除。然后我们添加新的处理器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isEvent = <span class="function"><span class="params">key</span> =&gt;</span> key.startsWith(<span class="string">&quot;on&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">  key !== <span class="string">&quot;children&quot;</span> &amp;&amp; !isEvent(key)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//3. Remove old or changed event listeners</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isEvent)</span><br><span class="line">    .filter(<span class="function"><span class="params">key</span> =&gt;</span>!(key <span class="keyword">in</span> nextProps) || isNew(prevProps, nextProps)(key))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name</span><br><span class="line">        .toLowerCase()</span><br><span class="line">        .substring(<span class="number">2</span>)</span><br><span class="line">      dom.removeEventListener(</span><br><span class="line">        eventType,</span><br><span class="line">        prevProps[name]</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. Add event listeners</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isEvent)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name</span><br><span class="line">        .toLowerCase()</span><br><span class="line">        .substring(<span class="number">2</span>)</span><br><span class="line">      dom.addEventListener(</span><br><span class="line">        eventType,</span><br><span class="line">        nextProps[name]</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Step-VII-Function-Components"><a href="#Step-VII-Function-Components" class="headerlink" title="Step VII: Function Components"></a>Step VII: Function Components</h2><p>接下来我们需要添加的是对函数组件的支持。首先让我们更改示例。我们将使用这个简单的函数组件，它返回一个h1元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">Didact.render(element, container)</span><br></pre></td></tr></table></figure>
<p>注意，如果我们将jsx转换成js，它将是</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Didact.createElement(</span><br><span class="line">    <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;Hi &quot;</span>,</span><br><span class="line">    props.name</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = Didact.createElement(App, &#123;</span><br><span class="line">  name: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>函数组件有两种不同的方面:</p>
<ol>
<li>来自函数组件的fiber没有DOM节点</li>
<li>子组件通过运行函数而不是直接从props获取</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber)</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children</span><br><span class="line">  reconcileChildren(fiber, elements)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们检查fiber类型是否是一个函数，根据这个函数，我们进入一个不同的更新函数。在updateHostComponent中，我们执行与前面相同的操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isFunctionComponent =</span><br><span class="line">    fiber.type <span class="keyword">instanceof</span> <span class="built_in">Function</span></span><br><span class="line">  <span class="keyword">if</span> (isFunctionComponent) &#123;</span><br><span class="line">    updateFunctionComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber)</span><br><span class="line">  &#125;</span><br><span class="line">  reconcileChildren(fiber, fiber.props.children)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在updateFunctionComponent中，我们运行函数来获取子元素。以fiber为例。类型是App函数，当我们运行它时，它返回h1元素。然后，一旦我们有了子元素，reconciliation 以同样的方式进行，我们不需要改变任何东西。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)]</span><br><span class="line">  reconcileChildren(fiber, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要改变的是commitWork函数。现在我们有了没有DOM节点的fiber，我们需要改变两件事。</p>
<p>首先，要找到DOM节点的父节点，我们需要沿着fiber tree往上走，直到找到带有DOM节点的fiber为止。</p>
<p>由<code>const domParent = fiber.parent.dom</code> 变为以下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> domParentFiber = fiber.parent</span><br><span class="line">  <span class="keyword">while</span> (!domParentFiber.dom) &#123;</span><br><span class="line">    domParentFiber = domParentFiber.parent</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = domParentFiber.dom</span><br><span class="line">​</span><br></pre></td></tr></table></figure>

<p>在删除节点时，我们还需要继续操作，直到找到带有DOM节点的子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">    commitDeletion(fiber, domParent)</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitDeletion</span>(<span class="params">fiber, domParent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.dom) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    commitDeletion(fiber.child, domParent)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Step-VIII-Hooks"><a href="#Step-VIII-Hooks" class="headerlink" title="Step VIII: Hooks"></a>Step VIII: Hooks</h2><p>最后一步。现在我们有了函数组件，让我们加上状态。</p>
<p>让我们将示例更改为典型的计数器组件。每次点击它，状态都会增加1。请注意，我们正在使用Didact。获取和更新计数器值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">  render,</span><br><span class="line">  useState,</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = Didact.useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h1 onClick=&#123;<span class="function">() =&gt;</span> setState(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">      Count: &#123;state&#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">Didact.render(element, container)</span><br></pre></td></tr></table></figure>

<p>这里是我们从例子中调用计数器函数的地方。在这个函数中，我们调用useState</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)]</span><br><span class="line">  reconcileChildren(fiber, children)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们需要在调用函数组件之前初始化一些全局变量，以便可以在useState函数内部使用它们。首先，我们把工作放在fiber中进行。我们还将一个hooks数组添加到fiber中，以支持在同一个组件中多次调用useState。我们跟踪当前的hookIndex。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wipFiber = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> hookIndex = <span class="literal">null</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  wipFiber = fiber</span><br><span class="line">  hookIndex = <span class="number">0</span></span><br><span class="line">  wipFiber.hooks = []</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当函数组件调用useState时，我们检查是否有旧的hooks。使用hookIndex来检查fiber的交替。</p>
<p>如果我们有一个旧hooks，我们将状态从旧hooks复制到新hooks，否则，我们将初始化状态。</p>
<p>然后将新hooks添加到fibers中，将hookIndex增加1，并返回状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldHook =</span><br><span class="line">    wipFiber.alternate &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks[hookIndex]</span><br><span class="line">  <span class="keyword">const</span> hook = &#123;</span><br><span class="line">    state: oldHook ? oldHook.state : initial,</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  wipFiber.hooks.push(hook)</span><br><span class="line">  hookIndex++</span><br><span class="line">  <span class="keyword">return</span> [hook.state]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>useState还应该返回一个用于更新状态的函数，因此我们定义了一个setState函数，该函数接收一个action（对于Counter示例，此动作是将状态加1的函数）。</p>
<p>我们将该动作推送到添加到Hooks上的队列中。</p>
<p>然后，我们执行与在render函数中所做的类似的操作，将新的进行中的工作根设置为下一个工作单元，以便工作循环可以开始新的渲染阶段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldHook =</span><br><span class="line">    wipFiber.alternate &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks[hookIndex]</span><br><span class="line">  <span class="keyword">const</span> hook = &#123;</span><br><span class="line">    state: oldHook ? oldHook.state : initial,</span><br><span class="line">    queue: [],</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    hook.queue.push(action)</span><br><span class="line">    wipRoot = &#123;</span><br><span class="line">      dom: currentRoot.dom,</span><br><span class="line">      props: currentRoot.props,</span><br><span class="line">      alternate: currentRoot,</span><br><span class="line">    &#125;</span><br><span class="line">    nextUnitOfWork = wipRoot</span><br><span class="line">    deletions = []</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">  wipFiber.hooks.push(hook)</span><br><span class="line">  hookIndex++</span><br><span class="line">  <span class="keyword">return</span> [hook.state, setState]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们还没有开始执行。我们在下次渲染组件时这样做，我们会从旧的Hoos队列中获取所有action，然后一个接一个地将它们应用到新的Hooks状态中，这样当我们返回状态时，它就更新了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = oldHook ? oldHook.queue : []</span><br><span class="line"> actions.forEach(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">   hook.state = action(hook.state)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p>现在，我们已经构建了自己的React版本。</p>
<p>除了帮助理解React如何工作外，本文的目标之一是使人更容易深入了解React代码库。这就是为什么我们在几乎所有地方都使用相同的变量和函数名。例如，如果在真实的React应用程序的某个函数组件中添加断点，调用堆栈应该会显示:workLoop、performUnitOfWork、updateFunctionComponent。</p>
<p>我们没有包含很多的React特性和优化。例如，有几件事情的反应是不同的:在Didact中，我们在渲染阶段遍历整个树。React遵循一些提示和启发来跳过没有变化的整个子树。我们还在提交阶段遍历整个树。React保持一个链表，只访问有效果的fiber，只访问那些fiber。每当我们构建一个新的工作进展树，我们为每个fibers创建新的对象。React回收利用旧树的fiber。当Didact在渲染阶段收到一个新的更新时，它会丢弃正在进行的工作树，并从根节点重新开始。React为每个更新添加一个过期时间戳，并使用它来决定哪个更新具有更高的优先级。</p>
<p>附完整js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children: children.map(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span> ? child : createTextElement(child)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextElement</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      nodeValue: text,</span><br><span class="line">      children: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDom</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    fiber.type == <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="built_in">document</span>.createElement(fiber.type);</span><br><span class="line"></span><br><span class="line">  updateDom(dom, &#123;&#125;, fiber.props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isEvent = <span class="function"><span class="params">key</span> =&gt;</span> key.startsWith(<span class="string">&quot;on&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span> &amp;&amp; !isEvent(key);</span><br><span class="line"><span class="keyword">const</span> isNew = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function"><span class="params">key</span> =&gt;</span> prev[key] !== next[key];</span><br><span class="line"><span class="keyword">const</span> isGone = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function"><span class="params">key</span> =&gt;</span> !(key <span class="keyword">in</span> next);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//Remove old or changed event listeners</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isEvent)</span><br><span class="line">    .filter(<span class="function"><span class="params">key</span> =&gt;</span> !(key <span class="keyword">in</span> nextProps) || isNew(prevProps, nextProps)(key))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">      dom.removeEventListener(eventType, prevProps[name]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove old properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isGone(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set new or changed properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = nextProps[name];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add event listeners</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isEvent)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">      dom.addEventListener(eventType, nextProps[name]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  deletions.forEach(commitWork);</span><br><span class="line">  commitWork(wipRoot.child);</span><br><span class="line">  currentRoot = wipRoot;</span><br><span class="line">  wipRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> domParentFiber = fiber.parent;</span><br><span class="line">  <span class="keyword">while</span> (!domParentFiber.dom) &#123;</span><br><span class="line">    domParentFiber = domParentFiber.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = domParentFiber.dom;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;PLACEMENT&quot;</span> &amp;&amp; fiber.dom != <span class="literal">null</span>) &#123;</span><br><span class="line">    domParent.appendChild(fiber.dom);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;UPDATE&quot;</span> &amp;&amp; fiber.dom != <span class="literal">null</span>) &#123;</span><br><span class="line">    updateDom(fiber.dom, fiber.alternate.props, fiber.props);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">    commitDeletion(fiber, domParent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  commitWork(fiber.child);</span><br><span class="line">  commitWork(fiber.sibling);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitDeletion</span>(<span class="params">fiber, domParent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.dom) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    commitDeletion(fiber.child, domParent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    dom: container,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: [element]</span><br><span class="line">    &#125;,</span><br><span class="line">    alternate: currentRoot</span><br><span class="line">  &#125;;</span><br><span class="line">  deletions = [];</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> currentRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> deletions = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextUnitOfWork &amp;&amp; wipRoot) &#123;</span><br><span class="line">    commitRoot();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  requestIdleCallback(workLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestIdleCallback(workLoop);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isFunctionComponent = fiber.type <span class="keyword">instanceof</span> <span class="built_in">Function</span>;</span><br><span class="line">  <span class="keyword">if</span> (isFunctionComponent) &#123;</span><br><span class="line">    updateFunctionComponent(fiber);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber;</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wipFiber = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> hookIndex = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  wipFiber = fiber;</span><br><span class="line">  hookIndex = <span class="number">0</span>;</span><br><span class="line">  wipFiber.hooks = [];</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)];</span><br><span class="line">  reconcileChildren(fiber, children);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldHook =</span><br><span class="line">    wipFiber.alternate &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks[hookIndex];</span><br><span class="line">  <span class="keyword">const</span> hook = &#123;</span><br><span class="line">    state: oldHook ? oldHook.state : initial,</span><br><span class="line">    queue: []</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> actions = oldHook ? oldHook.queue : [];</span><br><span class="line">  actions.forEach(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    hook.state = action(hook.state);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    hook.queue.push(action);</span><br><span class="line">    wipRoot = &#123;</span><br><span class="line">      dom: currentRoot.dom,</span><br><span class="line">      props: currentRoot.props,</span><br><span class="line">      alternate: currentRoot</span><br><span class="line">    &#125;;</span><br><span class="line">    nextUnitOfWork = wipRoot;</span><br><span class="line">    deletions = [];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  wipFiber.hooks.push(hook);</span><br><span class="line">  hookIndex++;</span><br><span class="line">  <span class="keyword">return</span> [hook.state, setState];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  reconcileChildren(fiber, fiber.props.children);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">wipFiber, elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = wipFiber.alternate &amp;&amp; wipFiber.alternate.child;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line">    <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sameType = oldFiber &amp;&amp; element &amp;&amp; element.type == oldFiber.type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        type: oldFiber.type,</span><br><span class="line">        props: element.props,</span><br><span class="line">        dom: oldFiber.dom,</span><br><span class="line">        parent: wipFiber,</span><br><span class="line">        alternate: oldFiber,</span><br><span class="line">        effectTag: <span class="string">&quot;UPDATE&quot;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        type: element.type,</span><br><span class="line">        props: element.props,</span><br><span class="line">        dom: <span class="literal">null</span>,</span><br><span class="line">        parent: wipFiber,</span><br><span class="line">        alternate: <span class="literal">null</span>,</span><br><span class="line">        effectTag: <span class="string">&quot;PLACEMENT&quot;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      oldFiber.effectTag = <span class="string">&quot;DELETION&quot;</span>;</span><br><span class="line">      deletions.push(oldFiber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      wipFiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element) &#123;</span><br><span class="line">      prevSibling.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevSibling = newFiber;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">  render,</span><br><span class="line">  useState</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = Didact.useState(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h1 onClick=&#123;<span class="function">() =&gt;</span> setState(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)&#125; style=<span class="string">&quot;user-select: none&quot;</span>&gt;</span><br><span class="line">      Count: &#123;state&#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">Didact.render(element, container);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>ThreadPoolExecutor源码解析</title>
    <url>/2020/02/04/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="构造方法参数"><a href="#构造方法参数" class="headerlink" title="构造方法参数"></a>构造方法参数</h2><p>1.构造方法就不在此赘述，重点关注构造方法种的参数。</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>参数名</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td align="center">核心线程池大小</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td align="center">最大线程池大小</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td align="center">线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)使得核心线程有效时间</td>
</tr>
<tr>
<td>TimeUnit</td>
<td align="center">keepAliveTime时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td align="center">阻塞任务队列</td>
</tr>
<tr>
<td>threadFactory</td>
<td align="center">新建线程工厂</td>
</tr>
<tr>
<td>RejectedExecutionHandler</td>
<td align="center">当提交任务数超过maxmumPoolSize+workQueue之和时，任务会交给RejectedExecutionHandler来处理</td>
</tr>
</tbody></table>
<p>2.重点理解：  corePoolSize  ，  maximumPoolSize ，workQueue这三者之间的联系</p>
<p>a.当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线 程。     b.当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行<br>c.当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务<br>d.当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理<br>e.当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程<br>f.当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭 </p>
<h2 id="核心变量"><a href="#核心变量" class="headerlink" title="核心变量"></a>核心变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意，代码的注释都在代码之后。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING,<span class="number">0</span>))；</span><br><span class="line">      <span class="comment">//标志当前线程池的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">     <span class="comment">//   等于29(标记线程个数)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//  CAPACITY =  0001 1111 1111 1111 1111 1111 1111 1111   </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池的各种状态：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//用二进制表示RUNNING  1110  0000 0000 0000 0000 0000 0000 0000 运行态，可处理新任务并执行队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//用二进制表示SHUTDOWN 0000  0000 0000 0000 0000 0000 0000 0000 关闭态，不接受新任务，但处理队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP   =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//用二进制表示STOP     0010  0000 0000 0000 0000 0000 0000 0000 停止态，不接受新任务，不处理队列中任务，且打断运行中任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING  =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//用二进制表示TIDYING  0100  0000 0000 0000 0000 0000 0000 0000 整理态，所有任务已经结束，workerCount = 0 ，将执行terminated()方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS</span><br><span class="line"><span class="comment">//用二进制表示TERMINATED 0110  0000 0000 0000 0000 0000 0000 0000  结束态，terminated() 方法已完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue；</span><br><span class="line"><span class="comment">//任务缓存队列，用来存放等待执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//操作许多变量都需要这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">//存放工作集，需要获取mainLock才可以操作这个变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"><span class="comment">//是否允许为核心线程设置存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">//用来记录线程池中曾经出现过的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount</span><br><span class="line"><span class="comment">//用来记录已经执行完毕的任务个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>状态</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>运行态，可处理新任务并执行队列中的任务</td>
</tr>
<tr>
<td>SHUTDOW</td>
<td>关闭态，不接受新任务，但处理队列中的任务</td>
</tr>
<tr>
<td>STOP</td>
<td>停止态，不接受新任务，不处理队列中任务，且打断运行中任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>整理态，所有任务已经结束，workerCount = 0，将执行terminated()方法</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>结束态，terminated() 方法已完成</td>
</tr>
</tbody></table>
<p><strong>状态转换：</strong></p>
<p><em>RUNNING -&gt; SHUTDOWN</em>：手动调用shutdown方法，或者ThreadPoolExecutor要被GC回收的时候调用finalize方法，finalize方法内部也会调用shutdown方法</p>
<p><em>(RUNNING or SHUTDOWN) -&gt; STOP</em>：调用shutdownNow方法</p>
<p><em>SHUTDOWN -&gt; TIDYING</em>：当队列和线程池都为空的时候</p>
<p><em>STOP -&gt; TIDYING</em>：当线程池为空的时候</p>
<p><em>TIDYING -&gt; TERMINATED</em>：terminated方法调用完成之后</p>
<p><strong>ThreadPoolExecutor演示状态图</strong></p>
<p><img src= "/img/loading.gif" data-src="executor.png" alt="ThreadPoolExecutor执行状态图"></p>
<blockquote>
<p>摘自：<a href="https://www.jianshu.com/p/f8a73cb0983a">https://www.jianshu.com/p/f8a73cb0983a</a></p>
</blockquote>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="runStateOf-int-c-计算线程池当前的状态"><a href="#runStateOf-int-c-计算线程池当前的状态" class="headerlink" title="runStateOf(int c)  计算线程池当前的状态"></a>runStateOf(int c)  计算线程池当前的状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法是计算出线程池的状态，</span></span><br><span class="line"><span class="comment"> * 由于 CAPACITY =  0001 1111 1111 1111 1111 1111 1111 1111 ，在进行取反运算后 </span></span><br><span class="line"><span class="comment"> * 变为11100000000000000000000000000000，再于参数做 &amp; 操作,会将低29位全部置为0,而   </span></span><br><span class="line"><span class="comment"> * 高三位还是保持 111 不变，就可以判断出线程池当前处于什么状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; ~CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="workerCountOf-int-c-计算线程数量"><a href="#workerCountOf-int-c-计算线程数量" class="headerlink" title="workerCountOf(int c) 计算线程数量"></a>workerCountOf(int c) 计算线程数量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法是计算当前线程池种线程的数量</span></span><br><span class="line"><span class="comment"> * CAPACITY =  0001 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment"> * 参数 c 与 CAPACITY 进行 &amp; 运算后，会保留 c 低29位的值，从而知道线程数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ctlOf-int-rs-int-wc"><a href="#ctlOf-int-rs-int-wc" class="headerlink" title="ctlOf(int rs, int wc)"></a>ctlOf(int rs, int wc)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 此方法是为了在本ThreadPoolExecutor种只是为了将“线程状态”和“线程数量” 放在一个变量中</span></span><br><span class="line"><span class="comment">  * 比如 ctlOf(RUNNING, 0)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="execute-Runnable-command-execute-是开启ThreadPoolExecutor工作的方法。"><a href="#execute-Runnable-command-execute-是开启ThreadPoolExecutor工作的方法。" class="headerlink" title="execute(Runnable command)  execute 是开启ThreadPoolExecutor工作的方法。"></a>execute(Runnable command)  execute 是开启ThreadPoolExecutor工作的方法。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 通过位运算得出当然线程池中的worker数量与构造参数corePoolSize进行比较</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 如果小于corePoolSize，则直接新增一个worker，并把当然用户提交的任务               command作为参数，如果成功则返回。</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">// 如果失败，则获取最新的线程池数据</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//如果线程池仍在运行，则把任务放到阻塞队列中等待执行。</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         <span class="comment">//这里的recheck思路是为了处理并发问题,再次检查线程池的状态是否为运行态</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">         <span class="comment">//当任务成功放入队列时，如果recheck发现线程池已经不再运行了则从队列中把任务             删除</span></span><br><span class="line">            <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                <span class="comment">// 删除成功以后，会调用构造参数传入的拒绝策略。</span></span><br><span class="line">                reject(command);</span><br><span class="line">                <span class="comment">// 如果worker的数量为0（此时队列中可能有任务没有执行），则新建一个                  worker（由于此时新建woker的目的是执行队列中堆积的任务，</span></span><br><span class="line">                <span class="comment">// 因此入参没有执行任务，请接着看 addWorker 方法）。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果前面的新增woker，放入队列都失败，则会继续新增worker此时线程池的状态是woker数量达到corePoolSize，阻塞队列任务已满</span></span><br><span class="line">        <span class="comment">//只能基于maximumPoolSize参数新建woker</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​   其实从以上execute 可以看出，再执行该方法时，会根据线程池的状态等进行不用的操作 a,直接创建线程池  b，添加到阻塞队列  c.  基于maximumPoolSize创建work</p>
<h3 id="addWorker-Runnable-firstTask-boolean-core"><a href="#addWorker-Runnable-firstTask-boolean-core" class="headerlink" title="addWorker(Runnable firstTask, boolean core)"></a>addWorker(Runnable firstTask, boolean core)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//CAS 操作校验线程池的状态</span></span><br><span class="line">       retry:</span><br><span class="line">       <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">           <span class="comment">//检查线程池 是否是 SHUTDOWN 状态 ,如果 “是SHUTDOWN 状态” &amp;&amp; “不是SHUTDOWN or  firstTask不是null or  workQueue不是空” 就不能添加</span></span><br><span class="line">           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                   !(rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                           firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                           !workQueue.isEmpty()))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">               <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">               <span class="comment">//校验线程数量</span></span><br><span class="line">               <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                       wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="comment">//线程数加1  CAS 操作 ，操作成功跳出循环</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                   <span class="keyword">break</span> retry; <span class="comment">//线程池加 1 成功，跳出循环</span></span><br><span class="line">                <span class="comment">//加1 失败，获取最新的线程池个数，判断线程池状态........</span></span><br><span class="line">               c = ctl.get(); </span><br><span class="line">               <span class="comment">//判断当前线程池状态是不是之前获取过的线程池状态，</span></span><br><span class="line">               <span class="comment">//如果不是，说明又别的地方已经将线程池数量、状态改变了，要从retry开始操作</span></span><br><span class="line">               <span class="comment">//如果是，说明不用再次判断线程池状态，继续当前循环即可</span></span><br><span class="line">               <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                   <span class="keyword">continue</span> retry;</span><br><span class="line">               <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">       ThreadPoolExecutor.Worker w = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//通过线程池构造函数参数threadFactory生成的woker对象</span></span><br><span class="line">           <span class="comment">//注意 Work 对象其实实现了 Runnable 它本身就是一个线程，Work 对象会 firstTask保              存我们的自定义线程</span></span><br><span class="line">           w = <span class="keyword">new</span> ThreadPoolExecutor.Worker(firstTask);           </span><br><span class="line">           <span class="comment">//这个变量t就是代表woker线程，不是用户提交的线程任务firstTask！！！</span></span><br><span class="line">           <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">           <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                <span class="comment">// 加锁,对线程池状态进行判断</span></span><br><span class="line">               mainLock.lock();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//获取线程池状态</span></span><br><span class="line">                   <span class="keyword">int</span> rs = runStateOf(ctl.get()); </span><br><span class="line">                   <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                           (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                       <span class="comment">//新建的work不能是存活，因为还没运行</span></span><br><span class="line">                       <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                       <span class="comment">//把新建的woker线程放入集合保存 -&gt;  HashSet</span></span><br><span class="line">                       workers.add(w);           </span><br><span class="line">                       <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                       <span class="comment">//为了实时监控 线程池中的线程数量</span></span><br><span class="line">                       <span class="keyword">if</span> (s &gt; largestPoolSize)  </span><br><span class="line">                           largestPoolSize = s;</span><br><span class="line">                       workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   mainLock.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//添加成功，开始执行</span></span><br><span class="line">               <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                   t.start();</span><br><span class="line">                   workerStarted = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//添加失败</span></span><br><span class="line">           <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">               addWorkerFailed(w);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> workerStarted;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​   在 addWork方法种，我们可以看到，ThreadPoolExecutor为了更高效的运行，只在必要的地方加锁，而其他操作采用CAS 操作来解决并发问题，关于CAS操作，请浏览本文最后一节。</p>
<h3 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h3><p>​   程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，看一下Worker的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">          <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">          <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Thread thread;</span><br><span class="line">    </span><br><span class="line">      Runnable firstTask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">      Worker(Runnable firstTask) &#123;</span><br><span class="line">          setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">          <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">          <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          runWorker(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Lock methods</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">      <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">              setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">          setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">          setState(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          acquire(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> tryAcquire(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          release(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> isHeldExclusively();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Thread t;</span><br><span class="line">          <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  t.interrupt();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Worker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。</p>
<p>在调用构造方法时，需要把任务传入，这里通过<code>getThreadFactory().newThread(this);</code>来新建一个线程，newThread方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。</p>
<p>Worker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的：</p>
<ol>
<li><p>lock方法一旦获取了独占锁，表示当前线程正在执行任务中，这时就不能中断该线程。</p>
</li>
<li><p>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</p>
</li>
<li><p>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；</p>
</li>
<li><p>之所以设置为不可重入，是因为不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。下面是setCorePoolSize方法，interruptIdleWorkers请接着往下看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">int</span> delta = corePoolSize - <span class="keyword">this</span>.corePoolSize;</span><br><span class="line">       <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)</span><br><span class="line">           <span class="comment">//中断线程</span></span><br><span class="line">           interruptIdleWorkers();</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> k = Math.min(delta, workQueue.size());</span><br><span class="line">           <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (workQueue.isEmpty())</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。</p>
<p>​   在构造方法中<code>setState(-1);</code>，把state变量设置为-1，为什么这么做呢？是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> tryAcquire(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">              setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="runWork"><a href="#runWork" class="headerlink" title="runWork ()"></a>runWork ()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(ThreadPoolExecutorBak.Worker w)</span> </span>&#123;</span><br><span class="line">       Thread wt = Thread.currentThread();</span><br><span class="line">       Runnable task = w.firstTask;</span><br><span class="line">       w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">       w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">       <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//如果task不为null 或者 从队列中取出的任务不为null</span></span><br><span class="line">           <span class="comment">//task != null 成立时，直接运行，不会从队列中拿任务; 只有再不成立时 才回去队列里               拿任务</span></span><br><span class="line">           <span class="comment">//当 task 传null 意味着建立工作线程执行队列中的自定义线程</span></span><br><span class="line">           <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               w.lock();</span><br><span class="line">               <span class="comment">//interrupt() 中断线程；interrupted()和isInterrupted()判断线程是否中断</span></span><br><span class="line">               <span class="comment">//Thread.interrupted() 测试当前线程是否被中断，并清除中断位</span></span><br><span class="line">               <span class="comment">//wt.isInterrupted() 测试wt线程是否被中断，不清楚状态位，直接返回是否被中断</span></span><br><span class="line">               <span class="comment">//如果（当前线程池的状态已经成为 STOP 状态 || (当前线程已终端 &amp;&amp; 线程池成为                          STOP）） &amp;&amp; wt线程不是中断状态</span></span><br><span class="line">               <span class="comment">//其实这个判断可以这么理解:</span></span><br><span class="line">               <span class="comment">//1，如果当前线程池已经是 STOP状态，那么 </span></span><br><span class="line">               <span class="comment">//   (runStateAtLeast(ctl.get(), STOP) ||(Thread.interrupted() &amp;&amp;                        runStateAtLeast(ctl.get(), STOP))肯定会返回true,将会直接中断wt</span></span><br><span class="line">               <span class="comment">//2, 如果当前线程池不是STOP状态，例如：running 那么 runStateAtLeast会返回                        false, Thread.interrupted()会清除中断位，如果 wt还是中断状态，将会                       直接中断wt</span></span><br><span class="line">               <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                       (Thread.interrupted() &amp;&amp;</span><br><span class="line">                               runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                       !wt.isInterrupted())</span><br><span class="line">                   wt.interrupt();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 无实现</span></span><br><span class="line">                   beforeExecute(wt, task);</span><br><span class="line">                   Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//用户提交的线程启动</span></span><br><span class="line">                       task.run();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                       thrown = x;</span><br><span class="line">                       <span class="keyword">throw</span> x;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                       thrown = x;</span><br><span class="line">                       <span class="keyword">throw</span> x;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                       thrown = x;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       <span class="comment">//无实现</span></span><br><span class="line">                       afterExecute(task, thrown);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   task = <span class="keyword">null</span>;</span><br><span class="line">                   w.completedTasks++;</span><br><span class="line">                   w.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//如果异常终止 completedAbruptly = true</span></span><br><span class="line">           processWorkerExit(w, completedAbruptly);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">//在必要的条件下检查任务队列是否为empty</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">// 减少线程池中线程数量，返回null</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//TODO 获取任务并返回，如果是定时等待任务，则使用poll方法，否则使用take方法</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​   </p>
<h3 id="getActiveCount（）-方法"><a href="#getActiveCount（）-方法" class="headerlink" title="getActiveCount（） 方法"></a>getActiveCount（） 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只是判断工作线程是否上锁</span></span><br><span class="line">        <span class="keyword">for</span> (ThreadPoolExecutorBak.Worker w : workers)</span><br><span class="line">            <span class="keyword">if</span> (w.isLocked())</span><br><span class="line">                ++n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> isHeldExclusively();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            release(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​   之前一直在疑惑 ThreadPoolExecutor.getActiveCount()为什么不准确，在work开始运行时，会执行一次unlock，也就是说会将 state 设置为0 ，而线程还未开始运行，所以当调用w.isLocked 时，只是判断 state != 0 ,那这是 isHeldExclusively 肯定返回false ,而  getActiveCount的值就不是最新，最准确的值。</p>
<h3 id="shutdown-与-shutdownNow"><a href="#shutdown-与-shutdownNow" class="headerlink" title="shutdown() 与 shutdownNow()"></a>shutdown() 与 shutdownNow()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检查安全权限</span></span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">//更改线程池状态</span></span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            <span class="comment">//这里只是尝试中断线程</span></span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            onShutdown(); <span class="comment">// hook for ScheduledThreakPoolExecutorBak</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="comment">//runStateAtLeast c &gt;= targetState</span></span><br><span class="line">            <span class="comment">//如果线程池已经达到 targetState 状态，那么直接返回，如果还没达到，将c 改为 targetState状态</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, targetState) ||</span><br><span class="line">                    ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//shutdownNow</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Runnable&gt; tasks;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">//和 shutdown() 处理方式一样，传参不一样而已</span></span><br><span class="line">            advanceRunState(STOP);</span><br><span class="line">            <span class="comment">//中断所有的 work线程</span></span><br><span class="line">            interruptWorkers();</span><br><span class="line">            <span class="comment">//取出阻塞队列中的work</span></span><br><span class="line">            tasks = drainQueue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">        <span class="keyword">return</span> tasks;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//中断线程</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (ThreadPoolExecutorBak.Worker w : workers)</span><br><span class="line">                w.interruptIfStarted();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 中断线程，无论线程是否处于空闲状态</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//拿出阻塞队列中的work  </span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">        ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">        <span class="comment">// drainTo():</span></span><br><span class="line">        <span class="comment">// 一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），</span></span><br><span class="line">        <span class="comment">//通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</span></span><br><span class="line">        q.drainTo(taskList);</span><br><span class="line">        <span class="comment">//如果还有接着从 workQueue 中拿出</span></span><br><span class="line">        <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.remove(r))</span><br><span class="line">                    taskList.add(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> taskList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​   上面程序的解释，可以明显看出shutdownNow 和 shutdown的区别。shutdown只会将线程池状态修改，也会中断线程，但是会的等所有正在运行的线程运行完成后中断但；shutdownNow 会直接结束正在运行的线程和清除队列中的线程。中断方法接着往下看。</p>
<h3 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate()"></a>tryTerminate()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试终止函数</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="comment">// 以下状态直接返回：</span></span><br><span class="line">        <span class="comment">// 1.线程池还处于RUNNING状态</span></span><br><span class="line">        <span class="comment">// 2.SHUTDOWN状态但是任务队列非空</span></span><br><span class="line">        <span class="comment">// 3.runState &gt;= TIDYING 线程池已经停止了或在停止了</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                runStateAtLeast(c, TIDYING) ||</span><br><span class="line">                (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//  workerCount不为0 则还不能停止线程池,而且这时线程都处于空闲等待的状态</span></span><br><span class="line">        <span class="comment">//  需要中断让线程“醒”过来，醒过来的线程才能继续处理shutdown的信号。</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            <span class="comment">//runWoker方法中w.unlock就是为了可以被中断,getTask方法也处理了中断。</span></span><br><span class="line">            <span class="comment">//ONLY_ONE:这里只需要中断1个线程去处理shutdown信号就可以了。</span></span><br><span class="line">            <span class="comment">//这里问什么传 ONLY_ONE ？</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//进入TIDYING状态</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">//继续awaitTermination</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​   tryTerminate这个方法会在多处调用，比如processWorkerExit、addWorkerFailed、shutdown、shutdownNow、remove、purge 中调用，为什么会多处调用？ 在这个方法中调用了 interruptIdleWorkers方法，请接着往下看。</p>
<h3 id="interruptIdleWorkers-boolean-onlyOne-和-interruptIdleWorkers"><a href="#interruptIdleWorkers-boolean-onlyOne-和-interruptIdleWorkers" class="headerlink" title="interruptIdleWorkers(boolean onlyOne) 和 interruptIdleWorkers()"></a>interruptIdleWorkers(boolean onlyOne) 和 interruptIdleWorkers()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//shutdown方法就是调用该下面的方法，去中断空闲线程，而不是中断所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这里为什么要获取mainLock锁，因为workers是HashSet 是线程不安全的，</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (ThreadPoolExecutorBak.Worker w : workers) &#123;</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                <span class="comment">// 由于Work实现的是AQS是不可重入的，所以只能等正在运行的线程主动释放锁</span></span><br><span class="line">                <span class="comment">// 如果线程可以被中断 并且 可以获取锁 ，那么就执行中断</span></span><br><span class="line">                <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        w.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="processWorkerExit-ThreadPoolExecutorBak-Worker-w-boolean-completedAbruptly-方法"><a href="#processWorkerExit-ThreadPoolExecutorBak-Worker-w-boolean-completedAbruptly-方法" class="headerlink" title="processWorkerExit(ThreadPoolExecutorBak.Worker w, boolean completedAbruptly) 方法"></a>processWorkerExit(ThreadPoolExecutorBak.Worker w, boolean completedAbruptly) 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异常情况下 completedAbruptly = true</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(ThreadPoolExecutorBak.Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// completedAbruptly true 线程数 -1</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 统计完成的work数量</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 移除work</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试终止线程池，</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">// 出现异常 completedAbruptly = true / 正常情况下 completedAbruptly = false</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">              <span class="comment">//如果允许核心线程超时，队列也不为空，相当于不会建立新的work去执行队列中的自定义线程，而是用当前的这些线程去执行，</span></span><br><span class="line">                <span class="comment">//如果不允许核心线程超时，当前线程池数量大于核心线程数 也会直接返回，也不会创建新的work去执行队列中的自定义线程</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果出现异常，将会新建一个 work ,去执行阻塞队列中的 work</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​   processWorkerExit方法是在runWork方法中的 finally 中调用，也就是说，执行线程不管结果如何都会调用该方法，该方法就是统计线程执行完成数量、维护works、尝试终止线程池、以及如果线程执行异常，会创建工作线程去执行队列中的用户自定义线程，其实也可以认为是“收尾工作”</p>
<p>​   为什么在shutdown 和 shutdownNow中都会采用不同的方式中断线程，因为在这两个方法中，已经将线程池的状态改SHUTDOWN，而这时如果workQueue为空，那肯定有线程在getTask方法中阻塞，而用户已经无法提交线程到线程池，这时线程池就无法关闭。</p>
<p>​   这也可以解释shutdown,shutdownNow 的不同，因为 shutdownNow 不会关心线程处于什么状态就直接中断，而shutdown会等所有线程执行完成而再进行中断。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h3><p>锁机制存在以下问题：</p>
<p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p>
<p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p>
<p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<p>​   <strong>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止</strong></p>
<p>​   <strong>乐观锁用的机制就是CAS</strong>，<strong>Compare and Swap</strong></p>
<p>​   CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<p>​        在Java中可以使用锁和循环CAS来进行原子操作，自旋CAS的基本思路就是循环进行CAS操作，直到成功为止。在JDK1.5之后，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean,AtomicInteger,AtomicLong都是用原子的方式来更新指定类型的值。例如AtomicInteger的用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger atomicInteger=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> i=atomicInteger.get();</span><br><span class="line">atomicInteger.compareAndSet(i,i++);</span><br></pre></td></tr></table></figure>

<p><strong>CAS还存在以下三个问题：</strong></p>
<p>（1）ABA问题。如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时发现它的值没有发生变        化，但实际上却发生了。ABA的解决思路就是使用版本号，在变量前面追加版本号，那么A——B——A 就变成了1A——2B——3A。<br>（2）循环时间长开销大 </p>
<p>（3）只能保证一个共性变量的原子操作。也就是多个共享变量操作时，循环CAS就无法保证操作的原子性了。但从JDK1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript分享</title>
    <url>/2021/09/08/TypeScript/</url>
    <content><![CDATA[<h1 id="typescript-分享"><a href="#typescript-分享" class="headerlink" title="typescript 分享"></a>typescript 分享</h1><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh8se06hddj30vq0nwgm3.jpg" alt="TypeScriptMap"></p>
<h2 id="为什么要使用-TypeScript"><a href="#为什么要使用-TypeScript" class="headerlink" title="为什么要使用 TypeScript"></a>为什么要使用 TypeScript</h2><p>微软推出 TypeScript 主要是为了实现两个目标。</p>
<ol>
<li>为 JavaScript 提供可选的类型系统：TypeScript 会在编译代码时进行严格的静态类型检查，这意味着你可以在编码阶段发现可能存在的隐患，而不必把它们带到线上。</li>
<li>兼容当前及未来的 JavaScript 的特性：TypeScript 会包括来自 ES 6 和未来提案中的特性，比如异步操作和装饰器；也会从其他语言借鉴某些特性，比如接口和抽象类。</li>
</ol>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="类型基础"><a href="#类型基础" class="headerlink" title="类型基础"></a>类型基础</h3><p>在了解 ts 的各种基本类型之前，首先先了解一下类型语言。</p>
<blockquote>
<p>在强类型语言中，当一个对象从调用函数传递到被调用函数时，其类型必须与被调用函数中声明的类型兼容<br>强类型语言不允许改变变量的数据类型，除非进行强制类型转换<br>弱类型语言中，变量可以被赋予不同的数据类型</p>
</blockquote>
<blockquote>
<p>静态类型语言：在编译阶段确定所有变量的类型（如 c++）</p>
</blockquote>
<pre><code>1. 对类型要求极其严格
2. 立即发现错误
3. 运行时性能较好
4. 自文档化
</code></pre>
<blockquote>
<p>动态类型语言：在执行阶段确定所有变量的类型（如 js）</p>
</blockquote>
<pre><code>1. 对类型非常宽松
2. Bug可能隐藏很久
3. 运行性能较差
4. 可读性差
</code></pre>
<p>注意：有人提出强类型语言在程序发生错误后不允许继续执行，但是 c++并没有对数组越界进行处理，所以认为它是弱类型语言。（归属特殊定义).</p>
<p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggabqdv9m6j30dy07bwef.jpg" alt="语言象限图"></p>
<p>注意：如果把 ts 当做一门语言看待，那么它是强类型还是弱类型，是静态类型还是动态类型</p>
<p>我认为是静态+强类型语言</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p><img src= "/img/loading.gif" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5m0bv2obj30kk0rcglu.jpg" alt="基本类型"></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由<strong>此类型元素</strong>组成的一个数组：</p>
<p><code>let list: number[] = [1, 2, 3];</code></p>
<p>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p>
<p><code>let list: Array&lt;number&gt; = [1, 2, 3];</code></p>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组为一个新的概念，元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。</p>
<p>数组合并相同类型的对象，元组合并了不同类型的对象。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个元组类型</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">x = [<span class="string">&quot;hello&quot;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// 不正确的赋值</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&quot;hello&quot;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="函数定义方式"><a href="#函数定义方式" class="headerlink" title="函数定义方式"></a>函数定义方式</h5><p>函数类型包含两部分：参数类型和返回值类型，</p>
<h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h5><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，ts 可以根据参数类型推断出返回值类型。</p>
<h5 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h5><ol>
<li>可选参数</li>
<li>默认参数</li>
<li>剩余参数</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 可选参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;buildName -&gt; firstName&quot;</span>, firstName, lastName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName1</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName = <span class="string">&quot;Smith&quot;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;buildName -&gt; firstName&quot;</span>, firstName, lastName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 剩余参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName2</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;buildName2&quot;</span>, firstName + <span class="string">&quot; &quot;</span> + restOfName.join(<span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = buildName2(<span class="string">&quot;Joseph&quot;</span>, <span class="string">&quot;Samuel&quot;</span>, <span class="string">&quot;Lucas&quot;</span>, <span class="string">&quot;MacKinzie&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>typescript 可以 为同一个函数提供多个函数类型定义来进行函数重载</p>
<ol>
<li>函数重载的意义在于能够让你知道传入不同的参数得到不同的结果，如果传入的参数不同，但是得到的结果（类型）却相同，那么这里就不要使用函数重载（没有意义）。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. 函数重载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> suits = [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前两个为重载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123; suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): </span>&#123; suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</span><br><span class="line">    <span class="keyword">return</span> pickedCard;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">suit</span>: suits[pickedSuit], <span class="attr">card</span>: x % <span class="number">13</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [</span><br><span class="line">  &#123; <span class="attr">suit</span>: <span class="string">&quot;diamonds&quot;</span>, <span class="attr">card</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">suit</span>: <span class="string">&quot;spades&quot;</span>, <span class="attr">card</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">suit</span>: <span class="string">&quot;hearts&quot;</span>, <span class="attr">card</span>: <span class="number">4</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;card-Object: &quot;</span> + pickedCard1.card + <span class="string">&quot; of &quot;</span> + pickedCard1.suit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;card-Number: &quot;</span> + pickedCard2.card + <span class="string">&quot; of &quot;</span> + pickedCard2.suit);</span><br></pre></td></tr></table></figure>

<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obje: &#123; <span class="attr">x</span>: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line">obje.x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;functionpickCard -&gt; obje&quot;</span>, obje);</span><br></pre></td></tr></table></figure>

<h4 id="undefined-和-null"><a href="#undefined-和-null" class="headerlink" title="undefined 和 null"></a>undefined 和 null</h4><p>默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> un: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nu: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num1;</span><br><span class="line"></span><br><span class="line">num1 = <span class="literal">null</span>;</span><br><span class="line">num1 = <span class="literal">undefined</span>;</span><br><span class="line">num1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;undefined-null -&gt; num&quot;</span>, num1);</span><br></pre></td></tr></table></figure>

<h4 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h4><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void.</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> noReturn = <span class="function">() =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h4><p>never 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。</p>
<p>never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的never指的是会抛出、返回错误或者无限循环</span></span><br><span class="line"><span class="keyword">let</span> error = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="comment">// while 循环会一直循环代码块，只要指定的条件为 true。</span></span><br><span class="line"><span class="keyword">let</span> endless = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="any"><a href="#any" class="headerlink" title="any"></a>any</h4><p>当一个变量为 any 类型，不作限制</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xabc;</span><br><span class="line">xabc = <span class="number">1</span>;</span><br><span class="line">xabc = [];</span><br><span class="line">xabc = <span class="function">() =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>基本实现：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Role &#123;</span><br><span class="line">  Reporter = <span class="number">1</span>,</span><br><span class="line">  Developer,</span><br><span class="line">  Maintainer,</span><br><span class="line">  Owner,</span><br><span class="line">  Guest,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h5><ol>
<li>枚举被编译为对象</li>
<li>枚举成员的名称被作为 key， 枚举成员的值被作为 value， 表达式返回 value</li>
<li>然后，value 又被作为 key，成员名称又被作为 value，返回枚举成员的名称。这种方法叫做反向映射</li>
</ol>
<p>上述 ts 中的枚举转换为 JavaScript 代码如下，其中就是利用了反向映射的原理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Role;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">Role</span>) </span>&#123;</span><br><span class="line">  Role[(Role[<span class="string">&quot;Reporter&quot;</span>] = <span class="number">1</span>)] = <span class="string">&quot;Reporter&quot;</span>;</span><br><span class="line">  Role[(Role[<span class="string">&quot;Developer&quot;</span>] = <span class="number">2</span>)] = <span class="string">&quot;Developer&quot;</span>;</span><br><span class="line">  Role[(Role[<span class="string">&quot;Maintainer&quot;</span>] = <span class="number">3</span>)] = <span class="string">&quot;Maintainer&quot;</span>;</span><br><span class="line">  Role[(Role[<span class="string">&quot;Owner&quot;</span>] = <span class="number">4</span>)] = <span class="string">&quot;Owner&quot;</span>;</span><br><span class="line">  Role[(Role[<span class="string">&quot;Guest&quot;</span>] = <span class="number">5</span>)] = <span class="string">&quot;Guest&quot;</span>;</span><br><span class="line">&#125;)(Role || (Role = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>这里可以使用 <a href="https://www.tslang.cn/play/index.html">tsPlayGround</a> 查看编译之后的 js 代码</p>
<h5 id="数字枚举-amp-字符串枚举"><a href="#数字枚举-amp-字符串枚举" class="headerlink" title="数字枚举&amp;字符串枚举"></a>数字枚举&amp;字符串枚举</h5><ol>
<li>使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型。</li>
<li>除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了 反向映射，从枚举值到枚举名字</li>
<li>正向映射（ name -&gt; value）和反向映射（ value -&gt; name）</li>
<li>数字枚举的实现原理为反向映射</li>
<li>在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</li>
<li>要注意的是 不会为字符串枚举成员生成反向映射。相比数字枚举,字符串枚举仅成员名称被作为 key,所以不支持反向映射</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数字枚举</span></span><br><span class="line"><span class="built_in">enum</span> Role &#123;</span><br><span class="line">  Reporter = <span class="number">1</span>,</span><br><span class="line">  Developer,</span><br><span class="line">  Maintainer,</span><br><span class="line">  Owner,</span><br><span class="line">  Guest,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串枚举</span></span><br><span class="line"><span class="built_in">enum</span> Message &#123;</span><br><span class="line">  Success = <span class="string">&quot;恭喜你，成功了&quot;</span>,</span><br><span class="line">  Fail = <span class="string">&quot;抱歉，失败了&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h5><ol>
<li>常数枚举是使用 const enum 定义的枚举类型</li>
<li>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</li>
<li>假如包含了计算成员，则会在编译阶段报错。</li>
<li>“const” 枚举仅可在属性、索引访问表达式、导入声明的右侧或导出分配中使用。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">enum</span> Month &#123;</span><br><span class="line">  Jan,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr = Month.Mar + <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> month = [Month.Jan, Month.Feb, Month.Mar];</span><br></pre></td></tr></table></figure>

<h5 id="常数项和计算所得项"><a href="#常数项和计算所得项" class="headerlink" title="常数项和计算所得项"></a>常数项和计算所得项</h5><ol>
<li>枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。</li>
<li>枚举成员的值在定义后变为只读类型，在定义之后是不能修改的</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Char &#123;</span><br><span class="line">  <span class="comment">// const member</span></span><br><span class="line">  a,</span><br><span class="line">  b = Char.a,</span><br><span class="line">  c = <span class="number">1</span> + <span class="number">3</span>,</span><br><span class="line">  <span class="comment">// computed member</span></span><br><span class="line">  d = <span class="built_in">Math</span>.random(),</span><br><span class="line">  <span class="comment">// g, // 如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</span></span><br><span class="line">  e = <span class="string">&quot;123&quot;</span>.length,</span><br><span class="line">  f = <span class="number">4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><ol>
<li>在某些情况下, 枚举和枚举成员都可以作为一种单独的类型</li>
<li>分为三种情况：<ol>
<li>枚举成员没有任何初始值</li>
<li>所有枚举成员都是数字枚举</li>
<li>所有枚举成员都是字符串枚举</li>
</ol>
</li>
<li>可将任意 number 类型赋值给枚举类型,取值也可以超出枚举成员定义。</li>
<li>两种不同类型的枚举,是不可以进行比较的,编辑器会报错</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举成员没有任何初始值</span></span><br><span class="line"><span class="built_in">enum</span> E &#123;</span><br><span class="line">  a,</span><br><span class="line">  b,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有枚举成员都是数字枚举</span></span><br><span class="line"><span class="built_in">enum</span> D &#123;</span><br><span class="line">  a,</span><br><span class="line">  b,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有枚举成员都是数字枚举</span></span><br><span class="line"><span class="built_in">enum</span> F &#123;</span><br><span class="line">  a = <span class="number">0</span>,</span><br><span class="line">  b = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有枚举成员都是字符串枚举</span></span><br><span class="line"><span class="built_in">enum</span> G &#123;</span><br><span class="line">  a = <span class="string">&quot;apple&quot;</span>,</span><br><span class="line">  b = <span class="string">&quot;banana&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e: E = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> dac: D = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> fok: F = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p>
<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p>
<h5 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h5><p><strong>赋值</strong>的时候，变量的形状必须和接口的形状保持一致。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> List &#123;</span><br><span class="line">  <span class="keyword">readonly</span> id: <span class="built_in">number</span>; <span class="comment">// 只读</span></span><br><span class="line">  name: <span class="built_in">string</span>; <span class="comment">// 确定</span></span><br><span class="line">  age?: <span class="built_in">number</span>; <span class="comment">// 可选</span></span><br><span class="line">  <span class="comment">// [x: string]: string; // 任意</span></span><br><span class="line">  [x: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 任意</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Result &#123;</span><br><span class="line">  data: List[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="关于属性"><a href="#关于属性" class="headerlink" title="关于属性"></a>关于属性</h5><ol>
<li>属性了解：<ol>
<li>可选属性（?:）</li>
<li>任意属性 ([x: string]: any)<ol>
<li>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</li>
<li>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型</li>
</ol>
</li>
<li>只读属性 (readonly)<ol>
<li>只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> List &#123;</span><br><span class="line">  <span class="keyword">readonly</span> id: <span class="built_in">number</span>; <span class="comment">// 只读</span></span><br><span class="line">  name: <span class="built_in">string</span>; <span class="comment">// 确定</span></span><br><span class="line">  age?: <span class="built_in">number</span>; <span class="comment">// 可选</span></span><br><span class="line">  <span class="comment">// [x: string]: string; // 任意</span></span><br><span class="line">  [x: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 任意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="类型检查跳过"><a href="#类型检查跳过" class="headerlink" title="类型检查跳过"></a>类型检查跳过</h5><p>为什么需要跳过类型检查？</p>
<p>对象类型接口直接验证有冗余字段的对象字面量时会报错，这种冗余字段有时是不可避免的存在的。</p>
<p>方法主要有三种：</p>
<ol>
<li>将对象字面量赋值给变量</li>
<li>使用类型断言</li>
<li>用字符串索引签名</li>
</ol>
<p>第一种：将对象字面量赋值给变量</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在外面声明变量 result ,然后把 result 传入 render 函数，避免传入对象字面量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">result: Result</span>) </span>&#123;</span><br><span class="line">  result.data.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;result: id,name&quot;</span>, &#123; <span class="attr">id</span>: value.id, <span class="attr">name</span>: value.name &#125;);</span><br><span class="line">    <span class="keyword">if</span> (value.age) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;result: age&quot;</span>, &#123; <span class="attr">age</span>: value.age &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只读属性不可进行操作</span></span><br><span class="line">    <span class="comment">// value.id++</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据结构描述</span></span><br><span class="line"><span class="comment">// 赋值的时候，变量的形状必须和接口的形状保持一致。</span></span><br><span class="line"><span class="keyword">let</span> result = &#123;</span><br><span class="line">  data: [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;A&quot;</span>, <span class="attr">sex</span>: <span class="string">&quot;male&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;B&quot;</span>, <span class="attr">age</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二种：类型断言</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> square = &lt;Square1&gt;&#123;&#125;;</span><br><span class="line"><span class="comment">// let square = &#123;&#125; as Square1;</span></span><br><span class="line">square.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>第三种：字符串索引签名》 <code>[x: string]: any; // 任意</code></p>
<h5 id="可索引类型接口"><a href="#可索引类型接口" class="headerlink" title="可索引类型接口"></a>可索引类型接口</h5><ol>
<li>数字索引</li>
<li>字符串索引</li>
</ol>
<p>可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number 来索引时，JavaScript 会将它转换成 string 然后再去索引对象。 也就是说用 100（一个 number）去索引等同于使用”100”（一个 string）去索引，因此两者需要保持一致。</p>
<p>当接口中定义了一个索引后，例如设置了 【x:string】= string，就不能设置 y：number 了。<br>因为设置了【x:string】= string 相当于这个接口的字符串索引返回值都是字符串，而 y：number 违背这一原则，冲突了。反过来 如果定义了【x:string】=Number, 就不能设置 y:string 了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> chars: StringArray = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 混用时，数字索引签名的返回值必须是字符串索引签名返回值的子类型</span></span><br><span class="line"><span class="keyword">interface</span> Names &#123;</span><br><span class="line">  [x: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  <span class="comment">// y: number;</span></span><br><span class="line">  [z: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="类类型接口"><a href="#类类型接口" class="headerlink" title="类类型接口"></a>类类型接口</h5><ol>
<li>类必须实现接口中的所有属性</li>
<li>接口只能约束类的公共成员，不能约束私有成员、受保护成员、静态成员和构造函数</li>
<li>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员</li>
</ol>
<h5 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h5><ol>
<li>一个接口可以继承多个接口，创建出多个接口的合成接口</li>
</ol>
<h5 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h5><ol>
<li>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。</li>
<li>就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。</li>
<li>接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</li>
</ol>
<h5 id="关于-interface-和-type"><a href="#关于-interface-和-type" class="headerlink" title="关于 interface 和 type"></a>关于 interface 和 type</h5><ol>
<li>interface: 接口</li>
<li>type: 类型别名</li>
</ol>
<p>接口就好比一个名字，用来描述对象。type 会给一个类型起个新名字。 type 有时和 interface 很像，但是可以作用于原始值（基本类型），联合类型，元组以及其它任何你需要手写的类型。</p>
<p>官方的文档说：</p>
<blockquote>
<p>“类型别名 可以和 interface 关键字一样，然而他们有一些细微的差别。”</p>
</blockquote>
<p>不同点：</p>
<ol>
<li>扩展语法： interface 使用 extends，type 使用‘&amp;’</li>
<li>同名合并：interface 支持，type 不支持。</li>
<li>描述类型：对象、函数两者都适用，但是 type 可以用于基础类型、联合类型、元祖。</li>
<li>计算属性：type 支持计算属性，生成映射类型,interface 不支持。</li>
</ol>
<p>相同点：</p>
<ol>
<li>两者都可以用来描述对象或函数的类型</li>
<li>两者都可以实现继承</li>
</ol>
<p>总的来说，公共的用 interface 实现，不能用 interface 实现的再用 type 实现。主要是一个项目最好保持一致。</p>
<p><a href="https://static.jixun.moe/json2tsinterface.html">推荐：jsonToInterface 转换</a></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jsonToInterFace convert eg</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;A&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;male&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;B&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span>: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 class。</p>
<p>TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p>
<h5 id="基本实现-1"><a href="#基本实现-1" class="headerlink" title="基本实现"></a>基本实现</h5><ol>
<li>类中定义的属性都是实例属性，类中定义的方法都是原型方法</li>
<li>实例属性必须有初始值，或在函数中被赋值，或为可选成员</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个 greet方法。</span></span><br><span class="line"><span class="comment">// 你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。</span></span><br><span class="line"><span class="comment">// 最后一行，我们使用 new构造了 Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个 Greeter类型的新对象，并执行构造函数初始化它。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  greeting: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.greeting = message;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.greeting;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> Greeter(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。基本继承实现如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类从基类中继承了属性和方法。 这里， Dog是一个 派生类，它派生自 Animal 基类，通过 extends关键字。 派生类通常被称作 子类，基类通常被称作 超类。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Animal moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogC</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">bark</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Woof! Woof!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> DogC();</span><br><span class="line">dog.bark();</span><br><span class="line">dog.move(<span class="number">10</span>);</span><br><span class="line">dog.bark();</span><br></pre></td></tr></table></figure>

<p>更复杂的继承，子类的构造函数中必须含有 super 调用。这一次，我们使用 extends 关键字创建了 Animal 的两个子类： Horse 和 Snake。</p>
<p>与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this 的属性之前，我们 一定要调用 super()。 这个是 TypeScript 强制执行的一条重要规则。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snake</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters = <span class="number">5</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Slithering...&quot;</span>);</span><br><span class="line">    <span class="built_in">super</span>.move(distanceInMeters);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters = <span class="number">45</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Galloping...&quot;</span>);</span><br><span class="line">    <span class="built_in">super</span>.move(distanceInMeters);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> Snake(<span class="string">&quot;Sammy the Python&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> tom: Animal = <span class="keyword">new</span> Horse(<span class="string">&quot;Tommy the Palomino&quot;</span>);</span><br><span class="line"></span><br><span class="line">sam.move();</span><br><span class="line">tom.move(<span class="number">34</span>);</span><br></pre></td></tr></table></figure>

<h5 id="成员修饰符"><a href="#成员修饰符" class="headerlink" title="成员修饰符"></a>成员修饰符</h5><ol>
<li>public：对所有人可见，所有成员默认为 public</li>
<li>private：<ol>
<li>只能在被定义的类中访问，不能通过实例或子类访问</li>
<li>private constructor：不能被实例化，不能被继承</li>
</ol>
</li>
<li>protected<ol>
<li>只能在被定义的类和子类中访问，不能通过实例访问</li>
<li>protected constructor：只能被实例化，不能被继承</li>
</ol>
</li>
<li>readonly：必须有初始值，或在构造函数中被赋值</li>
<li>static：只能由类名调用，不能通过实例访问，可继承</li>
</ol>
<h5 id="构造函数参数中的修饰符"><a href="#构造函数参数中的修饰符" class="headerlink" title="构造函数参数中的修饰符"></a>构造函数参数中的修饰符</h5><ol>
<li>将参数变为实例属性</li>
</ol>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><ol>
<li>不能被实例化，只能被继承<ol>
<li>抽象方法包含具体实现，子类可以直接复用</li>
<li>抽象方法不包含具体实现，子类必须实现</li>
</ol>
</li>
<li>多态：多个子类对父抽象类的方法有不同实现，实现运行时绑定</li>
</ol>
<h5 id="this-类型"><a href="#this-类型" class="headerlink" title="this 类型"></a>this 类型</h5><ol>
<li>实现实例方法的链式调用</li>
<li>在继承时，具有多态性，保持父子类之间接口调用的连贯性</li>
</ol>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>
<h4 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h4><p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p>
<p>我们需要一种方法使返回值的类型与传入参数的类型是相同的，如果没有这种方法，在写代码时可能是这样的</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity1</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是使用 any 可能会丢失一些信息：传入的类型与返回的类型应该是相同的</p>
<p>使用泛型则是下面所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把这个版本的 identity 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 any，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p>
<p>定义泛型函数之后，有两种使用方法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种是，传入所有的参数，包含类型参数：</span></span><br><span class="line">log&lt;<span class="built_in">string</span>[]&gt;([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;,b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种是，利用了类型推论 -- 即编译器会根据传入的参数自动地帮助我们确定T的类型：</span></span><br><span class="line">log([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;,b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</span><br></pre></td></tr></table></figure>

<h4 id="支持多种类型的方法"><a href="#支持多种类型的方法" class="headerlink" title="支持多种类型的方法"></a>支持多种类型的方法</h4><ol>
<li>函数重载</li>
<li>联合类型</li>
<li>any 类型 》 丢失类型约束</li>
<li>泛型 》不预先确定的类型，使用时才确定</li>
</ol>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> CreateArrayFunc&lt;V&gt; &#123;</span><br><span class="line">  (length: <span class="built_in">number</span>, <span class="attr">value</span>: V): <span class="built_in">Array</span>&lt;V&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;泛型接口》result&quot;</span>, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: CreateArrayFunc&lt;<span class="built_in">string</span>&gt; = identity;</span><br><span class="line"></span><br><span class="line">myIdentity(<span class="number">3</span>, <span class="string">&quot;x&quot;</span>); <span class="comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><!-- 重点研究 -->

<p>泛型类看上去与泛型接口差不多。 泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面。</p>
<p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>
<p>我们在类那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ! 非空断言. 联合类型，可选属性</span></span><br><span class="line">  zeroValue!: T;</span><br><span class="line">  add!: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><ol>
<li>确保属性存在</li>
<li>检查对象上的键是否存在</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length); <span class="comment">// Now we know it has a .length property, so no more error</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loggingIdentity(<span class="string">&quot;avc&quot;</span>);</span><br><span class="line"><span class="comment">// loggingIdentity(23123)</span></span><br></pre></td></tr></table></figure>

<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型。</p>
<h4 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h4><ol>
<li><code>Partial&lt;T&gt;</code> 的作用就是将某个类型里的属性全部变为可选项 ?。</li>
<li><code>Record&lt;K extends keyof any, T&gt;</code>的作用是将 K 中所有的属性的值转化为 T 类型。</li>
<li><code>Pick&lt;T, K extends keyof T&gt;</code> 的作用是将某个类型中的子属性挑出来，变成包含这个类型部分属性的子类型。</li>
<li><code>Exclude&lt;T, U&gt;</code> 的作用是将某个类型中属于另一个的类型移除掉。</li>
<li><code>ReturnType&lt;T&gt;</code>的作用是用于获取函数 T 的返回类型。</li>
<li><code>Readonly&lt;T&gt;</code>: 将 T 的所有属性变为只读</li>
</ol>
<h5 id="Partail"><a href="#Partail" class="headerlink" title="Partail"></a>Partail</h5><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Partail ts源码实现</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它用来将 T 中的所有的属性都变成可选的。下面的示例中定义了一个类型 IFoo，它拥有两个必选的属性 a 和 b。</p>
<p>使用：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IFoo &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo: Partial&lt;IFoo&gt; = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IFoo &#123;</span><br><span class="line">  a?: <span class="built_in">number</span>;</span><br><span class="line">  b?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h5><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码实现</span></span><br><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种场景</span></span><br><span class="line"><span class="keyword">type</span> Fooad = Record&lt;<span class="string">&quot;a&quot;</span>, <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> fooad: Fooad = &#123; <span class="attr">a</span>: <span class="string">&quot;1&quot;</span> &#125;; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>可以用 Record 来处理另外一种场景。假如我本来已经有了两个类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  a: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Bar &#123;</span><br><span class="line">  b: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我想把 Foo 和 Bar 两个类型的 key 合并到一起，并给它们重新指定成 number 类型，可以使用 Record 这样实现：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz = Record&lt;keyof Foo | keyof Bar, <span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Baz &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<p>它用来生成一个属性为 K，类型为 T 的类型集合。如下所示，我用它生成了一个 Foo 类型，那么就表示所有指定为 Foo 类型的变量都必须包含一个 key 为 a，value 为 string 类型的字段。否则，TS 类型检查器就会报错。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = Record&lt;<span class="string">&quot;a&quot;</span>, <span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo: Foo = &#123; <span class="attr">a</span>: <span class="string">&quot;1&quot;</span> &#125;; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> foo: Foo = &#123; <span class="attr">b</span>: <span class="string">&quot;1&quot;</span> &#125;; <span class="comment">// 错误，因为 key 不为 a</span></span><br><span class="line"><span class="keyword">const</span> foo: Foo = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;; <span class="comment">// 错误，因为 value 的值不是 str</span></span><br></pre></td></tr></table></figure>

<h5 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h5><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码实现</span></span><br><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<p>它的作用是从 T 中将所有的 K 取出来，并生成一个新的类型。下面示例中定义的 IFoo 类型包含了两个必选属性 a 和 b。所以，将 foo 指定为 IFoo 类型之后，就肯定必须包含这两个属性，否则就会报类型检查错误：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IFoo &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo: IFoo = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是，如果我想让 foo 只包含 IFoo 类型的 a 属性，就可以用 Pick 这样来实现。它就是告诉 TS 仅仅将 a 属性从 IFoo 中提取出来即可。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确，使用 Pick 生成的新类型确实只包含 a 属性</span></span><br><span class="line"><span class="keyword">const</span> foo: Pick&lt;IFoo, <span class="string">&quot;a&quot;</span>&gt; = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，使用 Pick 生成的新类型中并不包含 b 属性</span></span><br><span class="line"><span class="keyword">const</span> foo: Pick&lt;IFoo, <span class="string">&quot;a&quot;</span>&gt; = &#123;</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，它和上面的 Partial 不一样的地方在于，Partial 是将类型中的所有的属性都变成了可选状态，而不能将某一个属性单独提取出来。</p>
<h5 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h5><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<p>它的作用是从 T 中排除掉所有包含的 U 属性。如果不明白这句话，就看下面示例。</p>
<p>代码运行之后，TFoo 只会包含一个 2。这是因为 Exclude 会从第一个类型参数中将其所有包含的第二个类型参数中的值给排除掉。我们可以看到在第一个类型参数中只包含第二个类型参数中的 1，因此，它就会被排除掉，只剩下 2 了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TFoo = Exclude&lt;<span class="number">1</span> | <span class="number">2</span>, <span class="number">1</span> | <span class="number">3</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>所以，如果一个变量被指定为了 TFoo 类型，它就只能被赋值为 2 了，否则就会报类型检查错误：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo: TFoo = <span class="number">2</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> foo: TFoo = <span class="number">3</span>; <span class="comment">// 错误，因为 TFoo 中不包含 3</span></span><br></pre></td></tr></table></figure>

<h5 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h5><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p>它用来得到一个函数的返回值类型。看下面的示例用 ReturnType 获取到 Func 的返回值类型为 string，所以，foo 也就只能被赋值为字符串了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Func = <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo: ReturnType&lt;Func&gt; = <span class="string">&quot;1&quot;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h5><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Readonly在 TS 中的源码实现：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IFoo &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo: Readonly&lt;IFoo&gt; = &#123;</span><br><span class="line">  name: <span class="string">&quot;cxc&quot;</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.name = <span class="string">&quot;xiaoming&quot;</span>; <span class="comment">// 错误，因为 name 仅是只读的</span></span><br><span class="line">foo.age = <span class="number">20</span>; <span class="comment">// 错误，因为 age 也仅是只读的</span></span><br></pre></td></tr></table></figure>

<p>项目中不一定要强制使用泛型，还是应该用在对的场景。</p>
<h3 id="类型检查机制"><a href="#类型检查机制" class="headerlink" title="类型检查机制"></a>类型检查机制</h3><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>TypeScript 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a15 = <span class="number">1</span>; <span class="comment">// let a15: number</span></span><br><span class="line"><span class="keyword">let</span> b15 = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">&quot;a&quot;</span>]; <span class="comment">// let b15: (string | number | null)[]</span></span><br><span class="line"><span class="keyword">let</span> c15 = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="string">&quot;a&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// let c15: &#123;</span></span><br><span class="line"><span class="comment">//     x: number;</span></span><br><span class="line"><span class="comment">//     y: string;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>
<p>两种写法, 当你在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。</p>
<ol>
<li>第一种：尖括号语法</li>
<li>第二种：as 语法</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尖括号</span></span><br><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br><span class="line"><span class="comment">// as 语法</span></span><br><span class="line"><span class="keyword">let</span> someValueAs: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLengthAs: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure>

<p>弊端是没有按照接口的约定赋值</p>
<h4 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h4><p>typeScript 结构化类型系统的基本规则是，如果 x 要兼容 y，那么 y 至少具有与 x 相同的属性.</p>
<p>当一个类型 Y 可以被赋值给另一个类型 X 时，我们就可以说类型 X 兼容类型 Y。</p>
<p>X 兼容 Y：X（目标类型） = Y（源类型），源类型必须具备目标类型的所有属性。</p>
<ol>
<li>接口之间兼容：成员少的兼容成员多的</li>
<li>函数之间兼容：<ol>
<li>参数多的兼容参数少的</li>
<li>可选参数和剩余参数，遵循原则<ol>
<li>固定参数兼容可选参数和剩余参数</li>
<li>可选参数不兼容固定参数和剩余参数（严格模式）</li>
<li>剩余参数兼容固定参数和可选参数</li>
</ol>
</li>
<li>参数类型：必须匹配</li>
<li>参数为对象：<ol>
<li>严格模式：成员多的的兼容成员少的</li>
<li>非严格模式：相互兼容（函数参数双向协变）</li>
</ol>
</li>
<li>返回值类型：目标函数必须与源函数相同，或为其子类型</li>
</ol>
</li>
<li>枚举之间兼容：<ol>
<li>枚举类型和数字类型相互兼容</li>
<li>枚举类型之间不兼容</li>
</ol>
</li>
<li>类兼容性：<ol>
<li>静态成员和构造函数不在比较范围</li>
<li>两个类具有相同的实例成员，它们的示例相互兼容</li>
<li>类中包含私有成员或受保护成员，只有父类和子类的实例相互兼容</li>
</ol>
</li>
<li>泛型之间兼容：<ol>
<li>泛型接口：只有类型参数 T 被接口成员使用时，才会影响兼容性</li>
<li>泛型函数：定义相同，没有指定类型参数时就兼容</li>
</ol>
</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的接口兼容</span></span><br><span class="line"><span class="keyword">interface</span> X &#123;</span><br><span class="line">  a: <span class="built_in">any</span>;</span><br><span class="line">  b: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Y &#123;</span><br><span class="line">  a: <span class="built_in">any</span>;</span><br><span class="line">  b: <span class="built_in">any</span>;</span><br><span class="line">  c: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x: X = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> y: Y = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line">x = y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x : &#123;a: 1, b: 3, c: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h4><p>typescript 能够在特定的区块中保证变量属于某种确定的类型，可以在此区块中放心的引用此类型的属性，或者调用此类型的方法。</p>
<p>类型保护方法：</p>
<ol>
<li>使用 instanceof 可以判断一个实例是不是属于某个类</li>
<li>使用 in 可以判断一个属性是不是属于某个对象</li>
<li>使用 typeof 可以判断一个基本类型</li>
<li>类型保护函数：某些判断可能不是一条语句能够搞定的，需要更多复杂的逻辑，适合封装到一个函数内</li>
</ol>
<h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><h4 id="交叉类型（类型并集）"><a href="#交叉类型（类型并集）" class="headerlink" title="交叉类型（类型并集）"></a>交叉类型（类型并集）</h4><ol>
<li>含义：将多个类型合并为一个类型，新的类型将具有所有类型的特性</li>
<li>应用场景：混入</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pet: DogInterface &amp; CatInterface = &#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">jump</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="联合类型（类型交集）"><a href="#联合类型（类型交集）" class="headerlink" title="联合类型（类型交集）"></a>联合类型（类型交集）</h4><ol>
<li>含义：类型并不确定，可能为多个类型中的一个</li>
<li>应用场景：多类型支持</li>
<li>可区分的联合类型：结合联合类型和字面量类型的类型保护方法</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a18: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="number">1</span>; <span class="comment">// let a18: number | string</span></span><br><span class="line"><span class="keyword">let</span> b18: <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>; <span class="comment">//let b18: &quot;a&quot; | &quot;b&quot; | &quot;c&quot;</span></span><br><span class="line"><span class="keyword">let</span> c18: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>; <span class="comment">// let c18: 1 | 2 | 3</span></span><br></pre></td></tr></table></figure>

<h4 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h4><ol>
<li>字符串字面量</li>
<li>数字字面量</li>
<li>应用场景：限制变量取值范围</li>
</ol>
<p>限制取值范围</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Easing = <span class="string">&quot;ease-in&quot;</span> | <span class="string">&quot;ease-out&quot;</span> | <span class="string">&quot;ease-in-out&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIElement</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">animate</span>(<span class="params">dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>, easing: Easing</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (easing === <span class="string">&quot;ease-in&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">&quot;ease-out&quot;</span>) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">&quot;ease-in-out&quot;</span>) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// error! should not pass null or undefined.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> UIElement();</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;ease-in&quot;</span>);</span><br><span class="line"><span class="comment">// button.animate(0, 0, &quot;uneasy&quot;); // error: &quot;uneasy&quot; is not allowed here</span></span><br></pre></td></tr></table></figure>

<p>区别函数重载</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: <span class="string">&quot;img&quot;</span></span>): <span class="title">HTMLImageElement</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: <span class="string">&quot;input&quot;</span></span>): <span class="title">HTMLInputElement</span></span>;</span><br><span class="line"><span class="comment">// ... more overloads ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: <span class="built_in">string</span></span>): <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... code goes here ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ol>
<li>要点<ol>
<li><code>keyof T</code> （索引查询操作符）：类型 T 公共属性名的字面量联合类型</li>
<li><code>T[K]</code> （索引访问操作符）：对象 T 的属性 K 所代表的类型</li>
<li>泛型约束</li>
</ol>
</li>
<li>应用场景：从一个对象中选取某些属性的值</li>
</ol>
<p>使用索引类型，编译器就能够检查使用了动态属性名的代码。</p>
<p>keyof T， 索引类型查询操作符。 对于任何类型 T， keyof T 的结果为 T 上已知的公共属性名的联合。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, names: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Jarid&quot;</span>,</span><br><span class="line">  age: <span class="number">35</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> strings: <span class="built_in">string</span>[] = pluck(person, [<span class="string">&quot;name&quot;</span>]); <span class="comment">// ok, string[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> keyof T</span></span><br><span class="line"><span class="keyword">let</span> personProps: keyof Person; <span class="comment">// &#x27;name&#x27; | &#x27;age&#x27;</span></span><br><span class="line"><span class="comment">// pluck(person, [&#x27;age&#x27;, &#x27;unknown&#x27;]); // error, &#x27;unknown&#x27; is not in &#x27;name&#x27; | &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>

<p>T[K]: 只要确保类型变量 K extends keyof T 就可以</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> T[K]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, name: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o[name]; <span class="comment">// o[name] is of type T[K]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nameas: <span class="built_in">string</span> = getProperty(person, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;nameas&quot;</span>, nameas);</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = getProperty(person, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="comment">// let unknown = getProperty(person, &#x27;unknown&#x27;); // error, &#x27;unknown&#x27; is not in &#x27;name&#x27; | &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h4><ol>
<li>含义：从旧类型中创建出新的类型</li>
<li>应用场景：<ol>
<li><code>Readonly&lt;T&gt;</code>: 将 T 的所有属性变为只读</li>
<li><code>Partial&lt;T&gt;</code>: 将 T 的所有属性变为可选</li>
<li><code>Pick&lt;T,K&gt;</code>: 选取以 K 为属性的对象 T 的子集</li>
<li><code>Record&lt;K,T&gt;</code>: 创新属性为 K 的新对象，属性值的类型为 T</li>
</ol>
</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一种使用方式：在映射类型里，新类型以相同的形式去转换旧类型里每个属性。 例如，你可以令每个属性成为 readonly类型或可选的</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonPartial = Partial&lt;Person&gt;;</span><br><span class="line"><span class="keyword">type</span> ReadonlyPerson = Readonly&lt;Person&gt;;</span><br></pre></td></tr></table></figure>

<p>最简单的使用方式</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Keys = <span class="string">&quot;option1&quot;</span> | <span class="string">&quot;option2&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> Flags = &#123; [K <span class="keyword">in</span> Keys]: <span class="built_in">boolean</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>它的语法与索引签名的语法类型，内部使用了 for .. in。 具有三个部分：</p>
<ol>
<li>类型变量 K，它会依次绑定到每个属性。</li>
<li>字符串字面量联合的 Keys，它包含了要迭代的属性名的集合。</li>
<li>属性的结果类型。</li>
</ol>
<p>最终转换为：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Flags = &#123;</span><br><span class="line">  option1: <span class="built_in">boolean</span>;</span><br><span class="line">  option2: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h4><ol>
<li>含义：T extend U ? X: Y（如果类型 T 可以赋值给类型 U，那么结果类型就是 X，否则就是 Y）</li>
<li>应用场景：<ol>
<li><code>Exclude&lt;T,U&gt;</code>: 从 T 中过滤掉可以赋值给 U 的类型</li>
<li><code>Extract&lt;T,U&gt;</code>: 从 T 中抽取出可以赋值给 U 的类型</li>
<li><code>NonNullable&lt;T</code>&gt;: 从 T 中除去 undefined 和 null</li>
<li><code>ReturnType&lt;T&gt;</code>: 获取函数的返回值类型</li>
</ol>
</li>
</ol>
<p>使用场景</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<h2 id="typeScript-工程"><a href="#typeScript-工程" class="headerlink" title="typeScript 工程"></a>typeScript 工程</h2><h3 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h3><p>2019 年 1 月，TypeScirpt 官方决定全面采用 ESLint 作为代码检查的工具，并创建了一个新项目 typescript-eslint，提供了 TypeScript 文件的解析器 @typescript-eslint/parser 和相关的配置选项 @typescript-eslint/eslint-plugin 等。而之前的两个 lint 解决方案都将弃用：</p>
<ol>
<li>typescript-eslint-parser 已停止维护</li>
<li>TSLint 将提供迁移工具，并在 typescript-eslint 的功能足够完整后停止维护 TSLint（Once we consider ESLint feature-complete w.r.t. TSLint, we will deprecate TSLint and help users migrate to ESLint1）</li>
</ol>
<p>综上所述，目前以及将来的 TypeScript 的代码检查方案就是 typescript-eslint。</p>
<p>ts 已经能够在编译阶段检查出很多问题了，为什么 ts 项目中还需要代码检查？</p>
<p>这是因为 ts 关注的重心是类型的检查，而不是代码风格，当团队的成员越来越多时，同样的逻辑不同的人写出来可能会有很大的区别。比如说缩进应该是 4 个空格还是 2 个空格，这些问题 typescript 不会关注，但是却影响到多人协作开发时的效率、代码的可理解性以及可维护性。</p>
<h3 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h3><p>最容易理解的就是项目里引用 ui 库时，要为引入的组件编写声明文件，一般来说，我们目前在引用的库在社区中已经有编写好的声明文件，可以直接引用。</p>
<p><a href="https://microsoft.github.io/TypeSearch/">查找包是否有 types 文件</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@types/classnames&quot;</span>: <span class="string">&quot;^2.2.7&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@types/enzyme&quot;</span>: <span class="string">&quot;^3.10.5&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@types/enzyme-adapter-react-16&quot;</span>: <span class="string">&quot;^1.0.6&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@types/enzyme-to-json&quot;</span>: <span class="string">&quot;^1.5.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@types/express&quot;</span>: <span class="string">&quot;^4.17.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@types/history&quot;</span>: <span class="string">&quot;^4.7.2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@types/jest&quot;</span>: <span class="string">&quot;^24.0.13&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@types/lodash&quot;</span>: <span class="string">&quot;^4.14.133&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@types/qs&quot;</span>: <span class="string">&quot;^6.5.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@types/react&quot;</span>: <span class="string">&quot;^16.8.19&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@types/react-color&quot;</span>: <span class="string">&quot;^3.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@types/react-document-title&quot;</span>: <span class="string">&quot;^2.0.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;@types/react-dom&quot;</span>: <span class="string">&quot;^16.8.4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三斜线指令"><a href="#三斜线指令" class="headerlink" title="三斜线指令"></a>三斜线指令</h3><p>三斜线指令是包含单个 XML 标签的单行注释。 注释的内容会做为编译器指令使用。</p>
<p>三斜线指令仅可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;...&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;...&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<p>指令是三斜线指令中最常见的一种。 它用于声明文件间的 依赖。</p>
<p>三斜线引用告诉编译器在编译过程中要引入的额外的文件.编译器会对输入文件进行预处理来解析所有三斜线引用指令</p>
<h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><p>如果一个目录下存在一个 tsconfig.json 文件，那么它意味着这个目录是 TypeScript 项目的根目录。 tsconfig.json 文件中指定了用来编译这个项目的根文件和编译选项。 一个项目可以通过以下方式之一来编译：</p>
<p>使用 tsconfig.json</p>
<ol>
<li>不带任何输入文件的情况下调用 tsc，编译器会从当前目录开始去查找 tsconfig.json 文件，逐级向上搜索父目录。</li>
<li>不带任何输入文件的情况下调用 tsc，且使用命令行参数–project（或-p）指定一个包含 tsconfig.json 文件的目录。</li>
<li>当命令行上指定了输入文件时，tsconfig.json 文件会被忽略。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;build/dist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;esnext&quot;</span>, <span class="comment">// 指定使用的模块，common.jd、amd、system、umd、或者es2015</span></span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;esnext&quot;</span>, <span class="comment">// 指定ECMAScript的目标版本, esnext指的是当前的ECMAScript版本</span></span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [<span class="string">&quot;esnext&quot;</span>, <span class="string">&quot;dom&quot;</span>], <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>, <span class="comment">// 生成相应的 .map 文件</span></span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>, <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>, <span class="comment">// 指定 JSX 代码的生成 .preserve、react-native、react文件</span></span><br><span class="line">    <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>, <span class="comment">// 允许从没有设置默认导出的模块中默认导入</span></span><br><span class="line">    <span class="string">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>, <span class="comment">// 模块解析选项，选择模块解析策略、node或classic</span></span><br><span class="line">    <span class="string">&quot;resolveJsonModule&quot;</span>: <span class="literal">true</span>, <span class="comment">// 允许从 .json 中导入、导出其类型</span></span><br><span class="line">    <span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">false</span>, <span class="comment">// 在表达式和声明上有隐含的 any类型时报错。</span></span><br><span class="line">    <span class="string">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span>, <span class="comment">// 禁止对同一个文件的不一致的引用</span></span><br><span class="line">    <span class="string">&quot;noImplicitReturns&quot;</span>: <span class="literal">true</span>, <span class="comment">// 不是函数的所有返回路径都有返回值时报错。</span></span><br><span class="line">    <span class="string">&quot;suppressImplicitAnyIndexErrors&quot;</span>: <span class="literal">true</span>, <span class="comment">// 阻止 --noImplicitAny对缺少索引签名的索引对象报错。</span></span><br><span class="line">    <span class="string">&quot;noUnusedLocals&quot;</span>: <span class="literal">true</span>, <span class="comment">// 若有未使用的局部变量则抛错。</span></span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>, <span class="comment">// 允许编译javascript文件</span></span><br><span class="line">    <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>, <span class="comment">// 启用实验性的ES装饰器。</span></span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>, <span class="comment">// 启用所有严格类型检查选项。启用 --strict相当于启用 --noImplicitAny, --noImplicitThis, --alwaysStrict， --strictNullChecks和 --strictFunctionTypes和--strictPropertyInitialization。</span></span><br><span class="line">    <span class="string">&quot;strictNullChecks&quot;</span>: <span class="literal">false</span>, <span class="comment">// 在严格的 null检查模式下， null和 undefined值不包含在任何类型里，只允许用它们自己和 any来赋值（有个例外， undefined可以赋值到 void）。</span></span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123; <span class="comment">// 模块名到基于 baseUrl的路径映射的列表。</span></span><br><span class="line">      <span class="string">&quot;@/*&quot;</span>: [<span class="string">&quot;./src/*&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;exclude&quot;</span>: [ <span class="comment">// 编译过滤</span></span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>,</span><br><span class="line">    <span class="string">&quot;scripts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;acceptance-tests&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">    <span class="string">&quot;jest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;src/setupTests.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tslint:latest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tslint-config-prettier&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="代码迁移"><a href="#代码迁移" class="headerlink" title="代码迁移"></a>代码迁移</h3><p>JavaScript 项目迁移到 TypeScript 一般采用渐进式迁移策略，目前有三种</p>
<ol>
<li>共存策略<ol>
<li>如果我们用编译器选项 –allowJs，则 TypeScript 编译器支持 JavaScript 和 TypeScript 文件的混合，我们可以将文件一个一个的切换到 TypeScript</li>
</ol>
</li>
<li>宽松策略：将所有的 js 文件重命名为 ts 或者 tsx，然后使用最宽松的代码检查</li>
<li>严格策略：开启最严格的类型检查规则</li>
</ol>
<p>目前我们的项目基本上都是 通过 create-react-app 脚手架来搭建的，这里先介绍一下 关于这种搭建方式的迁移。</p>
<ol>
<li>第一步：安装 typescript 和一些包的声明文件，在我们的项目里用到了很多我们的自建库，注意需要为这些库编写声明文件。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save typescript @types&#x2F;node @types&#x2F;react @types&#x2F;react-dom @types&#x2F;jest</span><br><span class="line">$ # 或者</span><br><span class="line">$ yarn add typescript @types&#x2F;node @types&#x2F;react @types&#x2F;react-dom @types&#x2F;jest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>第二步：新建 tsconfig.json 文件</p>
</li>
<li><p>第三步：将文件的 js 后缀改为 tsx 后缀，修改所产生的问题</p>
</li>
</ol>
<h3 id="新建一个-ts-项目"><a href="#新建一个-ts-项目" class="headerlink" title="新建一个 ts 项目"></a>新建一个 ts 项目</h3><p>如果通过 create-react-app 脚手架搭建的话，可以直接 使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-app --template typescript</span><br><span class="line"># or</span><br><span class="line">yarn create react-app my-app --template typescript</span><br></pre></td></tr></table></figure>

<h3 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h3><p>如果系统不是用 babel 来编译，ts 3.7 以上就已经支持了，但是如果项目使用 babel 编译的话，使用 babel 调用 ts 的时候，ts 只会被用来做类型检查，真正的编译还是 babel 亲自上场的。所以如果想在项目中使用可选链接操作符，需要安装 <code>@babel/plugin-proposal-optional-chaining</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel&#x2F;plugin-proposal-optional-chaining</span><br></pre></td></tr></table></figure>

<p>在 webpack.config.json 中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [&quot;@babel&#x2F;plugin-proposal-optional-chaining&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以在项目中使用可选链接操作符了</p>
<p>完结撒花~</p>
]]></content>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2020/02/04/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="一、JS引擎的工作原理"><a href="#一、JS引擎的工作原理" class="headerlink" title="一、JS引擎的工作原理"></a>一、<a href="https://www.cnblogs.com/onepixel/p/5090799.html">JS引擎的工作原理</a></h3><p>先引入几个概念：<code>执行环境栈</code>、<code>执行环境</code>、<code>全局对象</code>、<code>变量对象</code>、<code>活动对象</code>、<code>作用域</code>和<code>作用域链</code></p>
<p>然后贴一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;                         <span class="comment">//定义一个全局变量 x</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;                       <span class="comment">//定义一个局部变量 x</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">z</span>)</span>&#123;                   <span class="comment">//定义一个内部函数 B</span></span><br><span class="line">    <span class="built_in">console</span>.log(x+y+z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B;                        <span class="comment">//返回函数B的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> C = A(<span class="number">1</span>);                      <span class="comment">//执行A,返回B</span></span><br><span class="line">C(<span class="number">1</span>);                              <span class="comment">//执行函数B，输出 4</span></span><br></pre></td></tr></table></figure>

<p>下面我们从<code>全局初始化</code>、<code>执行函数A</code>、<code>执行函数B</code> 三个阶段来分析JS引擎对这段代码的处理过程</p>
<h4 id="1-全局初始化"><a href="#1-全局初始化" class="headerlink" title="1.全局初始化"></a>1.全局初始化</h4><p>JS引擎在进入一段可执行代码时，会完成三项初始化工作：</p>
<blockquote>
<ul>
<li>首先，创建一个全局对象，该对象全局只存在一份，会伴随应用程序的整个生命周期，它的属性在应用程序的各个地方均可访问。我们平时经常用到的一些对象，如Math、String、Date、document等都是它的属性。由于这个全局对象不能通过名字直接访问，因此还有另外一个属性window，并将window指向了自身，这样就可以通过window访问这个全局对象了。用伪代码模拟全局对象的大体结构如下：</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalObject = &#123;</span><br><span class="line">  <span class="built_in">Math</span>:&#123;&#125;,</span><br><span class="line">  <span class="built_in">String</span>:&#123;&#125;,</span><br><span class="line">  <span class="built_in">Date</span>:&#123;&#125;,</span><br><span class="line">  <span class="built_in">document</span>:&#123;&#125;,                <span class="comment">//DOM操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">window</span>:<span class="built_in">this</span>                 <span class="comment">//让window属性指向了自身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>然后，JS引擎需要构建一个执行环境栈，同时创建一个全局执行环境，并将全局执行环境压入到执行环境栈中。执行环境栈的主要作用是保证应用程序能够按照正确的顺序执行。在JavaScript中，每个函数都会有自己的执行环境，当执行一个函数的时候，改函数的执行环境就会压入到执行环境栈的栈顶，并获得执行权，当函数执行完毕，函数的执行环境从栈顶移除，并将执行权交给之前的执行环境。用伪代码来模拟执行环境栈和执行环境的关系如下：</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ECStack = [];      <span class="comment">//定义一个执行环境栈，类似于数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> EC = &#123;&#125;;           <span class="comment">//创建一个执行空间，</span></span><br><span class="line"><span class="comment">//ECMA-262规范并没有对EC的数据结构做明确的定义，你可以理解为在内存中分配的一块空间</span></span><br><span class="line"></span><br><span class="line">ECStack.push(EC);     <span class="comment">//进入函数，压入执行环境</span></span><br><span class="line">ECStack.pop(EC);      <span class="comment">//函数返回后，删除执行环境</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>最后，JS引擎需要创建一个与全局执行环境相关联的全局变量对象，并把全局变量对象指向全局对象，全局变量对象不仅包含全局对象的原有属性，还包括我们在全局定义的变量和函数，如变量x、函数A。于此同时，在定义函数A的时候，会为函数A添加一个scope属性，指向函数A定义时所处的环境，即全局变量对象。在JavaScript中，每个函数在定义的时候，都会创建一个与之关联的scope属性，scope总是指向定义函数时所在的环境<font color="red">（记住这句话，很重要，很关键）</font>。此时执行环境栈的结构如下：</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [                              <span class="comment">//执行环境栈</span></span><br><span class="line">  EC(G) = &#123;                              <span class="comment">//全局执行环境</span></span><br><span class="line">    VO(G):&#123;                              <span class="comment">//定义全局变量对象</span></span><br><span class="line">      ...                                <span class="comment">//包含全局对象原有的属性</span></span><br><span class="line">      x: <span class="number">1</span>,                              <span class="comment">//定义变量x</span></span><br><span class="line">      A: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,                <span class="comment">//定义函数A</span></span><br><span class="line">      A[[scope]]: <span class="built_in">this</span>                   <span class="comment">//定义A的scope，并赋值为VO本身</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="2-执行函数A"><a href="#2-执行函数A" class="headerlink" title="2.执行函数A"></a>2.执行函数A</h4><p>当执行进入A(1) 时，JS引擎需要完成以下工作：</p>
<blockquote>
<ul>
<li>首先，JS引擎会创建函数A的执行环境，然后将函数A的执行环境压入到执行环境栈的栈顶并获得执行权。此时执行环境栈中有两个执行环境，分别是全局执行环境和函数A执行环境。</li>
<li>然后，创建函数A执行环境的作用域链，在JavaScript中，每个执行环境都会有自己的作用域链，用于标识符的解析，当执行环境被创建时，它的作用域链就初始化为当前运行函数的scope属性所包含的对象。</li>
<li>接着，JS引擎会创建一个与当前函数执行环境相关联的活动对象，这里的活动对象扮演着变量对象的角色，只是在函数中的叫法不同而已（你可以认为变量对象是一个总的概念，而活动对象是它的一个分支）。活动对象包含函数的形参、arguments对象，this以及局部定义的变量和函数。然后该活动对象会被加入到作用域链的顶端。需要注意的是，在定义函数B的时候，JS引擎同样也会为B添加了一个scope属性，并将scope指向了定义函数B时所在的环境，定义函数B的环境就是A的活动对象AO， 而AO位于链表的前端，由于链表具有首尾相连的特点，因此函数B的scope指向了A的整个作用域链。 我们再看看此时的ECStack结构：</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [                                <span class="comment">//执行环境栈</span></span><br><span class="line">  EC(A) = &#123;                                <span class="comment">//A的执行环境</span></span><br><span class="line">    [scope]:VO(G),                         <span class="comment">//VO是全局变量对象</span></span><br><span class="line">      AO(A) : &#123;                            <span class="comment">//创建函数A的活动对象</span></span><br><span class="line">        y: <span class="number">1</span>,                              <span class="comment">//A的形参</span></span><br><span class="line">        x: <span class="number">2</span>,                              <span class="comment">//定义局部变量x</span></span><br><span class="line">        B: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,                <span class="comment">//定义函数B</span></span><br><span class="line">        B[[scope]]:  <span class="built_in">this</span>,                 <span class="comment">//this指代AO本身，而AO位于scopeChain的顶端，因此B[[scope]]指向整个作用域链</span></span><br><span class="line">        <span class="built_in">arguments</span>: [],                     <span class="comment">//平时我们在函数中访问的arguments就是AO中的arguments</span></span><br><span class="line">        <span class="built_in">this</span>: <span class="built_in">window</span>                       <span class="comment">//函数中的this指向调用者window对象</span></span><br><span class="line">      &#125;,</span><br><span class="line">      scopeChain: [AO(A),A[[scope]]]       <span class="comment">//链表初始化为A[[scope]],然后再把AO加入该作用域链的顶端,此时A的作用域链：AO(A)-&gt;VO(G)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  EC(G) = &#123;                                <span class="comment">//全局执行环境</span></span><br><span class="line">    VO(G):&#123;                                <span class="comment">//创建全局变量对象</span></span><br><span class="line">      ...                                  <span class="comment">//包含全局对象原有的属性</span></span><br><span class="line">      x: <span class="number">1</span>,                                <span class="comment">//定义变量x</span></span><br><span class="line">      A: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,                  <span class="comment">//定义函数A</span></span><br><span class="line">      A[[scope]]: <span class="built_in">this</span>                     <span class="comment">//定义A的scope，A[[scope]] == VO(G)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h4 id="3-执行函数B"><a href="#3-执行函数B" class="headerlink" title="3.执行函数B"></a>3.执行函数B</h4><p>函数A被执行以后，返回了B的引用，并赋值给了变量C，执行 C(1) 就相当于执行B(1)，JS引擎需要完成以下工作：</p>
<blockquote>
<ul>
<li>首先，创建函数B的执行环境，并加入到执行环境栈的栈顶获得执行权（当函数A返回后，A的执行环境就会从栈中被删除，只留下全局执行环境）。</li>
<li>然后，创建函数B执行环境的作用域链，初始化为函数B的scope所包含的对象，即包含了A的作用域链。</li>
<li>最后，创建函数B执行环境相关联的活动对象。此时ECStack将会变成这样：</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [                                <span class="comment">//执行环境栈</span></span><br><span class="line">  EC(B) = &#123;                                <span class="comment">//创建B的执行环境,并处于作用域链的顶端</span></span><br><span class="line">    [scope]:AO(A),                         <span class="comment">//指向函数A的作用域链,AO(A)-&gt;VO(G)</span></span><br><span class="line">    AO(B) = &#123;                          <span class="comment">//创建函数B的活动对象</span></span><br><span class="line">      z: <span class="number">1</span>,</span><br><span class="line">      <span class="built_in">arguments</span>: [],</span><br><span class="line">      <span class="built_in">this</span>: <span class="built_in">window</span></span><br><span class="line">    &#125;</span><br><span class="line">    scopeChain: [AO(B),B[[scope]]]          <span class="comment">//链表初始化为B[[scope]],再将AO(B)加入链表表头，此时B的作用域链：AO(B)-&gt;AO(A)-VO(G)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  EC(G) = &#123;                                <span class="comment">//全局执行环境</span></span><br><span class="line">    VO:&#123;                                   <span class="comment">//定义全局变量对象</span></span><br><span class="line">      ...                                  <span class="comment">//包含全局对象原有的属性</span></span><br><span class="line">      x: <span class="number">1</span>,                                <span class="comment">//定义变量x</span></span><br><span class="line">      A: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,                  <span class="comment">//定义函数A</span></span><br><span class="line">      A[[scope]]: <span class="built_in">this</span>                     <span class="comment">//定义A的scope，A[[scope]] == VO(G)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>当函数B执行“x+y+z”时，需要对x、y、z 三个标识符进行一一解析，解析过程遵守变量查找规则：先查找自己的活动对象中是否存在该属性，如果存在，则停止查找并返回；如果不存在，继续沿着其作用域链从顶端依次查找，直到找到为止，如果整个作用域链上都未找到该变量，则返回“undefined”。从上面的分析可以看出函数B的作用域链是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AO(B)-&gt;AO(A)-&gt;VO(G)</span><br></pre></td></tr></table></figure>
<p>因此，变量x会在AO(A)中被找到，而不会查找VO(G)中的x，变量y也会在AO(A)中被找到，变量z 在自身的AO(B)中就找到了。所以执行结果：2+1+1=4.</p>
<h3 id="二、理解闭包"><a href="#二、理解闭包" class="headerlink" title="二、理解闭包"></a>二、理解闭包</h3><p>在JavaScript中，一个函数可以定义在另一个函数内部。内嵌函数的引用环境包含自身的局部变量和参数、外套函数的局部变量和参数，以及全局对象的属性。</p>
<p>一个内嵌函数可以访问外套函数的应用环境，当内嵌函数运行与外套函数的作用域内时，满足这个要求很简单。但是在JavaScript中，函数还可以作为参数和返回值，这时，送内嵌函数的定义到调用它的代码，引用环境发生了改变。如果还要访问原来的引用环境，就必须以某种方式将内嵌函数的引用环境与外套函数的引用环境绑定在一起，这个绑定的过程即为闭包的创建过程。</p>
<p>函数的局部变量存在于函数调用时与执行环境相关联的活动对象中，如果没有闭包的存在，外套函数返回内嵌函数后，外套函数的执行环境会从执行环境栈中移除，返回的内嵌函数所能应用的外套函数的局部变量也将随之消失。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClosure</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = createClosure()</span><br><span class="line">fn() <span class="comment">// 如果没有闭包存在，fn将无法访问createClosure函数的局部变量i</span></span><br></pre></td></tr></table></figure>
<p>实际上闭包并不只是在函数返回是才创建的，任何闭包都是随同函数定义时一起创建的，有人的地方就有江湖，有函数的地方就有闭包。在JavaScript中，每个函数在定义的时候，都会创建一个与之关联的scope属性，scope总是指向定义函数时所在的环境。我们可以将函数的scope属性看成函数的闭包，所以闭包无处不在，无时不有。</p>
<p>尝试说出以下代码的执行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">fn, x</span>) </span>&#123;           <span class="comment">//定义一个全局函数f</span></span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    f(g, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;              <span class="comment">//定义一个局部函数g</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params"></span>) </span>&#123;                <span class="comment">//定义一个全局函数h</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(h, <span class="number">0</span>)                       <span class="comment">//执行函数f</span></span><br></pre></td></tr></table></figure>
<h4 id="1-执行函数f"><a href="#1-执行函数f" class="headerlink" title="1.执行函数f"></a>1.执行函数f</h4><p>当执行进入f(h, 0)时，JS引擎需要完成以下工作：</p>
<blockquote>
<ul>
<li>首先，创建函数f的执行环境，并加入到执行环境栈的栈顶获得执行权。</li>
<li>然后，创建函数f执行环境的作用域链，初始化为函数f的scope所包含的对象。</li>
<li>接着，创建与函数f执行环境相关联的活动对象，该活动对象包含函数f的形参fn和x、arguments对象，this以及局部定义的函数g。注意，在定义函数g的时候，会为函数g添加一个scope属性，指向函数g定义时所处的环境即函数f的活动对象。此时的ECStack结构如下：</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [                            <span class="comment">//执行环境栈</span></span><br><span class="line">  EC(f) = &#123;                            <span class="comment">//函数f的执行环境</span></span><br><span class="line">    [scope]: VO(G),                    <span class="comment">//VO是全局变量对象</span></span><br><span class="line">    AO(f): &#123;                           <span class="comment">//创建函数f的活动对象</span></span><br><span class="line">      fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,             <span class="comment">//f的形参，全局函数h</span></span><br><span class="line">      x: <span class="number">0</span>,                            <span class="comment">//f的形参</span></span><br><span class="line">      g: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,              <span class="comment">//定义局部函数g</span></span><br><span class="line">      g[[scope]]: <span class="built_in">this</span>                 <span class="comment">//为局部函数g添加scope属性，指向函数f的活动对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    scopeChain:[AO(f), f[[scope]]]</span><br><span class="line">  &#125;,</span><br><span class="line">  EC(G) = &#123;</span><br><span class="line">    VO(G):&#123;                            <span class="comment">//创建全局变量对象</span></span><br><span class="line">      ...                              <span class="comment">//包含全局对象原有的属性</span></span><br><span class="line">      f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,              <span class="comment">//定义函数f</span></span><br><span class="line">      f[[scope]]: <span class="built_in">this</span>,                <span class="comment">//定义f的scope，f[[scope]] == VO(G)</span></span><br><span class="line">      h: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,              <span class="comment">//定义函数h</span></span><br><span class="line">      h[[scope]]: <span class="built_in">this</span>                 <span class="comment">//定义h的scope，gh[[scope]] == VO(G)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h4 id="2-第二次执行函数f"><a href="#2-第二次执行函数f" class="headerlink" title="2.第二次执行函数f"></a>2.第二次执行函数f</h4><p>由于x为0，满足x &lt; 1的条件，所以执行进入f(g, 1)，JS引擎需要完成以下工作：</p>
<blockquote>
<ul>
<li>首先，创建函数f的执行环境（该执行环境与进入f(h, 0)时创建的执行环境完全不同），并加入到执行环境栈的栈顶获得执行权（当执行f(h, 0)返回后，f的执行环境就会从栈中被删除，只留下全局执行环境）。</li>
<li>然后，创建函数f执行环境的作用域链，初始化为函数f的scope所包含的对象。</li>
<li>接着，创建与函数f执行环境相关联的活动对象，该活动对象包含函数f的形参fn和x、arguments对象，this以及局部定义的函数g。注意，在定义函数g的时候，会为函数g添加一个scope属性，指向函数g定义时所处的环境即函数f的活动对象。此时的ECStack结构如下：</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [                            <span class="comment">//执行环境栈</span></span><br><span class="line">  EC(f) = &#123;                            <span class="comment">//函数f的执行环境</span></span><br><span class="line">    [scope]: VO(G),                    <span class="comment">//VO是全局变量对象</span></span><br><span class="line">    AO(f): &#123;                           <span class="comment">//创建函数f的活动对象</span></span><br><span class="line">      fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,             <span class="comment">//f的形参，局部函数g</span></span><br><span class="line">      x: <span class="number">1</span>,                            <span class="comment">//f的形参</span></span><br><span class="line">      g: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,              <span class="comment">//定义局部函数g</span></span><br><span class="line">      g[[scope]]: <span class="built_in">this</span>                 <span class="comment">//为局部函数g添加scope属性，指向函数f的活动对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    scopeChain:[AO(f), f[[scope]]]</span><br><span class="line">  &#125;,</span><br><span class="line">  EC(G) = &#123;</span><br><span class="line">    VO(G):&#123;                            <span class="comment">//创建全局变量对象</span></span><br><span class="line">      ...                              <span class="comment">//包含全局对象原有的属性</span></span><br><span class="line">      f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,              <span class="comment">//定义函数f</span></span><br><span class="line">      f[[scope]]: <span class="built_in">this</span>,                <span class="comment">//定义f的scope，f[[scope]] == VO(G)</span></span><br><span class="line">      h: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,              <span class="comment">//定义函数h</span></span><br><span class="line">      h[[scope]]: <span class="built_in">this</span>                 <span class="comment">//定义h的scope，gh[[scope]] == VO(G)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h4 id="3-执行函数g"><a href="#3-执行函数g" class="headerlink" title="3.执行函数g"></a>3.执行函数g</h4><p>由于x为1，不满足x &lt; 1的条件，所以执行进入fn()，即执行局部函数g，JS引擎需要完成以下工作：</p>
<blockquote>
<ul>
<li>首先，创建函数g的执行环境，并加入到执行环境栈的栈顶获得执行权（当执行f(g, 1)返回后，f的执行环境就会从栈中被删除，只留下全局执行环境）。</li>
<li>然后，创建函数g执行环境的作用域链，初始化为函数g的scope所包含的对象，此时函数g的scope所指向的对象为执行f(h, 0)时所创建的活动对象。</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">AO(f): &#123;                           <span class="comment">//创建函数f的活动对象</span></span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,             <span class="comment">//f的形参，全局函数h</span></span><br><span class="line">  x: <span class="number">0</span>,                            <span class="comment">//f的形参</span></span><br><span class="line">  g: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,              <span class="comment">//定义局部函数g</span></span><br><span class="line">  g[[scope]]: <span class="built_in">this</span>                 <span class="comment">//为局部函数g添加scope属性，指向函数f的活动对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>接着，创建与函数g执行环境相关联的活动对象。</li>
<li>最后，执行console.log(x)，打印0。</li>
</ul>
</blockquote>
<p>闭包虽然是在函数定义时就创建了，但并不意味着其中的变量就会停留在那一刻。只要与闭包关联的函数不立马执行，程序的执行权仍在闭包的创建者手中，闭包中的值就可能会发生改变。举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.createElement(<span class="string">&#x27;ul);</span></span><br><span class="line"><span class="string">for (var i = 1; i &lt;= 5; i++) &#123;</span></span><br><span class="line"><span class="string">  var item = document.createElement(&#x27;</span>li);</span><br><span class="line">  item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;item &#x27;</span> + i));</span><br><span class="line"></span><br><span class="line">  item.onClick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;item &#x27;</span> + i + <span class="string">&#x27; is Clicked.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  list.appendChild(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(list);</span><br></pre></td></tr></table></figure>
<p>编写这段代码的原意是想要创建5个li元素，在每个li元素上单击时，控制台会打印出元素所对应的编号。但是实际上，所有li元素的打印结果都是”item 6 is Clicked.“。原因是事件处理函数的闭包记住了变量i，但记住的并不是创建闭包时的值，变量i的值会随着循环的执行而改变为6，而这就是元素单击时实践处理函数读取到的值。</p>
<h3 id="三、函数式编程"><a href="#三、函数式编程" class="headerlink" title="三、函数式编程"></a>三、函数式编程</h3><p>在JavaScript中，函数是一等值。何谓一等？一等，是编程语言中值的通用修饰词，只要某个值满足一下三个条件，就能被成为一等值：</p>
<blockquote>
<ul>
<li>可以作为参数传递给函数</li>
<li>可以作为函数的返回值</li>
<li>可以赋值给变量</li>
</ul>
</blockquote>
<p>众所周知 JavaScript 是一种拥有很多共享状态的动态语言，慢慢的，代码就会积累足够的复杂性，变得笨拙难以维护。当我们在设计应用程序的时候，我们应该考虑是否遵守了以下的设计原则。</p>
<blockquote>
<ul>
<li>可扩展性–我是否需要不断地重构代码来支持额外的功能？</li>
<li>易模块化–如果我更改了一个文件，另一个文件是否会受到影响？</li>
<li>可重用性–是否有很多重复的代码？</li>
<li>可测试性–给这些函数添加单元测试是否让我纠结？</li>
<li>易推理性–我写的代码是否非结构化严重并难以推理？</li>
</ul>
</blockquote>
<p>什么是函数式编程？就是打心眼里承认函数是一等公民。</p>
<p>简单来说，函数式编程是一种强调以函数使用为主的软件开发风格。函数式编程的目的是使用函数来抽象作用在数据之上的控制流和操作，从而在系统中消除副作用并减少对状态的改变。</p>
<p>举个栗子：</p>
<p>现在的需求就是输出在网页上输出 “Hello World”。</p>
<p>一般的初学者会这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;#msg&#x27;</span>).innerHTML = <span class="string">&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这样写很简单，但是所有都是写死的，不能复用，如果想改变消息的格式、内容等就需要重写整个表达式，所以可能有经验的前端开发者会这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMessage</span>(<span class="params">elementId, format, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(elementId).innerHTML = <span class="string">`&lt;<span class="subst">$&#123;format&#125;</span>&gt;<span class="subst">$&#123;message&#125;</span>&lt;/<span class="subst">$&#123;format&#125;</span>&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printMessage(<span class="string">&#x27;msg&#x27;</span>, <span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;Hello World&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这样确实有所改进，但是仍然不是一段可重用的代码，如果是要将文本写入文件，而不是插入到HTML中，或者我想重复的显示 Hello World。</p>
<p>那么作为一个函数式编程的开发者会怎么写这段代码呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> printMessage = compose(addToDom, h1, echo)</span><br><span class="line"></span><br><span class="line">printMessage(<span class="string">&#x27;Hello World&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>其中h1、echo、addToDom和compose都是函数，compose函数尤为关键，它的每个参数都是函数，自右向左执行参数，下一个函数接收上一个函数的执行结果作为参数。</p>
<p>那么我们为什么要写成这样呢？看起来多了很多函数。</p>
<p>其实我们是将程序分解为一些更可重用、更可靠且更易于理解的部分，然后再将他们组合起来，形成一个更易推理的程序整体。</p>
<p>好，我们现在再改变一下需求，现在我们需要将文本重复三遍，打印到控制台。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> printMessaage = compose(<span class="built_in">console</span>.log, repeat(<span class="number">3</span>), echo)</span><br><span class="line"></span><br><span class="line">printMessage(‘Hello World’)</span><br></pre></td></tr></table></figure>

<p>可以看到我们更改了需求并没有去修改内部逻辑，只是重组了一下函数而已。</p>
<p>为了充分理解函数式编程，我们先来看下几个基本概念。</p>
<blockquote>
<ul>
<li>声明式编程</li>
<li>不可变数据</li>
<li>纯函数</li>
<li>高阶函数</li>
<li>lambda 表达式</li>
<li>组合函数</li>
<li>point free</li>
<li>柯里化</li>
<li>部分应用（偏函数）</li>
</ul>
</blockquote>
<h4 id="1-声明式编程"><a href="#1-声明式编程" class="headerlink" title="1.声明式编程"></a>1.声明式编程</h4><p>函数式编程属于声明是编程范式：这种范式会描述一系列的操作，但并不会暴露它们是如何实现的或是数据流如何传过它们。</p>
<p>我们所熟知的 SQL 语句就是一种很典型的声明式编程，它由一个个描述查询结果应该是什么样的断言组成，对数据检索的内部机制进行了抽象。</p>
<p>我们再来看一组代码再来对比一下命令式编程和声明式编程。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令式方式</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    array[i] = <span class="built_in">Math</span>.pow(array[i], <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array; <span class="comment">// [0, 1, 4, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明式方式</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">num</span> =&gt;</span> <span class="built_in">Math</span>.pow(num, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>可以看到命令式很具体的告诉计算机如何执行某个任务，而声明式是将程序的描述与求值分离开来。它关注如何用各种表达式来描述程序逻辑，而不一定要指明其控制流或状态关系的变化。</p>
<p>为什么我们要去掉代码循环呢？循环是一种重要的命令控制结构，但很难重用，并且很难插入其他操作中。而函数式编程旨在尽可能的提高代码的无状态性和不变性。要做到这一点，就要学会使用无副作用的函数–也称纯函数。</p>
<h4 id="2-不可变数据"><a href="#2-不可变数据" class="headerlink" title="2.不可变数据"></a>2.不可变数据</h4><p>不可变数据其实是函数式编程相关的重要概念。相对的，函数式编程中认为可变性是万恶之源。简而言之可变状态会让程序的运行变得不可预测，代码可读性差，难以维护。</p>
<p>在 JS 中，当函数入参是对象类型的数据时，我们拿到的其实是个引用，所以即使在函数内部我们也是可以修改对象内部的属性，这种情景依然会产生副作用。</p>
<p>所以这个时候就需要引入 Immutable 的概念。 Immutable 即 unchangeable， Immutable data在初始化创建后就不能被修改了，每次对于 Immutable data 的操作都会返回一个新的 Immutable data。 所以并不会对原来的状态形成改变（当然不是简单的深拷贝再修改）。</p>
<p>创建不可变数据的主要实现思路就是：一次更新过程中，不应该改变原有对象，只需要新创建一个对象用来承载新的数据状态。</p>
<p>举个栗子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> student1 = &#123;</span><br><span class="line">    school: <span class="string">&quot;HUST&quot;</span>, </span><br><span class="line">    name: <span class="string">&#x27;YU JIHU&#x27;</span>,</span><br><span class="line">    birthday: <span class="string">&#x27;1995-6-14&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> changeStudent = <span class="function">(<span class="params">student, newName, newBirthday</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...student,             <span class="comment">// 使用解构</span></span><br><span class="line">        name: newName,          <span class="comment">// 覆盖name属性</span></span><br><span class="line">        birthday: newBirthday   <span class="comment">// birthday</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student2 = changeStudent(student1, <span class="string">&#x27;JIHU YU&#x27;</span>, <span class="string">&#x27;1994-6-14&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这样，我们达到了想要的效果：根据参数，产生了一个新对象，并正确赋值，最重要的就是并没有改变原对象。</p>
<h4 id="3-纯函数"><a href="#3-纯函数" class="headerlink" title="3.纯函数"></a>3.纯函数</h4><p>纯函数指没有副作用的函数，相同的输入有相同的输出。</p>
<p>常常这些情况会产生副作用。</p>
<blockquote>
<ul>
<li>改变一个函数参数的原始值</li>
<li>读取作用域外的其他变量</li>
<li>改变作用域外的其他变量</li>
<li>处理用户输入</li>
<li>抛出一个异常</li>
<li>屏幕打印或记录日志</li>
<li>访问浏览器的Cookie</li>
<li>发起一个网络请求</li>
<li>DOM查询/操作</li>
</ul>
</blockquote>
<p>举个栗子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tax = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTax</span>(<span class="params">productPrice</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (productPrice * (tax/<span class="number">100</span>)) + productPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数是不纯的，它读取了外部的变量tax，可能会觉得这段代码没有什么问题，但是我们要知道这种依赖外部变量来进行的计算，计算结果很难预测，你也有可能在其他地方修改了tax的值，导致你 calculateTax出来的值不是你预期的。</p>
<p>所以纯函数有如下特性：</p>
<blockquote>
<ul>
<li>变量都只在函数作用域内获取, 作为的函数的参数传入</li>
<li>不会产生副作用, 不会改变被传入的数据或者其他数据</li>
<li>相同的输入保证相同的输出</li>
</ul>
</blockquote>
<p>但是在我们平时的开发中，有一些副作用是难以避免的，与外部的存储系统或 DOM 交互等，我们可以通过将其从主逻辑中分离出来，使他们易于管理。</p>
<p>现在我们有一个小需求：通过id找到学生的记录并渲染在浏览器(在写程序的时候要想到可能也会写到控制台，数据库或者文件，所以要想如何让自己的代码能重用)中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令式代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showStudent</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里假如是同步查询</span></span><br><span class="line">    <span class="keyword">var</span> student = db.get(id)</span><br><span class="line">    <span class="keyword">if</span>(student !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 读取外部的 elementId</span></span><br><span class="line">          <span class="built_in">document</span>.querySelector(<span class="string">`<span class="subst">$&#123;elementId&#125;</span>`</span>).innerHTML = <span class="string">`<span class="subst">$&#123;student.id&#125;</span>,<span class="subst">$&#123;student.name&#125;</span>,<span class="subst">$&#123;student.lastname&#125;</span>`</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;not found&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">showStudent(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 find 函数找到学生</span></span><br><span class="line"><span class="keyword">var</span> find = curry(<span class="function"><span class="keyword">function</span>(<span class="params">db, id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = db.get(id)</span><br><span class="line">    <span class="keyword">if</span>(obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;not fount&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将学生对象 format</span></span><br><span class="line"><span class="keyword">var</span> csv = <span class="function">(<span class="params">student</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;student.id&#125;</span>,<span class="subst">$&#123;student.name&#125;</span>,<span class="subst">$&#123;student.lastname&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在屏幕上显示</span></span><br><span class="line"><span class="keyword">var</span> append = curry(<span class="function"><span class="keyword">function</span>(<span class="params">elementId, info</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(elementId).innerHTML = info</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> showStudent = compose(append(<span class="string">&#x27;#student-info&#x27;</span>), csv, find(db))</span><br><span class="line"></span><br><span class="line">showStudent(<span class="string">&#x27;666&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中curry函数的主要作用是将多参数函数转换成单参数函数，即柯里化。</p>
<p>可以看到函数式代码通过较少这些函数的长度，将 showStudent 编写为小函数的组合。这个程序还不够完美，但是已经可以展现出相比于命令式的很多优势了。</p>
<blockquote>
<ul>
<li>灵活。有三个可重用的组件</li>
<li>声明式的风格，给高阶步骤提供了一个清晰视图，增强了代码的可读性</li>
<li>另外是将纯函数与不纯的行为分离出来。</li>
</ul>
</blockquote>
<p>我们看到纯函数的输出结果是一致的，可预测的，相同的输入会有相同的返回值，这个其实也被称为引用透明。</p>
<p>引用透明是定义一个纯函数较为正确的方法。纯度在这个意义上表示一个函数的参数和返回值之间映射的纯的关系。如果一个函数对于相同的输入始终产生相同的结果，那么我们就说它是引用透明。</p>
<h4 id="4-高阶函数"><a href="#4-高阶函数" class="headerlink" title="4.高阶函数"></a>4.高阶函数</h4><p>所谓高阶函数是指可一把函数作为参数，或者是可以将函数作为返回值的函数。</p>
<p>对于程序的编写，高阶函数比普通函数要灵活的多，除了通常意义的函数调用返回外，还形成了一种后续传递风格的结果接收方式，而非单一的返回值形式，后续传递风格的程序编写将函数的业务重点从返回值转移到了回调函数中。<br>举个栗子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, bar</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> bar(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于相同的foo()函数，传入的bar的参数不同，则可以得到不同的结果。</p>
<p>高阶函数在JS中的应用比比皆是，其中ECMAScript5中提供的一些数组方法就是典型的高阶函数，比如：forEach()、map()、reduce()、reduceRight()、filter()、every()、some()等。</p>
<h4 id="5-lambda表达式"><a href="#5-lambda表达式" class="headerlink" title="5.lambda表达式"></a>5.lambda表达式</h4><p>lambda 表达式其实是一个匿名函数，使用箭头清晰的表示输入输出的映射关系，JavaScript 中使用箭头函数来实现。</p>
<blockquote>
<ul>
<li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li>
<li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li>
<li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply = <span class="function"><span class="params">x</span> =&gt;</span> x * x</span><br><span class="line">multiply(<span class="number">6</span>) <span class="comment">// 36</span></span><br></pre></td></tr></table></figure>

<h4 id="6-组合函数"><a href="#6-组合函数" class="headerlink" title="6.组合函数"></a>6.组合函数</h4><p>组合，是函数式编程的核心之一，通过组合小的、确定的函数，来创建更大的软件组件和功能，能够生成更加容易组织、理解、调试、扩展、测试和维护的代码。</p>
<p>函数的组合就是将已被分解的简单任务组合成复杂任务的过程。</p>
<p>举个栗子：</p>
<p>现在我们有这样一个需求：给你一个字符串，将这个字符串转化成大写，然后逆序。</p>
<p>你可能会这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;function program&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一行代码搞定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">oneLine</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> res = str.toUpperCase().split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者按要求一步一步来，先转成大写，然后逆序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiLine</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> upperStr = str.toUpperCase()</span><br><span class="line">    <span class="keyword">var</span> res = upperStr.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能看到这里你并没有觉得有什么不对的，但是现在产品又突发奇想，改了下需求，把字符串大写之后，把每个字符拆开之后组装成一个数组，比如 ’aaa‘ 最终会变成 [A, A, A]。</p>
<p>那么这个时候我们就需要更改我们之前我们封装的函数。这就修改了以前封装的代码，其实在设计模式里面就是破坏了开闭原则。</p>
<p>那么我们如果把最开始的需求代码写成这个样子，以函数式编程的方式来写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;function program&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToUpper</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringReverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toUpperAndReverse = 组合(stringReverse, stringToUpper)</span><br><span class="line"><span class="keyword">var</span> res = toUpperAndReverse(str)</span><br></pre></td></tr></table></figure>

<p>那么当我们需求变化的时候，我们根本不需要修改之前封装过的东西。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;function program&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToUpper</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringReverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toUpperAndReverse = 组合(stringReverse, stringToUpper)</span><br><span class="line"><span class="keyword">var</span> res = toUpperAndReverse(str)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToArray</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toUpperAndArray = 组合(stringToArray, stringToUpper)</span><br><span class="line">toUpperAndArray(str)</span><br></pre></td></tr></table></figure>
<p>可以看到当变更需求的时候，我们没有打破以前封装的代码，只是新增了函数功能，然后把函数进行重新组合。</p>
<p>突然产品一拍脑袋，又想改一下需求，把字符串大写之后，再翻转，再转成数组。</p>
<p>要是你按照以前的思考，没有进行抽象，你肯定心理一万只草泥马在奔腾，但是如果你抽象了，你完全可以不慌。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;function program&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToUpper</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringReverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToArray</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strUpperAndReverseAndArray = 组合(stringToArray, stringReverse, stringToUpper)</span><br><span class="line">strUpperAndReverseAndArray(str)</span><br></pre></td></tr></table></figure>
<p>发现并没有更换你之前封装的代码，只是更换了函数的组合方式。可以看到，组合的方式是真的就是抽象单一功能的函数，然后再组成复杂功能。这种方式既锻炼了你的抽象能力，也给维护带来巨大的方便。</p>
<p>注意：要传给组合函数的函数是有规范的，首先函数的执行是从最后一个参数开始执行，一直执行到第一个，必须只有一个形参，而且函数的返回值是下一个函数的实参。</p>
<p>如果<code>compose</code>函数接收的函数数量是固定的，那么它实现起来就很简单。</p>
<p>只接收两个函数作为参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">f, g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(x))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只接收三个函数作为参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">f, g, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(m(x)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是<code>compose</code>函数接收的参数通常不是固定的，我们可以用<code>rest</code>形式来接收参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们只需要考虑如果将函数数组从右向左执行，可以使用数组的<code>reduceRight</code>方法来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fns.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">arg, fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn(arg)</span><br><span class="line">    &#125;, x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>compose</code>函数的数据流是从右至左，最右侧的函数最先执行，最左侧的函数最后执行；<br>那么从左向右的数据流，即最左侧的函数最先执行，最右侧的函数最后执行，称之为什么？——<code>pipeline(管道)</code></p>
<p><code>管道(pipeline)</code>的实现同<code>compose</code>的实现方式很类似，因为二者的区别仅仅是数据流的方向不同而已。</p>
<p>对比<code>compose</code>函数的实现，仅需将<code>reduceRight</code>替换为<code>reduce</code>即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">arg, fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn(arg)</span><br><span class="line">    &#125;, x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-point-free"><a href="#7-point-free" class="headerlink" title="7.point-free"></a>7.point-free</h4><p>在函数式编程的世界中，有这样一种很流行的编程风格。这种风格被称为 tacit programming，也被称作为 point-free，point 表示的就是形参，意思大概就是没有形参的编程风格。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这就是有参的，因为word这个形参</span></span><br><span class="line"><span class="keyword">var</span> snakeCase = <span class="function"><span class="params">word</span> =&gt;</span> word.toLowerCase().replace(<span class="regexp">/\s+/ig</span>, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是 pointfree，没有任何形参</span></span><br><span class="line"><span class="keyword">var</span> snakeCase = compose(replace(<span class="regexp">/\s+/ig</span>, <span class="string">&#x27;_&#x27;</span>), toLowerCase);</span><br></pre></td></tr></table></figure>
<p>有参的函数的目的是得到一个数据，而 pointfree 的函数的目的是得到另一个函数。</p>
<p>那这 pointfree 有什么用？ 它可以让我们把注意力集中在函数上，参数命名的麻烦肯定是省了，代码也更简洁优雅。 需要注意的是，一个 pointfree 的函数可能是由众多非 pointfree 的函数组成的，也就是说底层的基础函数大都是有参的，pointfree 体现在用基础函数组合而成的高级函数上，这些高级函数往往可以作为我们的业务函数，通过组合不同的基础函数构成我们的复制的业务逻辑。</p>
<p>可以说 pointfree 使我们的编程看起来更美，更具有声明式，这种风格算是函数式编程里面的一种追求，一种标准，我们可以尽量的写成 pointfree，但是不要过度的使用，任何模式的过度使用都是不对的。</p>
<h4 id="8-柯里化"><a href="#8-柯里化" class="headerlink" title="8.柯里化"></a>8.柯里化</h4><p>在计算机科学，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<p>柯里化后的函数正式组合函数参数的要求，柯里化的作用就是解决基础函数如果是多参数函数，就不能作为参数传递给组合函数的问题。</p>
<p>柯里化函数可以使我们更好的去追求 pointfree，让我们代码写得更优美！</p>
<p>举个栗子来理解柯里化。</p>
<p>比如你有一间店铺，并且你想给你顾客打个九个优惠，现在我们需要计算优惠了多少钱</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">price, discount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * discount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以预见，从长远来看，我们会发现自己每天都在计算打九折的优惠</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> price1 = discount(<span class="number">1500</span>, <span class="number">0.10</span>); <span class="comment">// $150</span></span><br><span class="line"><span class="keyword">const</span> price2 = discount(<span class="number">2000</span>, <span class="number">0.10</span>); <span class="comment">// $200</span></span><br><span class="line"><span class="comment">// ... 等等很多</span></span><br></pre></td></tr></table></figure>

<p>我们可以将 discount 函数柯里化，这样我们就不用总是每次计算时都输入这 0.10 的折扣。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个就是一个柯里化函数，将本来两个参数的 discount ，转化为每次接收单个参数完成求职</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discountCurry</span>(<span class="params">discount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price * discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tenPercentDiscount = discountCurry(<span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，我们可以只计算你的顾客买的物品都价格了：</span></span><br><span class="line">tenPercentDiscount(<span class="number">500</span>); <span class="comment">// $50</span></span><br></pre></td></tr></table></figure>
<p>同样地，有些至尊vip客户，我们需要为他们提供 20% 的折扣。 可以使用我们的柯里化的discount函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> twentyPercentDiscount = discountCurry(<span class="number">0.2</span>);</span><br><span class="line">twentyPercentDiscount(<span class="number">500</span>); <span class="comment">// $100</span></span><br></pre></td></tr></table></figure>

<p>这就是柯里化，下面举个栗子说明柯里化在函数式编程里的应用</p>
<p>假设现在我们有这么一个需求：给定的一个字符串，先翻转，然后转大写，找是否有JD，如果有那么就输出 yes，否则就输出 no。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToUpper</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringReverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">str, targetStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.includes(targetStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judge</span>(<span class="params">is</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(is ? <span class="string">&#x27;yes&#x27;</span> : <span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们很容易就写出了这四个函数，现在我们想通过组合函数的方式来实现 pointfree，但是我们的 find 函数要接受两个参数，不符合组合函数参数的规定，这个时候我们像前面一个例子一样，把 find 函数柯里化一下，然后再进行组合：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 柯里化 find 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findCurry</span>(<span class="params">targetStr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">str</span> =&gt;</span> str.includes(targetStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findTaoweng = findCurry(<span class="string">&#x27;JD&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = compose(judge, findTaoweng, stringReverse, stringToUpper)</span><br></pre></td></tr></table></figure>

<p>对于JavaScript而言，我们通常所说的柯里化函数与数学和计算机科学中的柯里化的概念并不一样。</p>
<p>在数学和计算机科学中的柯里化函数，一次只能传递一个参数；</p>
<p>而JavaScript中的柯里化函数，可以传递一个或多个参数。</p>
<p>举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b,c,d,e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a,b,c,d,e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成的柯里化函数</span></span><br><span class="line"><span class="keyword">let</span> _fn = curry(fn);</span><br><span class="line"></span><br><span class="line">_fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);     <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">_fn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);   <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">_fn(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>)(<span class="number">5</span>);   <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">_fn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>); <span class="comment">// print: 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>

<p>对于已经柯里化后的 _fn 函数来说，当接收的参数数量与原函数的形参数量相同时，执行原函数； 当接收的参数数量小于原函数的形参数量时，返回一个函数用于接收剩余的参数，直至接收的参数数量与形参数量一致，执行原函数。</p>
<p>那么如何实现 curry 函数呢？</p>
<p>回想之前我们对于柯里化的定义，接收一部分参数，返回一个函数接收剩余参数，接收足够参数后，执行原函数。</p>
<p>我们已经知道了，当柯里化函数接收到足够参数后，就会执行原函数，那么我们如何去确定何时达到足够的参数呢？</p>
<p>我们有两种思路：</p>
<blockquote>
<ol>
<li>通过函数的 length 属性，获取函数的形参个数，形参的个数就是所需的参数个数;</li>
<li>在调用柯里化工具函数时，手动指定所需的参数个数。</li>
</ol>
</blockquote>
<p>我们将这两点结合以下，实现一个简单 curry 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将函数柯里化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn    待柯里化的原函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>len   所需的参数个数，默认为原函数的形参个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, len = fn.length</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _curry.call(<span class="built_in">this</span>, fn, len)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中转函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn    待柯里化的原函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>len   所需的参数个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>args  已接收的参数列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_curry</span>(<span class="params">fn, len, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _args = [...args, ...params];</span><br><span class="line">    <span class="keyword">if</span>(_args.length &gt;= len)&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, _args);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _curry.call(<span class="built_in">this</span>, fn, len, ..._args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-部分应用（偏函数）"><a href="#9-部分应用（偏函数）" class="headerlink" title="9.部分应用（偏函数）"></a>9.部分应用（偏函数）</h4><p>部分应用是一种通过将函数的不可变参数子集，初始化为固定值来创建更小元数函数的操作。简单来说，如果存在一个具有五个参数的函数，给出三个参数后，就会得到一个两个参数的函数。</p>
<p>部分应用与柯里化类似，都是用来减少函数参数的手段。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debug</span>(<span class="params">type, firstArg, secondArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(type === <span class="string">&#x27;log&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(firstArg, secondArg)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;info&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(firstArg, secondArg)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;warn&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(firstArg, secondArg)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(firstArg, secondArg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logDebug = 部分应用(debug, <span class="string">&#x27;log&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> infoDebug = 部分应用(debug, <span class="string">&#x27;info&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> warnDebug = 部分应用(debug, <span class="string">&#x27;warn&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> errDebug = 部分应用(debug, <span class="string">&#x27;error&#x27;</span>)</span><br><span class="line"></span><br><span class="line">logDebug(<span class="string">&#x27;log:&#x27;</span>, <span class="string">&#x27;测试部分应用&#x27;</span>)</span><br><span class="line">infoDebug(<span class="string">&#x27;info:&#x27;</span>, <span class="string">&#x27;测试部分应用&#x27;</span>)</span><br><span class="line">warnDebug(<span class="string">&#x27;warn:&#x27;</span>, <span class="string">&#x27;测试部分应用&#x27;</span>)</span><br><span class="line">errDebug(<span class="string">&#x27;error:&#x27;</span>, <span class="string">&#x27;测试部分应用&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>debug方法封装了我们平时用 console 对象调试的时候各种方法，本来是要传三个参数，我们通过部分应用的封装之后，我们只需要根据需要调用不同的方法，传必须的参数就可以了。</p>
<p>因为部分应用也可以减少参数，所以他在我们进行编写组合函数的时候也占有一席之地，而且可以更快传递需要的参数，留下为了 compose 传递的参数，这里是跟柯里化比较，因为柯里化按照定义的话，一次函数调用只能传一个参数，如果有四五个参数就需要:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c +d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用柯里化方式来使 add 转化为一个一元函数</span></span><br><span class="line"><span class="keyword">let</span> addPreThreeCurry = currying(add)(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line">addPreThree(<span class="number">4</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>用部分应用就可以</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用部分应用的方式使 add 转化为一个一元函数</span></span><br><span class="line"><span class="keyword">const</span> addPreThreePartial = 部分应用(add, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">addPreThree(<span class="number">4</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>functional</tag>
      </tags>
  </entry>
  <entry>
    <title>事务隔离级别与MVCC</title>
    <url>/2020/02/04/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC/</url>
    <content><![CDATA[<body><a name="2598"></a><div><a name="2598"><span></span></a><div><a name="2598"><div><span style="font-size: 14pt;">MySql常见的几种存储引擎及其特点：</span></div><div><font style="font-size: 14pt;"><br></font></div><div><span style="font-family: Arial; font-variant: normal; font-weight: bold; color: rgb(250, 122, 0); font-size: 14pt;">MyISAM</span></div><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(54, 46, 43); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器；</span></div><div style="font-size: 14px;letter-spacing: normal;text-align: left;text-indent: 0px;text-transform: none;white-space: normal;widows: 1;word-spacing: 0px;-webkit-text-stroke-width: 0px;background-color: rgb(255, 255, 255);margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><span style="font-size: 14px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;-en-paragraph:true;">无法处理事务</span></div><div style="font-size: 14px;letter-spacing: normal;text-align: left;text-indent: 0px;text-transform: none;white-space: normal;widows: 1;word-spacing: 0px;-webkit-text-stroke-width: 0px;background-color: rgb(255, 255, 255);margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><span style="font-size: 14px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;-en-paragraph:true;">MyISAM存储引擎特别适合在以下几种情况下使用：<a id="more"></a></span></div><div style="font-size: 14px;letter-spacing: normal;text-align: left;text-indent: 0px;text-transform: none;white-space: normal;widows: 1;word-spacing: 0px;-webkit-text-stroke-width: 0px;background-color: rgb(255, 255, 255);margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><div><span style="font-size: 14px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;">1.选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</span></div><div><span style="font-size: 14px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;">2.插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据</span></div></div><div style="font-size: 14px;letter-spacing: normal;text-align: left;text-indent: 0px;text-transform: none;white-space: normal;widows: 1;word-spacing: 0px;-webkit-text-stroke-width: 0px;background-color: rgb(255, 255, 255);margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><div><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(250, 122, 0); font-family: Arial; font-weight: bold;">InnoDB</span></span></div><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(54, 46, 43); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">健壮的事务型存储引擎</span></div><div style="font-size: 14px;letter-spacing: normal;text-align: left;text-indent: 0px;text-transform: none;white-space: normal;widows: 1;word-spacing: 0px;-webkit-text-stroke-width: 0px;background-color: rgb(255, 255, 255);margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><span style="font-size: 14px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;-en-paragraph:true;">在以下场合下，使用InnoDB是最理想的选择：</span></div><div style="font-size: 14px;letter-spacing: normal;text-align: left;text-indent: 0px;text-transform: none;white-space: normal;widows: 1;word-spacing: 0px;-webkit-text-stroke-width: 0px;background-color: rgb(255, 255, 255);margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><div><span style="font-size: 14px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;">1.更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。</span></div><div><span style="font-size: 14px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;">2.事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。</span></div><div><span style="font-size: 14px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;">3.自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。</span></div><div><span style="font-size: 14px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;">4.外键约束。MySQL支持外键的存储引擎只有InnoDB。</span></div><div><span style="font-size: 14px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;">5.支持自动增加列AUTO_INCREMENT属性。</span></div></div><div><span style="font-size: 14px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;-en-paragraph:true;">一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。</span></div></div><div><span style="font-size: 14pt;"><span style="color: rgb(250, 122, 0); font-family: Arial; font-size: 14pt; font-weight: bold;">MEMORY&nbsp;</span></span></div><div><span style="font-size: 14px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;-en-paragraph:true;">存储介质是系统内存</span></div><div style="font-size: 14px;letter-spacing: normal;text-align: left;text-indent: 0px;text-transform: none;white-space: normal;widows: 1;word-spacing: 0px;-webkit-text-stroke-width: 0px;background-color: rgb(255, 255, 255);margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><span style="font-size: 14px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;-en-paragraph:true;">一般在以下几种情况下使用Memory存储引擎：</span></div><div style="font-size: 14px;letter-spacing: normal;text-align: left;text-indent: 0px;text-transform: none;white-space: normal;widows: 1;word-spacing: 0px;-webkit-text-stroke-width: 0px;background-color: rgb(255, 255, 255);margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><span style="font-size: 14px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;-en-paragraph:true;">1.目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。</span></div><div style="font-size: 14px;letter-spacing: normal;text-align: left;text-indent: 0px;text-transform: none;white-space: normal;widows: 1;word-spacing: 0px;-webkit-text-stroke-width: 0px;background-color: rgb(255, 255, 255);margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><span style="font-size: 14px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;-en-paragraph:true;">2.如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。</span></div><div style="font-size: 14px;letter-spacing: normal;text-align: left;text-indent: 0px;text-transform: none;white-space: normal;widows: 1;word-spacing: 0px;-webkit-text-stroke-width: 0px;background-color: rgb(255, 255, 255);margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"><span style="font-size: 14px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;-en-paragraph:true;">3.存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。</span></div><div><span style="font-size: 14pt;"><span style="color: rgb(250, 122, 0); font-family: Arial; font-size: 14pt; font-weight: bold;">ARCHIVE</span></span></div><div><span style="font-size: 14px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;-en-paragraph:true;">Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。</span></div><div><span style="font-size: 14px; color: rgb(54, 46, 43); font-family: Arial; font-variant: normal;-en-paragraph:true;">Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。</span></div><div><br></div><div><br></div><div><br></div><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(227, 0, 0); font-weight: bold;">一、 事务隔离级别</span></span></div><div><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(250, 122, 0); font-weight: bold;">事务</span></span></div><div><span style="font-size: 14pt;">一系列对数据访问与更新的操作 所组成的程序执行单元；</span></div><div><font style="font-size: 14pt;"><br></font></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;"><span style="font-size: 14pt; font-weight: bold; color: rgb(250, 122, 0);">事务特性</span>：ACID</span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">原子性</span><span style="font-size: 12pt;">（atomicity&nbsp;&nbsp;</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: nowrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(51, 51, 51); font-family: arial; font-variant-caps: normal; font-variant-ligatures: normal;">[ˌætəˈmɪsɪti]</span><span style="font-size: 12pt;">）</span></font></div><div><span style="font-size: 12pt;">一个事务必须被视为一个不可分割的的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚；</span></div><div><br></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">一致性</span><span style="font-size: 12pt;">（consistency&nbsp;&nbsp;</span><span style="white-space: nowrap; font-size: 12pt; color: rgb(51, 51, 51); font-family: arial;">[kənˈsɪstənsi]</span><span style="font-size: 12pt;">）</span></font></div><div><span style="font-size: 12pt;">数据库总是从一个一致性的状态转换成另外一个一致性状态；</span></div><div><span style="font-size: 12pt;">不一致状态：比如 数据库系统在运行中发生故障，有些事务尚未完成就被迫中断，对数据库的修改只有一部分写入物理数据库，这时数据库就是处于一种不一致的状态；</span></div><div><span style="font-size: 12pt;">所以说，事务是一致性的单位，如果事务中某个动作失败了，系统可以自动撤销事务，返回初始化的状态。</span></div><div><font style="font-size: 12pt;"><br></font></div><div><span style="font-size: 12pt; font-weight: bold;">隔离性</span><span style="font-size: 12pt;">（isolation&nbsp;&nbsp;</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: nowrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: arial; font-variant-caps: normal; font-variant-ligatures: normal;">[ˌaɪsəˈleʃən]</span><span style="font-size: 12pt;">）</span><span style="font-size: 12pt; font-weight: bold;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></div><div><span style="font-size: 12pt;">一个事务所做的修改在最终提交前，对其它事务是不可见的；</span></div><div><br></div><div><span style="font-size: 12pt; font-weight: bold;">持久性</span><span style="font-size: 12pt;">（durability&nbsp;&nbsp;</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: nowrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: arial; font-variant-caps: normal; font-variant-ligatures: normal;">[ˌdjʊrəˈbɪlətɪ]</span><span style="font-size: 12pt;">）</span></div><div><span style="font-size: 12pt;">事务一旦提交，其所做的修改就会永久保存到数据库中。</span></div><div><font style="font-size: 14pt;"><br></font></div><div><span style="font-size: 14pt; font-weight: bold;"><span style="font-size: 14pt; font-weight: bold; color: rgb(250, 122, 0);">隔离级别</span>：</span></div><div><span style="font-size: 12pt;">标准SQL规范中定义了4种隔离级别，不同的隔离级别对事务的处理不同；</span></div><div><br></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">READ UNCOMMITED（未提交读）</span></span></div><div><span style="font-size: 12pt;">事务中的修改，即使没有提交，对其它事务也都是可见的。</span></div><div><span style="font-size: 12pt;">事务可以读取未提交的数据，也被称为脏读。</span></div><div><span style="font-size: 12pt;">从性能上讲，不会比其它级别好太多，却缺乏其它级别的好处，实际应用中很少使用，如Oracle就不支持该级别。</span></div><div><br></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">READ COMMITED（提交读）</span></span></div><div><span style="font-size: 12pt;">大多数的数据库系统默认级别都是该级别（MySql是REPEATABLE READ）；</span></div><div><span style="font-size: 12pt;">只允许获取已经提交的数据。</span></div><div><br></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">REPEATABLE READ（可重复读）</span></span></div><div><span style="font-size: 12pt;">保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的。</span></div><div><span style="font-size: 16px;">可能出现幻读：如&nbsp;</span> <span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</span></div><div><br></div><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">SERIALIZABLE（串行化）</span></span></div><div><span style="font-size: 12pt;">事务只能一个接一个进行处理，不能并发执行；</span></div><div><span style="font-size: 12pt;">最高的隔离级别；</span></div><table style="border-collapse: collapse; min-width: 100%;table-layout: auto;"><colgroup><col style="width: 468px;"><col style="width: 131px;"><col style="width: 225px;"><col style="width: 166px;"><col style="width: 425px;"></colgroup><tbody style="box-sizing: border-box; outline: 0px; border: 0px; overflow-wrap: break-word;"><tr style="box-sizing: border-box; outline: 0px; background-color: rgb(255, 255, 255); overflow-wrap: break-word; padding: 0px;"><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; background-color: rgb(239, 243, 245); border: 1px solid rgb(204, 204, 204); width: 468px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 140.833px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: 700; line-height: 22px;">隔离级别</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; background-color: rgb(239, 243, 245); border: 1px solid rgb(204, 204, 204); width: 131px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 55px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: 700; line-height: 22px;">脏读</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; background-color: rgb(239, 243, 245); border: 1px solid rgb(204, 204, 204); width: 225px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 81.6667px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: 700; line-height: 22px;">不可重复读</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; background-color: rgb(239, 243, 245); border: 1px solid rgb(204, 204, 204); width: 166px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 55px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: 700; line-height: 22px;">幻读</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; background-color: rgb(239, 243, 245); border: 1px solid rgb(204, 204, 204); width: 425px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 157.5px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: 700; line-height: 22px;">数据库默认隔离级别</span></div></td></tr><tr style="box-sizing: border-box; outline: 0px; background-color: rgb(255, 255, 255); overflow-wrap: break-word; padding: 0px;"><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 468px; padding: 8px;"><div><span style="font-size: 12pt; color: rgb(79, 79, 79); line-height: 22px;">READ UNCOMMITED（未提交读）</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 131px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 55px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: normal; line-height: 22px;">是</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 225px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 81.6667px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: normal; line-height: 22px;">是</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 166px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 55px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: normal; line-height: 22px;">是</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 425px; padding: 8px;"><div><br></div></td></tr><tr style="box-sizing: border-box; outline: 0px; background-color: rgb(248, 248, 248); overflow-wrap: break-word; padding: 0px;"><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 468px; padding: 8px;"><div><span style="font-size: 12pt; color: rgb(79, 79, 79); line-height: 22px;">READ COMMITED（提交读）</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 131px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 55px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: normal; line-height: 22px;">否</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 225px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 81.6667px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: normal; line-height: 22px;">是</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 166px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 55px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: normal; line-height: 22px;">是</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 425px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 157.5px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; line-height: 22px;">Oracle和</span><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 157.5px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; line-height: 22px;">SQL</span> <span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 157.5px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; line-height: 22px;">Server</span></div></td></tr><tr style="box-sizing: border-box; outline: 0px; background-color: rgb(255, 255, 255); overflow-wrap: break-word; padding: 0px;"><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 468px; padding: 8px;"><div><span style="font-size: 12pt; color: rgb(79, 79, 79); line-height: 22px;">REPEATABLE READ（可重复读）</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 131px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 55px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: normal; line-height: 22px;">否</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 225px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 81.6667px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: normal; line-height: 22px;">否</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 166px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 55px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-weight: normal; line-height: 22px;">是</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; border: 1px solid rgb(204, 204, 204); width: 425px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 157.5px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; line-height: 22px;">MySQL</span></div></td></tr><tr style="box-sizing: border-box; outline: 0px; background-color: rgb(248, 248, 248); overflow-wrap: break-word; padding: 0px;"><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; border: 1px solid rgb(204, 204, 204); width: 468px; padding: 8px;"><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 22px; text-decoration-color: initial; text-decoration-style: initial;">SERIALIZABLE（串行化）</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; border: 1px solid rgb(204, 204, 204); width: 131px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 55px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 22px; text-decoration-color: initial; text-decoration-style: initial;">否</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; border: 1px solid rgb(204, 204, 204); width: 225px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 81.6667px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 22px; text-decoration-color: initial; text-decoration-style: initial;">否</span></div></td><td style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; text-align: left; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; border: 1px solid rgb(204, 204, 204); width: 166px; padding: 8px;"><div><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; width: 55px; min-height: 10px; font-size: 14px; color: rgb(79, 79, 79); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-style: normal; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 22px; text-decoration-color: initial; text-decoration-style: initial;">否</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 425px; padding: 8px;"><div><br></div></td></tr></tbody></table><div><br></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(250, 122, 0); font-weight: bold;">事务隔离级别相关的命令</span></span></span></div><div><br></div><div><span style="font-size: 12pt;">查询隔离级别</span></div><div><span style="font-size: 12pt;">-- select @@tx_isolation;</span></div><div><br></div><div><span style="font-size: 12pt;">设置隔离级别</span></div><div><span style="font-size: 12pt;">-- set global transaction isolation level 级别字符串; &nbsp;</span></div><div><br></div><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0); font-weight: bold;">二、MVCC</span></span></div><div><br></div><div><span style="font-size: 17px; letter-spacing: 0.1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif; font-variant-caps: normal; font-variant-ligatures: normal;">引入了并发事务之后，如果不对事务的执行进行控制就会出现各种各样的问题，常见的并发控制机制主要有三种：</span></div><div><span style="font-size: 17px; letter-spacing: 0.1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif; font-variant-caps: normal; font-variant-ligatures: normal;">悲</span><span style="font-size: 17px; letter-spacing: 0.1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif; font-variant-caps: normal; font-variant-ligatures: normal;">观并发控制、</span><span style="font-size: 17px; letter-spacing: 0.1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif; font-variant-caps: normal; font-variant-ligatures: normal;">乐</span><span style="font-size: 17px; letter-spacing: 0.1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif; font-variant-caps: normal; font-variant-ligatures: normal;">观并发控制、多版本并发控制；</span></div><h2 style="margin: 1em 0px 0.6em; text-rendering: geometricPrecision; letter-spacing: -1px; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-rendering: geometricPrecision; letter-spacing: -1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(250, 122, 0); font-family: &quot;Open Sans&quot;, sans-serif; font-feature-settings: 'dlig' 1, 'liga' 1, 'lnum' 1, 'kern' 1; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.2em;">悲观并发控制</span></span><span style="font-size: 14pt; color: rgb(46, 46, 46); font-family: &quot;Open Sans&quot;, sans-serif; font-feature-settings: 'dlig' 1, 'liga' 1, 'lnum' 1, 'kern' 1; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal; line-height: 1.2em;">（Pessimistic&nbsp;</span></span> <span style="font-size: 17px; letter-spacing: 0.1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif; font-feature-settings: 'dlig' 1, 'liga' 1, 'lnum' 1, 'kern' 1; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal; line-height: 1.2em;">Concurrency Control</span><span style="text-rendering: geometricPrecision; letter-spacing: -1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14pt; color: rgb(46, 46, 46); font-family: &quot;Open Sans&quot;, sans-serif; font-feature-settings: 'dlig' 1, 'liga' 1, 'lnum' 1, 'kern' 1; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal; line-height: 1.2em;">）</span></span></h2><div><span style="font-size: 17px; letter-spacing: 0.1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif; font-variant-caps: normal; font-variant-ligatures: normal;">悲观并发控制其实是最常见的并发控制机制，也就是锁；（后续“锁”专题分享，此处不赘述）</span></div><div><br></div><div><span style="text-rendering: geometricPrecision; letter-spacing: -1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 14pt;"><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(250, 122, 0); font-family: &quot;Open Sans&quot;, sans-serif; font-feature-settings: 'dlig' 1, 'liga' 1, 'lnum' 1, 'kern' 1; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.2em;">乐观并发控制</span></span><span style="font-size: 14pt; color: rgb(46, 46, 46); font-family: &quot;Open Sans&quot;, sans-serif; font-feature-settings: 'dlig' 1, 'liga' 1, 'lnum' 1, 'kern' 1; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.2em;">（Optimistic&nbsp;</span></span><span style="font-size: 17px; letter-spacing: 0.1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif; font-variant-caps: normal; font-variant-ligatures: normal;">Concurrency Control</span><span style="text-rendering: geometricPrecision; letter-spacing: -1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(46, 46, 46); font-family: &quot;Open Sans&quot;, sans-serif; font-feature-settings: 'dlig' 1, 'liga' 1, 'lnum' 1, 'kern' 1; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.2em;">）</span></div><div><br></div><div><span style="font-size: 17px; letter-spacing: 0.1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif; font-variant-caps: normal; font-variant-ligatures: normal;">乐观并发控制也叫乐观锁，但是它并不是真正的锁，基于时间戳的协议</span><span style="font-size: 17px; letter-spacing: 0.1px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif;">能够保证所有冲突的读写操作都能按照时间戳的大小串行执行，在执行对应的操作时不需要关注其他的事务只需要关心数据项对应时间戳的值就可以了；</span></div><div><span style="font-size: 17px; letter-spacing: 0.1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif; font-variant-caps: normal; font-variant-ligatures: normal;">（后续</span><span style="font-size: 17px; letter-spacing: 0.1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif; font-variant-caps: normal; font-variant-ligatures: normal;">“锁”</span><span style="font-size: 17px; letter-spacing: 0.1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif; font-variant-caps: normal; font-variant-ligatures: normal;">专题分享，此处不赘述）</span></div><div><br></div><div><span style="text-rendering: geometricPrecision; letter-spacing: -1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 14pt;"><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(250, 122, 0); font-family: &quot;Open Sans&quot;, sans-serif; font-feature-settings: 'dlig' 1, 'liga' 1, 'lnum' 1, 'kern' 1; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.2em;">多版本并发控制</span></span></span><span style="text-rendering: geometricPrecision; letter-spacing: -1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(46, 46, 46); font-family: &quot;Open Sans&quot;, sans-serif; font-feature-settings: 'dlig' 1, 'liga' 1, 'lnum' 1, 'kern' 1; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.2em;">（MultiVersion&nbsp;</span><span style="font-size: 17px; letter-spacing: 0.1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(58, 65, 69); font-family: &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif, Merriweather, serif; font-variant-caps: normal; font-variant-ligatures: normal;">Concurrency Control, MVCC</span><span style="text-rendering: geometricPrecision; letter-spacing: -1px; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 14pt; color: rgb(46, 46, 46); font-family: &quot;Open Sans&quot;, sans-serif; font-feature-settings: 'dlig' 1, 'liga' 1, 'lnum' 1, 'kern' 1; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.2em;">）</span></div><div><br></div><div><span style="font-size: 12pt;">大多数事务型存储引擎实现的都不是简单的行级锁，一般都同时实现了MVCC；</span></div><div><span style="font-size: 12pt;">可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低；</span>&nbsp;</div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; font-variant-caps: normal; font-variant-ligatures: normal;">虽然实现机制有所不同,但大都实现了非阻塞的读操作,写操作也只需要锁定必要的行，</span></span><span style="font-size: 12pt;">下面主要介绍InnoDB的实现。</span></div><div><br></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">基本原理：</span></span></div><div><font style="font-size: 11pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal;">MVCC 的实现,是通过</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">保存数据在某个时间点的快照</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; font-variant-caps: normal; font-variant-ligatures: normal;">来实现的</span></font></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(61, 70, 77); font-family: -apple-system, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Microsoft Yahei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;"><span style="font-size: 11pt; color: rgb(61, 70, 77); font-family: -apple-system, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Microsoft Yahei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">对普通的SELECT不加锁</span>，</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(61, 70, 77); font-family: -apple-system, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Microsoft Yahei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">即在某个时刻对事</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(61, 70, 77); font-family: -apple-system, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Microsoft Yahei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">务</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(61, 70, 77); font-family: -apple-system, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Microsoft Yahei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">系统打快照记下所有活跃读写事务ID，之后读操作<span style="font-size: 11pt; color: rgb(61, 70, 77); font-family: -apple-system, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Microsoft Yahei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">根据事务ID与快照中的事务ID进行比较，判断可见性。</span></span></div><div><br></div><h3 style="box-sizing: border-box; margin: 0px 0px 15px; text-rendering: optimizeLegibility; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; text-rendering: optimizeLegibility; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 11pt; color: rgb(47, 47, 47); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.7;">Innodb中的隐藏列</span></span></h3><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(47, 47, 47); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">InnoDB的内部实现中为每一行数据增加了几个隐藏列用于实现MVCC。</span></div><table style="table-layout: auto;border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 421px;"><col style="width: 920px;"></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 421px; padding: 8px;"><div>列名</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 920px; padding: 8px;"><div>作用</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 421px; padding: 8px;"><div>DB_TRX_ID</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 920px; padding: 8px;"><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal;"><span style="font-size: 14px; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">系统版本号</span>，标记了最新更新这条行记录的transaction id，<span style="font-size: 14px; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">每处理一个事务，其值自动+1</span></span>。</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 421px; padding: 8px;"><div>DB_ROLL_PTR</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 920px; padding: 8px;"><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal;">指向当前记录项的rollback segment的undo log记录，<span style="font-size: 14px; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">找之前版本的数据就是通过这个指针</span></span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 421px; padding: 8px;"><div><span style="font-size: 11pt;">DB_ROW_ID</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 920px; padding: 8px;"><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 11pt; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal;">隐含ID，当由innodb自动产生聚集索引时，聚集索引包括这个DB_ROW_ID的值，否则聚集索引中不包括这个值.这个用于索引当中；</span></span></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 11pt; color: rgb(61, 70, 77); font-variant-caps: normal; font-variant-ligatures: normal;">如果表没有定义主键那么DATA_ROW_ID作为主键列，否则行结构中没有DATA_ROW_ID列。</span></span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 421px; padding: 8px;"><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 11pt; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal;">DELETE BIT</span></span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 920px; padding: 8px;"><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 11pt; color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal;">标识该记录是否被删除</span></span></div></td></tr></tbody></table><div><br></div><div><br></div><div><span style="font-size: 10pt;"><span style="font-size: 10pt; font-family: Verdana;">名词延伸：</span></span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><br></div><table style="table-layout: auto;border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 293px;"><col style="width: 1020px;"></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 293px; padding: 8px;"><div><span style="font-size: 14px;">名词</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 1020px; padding: 8px;"><div><span style="font-size: 14px;">解释</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 293px; padding: 8px;"><div><span style="font-size: 11pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(254, 254, 242); color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">undo log</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 1020px; padding: 8px;"><div><span style="font-size: 11pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(254, 254, 242); color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">用于存放数据修改被修改前的值</span> <span style="font-size: 11pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">，可以用来在事务失败时进行rollback；</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 293px; padding: 8px;"><div><span style="font-size: 11pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">redo</span><span style="font-size: 11pt;">&nbsp;l</span><span style="font-size: 11pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(254, 254, 242); color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">og</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 1020px; padding: 8px;"><div><span style="font-size: 11pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">记录某数据块被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 293px; padding: 8px;"><div><span style="font-size: 11pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(34, 34, 34); font-family: Verdana; font-variant-caps: normal; font-variant-ligatures: normal;">rollback segment</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 1020px; padding: 8px;"><div><span style="font-size: 11pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(34, 34, 34); font-family: Verdana; font-variant-caps: normal; font-variant-ligatures: normal;">在Innodb中，undo log被划分为多个段，具体某行的undo log就保存在某个段中，称为回滚段</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 293px; padding: 8px;"><div><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">data file</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 1020px; padding: 8px;"><div><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">数据库文件</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 293px; padding: 8px;"><div><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">db buffer</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 1020px; padding: 8px;"><div><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">数据库缓存</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 293px; padding: 8px;"><div><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">log buffer</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 1020px; padding: 8px;"><div><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">日志缓存</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 293px; padding: 8px;"><div><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">log file</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 1020px; padding: 8px;"><div><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">磁盘日志文件</span></div></td></tr></tbody></table><div><br></div></div><div style="margin-top: 1em; margin-bottom: 1em; text-align: start;"><span style="-en-paragraph:true;">在不考虑redo log 的情况下利用undo log工作的简化过程为：</span></div><table style="table-layout: auto;border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 132px;"><col style="width: 471px;"></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 132px; padding: 8px;"><div>序号</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 471px; padding: 8px;"><div>动作</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 132px; padding: 8px;"><div>1</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 471px; padding: 8px;"><div>开始事务</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 132px; padding: 8px;"><div>2</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 471px; padding: 8px;"><div>记录数据行数据快照到undo log</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 132px; padding: 8px;"><div>3</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 471px; padding: 8px;"><div>更新数据</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 132px; padding: 8px;"><div>4</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 471px; padding: 8px;"><div>将undo log写到磁盘</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 132px; padding: 8px;"><div>5</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 471px; padding: 8px;"><div>将数据写到磁盘</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 132px; padding: 8px;"><div>6</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 471px; padding: 8px;"><div>提交事务</div></td></tr></tbody></table><blockquote style="text-align: start;"><div>1）为了保证数据的持久性，数据要在事务提交之前持久化</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">2）undo log的持久化必须在在数据持久化之前，这样才能保证系统崩溃时，可以用undo log来回滚事务</span></div></blockquote><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></div><h4 style="margin: 10px 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></h4><h4 style="margin: 10px 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">下面分别以select、delete、 insert、 update语句来说明</span></h4><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">SELECT</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">Innodb检查每行数据，确保他们符合两个标准：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">1、InnoDB只查找版本早于当前事务版本的数据行(也就是数据行的版本必须小于等于事务的版本)，这确保当前事务读取的行都是事务之前已经存在的，或者是由当前事务创建或修改的行</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">2、行的删除操作的版本一定是未定义的或者大于当前事务的版本号，确定了当前事务开始之前，行没有</span><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">被删除</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">符合了以上两点则返回查询结果。</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">INSERT</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">InnoDB为每个新增行 记录当前系统版本号作为行版本号。</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">DELETE</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">InnoDB为每个删除行 记录当前系统版本号作为行的删除</span><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">标识</span><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">。</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">UPDATE</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">InnoDB插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</span></span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></div><div style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(47, 47, 47); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">下面演示下事务对某行记录的更新过程：</span></div><h4 style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(47, 47, 47); font-family: 微软雅黑, 宋体, 黑体, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">1. 初始数据行</span></h4><div style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14px; color: rgb(47, 47, 47); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;"><img src= "/img/loading.gif" data-src="../事务隔离级别与MVCC/44474267_1.gif" type="image/gif" data-filename="44474267_1.gif"></span></div><div style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(47, 47, 47); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">F1～F6是某行列的名字，1～6是其对应的数据。后面三个隐含字段分别对应该行的事务号和回滚指针，假如这条数据是刚INSERT的，可以认为ID为1，其他两个字段为空。</span></div><div style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></div><h4 style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(47, 47, 47); font-family: 微软雅黑, 宋体, 黑体, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">2.事务1更改该行的各字段的值</span></h4><div style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14px; color: rgb(47, 47, 47); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;"><img src= "/img/loading.gif" data-src="../事务隔离级别与MVCC/44474267_2.gif" type="image/gif" data-filename="44474267_2.gif"></span></div><div style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(47, 47, 47); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">当事务1更改该行的值时，会进行如下操作：</span></div><div style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div style="padding: 0px; margin: 0px; list-style: none;"><span style="font-size: 14px; color: rgb(47, 47, 47); font-family: 微软雅黑, 宋体, 黑体, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">用排他锁锁定该行</span></div><div style="padding: 0px; margin: 0px; list-style: none;"><span style="font-size: 14px; color: rgb(47, 47, 47); font-family: 微软雅黑, 宋体, 黑体, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">记录redo log</span></div><div style="padding: 0px; margin: 0px; list-style: none;"><span style="font-size: 14px; color: rgb(47, 47, 47); font-family: 微软雅黑, 宋体, 黑体, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">把该行修改前的值Copy到undo log，即上图中下面的行</span></div><div style="padding: 0px; margin: 0px; list-style: none;"><span style="font-size: 14px; color: rgb(47, 47, 47); font-family: 微软雅黑, 宋体, 黑体, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">修改当前行的值，填写事务编号，使回滚指针指向undo log中的修改前的行</span></div><div style="padding: 0px; margin: 0px; list-style: none;"></div></div><h4 style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(47, 47, 47); font-family: 微软雅黑, 宋体, 黑体, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">3.事务2修改该行的值</span></h4><div style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14px; color: rgb(47, 47, 47); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;"><img src= "/img/loading.gif" data-src="../事务隔离级别与MVCC/44474267_3.gif" type="image/gif" data-filename="44474267_3.gif"></span></div><div style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(47, 47, 47); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">与事务1相同，此时undo log，中有有两行记录，并且通过回滚指针连在一起。</span></div><div style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(47, 47, 47); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">因此，如果undo log一直不删除，则会通过当前记录的回滚指针回溯到该行创建时的初始内容，所幸的时在<span style="font-size: 14px; color: rgb(47, 47, 47); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Innodb中存在purge线程，它会查询那些比现在最老的活动事务还早的undo log，并删除它们，从而保证undo log文件不至于无限增长。</span></span></div><h4 style="margin: 10px 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></h4><div style="text-align: start;"><font style="font-size: 14pt;"><br></font></div><div style="text-align: start;"><span style="font-size: 14pt; font-weight: bold;">事务提交</span></div><div style="text-align: start;"><font style="font-size: 14pt;"><br></font></div><div style="text-align: start;"><span style="font-size: 12pt;">当事务正常提交时Innodb只需要更改事务状态为COMMIT即可，不需做其他额外的工作；</span></div><div style="text-align: start;"><span style="font-size: 12pt;">而Rollback则稍微复杂点，需要根据当前回滚指针从undo log中找出事务修改前的版本，并恢复。如果事务影响的行非常多，回滚则可能会变的效率不高，根据经验值：事务行数在1000～10000之间，Innodb效率还是非常高的。</span></div><div style="text-align: start;"><font style="font-size: 14pt;"><br></font></div><div style="text-align: start;"></div><div style="text-align: start;"><span style="font-size: 14pt; font-weight: bold;">适用范围</span></div><div style="text-align: start;"><font style="font-size: 14pt;"><br></font></div><div style="text-align: start;"><span style="font-size: 16px;">MVCC只在</span><span style="font-size: 12pt;">REPEATABLE READ（可重复读）和</span><span style="font-size: 12pt;">READ COMMITED（提交读）两个隔离级别下工作。</span></div><div style="text-align: start;"><span style="font-size: 12pt;">因为：</span></div><div style="text-align: start;"><span style="font-size: 12pt;">READ UNCOMMITED总是读取最新的数据行，而不是符合当前事务版本的数据行；</span></div><h3 style="box-sizing: border-box; margin: 0px 0px 15px; font-size: 22px; text-rendering: optimizeLegibility; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 12pt; color: rgb(47, 47, 47); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: normal; line-height: 1.7;">SERIALIZABLE则会对所有读取的行都加锁；</span></h3><div><br></div><h3 style="box-sizing: border-box; margin: 0px 0px 15px; text-rendering: optimizeLegibility; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; text-rendering: optimizeLegibility; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14pt; color: rgb(47, 47, 47); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.7;">MVCC优缺点</span></span></h3><div style="box-sizing: border-box; margin: 0px 0px 25px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); word-break: break-word !important;"><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; word-break: break-word !important; color: rgb(47, 47, 47); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。</span></div><div style="box-sizing: border-box; margin: 0px 0px 25px; font-size: 16px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); word-break: break-word !important;"><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; word-break: break-word !important; color: rgb(47, 47, 47); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作。</span></div><div style="margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div style="margin: 0px; padding: 0px;"></div><div style="margin: 0px; padding: 0px;"><font style="font-size: 14pt;"><br></font></div><div style="margin: 0px; padding: 0px;"><span style="font-size: 14pt; color: rgb(47, 47, 47); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">思考：</span></div><div style="margin: 0px; padding: 0px;"></div><div style="box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px; overflow-wrap: break-word; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div style="box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px; overflow-wrap: break-word;"><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">Innodb的实现方式是：</span></div></div><div style="font-size: 14px; padding: 0px; margin: 0px; list-style: none;"><div style="box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 0px 32px; list-style-type: disc; overflow-wrap: break-word;"><span style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">事务以排他锁的形式修改原始数据</span></span></div><div style="box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 0px 32px; list-style-type: disc; overflow-wrap: break-word;"><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif;">把修改前的数据存放于undo log，通过回滚指针与主数据关联</span></div><div style="box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 0px 32px; list-style-type: disc; overflow-wrap: break-word;"><span style="box-sizing: border-box; outline: 0px; overflow-wrap: break-word; font-size: 14px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif;">修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</span></div><div><br></div></div><div style="font-size: 14px; margin: 0px; padding: 0px;"><span style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(47, 47, 47); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？&nbsp;</span></span></div><div style="font-size: 14px; margin: 0px; padding: 0px;"><br></div><div style="font-size: 14px; margin: 0px; padding: 0px;"><span style="font-size: 14px; color: rgb(47, 47, 47); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">Innodb的实现真算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC据无能为力了。</span></div></div><div style="margin: 0px; padding: 0px; font-size: 14px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(47, 47, 47); font-family: Arial; font-variant-caps: normal; font-variant-ligatures: normal;">比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。</span></div><div><br></div><div><br></div><div><br></div><div><span style="font-size: 12pt;">参考：</span></div><div><span style="font-size: 12pt;">《高性能MySql》</span></div></a><div><a name="2598"><span style="font-size: 12pt;"></span></a><a href="https://draveness.me/database-concurrency-control" style="font-size: 12pt;">https://draveness.me/database-concurrency-control</a></div><div><span style="font-size: 12pt;"><a href="http://www.cnblogs.com/chenpingzhao/p/5065316.html" style="font-size: 12pt;">http://www.cnblogs.com/chenpingzhao/p/5065316.html</a></span></div><div><a href="https://www.jianshu.com/p/a3d49f7507ff">https://www.jianshu.com/p/a3d49f7507ff</a></div><div><a href="https://blog.csdn.net/chen77716/article/details/6742128">https://blog.csdn.net/chen77716/article/details/6742128</a></div><div><a href="http://www.360doc.com/content/14/0821/09/12904276_403505950.shtml">http://www.360doc.com/content/14/0821/09/12904276_403505950.shtml</a></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><div><font style="font-size: 12pt;"><br></font></div></div><div><br></div></div></body>
<script>window.onload=function(){setTimeout(function(){document.querySelector('.sidebar-inner').style.display = 'none';}, 900)}</script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MVCC</tag>
        <tag>事务隔离</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化编译工具瞭望</title>
    <url>/2020/02/04/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E7%9E%AD%E6%9C%9B/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p> 随着前端vue、react、Angular等框架越来越火，自动化构建工具也时不时映入我们的眼帘，转眼已是几分天下的局面，功能很强大，使得前端项目开发和维护越来越方便，但是想灵活运用，学习曲线却越发陡峭，文档更是爆炸式的膨胀，我们面对的是各种基于不同编译工具的专项功能插件，及对应的配置参数。</p>
<a id="more"></a>

<p> 搞好了：解放双手，极大的提升&quot;开发体验&quot;，一键搞定一切，空对空导弹一键发射，发射后不管！自动追击目标。脱靶自动启动自曝程序，不会伤及地面。</p>
<p> 搞不好：鸡肋，加重负担，浪费人力（专人维护，其他人一点不会,或者多版本迭代后变得难以上手），反而浪费时间（调试流程别扭，半自动半手动ctrl+c还得关闭这个软件打开那个软件），黑盒（最禁忌！直接傻眼），过度依赖编译工具，束缚技术选型，单一技术栈。</p>
<h3 id="编译工具带给我们什么？"><a href="#编译工具带给我们什么？" class="headerlink" title="编译工具带给我们什么？"></a>编译工具带给我们什么？</h3><p>（1）搭建开发环境：</p>
<ul>
<li><p>热更新</p>
</li>
<li><p>mock数据</p>
</li>
<li><p>代理</p>
</li>
</ul>
<p>（2）生成上线文件：</p>
<ul>
<li><p>编译（less，sass，es6，typescript，.vue，.jsx ）</p>
</li>
<li><p>语法校验</p>
</li>
<li><p>压缩校验 css ，js</p>
</li>
<li><p>css3代码自动补全</p>
</li>
<li><p>px转rem</p>
</li>
<li><p>自动化测试</p>
</li>
<li><p>自动精灵图片</p>
</li>
<li><p>模块化</p>
</li>
<li><p>代码分离</p>
</li>
<li><p>智能 WebP</p>
</li>
</ul>
<p>（3）文件操作，一键发版到服务器等。</p>
<h3 id="编译工具对比"><a href="#编译工具对比" class="headerlink" title="编译工具对比"></a>编译工具对比</h3><p><img src= "/img/loading.gif" data-src="data:image/*;base64,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"></p>
<p>偏流程：</p>
<p>  Grunt(需要&quot;配置&quot;很多任务)</p>
<p>Gulp（需要&quot;编写&quot;很多任务）</p>
<p>偏模块化：</p>
<p>Browserify（只能对js文件有效,较轻量级）</p>
<p>Webpack（需要配置，最初定位SPA，模块化）</p>
<p>rollup.js（后起，定位和Webpack相同，配置简单，各有所长）</p>
<p>国际空间站：(高度集成，一站式服务，什么功能都有)</p>
<p>Yeoman、FIS、jdf、Athena、cooking、weflow</p>
<p>（1）Yeoman：google</p>
<p>yo（脚手架工具）、grunt（构建工具）、bower（包管理器）</p>
<p>yo （脚手架工具）安装generator 可以安装许多generator项目中使用某个（很好）</p>
<p>Bower（包管理器，不再维护） or npm 管理各种包 升级 卸载 或者制定使用某个版本</p>
<p>Grunt or Gulp （构建工具）</p>
<p>（2）百度的FIS（很多封装成熟的功能，简单配置即可使用，自由度受限）</p>
<p>官网：<a href="http://fis.baidu.com/">http://fis.baidu.com/</a></p>
<p><a href="https://github.com/fex-team/fis3-demo">https://github.com/fex-team/fis3-demo</a>  3年前停止维护，不支持最新的node版本！</p>
<p>（3）jdf、Athena</p>
<p>讨论：如何选择？</p>
<h3 id="熟悉下grunt、gulp、webpack的配置项"><a href="#熟悉下grunt、gulp、webpack的配置项" class="headerlink" title="熟悉下grunt、gulp、webpack的配置项"></a>熟悉下grunt、gulp、webpack的配置项</h3><p><strong>grunt：</strong></p>
<p> <img src= "/img/loading.gif" data-src="data:image/*;base64,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"></p>
<p>更多实例分析。。。</p>
<p><strong>gulp：</strong></p>
<p> <img src= "/img/loading.gif" data-src="data:image/*;base64,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"></p>
<p>更多实例分析。。。</p>
<p>  <strong>webpack：</strong></p>
<p> &quot;依赖链&quot;来组织最终的文件。</p>
<p> <img src= "/img/loading.gif" data-src="data:image/*;base64,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"></p>
<p>打包后的样子：</p>
<p> <img src= "/img/loading.gif" data-src="data:image/*;base64,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"></p>
<p>更多实例分析。。。</p>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><ol>
<li>学习方法。</li>
<li>我们能做些什么？毕竟已经有很多脚手架或者比较成熟的例子。</li>
</ol>
]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
      </tags>
  </entry>
</search>
