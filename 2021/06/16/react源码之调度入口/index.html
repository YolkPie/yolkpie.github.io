<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>react源码之调度入口 | YolkPie</title><meta name="description" content="在react-native项目中实现沉浸式标题栏"><meta name="keywords" content="react, 源码"><meta name="author" content="YolkPie"><meta name="copyright" content="YolkPie"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yolkpie.net/2021/06/16/react%E6%BA%90%E7%A0%81%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%85%A5%E5%8F%A3/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="react源码之调度入口"><meta property="og:url" content="https://yolkpie.net/2021/06/16/react%E6%BA%90%E7%A0%81%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%85%A5%E5%8F%A3/"><meta property="og:site_name" content="YolkPie"><meta property="og:description" content="在react-native项目中实现沉浸式标题栏"><meta property="og:image" content="https://img12.360buyimg.com/imagetools/jfs/t1/192410/37/8360/23491/60c9b074Ea765d291/3e52890e0c12a36e.jpg"><meta property="article:published_time" content="2021-06-16T08:07:54.000Z"><meta property="article:modified_time" content="2022-10-28T01:38:08.635Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="react源码之调度开始" href="https://yolkpie.net/2021/06/16/react%E6%BA%90%E7%A0%81%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%BC%80%E5%A7%8B/"><link rel="next" title="微前端实践一" href="https://yolkpie.net/2021/06/08/%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">179</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">85</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">35</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%B0%83%E5%BA%A6%E5%85%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">2. 调度入口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-markUpdateLaneFromFiberToRoot-%E6%9B%B4%E6%96%B0fiber%E7%9A%84lanes-%E8%BF%94%E5%9B%9EfiberRoot"><span class="toc-number">1.1.</span> <span class="toc-text">2.1 markUpdateLaneFromFiberToRoot: 更新fiber的lanes,返回fiberRoot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-markRootUpdated%EF%BC%9A%E6%9B%B4%E6%96%B0rootFiber%E7%9A%84pendingLanes%E5%92%8CeventTimes"><span class="toc-number">1.2.</span> <span class="toc-text">2.2 markRootUpdated：更新rootFiber的pendingLanes和eventTimes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-ensureRootIsScheduled-%E5%AE%9A%E4%B9%89%E4%BA%86%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E6%8F%92%E9%98%9F%E9%80%BB%E8%BE%91%EF%BC%88%E8%B5%9B%E8%BD%A6%E6%8A%A2%E8%B5%9B%E9%81%93%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">2.3 ensureRootIsScheduled: 定义了高优先级任务插队逻辑（赛车抢赛道）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89markStarvedLanesAsExpired"><span class="toc-number">1.3.1.</span> <span class="toc-text">1）markStarvedLanesAsExpired</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89getNextLanes"><span class="toc-number">1.3.2.</span> <span class="toc-text">2）getNextLanes</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://img10.360buyimg.com/imagetools/jfs/t1/171645/8/14914/73312/60c9b074Efb29a81e/efd6e5e2b4a4eb99.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">YolkPie</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">react源码之调度入口</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-06-16 16:07:54"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-06-16</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-10-28 09:38:08"><i class="fas fa-history fa-fw"></i> 更新于 2022-10-28</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/react/">react</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="2-调度入口"><a href="#2-调度入口" class="headerlink" title="2. 调度入口"></a>2. 调度入口</h2><ul>
<li>获取rootFiber；更新fiber的lanes；从当前fiber往上遍历至fiberRoot，更新父fiber的childLanes</li>
<li>更新rootFiber的pendingLanes和eventTimes</li>
<li>若是同步非批量更新，调用performSyncWorkOnRoot(root)；同步非批量更新和异步更新，调用ensureRootIsScheduled(root, eventTime)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params">fiber, lane, eventTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 得到fiberRoot节点</span></span><br><span class="line">  <span class="comment">// 更新fiber的lanes；从当前fiber往上遍历至fiberRoot，更新父fiber的childLanes</span></span><br><span class="line">  <span class="keyword">var</span> root = markUpdateLaneFromFiberToRoot(fiber, lane);</span><br><span class="line">  <span class="comment">// 更新rootFiber的pendingLanes和eventTimes</span></span><br><span class="line">  markRootUpdated(root, lane, eventTime);</span><br><span class="line">  <span class="keyword">if</span> (root === workInProgressRoot) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前任务被暂停，即workInProgressRootRenderLanes都是被暂停的lanes</span></span><br><span class="line">    <span class="comment">// 从suspendedLanes中移除已经恢复任务的lanes和已经更新完成任务的lanes</span></span><br><span class="line">    <span class="comment">// 更新expirationTimes数组，对suspendedLanes对应index的过期时间设置为-1</span></span><br><span class="line">    <span class="keyword">if</span> (workInProgressRootExitStatus === RootSuspendedWithDelay) &#123;</span><br><span class="line">      markRootSuspended$<span class="number">1</span>(root, workInProgressRootRenderLanes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lane === SyncLane) &#123; <span class="comment">// 同步更新</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">// 当前是同步非批量更新，且非render或非commit阶段</span></span><br><span class="line">    (executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp; <span class="comment">// Check if we&#x27;re not already rendering</span></span><br><span class="line">    (executionContext &amp; (RenderContext | CommitContext)) === NoContext) &#123;</span><br><span class="line">      <span class="comment">// 执行同步更新</span></span><br><span class="line">      performSyncWorkOnRoot(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 批量更新</span></span><br><span class="line">      ensureRootIsScheduled(root, eventTime);</span><br><span class="line">      <span class="comment">// ???</span></span><br><span class="line">      <span class="keyword">if</span> (executionContext === NoContext &amp;&amp; (fiber.mode &amp; ConcurrentMode) === NoMode) &#123;</span><br><span class="line">        resetRenderTimer();</span><br><span class="line">        flushSyncCallbacksOnlyInLegacyMode();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 异步更新</span></span><br><span class="line">    <span class="comment">// Schedule other updates after in case the callback is sync.</span></span><br><span class="line">    ensureRootIsScheduled(root, eventTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-markUpdateLaneFromFiberToRoot-更新fiber的lanes-返回fiberRoot"><a href="#2-1-markUpdateLaneFromFiberToRoot-更新fiber的lanes-返回fiberRoot" class="headerlink" title="2.1 markUpdateLaneFromFiberToRoot: 更新fiber的lanes,返回fiberRoot"></a>2.1 markUpdateLaneFromFiberToRoot: 更新fiber的lanes,返回fiberRoot</h3><p>从当前fiber开始往上到rootFiber更新所有fiber的childLanes</p>
<ul>
<li>更新当前fiber的lanes和alternate的lanes，</li>
<li>从下往上遍历父fiber，更新父fiber的childLanes和父fiber.alternate的childLanes，直到rootFiber </li>
<li>返回fiberRoot</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markUpdateLaneFromFiberToRoot</span>(<span class="params">sourceFiber, lane</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 更新当前fiber的lanes，将lane加入到sourceFiber.lanes中</span></span><br><span class="line">  <span class="comment">// mergeLanes(a, b) =&gt; a | b</span></span><br><span class="line">  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);</span><br><span class="line">  <span class="comment">// 第一次更新，sourceFiber.alternate = null</span></span><br><span class="line">  <span class="keyword">var</span> alternate = sourceFiber.alternate;</span><br><span class="line">  <span class="comment">// alternate非空，也更新alternate的lanes</span></span><br><span class="line">  <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">    alternate.lanes = mergeLanes(alternate.lanes, lane);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> node = sourceFiber;</span><br><span class="line">  <span class="comment">// 获取当前fiber的父fiber，若当前fiber为rootFiber，其父fiber为null</span></span><br><span class="line">  <span class="keyword">var</span> parent = sourceFiber.return;</span><br><span class="line">  <span class="comment">// 从当前fiber开始，从下往上，遍历父fiber，更新父fiber的childLanes和父fiber.alternate的childLanes，直到rootFiber</span></span><br><span class="line">  <span class="keyword">while</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">    parent.childLanes = mergeLanes(parent.childLanes, lane);</span><br><span class="line">    alternate = parent.alternate;</span><br><span class="line">    <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">      alternate.childLanes = mergeLanes(alternate.childLanes, lane);</span><br><span class="line">    &#125;</span><br><span class="line">    node = parent;</span><br><span class="line">    parent = parent.return;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回fiberRoot（rootFiber.tag=3=HostRoot）</span></span><br><span class="line">  <span class="keyword">if</span> (node.tag === HostRoot) &#123;</span><br><span class="line">    <span class="keyword">var</span> root = node.stateNode;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="2-2-markRootUpdated：更新rootFiber的pendingLanes和eventTimes"><a href="#2-2-markRootUpdated：更新rootFiber的pendingLanes和eventTimes" class="headerlink" title="2.2 markRootUpdated：更新rootFiber的pendingLanes和eventTimes"></a>2.2 markRootUpdated：更新rootFiber的pendingLanes和eventTimes</h3><ul>
<li>将当前更新的lane和更新开始时间分别保存到rootFiber.pendingLanes和rootFiber.eventTimes</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新rootFiber的pendingLanes和eventTimes（将当前更新的lane和更新开始时间分别保存到rootFiber.pendingLanes和rootFiber.eventTimes）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markRootUpdated</span>(<span class="params">root, updateLane, eventTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将当前更新的lane(updateLane)放入到rootFiber的pendingLanes中</span></span><br><span class="line">  root.pendingLanes |= updateLane;</span><br><span class="line">  <span class="comment">// 获取比当前updateLane优先级更高的lanes</span></span><br><span class="line">  <span class="keyword">var</span> higherPriorityLanes = updateLane - <span class="number">1</span>; <span class="comment">// Turns 0b1000 into 0b0111</span></span><br><span class="line"> <span class="comment">// ??? 目的是剔除掉suspendedLanes 和 pingedLanes中优先级低于本次更新优先级（updateLane）的lane</span></span><br><span class="line">  <span class="comment">// 实现上方注释中的 “取消同等或较低优先级的更新。”</span></span><br><span class="line">  root.suspendedLanes &amp;= higherPriorityLanes;</span><br><span class="line">  root.pingedLanes &amp;= higherPriorityLanes;</span><br><span class="line">  <span class="comment">// 获取所有的更新开始时间数组eventTimes，31位</span></span><br><span class="line">  <span class="keyword">var</span> eventTimes = root.eventTimes;</span><br><span class="line">  <span class="comment">// 找到lanes中最靠左的那个1在lanes中的index</span></span><br><span class="line">  <span class="keyword">var</span> index = laneToIndex(updateLane); </span><br><span class="line">  <span class="comment">// 将当前更新的开始时间保存到root的更新时间数组中</span></span><br><span class="line">  eventTimes[index] = eventTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-ensureRootIsScheduled-定义了高优先级任务插队逻辑（赛车抢赛道）"><a href="#2-3-ensureRootIsScheduled-定义了高优先级任务插队逻辑（赛车抢赛道）" class="headerlink" title="2.3 ensureRootIsScheduled: 定义了高优先级任务插队逻辑（赛车抢赛道）"></a>2.3 ensureRootIsScheduled: 定义了高优先级任务插队逻辑（赛车抢赛道）</h3><p>获取优先级最高的lane，高优先级任务打断低优先级任务</p>
<ul>
<li>1）循环遍历root.pendingLanes，没有过期时间，计算过期时间；有过期时间，判断是否过期，若过期，加入到root.expiredLanes中</li>
<li>2）从root.expiredLanes和root.pendingLanes未执行任务中找出优先级最高的lane和对应的优先级，获取lanes集合的优先级顺序是，过期任务的expiredLanes&gt;非空闲且非挂起任务的lanes &gt; 非空闲且挂起又恢复任务的lanes &gt; 空闲且非挂起任务的lanes &gt; 空闲且挂起又恢复任务的lanes</li>
<li>3）比较新旧任务的优先级，两者相等，无需调度；前者大于后者，取消旧任务</li>
<li>4）新任务的优先级高于旧任务，根据新任务的优先级来进行不同的调度任务：<blockquote>
<p>同步优先级：调用scheduleSyncCallback去同步执行任务。<br>同步批量执行：调用scheduleCallback，将任务以立即执行的优先级去加入调度。<br>属于concurrent模式的优先级：调用scheduleCallback，将任务通过lanePriorityToSchedulerPriority获取到的新任务优先级去加入调度。</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureRootIsScheduled</span>(<span class="params">root, currentTime</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取旧任务</span></span><br><span class="line">  <span class="keyword">var</span> existingCallbackNode = root.callbackNode; </span><br><span class="line">    <span class="comment">// 从root.pendingLanes最左边的第一个1开始，循环遍历，没有过期时间，计算过期时间；有过期时间，判断是否过期，若过期，加入到root.expiredLanes中</span></span><br><span class="line">  markStarvedLanesAsExpired(root, currentTime); <span class="comment">// Determine the next lanes to work on, and their priority.</span></span><br><span class="line">    <span class="comment">// 从root.pendingLanes未执行任务中和root.expiredLanes中找出优先级最高的lane（过期任务的优先级最高）</span></span><br><span class="line">  <span class="keyword">var</span> nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); </span><br><span class="line">    <span class="comment">// 获取新任务的优先级，即nextLanes对应的优先级，return_highestLanePriority</span></span><br><span class="line">  <span class="keyword">var</span> newCallbackPriority = returnNextLanesPriority();</span><br><span class="line">    <span class="comment">// nextLanes为未执行任务中优先级最高的lanes，若它为空，则说明不需要调度，取消回调，return</span></span><br><span class="line">  <span class="keyword">if</span> (nextLanes === NoLanes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">      root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">      root.callbackPriority = NoLanePriority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 若存在旧任务</span></span><br><span class="line">  <span class="comment">// 新任务的优先级高于或等于旧任务优先级</span></span><br><span class="line">  <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取旧任务的优先级</span></span><br><span class="line">    <span class="keyword">var</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line">    <span class="comment">// 若新旧任务的优先级一样，进入batchedUpdate的逻辑</span></span><br><span class="line">    <span class="comment">// 无需再次发起一次调度，直接复用旧任务即可，让旧任务在处理更新的时候顺便把新任务给做了</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackPriority === newCallbackPriority) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新旧任务的优先级不相等，则说明新任务的优先级一定高于旧任务，这种情况就是高优先级任务插队，需要把旧任务取消掉</span></span><br><span class="line">    <span class="comment">// 每次获取nextLanes时，都是从root.pendingLanes中获取优先级最高的lanes，nextLanes对应的优先级newCallbackPriority也是最高的</span></span><br><span class="line">    cancelCallback(existingCallbackNode); <span class="comment">// existingCallbackNode.callback = null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> newCallbackNode;</span><br><span class="line">  <span class="comment">// 若新任务的优先级为同步优先级，则同步调度，传统的同步渲染和过期任务会走这里</span></span><br><span class="line">  <span class="keyword">if</span> (newCallbackPriority === SyncLanePriority) &#123;</span><br><span class="line">    newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(<span class="literal">null</span>, root));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newCallbackPriority === SyncBatchedLanePriority) &#123; <span class="comment">// 同步模式到concurrent模式的过渡模式：blocking模式会走这里</span></span><br><span class="line">    newCallbackNode = scheduleCallback(ImmediatePriority$<span class="number">1</span>, performSyncWorkOnRoot.bind(<span class="literal">null</span>, root));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// concurrent模式的渲染会走这里</span></span><br><span class="line">    <span class="comment">// 根据任务优先级获取Scheduler的调度优先级</span></span><br><span class="line">    <span class="keyword">var</span> schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);</span><br><span class="line">    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root));</span><br><span class="line">  &#125;</span><br><span class="line">  root.callbackPriority = newCallbackPriority;</span><br><span class="line">  root.callbackNode = newCallbackNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1）markStarvedLanesAsExpired"><a href="#1）markStarvedLanesAsExpired" class="headerlink" title="1）markStarvedLanesAsExpired"></a>1）markStarvedLanesAsExpired</h4><ul>
<li>循环遍历pendingLanes（未执行的任务包含的lane），如果没过期时间就计算一个过期时间，如果过期了就加入root.expiredLanes中</li>
<li>在下次调用getNextLane函数的时候会优先返回expiredLanes</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStarvedLanesAsExpired</span>(<span class="params">root, currentTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pendingLanes = root.pendingLanes;</span><br><span class="line">  <span class="keyword">var</span> suspendedLanes = root.suspendedLanes;</span><br><span class="line">  <span class="keyword">var</span> pingedLanes = root.pingedLanes;</span><br><span class="line">  <span class="keyword">var</span> expirationTimes = root.expirationTimes; </span><br><span class="line">  <span class="keyword">var</span> lanes = pendingLanes;</span><br><span class="line">  <span class="keyword">while</span> (lanes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 以8位二进制0001100为例</span></span><br><span class="line">    <span class="comment">// clz32(lanes) = 3，7 - 3 = 4，index = 4</span></span><br><span class="line">    <span class="comment">// lane = 1 &lt;&lt; 4 = 00010000</span></span><br><span class="line">    <span class="keyword">var</span> index = pickArbitraryLaneIndex(lanes); <span class="comment">// 31 - clz32(lanes)</span></span><br><span class="line">    <span class="keyword">var</span> lane = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">    <span class="keyword">var</span> expirationTime = expirationTimes[index];</span><br><span class="line">        <span class="comment">// 当前没有过期时间就计算一个过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expirationTime === NoTimestamp) &#123;</span><br><span class="line">        <span class="comment">// 当前lane不是挂起任务或当前lane是挂起任务被恢复的lanes，计算当前任务的过期时间</span></span><br><span class="line">      <span class="keyword">if</span> ((lane &amp; suspendedLanes) === NoLanes || (lane &amp; pingedLanes) !== NoLanes) &#123;</span><br><span class="line">        expirationTimes[index] = computeExpirationTime(lane, currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expirationTime &lt;= currentTime) &#123; <span class="comment">// 当前任务过期了</span></span><br><span class="line">      root.expiredLanes |= lane; <span class="comment">// 在expiredLanes加入当前遍历到的lane</span></span><br><span class="line">    &#125;</span><br><span class="line">    lanes &amp;= ~lane;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据优先级，计算lane的过期时间，过期时间分为3种情况：</span></span><br><span class="line"><span class="comment">// 1）用户阻塞型优先级：currentTime + 250（250 ms 后过期），需要用户交互的任务，如按钮点击；</span></span><br><span class="line"><span class="comment">// 2）普通优先级：currentTime + 5000（5 后过期），不必让用户立即感受到的更xin</span></span><br><span class="line"><span class="comment">// 3) 更低优先级或空闲优先级（永不过期）：-1，不必运行的任务（例如，隐藏界面以外的内容）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeExpirationTime</span>(<span class="params">lane, currentTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取lane对应的更新任务优先级</span></span><br><span class="line">  getHighestPriorityLanes(lane); <span class="comment">// lane=512，对应的return_highestLanePriority=DefaultLanePriority=8</span></span><br><span class="line">  <span class="keyword">var</span> priority = return_highestLanePriority;</span><br><span class="line">  <span class="comment">// InputContinuousLanePriority = 10</span></span><br><span class="line">  <span class="keyword">if</span> (priority &gt;= InputContinuousLanePriority) &#123;</span><br><span class="line">    <span class="keyword">return</span> currentTime + <span class="number">250</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priority &gt;= TransitionPriority) &#123; <span class="comment">// TransitionPriority = 6</span></span><br><span class="line">    <span class="keyword">return</span> currentTime + <span class="number">5000</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 任何空闲或更低的优先级都不应该过期</span></span><br><span class="line">    <span class="keyword">return</span> NoTimestamp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）getNextLanes"><a href="#2）getNextLanes" class="headerlink" title="2）getNextLanes"></a>2）getNextLanes</h4><p>获取下一个执行任务的lanes，即从root.pendingLanes未执行任务和root.expiredLanes中找出优先级最高的lane</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNextLanes</span>(<span class="params">root, wipLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pendingLanes = root.pendingLanes;</span><br><span class="line">    <span class="comment">// 没有未执行任务的时，return</span></span><br><span class="line">  <span class="keyword">if</span> (pendingLanes === NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = NoLanePriority;</span><br><span class="line">    <span class="keyword">return</span> NoLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> nextLanes = NoLanes;</span><br><span class="line">  <span class="keyword">var</span> nextLanePriority = NoLanePriority;</span><br><span class="line">  <span class="keyword">var</span> expiredLanes = root.expiredLanes;</span><br><span class="line">  <span class="keyword">var</span> suspendedLanes = root.suspendedLanes;</span><br><span class="line">  <span class="keyword">var</span> pingedLanes = root.pingedLanes; </span><br><span class="line">  <span class="comment">/*检查是有任务过期</span></span><br><span class="line"><span class="comment">    1）任务已过期，设置渲染任务为同步优先级，nextLanes=expiredLanes,nextLanePriority=SyncLanePriority，过期任务优先级最高</span></span><br><span class="line"><span class="comment">    2）任务未过期，从未执行任务的lanes(pendingLanes)获取lanes集合的优先级顺序是，非空闲且非挂起任务的lanes &gt; 非空闲且挂起又恢复任务的lanes &gt; 空闲且非挂起任务的lanes &gt; 空闲且挂起任务的lanes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     3）通过getHighestPriorityLanes，从获取到优先级lanes集合中拿到优先级最高lanes</span></span><br><span class="line"><span class="comment">   拿到nextLanes后，通过getHighestPriorityLanes(lanes)，获取lanes对应的优先级nextLanePriority */</span></span><br><span class="line">  <span class="keyword">if</span> (expiredLanes !== NoLanes) &#123; <span class="comment">// 有任务过期</span></span><br><span class="line">    nextLanes = expiredLanes;</span><br><span class="line">    nextLanePriority = return_highestLanePriority = SyncLanePriority; <span class="comment">// 15，过期任务优先级最高，需要立即执行</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 无任务过期</span></span><br><span class="line">    <span class="comment">// 获取未执行任务lans中非空闲优先级的任务lans</span></span><br><span class="line">    <span class="keyword">var</span> nonIdlePendingLanes = pendingLanes &amp; NonIdleLanes;</span><br><span class="line">    <span class="comment">// 从未执行任务lans中，先取非挂起任务的lans，从非挂起任务的lans中获取最高的优先级的lane和lane对应的优先级</span></span><br><span class="line">    <span class="comment">// 若全是非挂起任务的lans，则从非挂起任务的lans中获取最高的优先级的lanes和lanes对应的优先级</span></span><br><span class="line">    <span class="keyword">if</span> (nonIdlePendingLanes !== NoLanes) &#123; <span class="comment">// 有非空闲任务的lans</span></span><br><span class="line">      <span class="keyword">var</span> nonIdleUnblockedLanes = nonIdlePendingLanes &amp; ~suspendedLanes; <span class="comment">// 去掉挂起任务的lans</span></span><br><span class="line">    <span class="comment">// nonIdleUnblockedLanes：nonIdlePendingLanes中去掉挂起任务的lans</span></span><br><span class="line">      <span class="keyword">if</span> (nonIdleUnblockedLanes !== NoLanes) &#123; <span class="comment">// 说明nonIdlePendingLanes中，除了有非挂起任务的lans，还有其他的lans</span></span><br><span class="line">        nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);</span><br><span class="line">        nextLanePriority = return_highestLanePriority;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// nonIdleUnblockedLanes为null，说明nonIdlePendingLanes中只有挂起任务的lans</span></span><br><span class="line">        <span class="comment">// 从nonIdlePendingLanes中获取挂起任务lanes中被恢复的lanes</span></span><br><span class="line">        <span class="keyword">var</span> nonIdlePingedLanes = nonIdlePendingLanes &amp; pingedLanes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nonIdlePingedLanes !== NoLanes) &#123;</span><br><span class="line">          nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);</span><br><span class="line">          nextLanePriority = return_highestLanePriority;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有空闲任务的lans</span></span><br><span class="line">      <span class="comment">// 从未执行任务的lans中去掉挂起任务的lans，即获取非阻塞任务lans</span></span><br><span class="line">      <span class="keyword">var</span> unblockedLanes = pendingLanes &amp; ~suspendedLanes;</span><br><span class="line">      <span class="comment">// 也是优先取非挂起任务的lans，没有的话，再取挂起任务的lans</span></span><br><span class="line">      <span class="comment">// 从lanes中，获取最高的优先级的lanes和lanes对应的优先级</span></span><br><span class="line">      <span class="keyword">if</span> (unblockedLanes !== NoLanes) &#123;</span><br><span class="line">        nextLanes = getHighestPriorityLanes(unblockedLanes);</span><br><span class="line">        nextLanePriority = return_highestLanePriority;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pingedLanes !== NoLanes) &#123;</span><br><span class="line">          nextLanes = getHighestPriorityLanes(pingedLanes);</span><br><span class="line">          nextLanePriority = return_highestLanePriority;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 如果nextLanes=0，则说明不需要调度任务，return</span></span><br><span class="line">  <span class="keyword">if</span> (nextLanes === NoLanes) &#123;</span><br><span class="line">    <span class="keyword">return</span> NoLanes;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 通过getEqualOrHigherPriorityLanes获取比nextLanes优先级更高的lanes</span></span><br><span class="line">    <span class="comment">// 如果未执行任务的pendingLanes中有比nextLanes优先级更高的lanes，也放入到nextLanes中</span></span><br><span class="line">    <span class="comment">// getEqualOrHigherPriorityLanes(0b001100) = 0b001111</span></span><br><span class="line">  nextLanes = pendingLanes &amp; getEqualOrHigherPriorityLanes(nextLanes);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// wipLanes不为空，说明正在渲染，若渲染任务的lanes不等于新任务的lanes，且其不为挂起任务</span></span><br><span class="line">  <span class="comment">// 判断新旧任务的优先级，旧任务优先级高，忽略新任务，继续执行旧任务，往下渲染；新任务优先级高，那就打断旧任务，插队</span></span><br><span class="line">  <span class="keyword">if</span> (wipLanes !== NoLanes &amp;&amp; wipLanes !== nextLanes &amp;&amp; </span><br><span class="line">  (wipLanes &amp; suspendedLanes) === NoLanes) &#123;</span><br><span class="line">    getHighestPriorityLanes(wipLanes);</span><br><span class="line">    <span class="keyword">var</span> wipLanePriority = return_highestLanePriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextLanePriority &lt;= wipLanePriority) &#123;</span><br><span class="line">      <span class="keyword">return</span> wipLanes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      return_highestLanePriority = nextLanePriority;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nextLanes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getHighestPriorityLanes：从优先级lanes集合中拿到优先级最高lanes和对应的更新任务优先级</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据lanes，获取最高的优先级的lanes和lanes对应的优先级</span></span><br><span class="line"><span class="comment">// 若所有的lanes都未匹配到，则返回lanes和DefaultLanePriority</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHighestPriorityLanes</span>(<span class="params">lanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((SyncLane &amp; lanes) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = SyncLanePriority;</span><br><span class="line">    <span class="keyword">return</span> SyncLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((SyncBatchedLane &amp; lanes) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = SyncBatchedLanePriority;</span><br><span class="line">    <span class="keyword">return</span> SyncBatchedLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((InputDiscreteHydrationLane &amp; lanes) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = InputDiscreteHydrationLanePriority;</span><br><span class="line">    <span class="keyword">return</span> InputDiscreteHydrationLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> inputDiscreteLanes = InputDiscreteLanes &amp; lanes;</span><br><span class="line">  <span class="keyword">if</span> (inputDiscreteLanes !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = InputDiscreteLanePriority;</span><br><span class="line">    <span class="keyword">return</span> inputDiscreteLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((lanes &amp; InputContinuousHydrationLane) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = InputContinuousHydrationLanePriority;</span><br><span class="line">    <span class="keyword">return</span> InputContinuousHydrationLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> inputContinuousLanes = InputContinuousLanes &amp; lanes;</span><br><span class="line">  <span class="keyword">if</span> (inputContinuousLanes !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = InputContinuousLanePriority;</span><br><span class="line">    <span class="keyword">return</span> inputContinuousLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((lanes &amp; DefaultHydrationLane) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = DefaultHydrationLanePriority;</span><br><span class="line">    <span class="keyword">return</span> DefaultHydrationLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> defaultLanes = DefaultLanes &amp; lanes;</span><br><span class="line">  <span class="keyword">if</span> (defaultLanes !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = DefaultLanePriority;</span><br><span class="line">    <span class="keyword">return</span> defaultLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((lanes &amp; TransitionHydrationLane) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = TransitionHydrationPriority;</span><br><span class="line">    <span class="keyword">return</span> TransitionHydrationLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> transitionLanes = TransitionLanes &amp; lanes;</span><br><span class="line">  <span class="keyword">if</span> (transitionLanes !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = TransitionPriority;</span><br><span class="line">    <span class="keyword">return</span> transitionLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> retryLanes = RetryLanes &amp; lanes;</span><br><span class="line">  <span class="keyword">if</span> (retryLanes !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = RetryLanePriority;</span><br><span class="line">    <span class="keyword">return</span> retryLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lanes &amp; SelectiveHydrationLane) &#123;</span><br><span class="line">    return_highestLanePriority = SelectiveHydrationLanePriority;</span><br><span class="line">    <span class="keyword">return</span> SelectiveHydrationLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((lanes &amp; IdleHydrationLane) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = IdleHydrationLanePriority;</span><br><span class="line">    <span class="keyword">return</span> IdleHydrationLane;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> idleLanes = IdleLanes &amp; lanes;</span><br><span class="line">  <span class="keyword">if</span> (idleLanes !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = IdleLanePriority;</span><br><span class="line">    <span class="keyword">return</span> idleLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((OffscreenLane &amp; lanes) !== NoLanes) &#123;</span><br><span class="line">    return_highestLanePriority = OffscreenLanePriority;</span><br><span class="line">    <span class="keyword">return</span> OffscreenLane;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return_highestLanePriority = DefaultLanePriority;</span><br><span class="line">  <span class="keyword">return</span> lanes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getEqualOrHigherPriorityLanes：获取比当前lanes优先级更高或相等的lanes集合</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEqualOrHigherPriorityLanes</span>(<span class="params">lanes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 假设lanes=0b001100,getLowestPriorityLane(0b001100) = 0b001000</span></span><br><span class="line">  <span class="comment">// 0b001000 &lt;&lt; 1 = 0b010000</span></span><br><span class="line">  <span class="comment">// 0b010000 - 1  = 0b001111</span></span><br><span class="line">  <span class="keyword">return</span> (getLowestPriorityLane(lanes) &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从lanes中获取最低优先级的lane，即找到lanes中最靠左的那个1所对应的lane</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLowestPriorityLane</span>(<span class="params">lanes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// This finds the most significant non-zero bit.</span></span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">31</span> - clz32(lanes);</span><br><span class="line">  <span class="keyword">return</span> index &lt; <span class="number">0</span> ? NoLanes : <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到lanes中最靠左的那个1在lanes中的index </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickArbitraryLaneIndex</span>(<span class="params">lanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">31</span> - clz32(lanes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">laneToIndex</span>(<span class="params">lane</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pickArbitraryLaneIndex(lane);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>lanePriorityToSchedulerPriority：更新任务优先级转为调度优先级</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lanePriorityToSchedulerPriority</span>(<span class="params">lanePriority</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (lanePriority) &#123;</span><br><span class="line">    <span class="keyword">case</span> SyncLanePriority:</span><br><span class="line">    <span class="keyword">case</span> SyncBatchedLanePriority:</span><br><span class="line">      <span class="keyword">return</span> ImmediatePriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> InputDiscreteHydrationLanePriority:</span><br><span class="line">    <span class="keyword">case</span> InputDiscreteLanePriority:</span><br><span class="line">    <span class="keyword">case</span> InputContinuousHydrationLanePriority:</span><br><span class="line">    <span class="keyword">case</span> InputContinuousLanePriority:</span><br><span class="line">      <span class="keyword">return</span> UserBlockingPriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DefaultHydrationLanePriority:</span><br><span class="line">    <span class="keyword">case</span> DefaultLanePriority:</span><br><span class="line">    <span class="keyword">case</span> TransitionHydrationPriority:</span><br><span class="line">    <span class="keyword">case</span> TransitionPriority:</span><br><span class="line">    <span class="keyword">case</span> SelectiveHydrationLanePriority:</span><br><span class="line">    <span class="keyword">case</span> RetryLanePriority:</span><br><span class="line">      <span class="keyword">return</span> NormalPriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IdleHydrationLanePriority:</span><br><span class="line">    <span class="keyword">case</span> IdleLanePriority:</span><br><span class="line">    <span class="keyword">case</span> OffscreenLanePriority:</span><br><span class="line">      <span class="keyword">return</span> IdlePriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NoLanePriority:</span><br><span class="line">      <span class="keyword">return</span> NoPriority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YolkPie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yolkpie.net/2021/06/16/react%E6%BA%90%E7%A0%81%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%85%A5%E5%8F%A3/">https://yolkpie.net/2021/06/16/react%E6%BA%90%E7%A0%81%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%85%A5%E5%8F%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yolkpie.net" target="_blank">YolkPie</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/react/">react</a></div><div class="post_share"><div class="social-share" data-image="https://web-dev.imgix.net/image/admin/uc1IWVOW2wEhIY6z4KjJ.png?auto=format&amp;w=1600" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/16/react%E6%BA%90%E7%A0%81%E4%B9%8B%E8%B0%83%E5%BA%A6%E5%BC%80%E5%A7%8B/"><img class="prev-cover" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/192410/37/8360/23491/60c9b074Ea765d291/3e52890e0c12a36e.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">react源码之调度开始</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/08/%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5%E4%B8%80/"><img class="next-cover" data-src="https://img13.360buyimg.com/pop/jfs/t1/186410/34/7201/12974/60bf59c8Eb4d705c0/031ef90f70fcc962.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">微前端实践一</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/02/21/react-hooks/" title="React 内置 Hook 简介"><img class="relatedPosts_cover" data-src="https://img14.360buyimg.com/imagetools/jfs/t1/97654/25/12741/24574/5e4f3d7aE2ca43b3f/814d5d47d6e9b205.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-21</div><div class="relatedPosts_title">React 内置 Hook 简介</div></div></a></div><div class="relatedPosts_item"><a href="/2021/02/24/reactHook之useState和useEffect的原理与简单实现/" title="reactHook之useState和useEffect的原理与简单实现"><img class="relatedPosts_cover" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/165706/12/8850/11857/60364392E830fa141/8cc507f9b004a4a2.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-24</div><div class="relatedPosts_title">reactHook之useState和useEffect的原理与简单实现</div></div></a></div><div class="relatedPosts_item"><a href="/2021/02/24/reactHook之useState的源码解析/" title="reactHook之useState的源码解析"><img class="relatedPosts_cover" data-src="https://img13.360buyimg.com/imagetools/jfs/t1/165706/12/8850/11857/60364392E830fa141/8cc507f9b004a4a2.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-24</div><div class="relatedPosts_title">reactHook之useState的源码解析</div></div></a></div><div class="relatedPosts_item"><a href="/2021/05/26/react源码之前置知识/" title="react源码之前置知识"><img class="relatedPosts_cover" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/192410/37/8360/23491/60c9b074Ea765d291/3e52890e0c12a36e.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-26</div><div class="relatedPosts_title">react源码之前置知识</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/19/diff/" title="核心Diff算法"><img class="relatedPosts_cover" data-src="https://img11.360buyimg.com/imagetools/jfs/t1/145814/24/8751/761861/5f65d465Ec74e3d82/13384de14843dee4.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-19</div><div class="relatedPosts_title">核心Diff算法</div></div></a></div><div class="relatedPosts_item"><a href="/2021/05/31/react源码之react入口函数/" title="react源码之react入口函数"><img class="relatedPosts_cover" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/192410/37/8360/23491/60c9b074Ea765d291/3e52890e0c12a36e.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-31</div><div class="relatedPosts_title">react源码之react入口函数</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By YolkPie</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>